{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6**","webpack:///plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.js","webpack:///webpack/bootstrap 342ed643c9ba45b2462e?e0ad**","webpack:///./plugins/src/TrendsMarksPlugin/index.ts","webpack:///external \"three-charts\"?bed9**","webpack:///./plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.ts","webpack:///./plugins/src/TrendsMarksPlugin/TrendsMarksWidget.ts","webpack:///./src/Color.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","__export","hasOwnProperty","__extends","d","b","__","constructor","prototype","Object","create","three_charts_1","TrendsMarksWidget_1","TREND_MARK_SIDE","EVENTS","AXIS_MARK_DEFAULT_OPTIONS","trendName","title","color","xVal","orientation","TOP","width","height","margin","onRender","DEFAULT_RENDERER","TrendsMarksPlugin","_super","trendsMarksPluginOptions","items","rects","onInitialStateApplied","bindEvents","onMarksChangeHandler","onStateChanged","getOptions","getItems","getItem","markName","createMark","options","marksOptions","newMarkOptions","concat","chart","setState","pluginsState","_a","name","onChange","cb","ee","subscribe","CHANGE","_this","trendsManager","onSegmentsRebuilded","updateMarksSegments","screen","onZoomFrame","calclulateMarksPositions","onInitialStateAppliedHandler","trendsMarksOptions","actualMarksNames","_i","trendsMarksOptions_1","length","marks","Utils","getUid","toString","push","error","deepMerge","mark","TrendMark","indexOf","emit","createMarkRect","segment","left","getPointOnXAxis","top","getPointOnYAxis","yVal","isTopSideMark","newOffset","row","markRect","hasIntersection","rect","rectsIntersect","_setOffset","_setRow","trends","getTrendMarks","marksArr","xVals","_setSegment","sort","a","trend","getTrend","points","segmentsManager","getSegmentsForXValues","markInd","trendMarks","NAME","providedWidgets","TrendsMarksWidget","ChartPlugin","type","TREND_TYPE","LINE","endXVal","endYVal","maxYVal","minYVal","offset","Mesh","THREE","Object3D","TrendsMarksPlugin_1","Color_1","MAX_MARKS_IN_ROW","apply","arguments","getTrendWidgetClass","TrendMarksWidget","widgetName","TrendsWidget","marksWidgets","object3D","onMarksChange","getObject3D","getTrendsMarksPlugin","getPlugin","marksItems","widgets","createMarkWidget","destroyMarkWidget","markWidget","TrendMarkWidget","add","remove","onZoomFrameHandler","onSegmentsAnimate","TrendWidget","trendMark","initObject","show","texture","createPixelPerfectTexture","ctx","material","MeshBasicMaterial","map","side","FrontSide","transparent","markMesh","PlaneGeometry","updatePosition","posX","posY","position","set","animations","state","time","enabled","scale","TweenLite","to","x","y","ease","Elastic","easeOut","isTopSide","Color","lineColor","rgbaColor","getTransparent","rgbaStr","centerX","Math","round","centerY","font","textOffset","parseInt","textPosX","textPosY","fillStyle","strokeStyle","fillRect","beginPath","arc","PI","fill","lineEndY","moveTo","lineTo","stroke","textAlign","fillText","parseColor","cache","replace","exec","Error","isNaN","numberToHexStr","value","result","repeat","colorStr","rgba","r","g","hexStr","opacity"],"mappings":"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","file":"plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three-charts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three-charts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TrendsMarksPlugin\"] = factory(require(\"three-charts\"));\n\telse\n\t\troot[\"THREE_CHARTS\"] = root[\"THREE_CHARTS\"] || {}, root[\"THREE_CHARTS\"][\"TrendsMarksPlugin\"] = factory(root[\"three-charts\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three-charts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three-charts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TrendsMarksPlugin\"] = factory(require(\"three-charts\"));\n\telse\n\t\troot[\"THREE_CHARTS\"] = root[\"THREE_CHARTS\"] || {}, root[\"THREE_CHARTS\"][\"TrendsMarksPlugin\"] = factory(root[\"three-charts\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(5));\r\n\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar three_charts_1 = __webpack_require__(2);\r\n\tvar TrendsMarksWidget_1 = __webpack_require__(6);\r\n\t(function (TREND_MARK_SIDE) {\r\n\t    TREND_MARK_SIDE[TREND_MARK_SIDE[\"TOP\"] = 0] = \"TOP\";\r\n\t    TREND_MARK_SIDE[TREND_MARK_SIDE[\"BOTTOM\"] = 1] = \"BOTTOM\";\r\n\t})(exports.TREND_MARK_SIDE || (exports.TREND_MARK_SIDE = {}));\r\n\tvar TREND_MARK_SIDE = exports.TREND_MARK_SIDE;\r\n\t(function (EVENTS) {\r\n\t    EVENTS[EVENTS[\"CHANGE\"] = 0] = \"CHANGE\";\r\n\t})(exports.EVENTS || (exports.EVENTS = {}));\r\n\tvar EVENTS = exports.EVENTS;\r\n\tvar AXIS_MARK_DEFAULT_OPTIONS = {\r\n\t    trendName: '',\r\n\t    title: '',\r\n\t    color: 'rgb(40,136,75)',\r\n\t    xVal: 0,\r\n\t    orientation: TREND_MARK_SIDE.TOP,\r\n\t    width: 85,\r\n\t    height: 200,\r\n\t    margin: 10,\r\n\t    onRender: TrendsMarksWidget_1.DEFAULT_RENDERER\r\n\t};\r\n\tvar TrendsMarksPlugin = (function (_super) {\r\n\t    __extends(TrendsMarksPlugin, _super);\r\n\t    function TrendsMarksPlugin(trendsMarksPluginOptions) {\r\n\t        _super.call(this, trendsMarksPluginOptions);\r\n\t        this.items = {};\r\n\t        this.rects = {};\r\n\t    }\r\n\t    TrendsMarksPlugin.prototype.onInitialStateApplied = function () {\r\n\t        this.bindEvents();\r\n\t        this.onMarksChangeHandler();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onStateChanged = function () {\r\n\t        this.onMarksChangeHandler();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getOptions = function () {\r\n\t        return _super.prototype.getOptions.call(this);\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getItems = function () {\r\n\t        return this.items;\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getItem = function (markName) {\r\n\t        return this.items[markName];\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.createMark = function (options) {\r\n\t        var marksOptions = this.getOptions().items;\r\n\t        var newMarkOptions = marksOptions.concat([options]);\r\n\t        this.chart.setState({ pluginsState: (_a = {}, _a[this.name] = { items: newMarkOptions }, _a) });\r\n\t        var _a;\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onChange = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS[EVENTS.CHANGE], cb);\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chart.trendsManager.onSegmentsRebuilded(function () { return _this.updateMarksSegments(); });\r\n\t        this.chart.screen.onZoomFrame(function () { return _this.calclulateMarksPositions(); });\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onInitialStateAppliedHandler = function () {\r\n\t        this.onMarksChangeHandler();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onMarksChangeHandler = function () {\r\n\t        var trendsMarksOptions = this.getOptions().items;\r\n\t        var actualMarksNames = [];\r\n\t        for (var _i = 0, trendsMarksOptions_1 = trendsMarksOptions; _i < trendsMarksOptions_1.length; _i++) {\r\n\t            var options = trendsMarksOptions_1[_i];\r\n\t            var marks = this.items;\r\n\t            // set mark name\r\n\t            if (!options.name) {\r\n\t                options.name = three_charts_1.Utils.getUid().toString();\r\n\t                actualMarksNames.push(options.name);\r\n\t                if (marks[options.name])\r\n\t                    three_charts_1.Utils.error('duplicated mark name ' + options.name);\r\n\t            }\r\n\t            else if (marks[options.name]) {\r\n\t                actualMarksNames.push(options.name);\r\n\t                continue;\r\n\t            }\r\n\t            options = three_charts_1.Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\r\n\t            var mark = new TrendMark(this.chart, options);\r\n\t            marks[options.name] = mark;\r\n\t        }\r\n\t        // delete not relevant marks\r\n\t        for (var markName in this.items) {\r\n\t            if (actualMarksNames.indexOf(markName) != -1)\r\n\t                continue;\r\n\t            delete this.items[markName];\r\n\t        }\r\n\t        this.updateMarksSegments();\r\n\t        this.ee.emit(EVENTS[EVENTS.CHANGE]);\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.calclulateMarksPositions = function () {\r\n\t        this.rects = {};\r\n\t        for (var markName in this.items) {\r\n\t            this.createMarkRect(this.items[markName]);\r\n\t        }\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.createMarkRect = function (mark) {\r\n\t        if (!mark.segment)\r\n\t            return;\r\n\t        var chart = this.chart;\r\n\t        var options = mark.options;\r\n\t        var width = options.width, height = options.height, name = options.name;\r\n\t        var left = chart.getPointOnXAxis(mark.xVal) - width / 2;\r\n\t        var top = chart.getPointOnYAxis(mark.yVal);\r\n\t        var isTopSideMark = options.orientation == TREND_MARK_SIDE.TOP;\r\n\t        var newOffset;\r\n\t        var row = 0;\r\n\t        if (isTopSideMark) {\r\n\t            top += height;\r\n\t        }\r\n\t        var markRect = [left, top, width, height];\r\n\t        var hasIntersection = false;\r\n\t        do {\r\n\t            for (var markName in this.rects) {\r\n\t                var rect = this.rects[markName];\r\n\t                hasIntersection = three_charts_1.Utils.rectsIntersect(rect, markRect);\r\n\t                if (!hasIntersection)\r\n\t                    continue;\r\n\t                if (isTopSideMark) {\r\n\t                    markRect[1] = rect[1] + markRect[3] + options.margin;\r\n\t                }\r\n\t                else {\r\n\t                    markRect[1] = rect[1] - rect[3] - options.margin;\r\n\t                }\r\n\t                row++;\r\n\t                break;\r\n\t            }\r\n\t        } while (hasIntersection);\r\n\t        if (isTopSideMark) {\r\n\t            newOffset = markRect[1] - markRect[3] - chart.getPointOnYAxis(mark.yVal);\r\n\t        }\r\n\t        else {\r\n\t            newOffset = chart.getPointOnYAxis(mark.yVal) - markRect[1];\r\n\t        }\r\n\t        mark._setOffset(newOffset);\r\n\t        mark._setRow(row);\r\n\t        this.rects[name] = markRect;\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.updateMarksSegments = function () {\r\n\t        var chart = this.chart;\r\n\t        var trends = chart.trendsManager.trends;\r\n\t        for (var trendName in trends) {\r\n\t            var marks = this.getTrendMarks(trendName);\r\n\t            var marksArr = [];\r\n\t            var xVals = [];\r\n\t            for (var markName in marks) {\r\n\t                var mark = marks[markName];\r\n\t                xVals.push(mark.options.xVal);\r\n\t                marksArr.push(mark);\r\n\t                mark._setSegment(null);\r\n\t            }\r\n\t            marksArr.sort(function (a, b) { return a.options.xVal - b.options.xVal; });\r\n\t            var trend = chart.getTrend(trendName);\r\n\t            var points = trend.segmentsManager.getSegmentsForXValues(xVals.sort(function (a, b) { return a - b; }));\r\n\t            for (var markInd = 0; markInd < marksArr.length; markInd++) {\r\n\t                marksArr[markInd]._setSegment(points[markInd]);\r\n\t            }\r\n\t        }\r\n\t        this.calclulateMarksPositions();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getTrendMarks = function (trendName) {\r\n\t        var trendMarks = [];\r\n\t        for (var markName in this.items) {\r\n\t            if (this.items[markName].options.trendName != trendName)\r\n\t                continue;\r\n\t            trendMarks.push(this.items[markName]);\r\n\t        }\r\n\t        return trendMarks;\r\n\t    };\r\n\t    TrendsMarksPlugin.NAME = 'TrendsMarks';\r\n\t    TrendsMarksPlugin.providedWidgets = [TrendsMarksWidget_1.TrendsMarksWidget];\r\n\t    return TrendsMarksPlugin;\r\n\t}(three_charts_1.ChartPlugin));\r\n\texports.TrendsMarksPlugin = TrendsMarksPlugin;\r\n\tvar TrendMark = (function () {\r\n\t    function TrendMark(chart, options) {\r\n\t        this.row = 0;\r\n\t        this.options = options;\r\n\t        this.chart = chart;\r\n\t    }\r\n\t    /**\r\n\t     * only for internal usage\r\n\t     */\r\n\t    TrendMark.prototype._setSegment = function (segment) {\r\n\t        this.segment = segment;\r\n\t        if (!segment)\r\n\t            return;\r\n\t        var trend = this.chart.getTrend(this.options.trendName);\r\n\t        if (trend.getOptions().type == three_charts_1.TREND_TYPE.LINE) {\r\n\t            this.xVal = segment.endXVal;\r\n\t            this.yVal = segment.endYVal;\r\n\t        }\r\n\t        else if (this.options.orientation == TREND_MARK_SIDE.TOP) {\r\n\t            this.xVal = segment.xVal;\r\n\t            this.yVal = segment.maxYVal;\r\n\t        }\r\n\t        else {\r\n\t            this.xVal = segment.xVal;\r\n\t            this.yVal = segment.minYVal;\r\n\t        }\r\n\t    };\r\n\t    TrendMark.prototype._setOffset = function (offset) {\r\n\t        this.offset = offset;\r\n\t    };\r\n\t    TrendMark.prototype._setRow = function (row) {\r\n\t        this.row = row;\r\n\t    };\r\n\t    return TrendMark;\r\n\t}());\r\n\texports.TrendMark = TrendMark;\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar three_charts_1 = __webpack_require__(2);\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar TrendsMarksPlugin_1 = __webpack_require__(5);\r\n\tvar Color_1 = __webpack_require__(7);\r\n\tvar MAX_MARKS_IN_ROW = 3;\r\n\t/**\r\n\t * widget for drawing trends marks for all trends\r\n\t */\r\n\tvar TrendsMarksWidget = (function (_super) {\r\n\t    __extends(TrendsMarksWidget, _super);\r\n\t    function TrendsMarksWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsMarksWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendMarksWidget;\r\n\t    };\r\n\t    TrendsMarksWidget.widgetName = \"TrendsMarks\";\r\n\t    return TrendsMarksWidget;\r\n\t}(three_charts_1.TrendsWidget));\r\n\texports.TrendsMarksWidget = TrendsMarksWidget;\r\n\t/**\r\n\t * widget for drawing trend marks for one trend\r\n\t */\r\n\tvar TrendMarksWidget = (function (_super) {\r\n\t    __extends(TrendMarksWidget, _super);\r\n\t    function TrendMarksWidget(chart, trendName) {\r\n\t        _super.call(this, chart, trendName);\r\n\t        this.marksWidgets = {};\r\n\t        this.object3D = new Object3D();\r\n\t        this.onMarksChange();\r\n\t    }\r\n\t    TrendMarksWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendMarksWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.getTrendsMarksPlugin().onChange(function () { return _this.onMarksChange(); });\r\n\t    };\r\n\t    TrendMarksWidget.prototype.getTrendsMarksPlugin = function () {\r\n\t        return this.chart.getPlugin(TrendsMarksPlugin_1.TrendsMarksPlugin.NAME);\r\n\t    };\r\n\t    TrendMarksWidget.prototype.onMarksChange = function () {\r\n\t        var marksItems = this.getTrendsMarksPlugin().getItems();\r\n\t        var widgets = this.marksWidgets;\r\n\t        var actualMarksNames = [];\r\n\t        for (var markName in marksItems) {\r\n\t            actualMarksNames.push(markName);\r\n\t            if (!widgets[markName])\r\n\t                this.createMarkWidget(marksItems[markName]);\r\n\t        }\r\n\t        for (var markName in this.marksWidgets) {\r\n\t            if (actualMarksNames.indexOf(markName) !== -1)\r\n\t                continue;\r\n\t            this.destroyMarkWidget(markName);\r\n\t        }\r\n\t    };\r\n\t    TrendMarksWidget.prototype.createMarkWidget = function (mark) {\r\n\t        if (!mark.segment)\r\n\t            return;\r\n\t        var markWidget = new TrendMarkWidget(this.chart, mark);\r\n\t        this.marksWidgets[mark.options.name] = markWidget;\r\n\t        this.object3D.add(markWidget.getObject3D());\r\n\t    };\r\n\t    TrendMarksWidget.prototype.destroyMarkWidget = function (markName) {\r\n\t        this.object3D.remove(this.marksWidgets[markName].getObject3D());\r\n\t        delete this.marksWidgets[markName];\r\n\t    };\r\n\t    TrendMarksWidget.prototype.onZoomFrame = function () {\r\n\t        var widgets = this.marksWidgets;\r\n\t        for (var markName in widgets) {\r\n\t            widgets[markName].onZoomFrameHandler();\r\n\t        }\r\n\t    };\r\n\t    TrendMarksWidget.prototype.onSegmentsAnimate = function () {\r\n\t        var widgets = this.marksWidgets;\r\n\t        for (var markName in widgets) {\r\n\t            widgets[markName].onSegmentsAnimate();\r\n\t        }\r\n\t    };\r\n\t    return TrendMarksWidget;\r\n\t}(three_charts_1.TrendWidget));\r\n\texports.TrendMarksWidget = TrendMarksWidget;\r\n\t/**\r\n\t * widget for drawing one trend mark\r\n\t */\r\n\tvar TrendMarkWidget = (function () {\r\n\t    function TrendMarkWidget(chart, trendMark) {\r\n\t        this.chart = chart;\r\n\t        this.mark = trendMark;\r\n\t        this.initObject();\r\n\t        this.show();\r\n\t    }\r\n\t    TrendMarkWidget.prototype.initObject = function () {\r\n\t        var _this = this;\r\n\t        var options = this.mark.options;\r\n\t        var width = options.width, height = options.height;\r\n\t        var texture = three_charts_1.Utils.createPixelPerfectTexture(width, height, function (ctx) {\r\n\t            options.onRender([_this.mark], ctx, _this.chart);\r\n\t        });\r\n\t        var material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });\r\n\t        material.transparent = true;\r\n\t        this.markMesh = new Mesh(new THREE.PlaneGeometry(width, height), material);\r\n\t    };\r\n\t    TrendMarkWidget.prototype.getObject3D = function () {\r\n\t        return this.markMesh;\r\n\t    };\r\n\t    TrendMarkWidget.prototype.onSegmentsAnimate = function () {\r\n\t        this.updatePosition();\r\n\t    };\r\n\t    TrendMarkWidget.prototype.onZoomFrameHandler = function () {\r\n\t        this.updatePosition();\r\n\t    };\r\n\t    TrendMarkWidget.prototype.updatePosition = function () {\r\n\t        if (!this.mark.segment)\r\n\t            return;\r\n\t        var mark = this.mark;\r\n\t        var options = this.mark.options;\r\n\t        // let meshMaterial = this.markMesh.material as MeshBasicMaterial;\r\n\t        // let lineMaterial = this.line.material as LineBasicMaterial;\r\n\t        // if (mark.row >= MAX_MARKS_IN_ROW - 1) {\r\n\t        // \tmeshMaterial.opacity = 0;\r\n\t        // \tlineMaterial.opacity = 0;\r\n\t        // } else {\r\n\t        // \tmeshMaterial.opacity = 1;\r\n\t        // \tlineMaterial.opacity = 1;\r\n\t        // }\r\n\t        var screen = this.chart.screen;\r\n\t        var posX = screen.getPointOnXAxis(mark.xVal);\r\n\t        var posY = screen.getPointOnYAxis(mark.yVal);\r\n\t        this.markMesh.position.set(posX, posY, 0);\r\n\t    };\r\n\t    TrendMarkWidget.prototype.show = function () {\r\n\t        if (!this.mark.segment)\r\n\t            return;\r\n\t        this.updatePosition();\r\n\t        var animations = this.chart.state.animations;\r\n\t        var time = animations.enabled ? 1 : 0;\r\n\t        this.markMesh.scale.set(0.01, 0.01, 1);\r\n\t        TweenLite.to(this.markMesh.scale, time, { x: 1, y: 1, ease: Elastic.easeOut });\r\n\t    };\r\n\t    return TrendMarkWidget;\r\n\t}());\r\n\texports.DEFAULT_RENDERER = function (marks, ctx, chart) {\r\n\t    var mark = marks[0];\r\n\t    var options = mark.options;\r\n\t    var isTopSide = options.orientation == TrendsMarksPlugin_1.TREND_MARK_SIDE.TOP;\r\n\t    var color = options.color !== void 0 ?\r\n\t        new Color_1.Color(options.color) :\r\n\t        new Color_1.Color(chart.getTrend(options.trendName).getOptions().lineColor);\r\n\t    var rgbaColor = color.getTransparent(0.5).rgbaStr;\r\n\t    var width = options.width, height = options.height;\r\n\t    var centerX = Math.round(width / 2);\r\n\t    var centerY = Math.round(height / 2);\r\n\t    var font = chart.state.font.m;\r\n\t    var textOffset = parseInt(font);\r\n\t    var textPosX = centerX;\r\n\t    var textPosY = isTopSide ? textOffset * 1.3 : height - textOffset * 0.7;\r\n\t    // draw rect\r\n\t    ctx.fillStyle = rgbaColor; //'rgba(0,0,0,0.3)';\r\n\t    ctx.strokeStyle = rgbaColor;\r\n\t    ctx.fillRect(0, isTopSide ? 0 : height, width, isTopSide ? textOffset * 2 : -textOffset * 2);\r\n\t    // draw dot\r\n\t    ctx.beginPath();\r\n\t    ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI, false);\r\n\t    ctx.fill();\r\n\t    // draw line\r\n\t    var lineEndY = textPosY;\r\n\t    ctx.beginPath();\r\n\t    ctx.moveTo(centerX, centerY);\r\n\t    ctx.lineTo(textPosX, lineEndY);\r\n\t    ctx.stroke();\r\n\t    // draw text\r\n\t    ctx.beginPath();\r\n\t    ctx.textAlign = 'center';\r\n\t    ctx.font = font;\r\n\t    ctx.fillStyle = 'white';\r\n\t    ctx.strokeStyle = 'white';\r\n\t    ctx.fillText(options.title, Math.round(textPosX), Math.round(textPosY));\r\n\t    // uncomment to preview mark rect\r\n\t    // ctx.rect(0, 0, width, height);\r\n\t    // ctx.stroke();\r\n\t    // let isTopSide = options.orientation == TREND_MARK_SIDE.TOP;\r\n\t    // var circleOffset = isTopSide ? 30 : 0;\r\n\t    // var circleR = 22;\r\n\t    // var circleX = markWidth / 2;\r\n\t    // var circleY = circleOffset + circleR;\r\n\t    // var textOffset = isTopSide ? 10 : circleR * 2 + 15;\r\n\t    // // title and description\r\n\t    // ctx.beginPath();\r\n\t    // ctx.textAlign = 'center';\r\n\t    // ctx.font = \"11px Arial\";\r\n\t    // ctx.fillStyle = 'rgba(255,255,255, 0.6)';\r\n\t    // ctx.fillText(options.title, circleX, textOffset);\r\n\t    // ctx.fillStyle = options.descriptionColor;\r\n\t    // ctx.fillText(options.description, circleX, textOffset + 12);\r\n\t    //\r\n\t    // // icon circle\r\n\t    // ctx.beginPath();\r\n\t    // ctx.fillStyle = options.iconColor;\r\n\t    // ctx.arc(circleX, circleY, circleR, 0, 2 * Math.PI);\r\n\t    // ctx.fill();\r\n\t    //\r\n\t    // // icon text\r\n\t    // ctx.font = \"19px Arial\";\r\n\t    // ctx.fillStyle = 'rgb(255, 255, 255)';\r\n\t    // ctx.fillText(options.icon, circleX, circleY + 7);\r\n\t};\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar Color = (function () {\r\n\t    function Color(color) {\r\n\t        this.set(color);\r\n\t    }\r\n\t    /**!\r\n\t     * @preserve $.parseColor\r\n\t     * Copyright 2011 THEtheChad Elliott\r\n\t     * Released under the MIT and GPL licenses.\r\n\t     */\r\n\t    /**\r\n\t     * Parse hex/rgb{a} color syntax.\r\n\t     * @input string\r\n\t     * @returns array [r,g,b{,o}]\r\n\t     */\r\n\t    Color.parseColor = function (color) {\r\n\t        var cache, p = parseInt // Use p as a byte saving reference to parseInt\r\n\t        , color = color.replace(/\\s\\s*/g, ''); //var\r\n\t        // Checks for 6 digit hex and converts string to integer\r\n\t        if (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\r\n\t        else if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\r\n\t            cache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\r\n\t        else if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\r\n\t        else if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3], +cache[4]];\r\n\t        else if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3]];\r\n\t        else\r\n\t            throw Error(color + ' is not supported by parseColor');\r\n\t        // Performs RGBA conversion by default\r\n\t        isNaN(cache[3]) && (cache[3] = 1);\r\n\t        return cache;\r\n\t        // Adds or removes 4th xVal based on rgba support\r\n\t        // Support is flipped twice to prevent erros if\r\n\t        // it's not defined\r\n\t        //return cache.slice(0,3 + !!$.support.rgba);\r\n\t    };\r\n\t    Color.numberToHexStr = function (value) {\r\n\t        var result = value.toString(16);\r\n\t        return '#' + '0'.repeat(6 - result.length) + result;\r\n\t    };\r\n\t    Color.prototype.set = function (color) {\r\n\t        if (typeof color == 'number')\r\n\t            color = Color.numberToHexStr(color);\r\n\t        var colorStr = color;\r\n\t        var rgba = Color.parseColor(colorStr);\r\n\t        this.r = rgba[0];\r\n\t        this.g = rgba[1];\r\n\t        this.b = rgba[2];\r\n\t        this.a = rgba[3];\r\n\t        this.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\r\n\t        this.hexStr = Color.numberToHexStr(this.value);\r\n\t        this.rgbaStr = \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.a + \")\";\r\n\t    };\r\n\t    Color.prototype.getTransparent = function (opacity) {\r\n\t        return new Color(\"rgba(\" + this.hexStr + \", \" + opacity + \")\");\r\n\t    };\r\n\t    return Color;\r\n\t}());\r\n\texports.Color = Color;\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 342ed643c9ba45b2462e\n **/","export * from './TrendsMarksPlugin';\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/src/TrendsMarksPlugin/index.ts\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"three-charts\"\n ** module id = 2\n ** module chunks = 0 1 2 3\n **/","\nimport Vector3 = THREE.Vector3;\nimport { ChartPlugin, ChartWidget, TrendSegment, TREND_TYPE, Utils, Chart } from 'three-charts';\nimport { TrendsMarksWidget, DEFAULT_RENDERER } from './TrendsMarksWidget';\nimport { TColor } from \"../../../src/Color\";\n\nexport enum TREND_MARK_SIDE {TOP, BOTTOM}\nexport enum EVENTS {CHANGE}\nexport type TTrendsMarksPluginOptions = {items: ITrendMarkOptions[]};\n\nexport interface ITrendMarkOptions {\n\ttrendName: string,\n\txVal: number,\n\ttitle?: string,\n\tname?: string,\n\tcolor?: TColor,\n\torientation?: TREND_MARK_SIDE,\n\twidth?: number,\n\theight?: number,\n\t/**\n\t * space between marks\n\t */\n\tmargin?: number,\n\t/**\n\t * custom render function\n\t */\n\tonRender?: (\n\t\tmarks: TrendMark[],\n\t\tctx: CanvasRenderingContext2D,\n\t\tchart: Chart\n\t) => any,\n\tuserData?: any\n}\n\nconst AXIS_MARK_DEFAULT_OPTIONS: ITrendMarkOptions = {\n\ttrendName: '',\n\ttitle: '',\n\tcolor: 'rgb(40,136,75)',\n\txVal: 0,\n\torientation: TREND_MARK_SIDE.TOP,\n\twidth: 85,\n\theight: 200,\n\tmargin: 10,\n\tonRender: DEFAULT_RENDERER\n};\n\n\nexport class TrendsMarksPlugin extends ChartPlugin {\n\tstatic NAME = 'TrendsMarks';\n\tstatic providedWidgets: typeof ChartWidget[] = [TrendsMarksWidget];\n\n\tprivate items: {[name: string]: TrendMark} = {};\n\tprivate rects: {[name: string]: number[]} = {};\n\n\tconstructor(trendsMarksPluginOptions: TTrendsMarksPluginOptions) {\n\t\tsuper(trendsMarksPluginOptions);\n\t}\n\n\tprotected onInitialStateApplied() {\n\t\tthis.bindEvents();\n\t\tthis.onMarksChangeHandler();\n\t}\n\n\tprotected onStateChanged() {\n\t\tthis.onMarksChangeHandler();\n\t}\n\n\n\tgetOptions(): TTrendsMarksPluginOptions {\n\t\treturn super.getOptions() as TTrendsMarksPluginOptions;\n\t}\n\n\tgetItems() {\n\t\treturn this.items;\n\t}\n\n\tgetItem(markName: string) {\n\t\treturn this.items[markName];\n\t}\n\n\tcreateMark(options: ITrendMarkOptions) {\n\t\tvar marksOptions = this.getOptions().items;\n\t\tvar newMarkOptions = marksOptions.concat([options]);\n\t\tthis.chart.setState({pluginsState: {[this.name]: {items: newMarkOptions}}});\n\t}\n\n\tonChange(cb: () => any) {\n\t\treturn this.ee.subscribe(EVENTS[EVENTS.CHANGE], cb);\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.chart.trendsManager.onSegmentsRebuilded(() => this.updateMarksSegments());\n\t\tthis.chart.screen.onZoomFrame(() => this.calclulateMarksPositions());\n\t}\n\n\tprotected onInitialStateAppliedHandler() {\n\t\tthis.onMarksChangeHandler();\n\t}\n\n\tprivate onMarksChangeHandler() {\n\t\tvar trendsMarksOptions = this.getOptions().items;\n\t\tlet actualMarksNames: string[] = [];\n\t\tfor (let options of trendsMarksOptions) {\n\t\t\tvar marks = this.items;\n\n\t\t\t// set mark name\n\t\t\tif (!options.name) {\n\t\t\t\toptions.name = Utils.getUid().toString();\n\t\t\t\tactualMarksNames.push(options.name);\n\t\t\t\tif (marks[options.name]) Utils.error('duplicated mark name ' + options.name);\n\t\t\t} else if (marks[options.name]) {\n\t\t\t\tactualMarksNames.push(options.name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toptions = Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\n\n\t\t\tlet mark = new TrendMark(this.chart, options);\n\t\t\tmarks[options.name] = mark;\n\t\t}\n\n\t\t// delete not relevant marks\n\t\tfor (let markName in this.items) {\n\t\t\tif (actualMarksNames.indexOf(markName) != -1) continue;\n\t\t\tdelete this.items[markName];\n\t\t}\n\t\tthis.updateMarksSegments();\n\t\tthis.ee.emit(EVENTS[EVENTS.CHANGE]);\n\t}\n\n\n\tprivate calclulateMarksPositions() {\n\t\tthis.rects = {};\n\t\tfor (let markName in this.items) {\n\t\t\tthis.createMarkRect(this.items[markName]);\n\t\t}\n\t}\n\n\tprivate createMarkRect(mark: TrendMark) {\n\t\tif (!mark.segment) return;\n\n\t\tlet chart = this.chart;\n\t\tlet options = mark.options;\n\t\tlet {width, height, name} = options;\n\t\tlet left = chart.getPointOnXAxis(mark.xVal) - width / 2;\n\t\tlet top = chart.getPointOnYAxis(mark.yVal);\n\t\tlet isTopSideMark = options.orientation == TREND_MARK_SIDE.TOP;\n\t\tlet newOffset: number;\n\t\tlet row = 0;\n\n\t\tif (isTopSideMark) {\n\t\t\ttop += height;\n\t\t}\n\n\t\tlet markRect = [left, top, width, height];\n\t\tlet hasIntersection = false;\n\t\tdo {\n\t\t\tfor (let markName in this.rects) {\n\t\t\t\tlet rect = this.rects[markName];\n\t\t\t\thasIntersection = Utils.rectsIntersect(rect, markRect);\n\t\t\t\tif (!hasIntersection) continue;\n\t\t\t\tif (isTopSideMark) {\n\t\t\t\t\tmarkRect[1] = rect[1] + markRect[3] + options.margin;\n\t\t\t\t} else {\n\t\t\t\t\tmarkRect[1] = rect[1] - rect[3] - options.margin;\n\t\t\t\t}\n\t\t\t\trow++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (hasIntersection);\n\n\t\tif (isTopSideMark) {\n\t\t\tnewOffset = markRect[1] - markRect[3] - chart.getPointOnYAxis(mark.yVal);\n\t\t} else {\n\t\t\tnewOffset = chart.getPointOnYAxis(mark.yVal) - markRect[1];\n\t\t}\n\n\t\tmark._setOffset(newOffset);\n\t\tmark._setRow(row);\n\t\tthis.rects[name] = markRect;\n\t}\n\n\tprivate updateMarksSegments() {\n\t\tlet chart = this.chart;\n\t\tlet trends = chart.trendsManager.trends;\n\t\tfor (let trendName in trends) {\n\t\t\tvar marks = this.getTrendMarks(trendName);\n\t\t\tvar marksArr: TrendMark[] = [];\n\t\t\tvar xVals: number[] = [];\n\t\t\tfor (let markName in marks) {\n\t\t\t\tlet mark = marks[markName];\n\t\t\t\txVals.push(mark.options.xVal);\n\t\t\t\tmarksArr.push(mark);\n\t\t\t\tmark._setSegment(null);\n\t\t\t}\n\t\t\tmarksArr.sort((a, b) => a.options.xVal - b.options.xVal);\n\t\t\tlet trend = chart.getTrend(trendName);\n\t\t\tlet points = trend.segmentsManager.getSegmentsForXValues(xVals.sort((a, b) => a - b));\n\t\t\tfor (let markInd = 0; markInd < marksArr.length; markInd++) {\n\t\t\t\tmarksArr[markInd]._setSegment(points[markInd]);\n\t\t\t}\n\t\t}\n\t\tthis.calclulateMarksPositions();\n\t}\n\n\tprivate getTrendMarks(trendName: string): TrendMark[] {\n\t\tlet trendMarks: TrendMark[] = [];\n\t\tfor (let markName in this.items) {\n\t\t\tif (this.items[markName].options.trendName != trendName) continue;\n\t\t\ttrendMarks.push(this.items[markName]);\n\t\t}\n\t\treturn trendMarks;\n\t}\n\n}\n\nexport class TrendMark {\n\toptions: ITrendMarkOptions;\n\tsegment: TrendSegment;\n\txVal: number;\n\tyVal: number;\n\toffset: number;\n\trow = 0;\n\tprotected chart: Chart;\n\n\tconstructor(chart: Chart, options: ITrendMarkOptions) {\n\t\tthis.options = options;\n\t\tthis.chart = chart;\n\t}\n\n\n\t/**\n\t * only for internal usage\n\t */\n\t_setSegment(segment: TrendSegment) {\n\t\tthis.segment = segment;\n\t\tif (!segment) return;\n\n\t\tlet trend = this.chart.getTrend(this.options.trendName);\n\n\t\tif (trend.getOptions().type == TREND_TYPE.LINE) {\n\t\t\tthis.xVal = segment.endXVal;\n\t\t\tthis.yVal = segment.endYVal;\n\t\t} else if (this.options.orientation == TREND_MARK_SIDE.TOP) {\n\t\t\tthis.xVal = segment.xVal;\n\t\t\tthis.yVal = segment.maxYVal;\n\t\t} else {\n\t\t\tthis.xVal = segment.xVal;\n\t\t\tthis.yVal = segment.minYVal;\n\t\t}\n\t}\n\n\t_setOffset(offset: number) {\n\t\tthis.offset = offset;\n\t}\n\n\t_setRow(row: number) {\n\t\tthis.row = row;\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.ts\n **/","import {Chart, Utils, TrendsWidget, TrendWidget } from 'three-charts';\nimport Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport LineSegments = THREE.LineSegments;\nimport LineDashedMaterial = THREE.LineDashedMaterial;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport { TrendMark, TREND_MARK_SIDE, TrendsMarksPlugin } from \"./TrendsMarksPlugin\";\nimport { Color } from \"../../../src/Color\";\n\n\nconst MAX_MARKS_IN_ROW = 3;\n\n/**\n * widget for drawing trends marks for all trends\n */\nexport class TrendsMarksWidget extends TrendsWidget<TrendMarksWidget> {\n\tstatic widgetName = \"TrendsMarks\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendMarksWidget;\n\t}\n}\n\n/**\n * widget for drawing trend marks for one trend\n */\nexport class TrendMarksWidget extends TrendWidget {\n\n\tprivate trendsMarksPlugin: TrendsMarksPlugin;\n\tprivate object3D: Object3D;\n\tprivate marksWidgets: {[name: string]: TrendMarkWidget} = {};\n\n\tconstructor (chart: Chart, trendName: string) {\n\t\tsuper(chart, trendName);\n\t\tthis.object3D = new Object3D();\n\t\tthis.onMarksChange();\n\t}\n\n\tgetObject3D() {\n\t\treturn this.object3D;\n\t}\n\t\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.getTrendsMarksPlugin().onChange(() => this.onMarksChange());\n\t}\n\n\tprivate getTrendsMarksPlugin(): TrendsMarksPlugin {\n\t\treturn this.chart.getPlugin(TrendsMarksPlugin.NAME) as TrendsMarksPlugin;\n\t}\n\n\tprivate onMarksChange() {\n\t\tlet marksItems = this.getTrendsMarksPlugin().getItems();\n\t\tlet widgets = this.marksWidgets;\n\t\tlet actualMarksNames: string[] = [];\n\t\tfor (let markName in marksItems) {\n\t\t\tactualMarksNames.push(markName);\n\t\t\tif (!widgets[markName]) this.createMarkWidget(marksItems[markName]);\n\t\t}\n\t\tfor (let markName in this.marksWidgets) {\n\t\t\tif (actualMarksNames.indexOf(markName) !== -1) continue;\n\t\t\tthis.destroyMarkWidget(markName);\n\t\t}\n\n\t}\n\t\n\tprivate createMarkWidget(mark: TrendMark) {\n\t\tif (!mark.segment) return;\n\t\tlet markWidget = new TrendMarkWidget(this.chart, mark);\n\t\tthis.marksWidgets[mark.options.name] = markWidget;\n\t\tthis.object3D.add(markWidget.getObject3D());\n\t}\n\n\tprivate destroyMarkWidget(markName: string) {\n\t\tthis.object3D.remove(this.marksWidgets[markName].getObject3D());\n\t\tdelete this.marksWidgets[markName];\n\t}\n\n\tprotected onZoomFrame() {\n\t\tvar widgets = this.marksWidgets;\n\t\tfor (let markName in widgets) {\n\t\t\twidgets[markName].onZoomFrameHandler();\n\t\t}\n\t}\n\n\tprotected onSegmentsAnimate() {\n\t\tvar widgets = this.marksWidgets;\n\t\tfor (let markName in widgets) {\n\t\t\twidgets[markName].onSegmentsAnimate();\n\t\t}\n\t}\n}\n\n/**\n * widget for drawing one trend mark\n */\nclass TrendMarkWidget {\n\tprivate chart: Chart;\n\tprivate mark: TrendMark;\n\tprivate markMesh: Mesh;\n\n\tconstructor(chart: Chart, trendMark: TrendMark) {\n\t\tthis.chart = chart;\n\t\tthis.mark = trendMark;\n\t\tthis.initObject();\n\t\tthis.show();\n\t}\n\t\n\tprotected initObject() {\n\t\tlet options = this.mark.options;\n\t\tlet {width, height} = options;\n\n\t\tlet texture = Utils.createPixelPerfectTexture(width, height, (ctx) => {\n\t\t\toptions.onRender([this.mark], ctx, this.chart);\n\t\t});\n\n\t\tvar material = new THREE.MeshBasicMaterial( {map: texture, side: THREE.FrontSide} );\n\t\tmaterial.transparent = true;\n\n\t\tthis.markMesh = new Mesh(\n\t\t\tnew THREE.PlaneGeometry(width, height),\n\t\t\tmaterial\n\t\t);\n\t}\n\n\tgetObject3D() {\n\t\treturn this.markMesh;\n\t}\n\n\tonSegmentsAnimate() {\n\t\tthis.updatePosition();\n\t}\n\n\tonZoomFrameHandler() {\n\t\tthis.updatePosition();\n\t}\n\n\tprivate updatePosition() {\n\t\tif (!this.mark.segment) return;\n\t\tlet mark = this.mark;\n\t\tlet options = this.mark.options;\n\t\t// let meshMaterial = this.markMesh.material as MeshBasicMaterial;\n\t\t// let lineMaterial = this.line.material as LineBasicMaterial;\n\t\t// if (mark.row >= MAX_MARKS_IN_ROW - 1) {\n\t\t// \tmeshMaterial.opacity = 0;\n\t\t// \tlineMaterial.opacity = 0;\n\t\t// } else {\n\t\t// \tmeshMaterial.opacity = 1;\n\t\t// \tlineMaterial.opacity = 1;\n\t\t// }\n\n\t\tlet screen = this.chart.screen;\n\t\tlet posX = screen.getPointOnXAxis(mark.xVal);\n\t\tlet posY = screen.getPointOnYAxis(mark.yVal);\n\t\tthis.markMesh.position.set(posX, posY, 0);\n\t}\n\n\tprivate show() {\n\t\tif (!this.mark.segment) return;\n\t\tthis.updatePosition();\n\t\tvar animations = this.chart.state.animations;\n\t\tvar time = animations.enabled ? 1 : 0;\n\t\tthis.markMesh.scale.set(0.01, 0.01, 1);\n\t\tTweenLite.to(this.markMesh.scale, time, {x: 1, y: 1, ease: Elastic.easeOut});\n\t}\n}\n\nexport const DEFAULT_RENDERER = (\n\tmarks: TrendMark[],\n\tctx: CanvasRenderingContext2D,\n\tchart: Chart\n) =>  {\n\n\tlet mark = marks[0];\n\tlet options = mark.options;\n\tlet isTopSide = options.orientation == TREND_MARK_SIDE.TOP;\n\tlet color = options.color !== void 0 ?\n\t\tnew Color(options.color) :\n\t\tnew Color(chart.getTrend(options.trendName).getOptions().lineColor);\n\tlet rgbaColor = color.getTransparent(0.5).rgbaStr;\n\tlet {width, height} = options;\n\tlet centerX = Math.round(width / 2);\n\tlet centerY =  Math.round(height / 2);\n\tlet font = chart.state.font.m;\n\tlet textOffset = parseInt(font);\n\tlet textPosX = centerX;\n\tlet textPosY = isTopSide ? textOffset * 1.3 : height - textOffset * 0.7;\n\n\t// draw rect\n\tctx.fillStyle = rgbaColor; //'rgba(0,0,0,0.3)';\n\tctx.strokeStyle = rgbaColor;\n\tctx.fillRect(\n\t\t0,\n\t\tisTopSide ? 0 : height,\n\t\twidth,\n\t\tisTopSide ? textOffset * 2 : -textOffset * 2\n\t);\n\n\n\t// draw dot\n\tctx.beginPath();\n\tctx.arc(centerX, centerY, 4, 0, 2 * Math.PI, false);\n\tctx.fill();\n\n\t// draw line\n\tlet lineEndY = textPosY ;\n\tctx.beginPath();\n\tctx.moveTo(centerX, centerY);\n\tctx.lineTo(textPosX, lineEndY);\n\tctx.stroke();\n\n\t// draw text\n\tctx.beginPath();\n\tctx.textAlign = 'center';\n\tctx.font = font;\n\tctx.fillStyle = 'white';\n\tctx.strokeStyle = 'white';\n\tctx.fillText(\n\t\toptions.title,\n\t\tMath.round(textPosX),\n\t\tMath.round(textPosY)\n\t);\n\n\n\n\t// uncomment to preview mark rect\n\t// ctx.rect(0, 0, width, height);\n\t// ctx.stroke();\n\n\n\t// let isTopSide = options.orientation == TREND_MARK_SIDE.TOP;\n\t// var circleOffset = isTopSide ? 30 : 0;\n\t// var circleR = 22;\n\t// var circleX = markWidth / 2;\n\t// var circleY = circleOffset + circleR;\n\t// var textOffset = isTopSide ? 10 : circleR * 2 + 15;\n\n\t// // title and description\n\t// ctx.beginPath();\n\t// ctx.textAlign = 'center';\n\t// ctx.font = \"11px Arial\";\n\t// ctx.fillStyle = 'rgba(255,255,255, 0.6)';\n\t// ctx.fillText(options.title, circleX, textOffset);\n\t// ctx.fillStyle = options.descriptionColor;\n\t// ctx.fillText(options.description, circleX, textOffset + 12);\n    //\n\t// // icon circle\n\t// ctx.beginPath();\n\t// ctx.fillStyle = options.iconColor;\n\t// ctx.arc(circleX, circleY, circleR, 0, 2 * Math.PI);\n\t// ctx.fill();\n    //\n\t// // icon text\n\t// ctx.font = \"19px Arial\";\n\t// ctx.fillStyle = 'rgb(255, 255, 255)';\n\t// ctx.fillText(options.icon, circleX, circleY + 7);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/src/TrendsMarksPlugin/TrendsMarksWidget.ts\n **/","export declare type TColor = string | number;\n\n\nexport class Color {\n\n\t/**!\n\t * @preserve $.parseColor\n\t * Copyright 2011 THEtheChad Elliott\n\t * Released under the MIT and GPL licenses.\n\t */\n\t/**\n\t * Parse hex/rgb{a} color syntax.\n\t * @input string\n\t * @returns array [r,g,b{,o}]\n\t */\n\tstatic parseColor(color: string): number[] {\n\n\t\tvar cache: any\n\t\t\t, p = parseInt // Use p as a byte saving reference to parseInt\n\t\t\t, color = color.replace(/\\s\\s*/g, '') // Remove all spaces\n\t\t\t;//var\n\n\t\t// Checks for 6 digit hex and converts string to integer\n\t\tif (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\n\n\t\t// Checks for 3 digit hex and converts string to integer\n\t\telse if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\n\t\t\tcache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\n\n\n\t\t// Checks for 6 digit hex with alpha and converts string to integer\n\t\telse if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\n\n\t\t// Checks for rgba and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3], +cache[4]];\n\n\t\t// Checks for rgb and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3]];\n\n\t\t// Otherwise throw an exception to make debugging easier\n\t\telse throw Error(color + ' is not supported by parseColor');\n\n\t\t// Performs RGBA conversion by default\n\t\tisNaN(cache[3]) && (cache[3] = 1);\n\t\treturn cache;\n\t\t// Adds or removes 4th xVal based on rgba support\n\t\t// Support is flipped twice to prevent erros if\n\t\t// it's not defined\n\t\t//return cache.slice(0,3 + !!$.support.rgba);\n\t}\n\n\tr: number;\n\tg: number;\n\tb: number;\n\ta: number;\n\tvalue: number;\n\thexStr: string;\n\trgbaStr: string;\n\n\tconstructor (color: TColor) {\n\t\tthis.set(color);\n\t}\n\n\tstatic numberToHexStr(value: number): string {\n\t\tlet result = value.toString(16);\n\t\treturn '#' + '0'.repeat(6 - result.length) + result;\n\t}\n\n\n\tset(color: TColor) {\n\t\tif (typeof color == 'number') color = Color.numberToHexStr(color);\n\t\tlet colorStr = color as string;\n\t\tlet rgba = Color.parseColor(colorStr);\n\t\tthis.r = rgba[0];\n\t\tthis.g = rgba[1];\n\t\tthis.b = rgba[2];\n\t\tthis.a = rgba[3];\n\t\tthis.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\n\t\tthis.hexStr = Color.numberToHexStr(this.value);\n\t\tthis.rgbaStr = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;\n\t}\n\n\tgetTransparent(opacity: number) {\n\t\treturn new Color(`rgba(${this.hexStr}, ${opacity})`);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Color.ts\n **/"],"sourceRoot":""}