{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6**","webpack:///plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.js","webpack:///webpack/bootstrap b41758098ad59fb86f3a?ea8e**","webpack:///./plugins/src/TrendsMarksPlugin/index.ts","webpack:///external \"three-charts\"?bed9**","webpack:///./plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.ts","webpack:///./plugins/src/TrendsMarksPlugin/TrendsMarksWidget.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","__export","hasOwnProperty","__extends","d","b","__","constructor","prototype","Object","create","three_charts_1","TrendsMarksWidget_1","TREND_MARK_SIDE","EVENTS","AXIS_MARK_DEFAULT_OPTIONS","trendName","title","description","descriptionColor","value","iconColor","orientation","TOP","width","height","offset","margin","TrendsMarksPlugin","_super","trendsMarksPluginOptions","items","rects","onInitialStateApplied","bindEvents","onMarksChangeHandler","onStateChanged","getOptions","getItems","getItem","markName","createMark","options","marksOptions","newMarkOptions","concat","chartState","setState","pluginsState","_a","name","onChange","cb","ee","subscribe","CHANGE","_this","trendsManager","onSegmentsRebuilded","updateMarksSegments","screen","onZoomFrame","calclulateMarksPositions","onInitialStateAppliedHandler","trendsMarksOptions","actualMarksNames","_i","trendsMarksOptions_1","length","marks","Utils","getUid","toString","push","error","deepMerge","mark","TrendMark","indexOf","emit","createMarkRect","segment","state","left","getPointOnXAxis","xVal","top","getPointOnYAxis","yVal","isTopSideMark","newOffset","row","markRect","hasIntersection","rect","rectsIntersect","_setOffset","_setRow","trends","getTrendMarks","marksArr","xVals","_setSegment","sort","a","trend","getTrend","points","segmentsManager","getSegmentsForXValues","markInd","trendMarks","NAME","pluginWidgets","TrendsMarksWidget","ChartPlugin","type","TREND_TYPE","LINE","endXVal","endYVal","maxYVal","minYVal","Geometry","THREE","Mesh","Object3D","TrendsMarksPlugin_1","MAX_MARKS_IN_ROW","apply","arguments","getTrendWidgetClass","TrendMarksWidget","widgetName","TrendsWidget","marksWidgets","object3D","onMarksChange","getObject3D","getTrendsMarksPlugin","getPlugin","marksItems","widgets","createMarkWidget","destroyMarkWidget","markWidget","TrendMarkWidget","add","remove","onZoomFrameHandler","onSegmentsAnimate","TrendWidget","trendMark","markHeight","markWidth","position","lineHeight","x","y","initObject","show","markMesh","createMarkMesh","line","createMarkLine","isTopSide","texture","createPixelPerfectTexture","ctx","circleOffset","circleR","circleX","circleY","textOffset","beginPath","textAlign","font","fillStyle","fillText","arc","Math","PI","fill","icon","material","MeshBasicMaterial","map","side","FrontSide","transparent","mesh","PlaneGeometry","lineGeometry","vertices","Vector3","computeLineDistances","lineMaterial","LineDashedMaterial","dashSize","gapSize","opacity","Line","setZ","updatePosition","meshMaterial","posX","posY","geometry","setY","verticesNeedUpdate","lineDistancesNeedUpdate","set","animations","data","time","enabled","scale","TweenLite","to","ease","Elastic","easeOut"],"mappings":"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","file":"plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three-charts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three-charts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory(require(\"three-charts\"));\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory(root[\"three-charts\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three-charts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three-charts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory(require(\"three-charts\"));\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory(root[\"three-charts\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(5));\r\n\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar three_charts_1 = __webpack_require__(2);\r\n\tvar TrendsMarksWidget_1 = __webpack_require__(6);\r\n\t(function (TREND_MARK_SIDE) {\r\n\t    TREND_MARK_SIDE[TREND_MARK_SIDE[\"TOP\"] = 0] = \"TOP\";\r\n\t    TREND_MARK_SIDE[TREND_MARK_SIDE[\"BOTTOM\"] = 1] = \"BOTTOM\";\r\n\t})(exports.TREND_MARK_SIDE || (exports.TREND_MARK_SIDE = {}));\r\n\tvar TREND_MARK_SIDE = exports.TREND_MARK_SIDE;\r\n\t(function (EVENTS) {\r\n\t    EVENTS[EVENTS[\"CHANGE\"] = 0] = \"CHANGE\";\r\n\t})(exports.EVENTS || (exports.EVENTS = {}));\r\n\tvar EVENTS = exports.EVENTS;\r\n\tvar AXIS_MARK_DEFAULT_OPTIONS = {\r\n\t    trendName: '',\r\n\t    title: '',\r\n\t    description: '',\r\n\t    descriptionColor: 'rgb(40,136,75)',\r\n\t    value: 0,\r\n\t    iconColor: 'rgb(255, 102, 217)',\r\n\t    orientation: TREND_MARK_SIDE.TOP,\r\n\t    width: 65,\r\n\t    height: 80,\r\n\t    offset: 40,\r\n\t    margin: 20\r\n\t};\r\n\tvar TrendsMarksPlugin = (function (_super) {\r\n\t    __extends(TrendsMarksPlugin, _super);\r\n\t    function TrendsMarksPlugin(trendsMarksPluginOptions) {\r\n\t        _super.call(this, trendsMarksPluginOptions);\r\n\t        this.items = {};\r\n\t        this.rects = {};\r\n\t    }\r\n\t    TrendsMarksPlugin.prototype.onInitialStateApplied = function () {\r\n\t        this.bindEvents();\r\n\t        this.onMarksChangeHandler();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onStateChanged = function () {\r\n\t        this.onMarksChangeHandler();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getOptions = function () {\r\n\t        return _super.prototype.getOptions.call(this);\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getItems = function () {\r\n\t        return this.items;\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getItem = function (markName) {\r\n\t        return this.items[markName];\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.createMark = function (options) {\r\n\t        var marksOptions = this.getOptions().items;\r\n\t        var newMarkOptions = marksOptions.concat([options]);\r\n\t        this.chartState.setState({ pluginsState: (_a = {}, _a[this.name] = { items: newMarkOptions }, _a) });\r\n\t        var _a;\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onChange = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS[EVENTS.CHANGE], cb);\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chartState.trendsManager.onSegmentsRebuilded(function () { return _this.updateMarksSegments(); });\r\n\t        this.chartState.screen.onZoomFrame(function () { return _this.calclulateMarksPositions(); });\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onInitialStateAppliedHandler = function () {\r\n\t        this.onMarksChangeHandler();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.onMarksChangeHandler = function () {\r\n\t        var trendsMarksOptions = this.getOptions().items;\r\n\t        var actualMarksNames = [];\r\n\t        for (var _i = 0, trendsMarksOptions_1 = trendsMarksOptions; _i < trendsMarksOptions_1.length; _i++) {\r\n\t            var options = trendsMarksOptions_1[_i];\r\n\t            var marks = this.items;\r\n\t            // set mark name\r\n\t            if (!options.name) {\r\n\t                options.name = three_charts_1.Utils.getUid().toString();\r\n\t                actualMarksNames.push(options.name);\r\n\t                if (marks[options.name])\r\n\t                    three_charts_1.Utils.error('duplicated mark name ' + options.name);\r\n\t            }\r\n\t            else if (marks[options.name]) {\r\n\t                actualMarksNames.push(options.name);\r\n\t                continue;\r\n\t            }\r\n\t            options = three_charts_1.Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\r\n\t            var mark = new TrendMark(this.chartState, options);\r\n\t            marks[options.name] = mark;\r\n\t        }\r\n\t        // delete not relevant marks\r\n\t        for (var markName in this.items) {\r\n\t            if (actualMarksNames.indexOf(markName) != -1)\r\n\t                continue;\r\n\t            delete this.items[markName];\r\n\t        }\r\n\t        this.updateMarksSegments();\r\n\t        this.ee.emit(EVENTS[EVENTS.CHANGE]);\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.calclulateMarksPositions = function () {\r\n\t        this.rects = {};\r\n\t        for (var markName in this.items) {\r\n\t            this.createMarkRect(this.items[markName]);\r\n\t        }\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.createMarkRect = function (mark) {\r\n\t        if (!mark.segment)\r\n\t            return;\r\n\t        var state = this.chartState;\r\n\t        var options = mark.options;\r\n\t        var width = options.width, height = options.height, offset = options.offset, name = options.name;\r\n\t        var left = state.getPointOnXAxis(mark.xVal) - width / 2;\r\n\t        var top = state.getPointOnYAxis(mark.yVal);\r\n\t        var isTopSideMark = options.orientation == TREND_MARK_SIDE.TOP;\r\n\t        var newOffset;\r\n\t        var row = 0;\r\n\t        if (isTopSideMark) {\r\n\t            top += offset + height;\r\n\t        }\r\n\t        else {\r\n\t            top -= offset;\r\n\t        }\r\n\t        var markRect = [left, top, width, height];\r\n\t        var hasIntersection = false;\r\n\t        do {\r\n\t            for (var markName in this.rects) {\r\n\t                var rect = this.rects[markName];\r\n\t                hasIntersection = three_charts_1.Utils.rectsIntersect(rect, markRect);\r\n\t                if (!hasIntersection)\r\n\t                    continue;\r\n\t                if (isTopSideMark) {\r\n\t                    markRect[1] = rect[1] + markRect[3] + options.margin;\r\n\t                }\r\n\t                else {\r\n\t                    markRect[1] = rect[1] - rect[3] - options.margin;\r\n\t                }\r\n\t                row++;\r\n\t                break;\r\n\t            }\r\n\t        } while (hasIntersection);\r\n\t        if (isTopSideMark) {\r\n\t            newOffset = markRect[1] - markRect[3] - state.getPointOnYAxis(mark.yVal);\r\n\t        }\r\n\t        else {\r\n\t            newOffset = state.getPointOnYAxis(mark.yVal) - markRect[1];\r\n\t        }\r\n\t        mark._setOffset(newOffset);\r\n\t        mark._setRow(row);\r\n\t        this.rects[name] = markRect;\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.updateMarksSegments = function () {\r\n\t        var chartState = this.chartState;\r\n\t        var trends = chartState.trendsManager.trends;\r\n\t        for (var trendName in trends) {\r\n\t            var marks = this.getTrendMarks(trendName);\r\n\t            var marksArr = [];\r\n\t            var xVals = [];\r\n\t            for (var markName in marks) {\r\n\t                var mark = marks[markName];\r\n\t                xVals.push(mark.options.value);\r\n\t                marksArr.push(mark);\r\n\t                mark._setSegment(null);\r\n\t            }\r\n\t            marksArr.sort(function (a, b) { return a.options.value - b.options.value; });\r\n\t            var trend = chartState.getTrend(trendName);\r\n\t            var points = trend.segmentsManager.getSegmentsForXValues(xVals.sort(function (a, b) { return a - b; }));\r\n\t            for (var markInd = 0; markInd < marksArr.length; markInd++) {\r\n\t                marksArr[markInd]._setSegment(points[markInd]);\r\n\t            }\r\n\t        }\r\n\t        this.calclulateMarksPositions();\r\n\t    };\r\n\t    TrendsMarksPlugin.prototype.getTrendMarks = function (trendName) {\r\n\t        var trendMarks = [];\r\n\t        for (var markName in this.items) {\r\n\t            if (this.items[markName].options.trendName != trendName)\r\n\t                continue;\r\n\t            trendMarks.push(this.items[markName]);\r\n\t        }\r\n\t        return trendMarks;\r\n\t    };\r\n\t    TrendsMarksPlugin.NAME = 'TrendsMarks';\r\n\t    TrendsMarksPlugin.pluginWidgets = [TrendsMarksWidget_1.TrendsMarksWidget];\r\n\t    return TrendsMarksPlugin;\r\n\t}(three_charts_1.ChartPlugin));\r\n\texports.TrendsMarksPlugin = TrendsMarksPlugin;\r\n\tvar TrendMark = (function () {\r\n\t    function TrendMark(chartState, options) {\r\n\t        this.row = 0;\r\n\t        this.options = options;\r\n\t        this.chartState = chartState;\r\n\t    }\r\n\t    /**\r\n\t     * only for internal usage\r\n\t     */\r\n\t    TrendMark.prototype._setSegment = function (segment) {\r\n\t        this.segment = segment;\r\n\t        if (!segment)\r\n\t            return;\r\n\t        var trend = this.chartState.getTrend(this.options.trendName);\r\n\t        if (trend.getOptions().type == three_charts_1.TREND_TYPE.LINE) {\r\n\t            this.xVal = segment.endXVal;\r\n\t            this.yVal = segment.endYVal;\r\n\t        }\r\n\t        else if (this.options.orientation == TREND_MARK_SIDE.TOP) {\r\n\t            this.xVal = segment.xVal;\r\n\t            this.yVal = segment.maxYVal;\r\n\t        }\r\n\t        else {\r\n\t            this.xVal = segment.xVal;\r\n\t            this.yVal = segment.minYVal;\r\n\t        }\r\n\t    };\r\n\t    TrendMark.prototype._setOffset = function (offset) {\r\n\t        this.offset = offset;\r\n\t    };\r\n\t    TrendMark.prototype._setRow = function (row) {\r\n\t        this.row = row;\r\n\t    };\r\n\t    return TrendMark;\r\n\t}());\r\n\texports.TrendMark = TrendMark;\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar three_charts_1 = __webpack_require__(2);\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar TrendsMarksPlugin_1 = __webpack_require__(5);\r\n\tvar MAX_MARKS_IN_ROW = 3;\r\n\t/**\r\n\t * widget for drawing trends marks for all trends\r\n\t */\r\n\tvar TrendsMarksWidget = (function (_super) {\r\n\t    __extends(TrendsMarksWidget, _super);\r\n\t    function TrendsMarksWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsMarksWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendMarksWidget;\r\n\t    };\r\n\t    TrendsMarksWidget.widgetName = \"TrendsMarks\";\r\n\t    return TrendsMarksWidget;\r\n\t}(three_charts_1.TrendsWidget));\r\n\texports.TrendsMarksWidget = TrendsMarksWidget;\r\n\t/**\r\n\t * widget for drawing trend marks for one trend\r\n\t */\r\n\tvar TrendMarksWidget = (function (_super) {\r\n\t    __extends(TrendMarksWidget, _super);\r\n\t    function TrendMarksWidget(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        this.marksWidgets = {};\r\n\t        this.object3D = new Object3D();\r\n\t        this.onMarksChange();\r\n\t    }\r\n\t    TrendMarksWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendMarksWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.getTrendsMarksPlugin().onChange(function () { return _this.onMarksChange(); });\r\n\t    };\r\n\t    TrendMarksWidget.prototype.getTrendsMarksPlugin = function () {\r\n\t        return this.chartState.getPlugin(TrendsMarksPlugin_1.TrendsMarksPlugin.NAME);\r\n\t    };\r\n\t    TrendMarksWidget.prototype.onMarksChange = function () {\r\n\t        var marksItems = this.getTrendsMarksPlugin().getItems();\r\n\t        var widgets = this.marksWidgets;\r\n\t        var actualMarksNames = [];\r\n\t        for (var markName in marksItems) {\r\n\t            actualMarksNames.push(markName);\r\n\t            if (!widgets[markName])\r\n\t                this.createMarkWidget(marksItems[markName]);\r\n\t        }\r\n\t        for (var markName in this.marksWidgets) {\r\n\t            if (actualMarksNames.indexOf(markName) !== -1)\r\n\t                continue;\r\n\t            this.destroyMarkWidget(markName);\r\n\t        }\r\n\t    };\r\n\t    TrendMarksWidget.prototype.createMarkWidget = function (mark) {\r\n\t        if (!mark.segment)\r\n\t            return;\r\n\t        var markWidget = new TrendMarkWidget(this.chartState, mark);\r\n\t        this.marksWidgets[mark.options.name] = markWidget;\r\n\t        this.object3D.add(markWidget.getObject3D());\r\n\t    };\r\n\t    TrendMarksWidget.prototype.destroyMarkWidget = function (markName) {\r\n\t        this.object3D.remove(this.marksWidgets[markName].getObject3D());\r\n\t        delete this.marksWidgets[markName];\r\n\t    };\r\n\t    TrendMarksWidget.prototype.onZoomFrame = function () {\r\n\t        var widgets = this.marksWidgets;\r\n\t        for (var markName in widgets) {\r\n\t            widgets[markName].onZoomFrameHandler();\r\n\t        }\r\n\t    };\r\n\t    TrendMarksWidget.prototype.onSegmentsAnimate = function () {\r\n\t        var widgets = this.marksWidgets;\r\n\t        for (var markName in widgets) {\r\n\t            widgets[markName].onSegmentsAnimate();\r\n\t        }\r\n\t    };\r\n\t    return TrendMarksWidget;\r\n\t}(three_charts_1.TrendWidget));\r\n\texports.TrendMarksWidget = TrendMarksWidget;\r\n\t/**\r\n\t * widget for drawing one trend mark\r\n\t */\r\n\tvar TrendMarkWidget = (function () {\r\n\t    function TrendMarkWidget(chartState, trendMark) {\r\n\t        this.markHeight = 74;\r\n\t        this.markWidth = 150;\r\n\t        this.position = { lineHeight: 30, x: 0, y: 0 };\r\n\t        this.chartState = chartState;\r\n\t        this.mark = trendMark;\r\n\t        this.initObject();\r\n\t        this.show();\r\n\t    }\r\n\t    TrendMarkWidget.prototype.initObject = function () {\r\n\t        this.object3D = new Object3D();\r\n\t        this.markMesh = this.createMarkMesh();\r\n\t        this.line = this.createMarkLine();\r\n\t        this.object3D.add(this.markMesh);\r\n\t        this.object3D.add(this.line);\r\n\t    };\r\n\t    TrendMarkWidget.prototype.createMarkMesh = function () {\r\n\t        var _a = this, markHeight = _a.markHeight, markWidth = _a.markWidth;\r\n\t        var mark = this.mark.options;\r\n\t        var isTopSide = mark.orientation == TrendsMarksPlugin_1.TREND_MARK_SIDE.TOP;\r\n\t        var texture = three_charts_1.Utils.createPixelPerfectTexture(markWidth, markHeight, function (ctx) {\r\n\t            var circleOffset = isTopSide ? 30 : 0;\r\n\t            var circleR = 22;\r\n\t            var circleX = markWidth / 2;\r\n\t            var circleY = circleOffset + circleR;\r\n\t            var textOffset = isTopSide ? 10 : circleR * 2 + 15;\r\n\t            // title and description\r\n\t            ctx.beginPath();\r\n\t            ctx.textAlign = 'center';\r\n\t            ctx.font = \"11px Arial\";\r\n\t            ctx.fillStyle = 'rgba(255,255,255, 0.6)';\r\n\t            ctx.fillText(mark.title, circleX, textOffset);\r\n\t            ctx.fillStyle = mark.descriptionColor;\r\n\t            ctx.fillText(mark.description, circleX, textOffset + 12);\r\n\t            // icon circle\r\n\t            ctx.beginPath();\r\n\t            ctx.fillStyle = mark.iconColor;\r\n\t            ctx.arc(circleX, circleY, circleR, 0, 2 * Math.PI);\r\n\t            ctx.fill();\r\n\t            // icon text\r\n\t            ctx.font = \"19px Arial\";\r\n\t            ctx.fillStyle = 'rgb(255, 255, 255)';\r\n\t            ctx.fillText(mark.icon, circleX, circleY + 7);\r\n\t        });\r\n\t        var material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });\r\n\t        material.transparent = true;\r\n\t        var mesh = new Mesh(new THREE.PlaneGeometry(markWidth, markHeight), material);\r\n\t        var offset = this.mark.options.orientation == TrendsMarksPlugin_1.TREND_MARK_SIDE.TOP ? this.mark.offset : -this.mark.offset;\r\n\t        // mesh.position.setY(markHeight / 2 + offset);\r\n\t        return mesh;\r\n\t    };\r\n\t    TrendMarkWidget.prototype.createMarkLine = function () {\r\n\t        var lineGeometry = new Geometry();\r\n\t        lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, this.mark.offset, 0));\r\n\t        lineGeometry.computeLineDistances();\r\n\t        var lineMaterial = new THREE.LineDashedMaterial({ dashSize: 1, gapSize: 4, transparent: true, opacity: 0.6 });\r\n\t        var line = new THREE.Line(lineGeometry, lineMaterial);\r\n\t        line.position.setZ(-0.1);\r\n\t        return line;\r\n\t    };\r\n\t    TrendMarkWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendMarkWidget.prototype.onSegmentsAnimate = function () {\r\n\t        this.updatePosition();\r\n\t    };\r\n\t    TrendMarkWidget.prototype.onZoomFrameHandler = function () {\r\n\t        this.updatePosition();\r\n\t    };\r\n\t    TrendMarkWidget.prototype.updatePosition = function () {\r\n\t        if (!this.mark.segment)\r\n\t            return;\r\n\t        var mark = this.mark;\r\n\t        var meshMaterial = this.markMesh.material;\r\n\t        var lineMaterial = this.line.material;\r\n\t        if (mark.row >= MAX_MARKS_IN_ROW - 1) {\r\n\t            meshMaterial.opacity = 0;\r\n\t            lineMaterial.opacity = 0;\r\n\t        }\r\n\t        else {\r\n\t            meshMaterial.opacity = 1;\r\n\t            lineMaterial.opacity = 1;\r\n\t        }\r\n\t        var screen = this.chartState.screen;\r\n\t        var posX = screen.getPointOnXAxis(mark.xVal);\r\n\t        var posY = screen.getPointOnYAxis(mark.yVal);\r\n\t        var lineGeometry = this.line.geometry;\r\n\t        if (mark.options.orientation == TrendsMarksPlugin_1.TREND_MARK_SIDE.TOP) {\r\n\t            this.markMesh.position.setY(this.markHeight / 2 + mark.offset);\r\n\t            lineGeometry.vertices[1].setY(mark.offset);\r\n\t        }\r\n\t        else {\r\n\t            this.markMesh.position.setY(-mark.offset - this.markHeight / 2);\r\n\t            lineGeometry.vertices[1].setY(-mark.offset);\r\n\t        }\r\n\t        lineGeometry.verticesNeedUpdate = true;\r\n\t        lineGeometry.lineDistancesNeedUpdate = true;\r\n\t        lineGeometry.computeLineDistances();\r\n\t        this.object3D.position.set(posX, posY, 0);\r\n\t    };\r\n\t    TrendMarkWidget.prototype.show = function () {\r\n\t        if (!this.mark.segment)\r\n\t            return;\r\n\t        this.updatePosition();\r\n\t        var animations = this.chartState.data.animations;\r\n\t        var time = animations.enabled ? 1 : 0;\r\n\t        this.object3D.scale.set(0.01, 0.01, 1);\r\n\t        TweenLite.to(this.object3D.scale, time, { x: 1, y: 1, ease: Elastic.easeOut });\r\n\t    };\r\n\t    return TrendMarkWidget;\r\n\t}());\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b41758098ad59fb86f3a\n **/","export * from './TrendsMarksPlugin';\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/src/TrendsMarksPlugin/index.ts\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"three-charts\"\n ** module id = 2\n ** module chunks = 0 1 2 3\n **/","\nimport Vector3 = THREE.Vector3;\nimport { ChartPlugin, ChartWidget, TrendSegment, TREND_TYPE, Utils, ChartState } from 'three-charts';\nimport { TrendsMarksWidget } from './TrendsMarksWidget';\n\nexport enum TREND_MARK_SIDE {TOP, BOTTOM}\nexport enum EVENTS {CHANGE}\nexport type TTrendsMarksPluginOptions = {items: ITrendMarkOptions[]};\n\nexport interface ITrendMarkOptions {\n\ttrendName: string,\n\tvalue: number,\n\tname?: string,\n\ttitle?: string\n\tdescription?: string,\n\tdescriptionColor?: string,\n\ticon?: string,\n\ticonColor?: string,\n\torientation?: TREND_MARK_SIDE,\n\twidth?: number,\n\theight?: number,\n\t/**\n\t * min distance between trend and mark\n\t */\n\toffset?: number,\n\t/**\n\t * space between marks\n\t */\n\tmargin?: number\n}\n\nconst AXIS_MARK_DEFAULT_OPTIONS: ITrendMarkOptions = {\n\ttrendName: '',\n\ttitle: '',\n\tdescription: '',\n\tdescriptionColor: 'rgb(40,136,75)',\n\tvalue: 0,\n\ticonColor: 'rgb(255, 102, 217)',\n\torientation: TREND_MARK_SIDE.TOP,\n\twidth: 65,\n\theight: 80,\n\toffset: 40,\n\tmargin: 20\n};\n\n\nexport class TrendsMarksPlugin extends ChartPlugin {\n\tstatic NAME = 'TrendsMarks';\n\tstatic pluginWidgets = [TrendsMarksWidget] as typeof ChartWidget[];\n\n\tprivate items: {[name: string]: TrendMark} = {};\n\tprivate rects: {[name: string]: number[]} = {};\n\n\tconstructor(trendsMarksPluginOptions: TTrendsMarksPluginOptions) {\n\t\tsuper(trendsMarksPluginOptions);\n\t}\n\n\tprotected onInitialStateApplied() {\n\t\tthis.bindEvents();\n\t\tthis.onMarksChangeHandler();\n\t}\n\n\tprotected onStateChanged() {\n\t\tthis.onMarksChangeHandler();\n\t}\n\n\n\tgetOptions(): TTrendsMarksPluginOptions {\n\t\treturn super.getOptions() as TTrendsMarksPluginOptions;\n\t}\n\n\tgetItems() {\n\t\treturn this.items;\n\t}\n\n\tgetItem(markName: string) {\n\t\treturn this.items[markName];\n\t}\n\n\tcreateMark(options: ITrendMarkOptions) {\n\t\tvar marksOptions = this.getOptions().items;\n\t\tvar newMarkOptions = marksOptions.concat([options]);\n\t\tthis.chartState.setState({pluginsState: {[this.name]: {items: newMarkOptions}}});\n\t}\n\n\tonChange(cb: () => any) {\n\t\treturn this.ee.subscribe(EVENTS[EVENTS.CHANGE], cb);\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.chartState.trendsManager.onSegmentsRebuilded(() => this.updateMarksSegments());\n\t\tthis.chartState.screen.onZoomFrame(() => this.calclulateMarksPositions());\n\t}\n\n\tprotected onInitialStateAppliedHandler() {\n\t\tthis.onMarksChangeHandler();\n\t}\n\n\tprivate onMarksChangeHandler() {\n\t\tvar trendsMarksOptions = this.getOptions().items;\n\t\tlet actualMarksNames: string[] = [];\n\t\tfor (let options of trendsMarksOptions) {\n\t\t\tvar marks = this.items;\n\n\t\t\t// set mark name\n\t\t\tif (!options.name) {\n\t\t\t\toptions.name = Utils.getUid().toString();\n\t\t\t\tactualMarksNames.push(options.name);\n\t\t\t\tif (marks[options.name]) Utils.error('duplicated mark name ' + options.name);\n\t\t\t} else if (marks[options.name]) {\n\t\t\t\tactualMarksNames.push(options.name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toptions = Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\n\n\t\t\tlet mark = new TrendMark(this.chartState, options);\n\t\t\tmarks[options.name] = mark;\n\t\t}\n\n\t\t// delete not relevant marks\n\t\tfor (let markName in this.items) {\n\t\t\tif (actualMarksNames.indexOf(markName) != -1) continue;\n\t\t\tdelete this.items[markName];\n\t\t}\n\t\tthis.updateMarksSegments();\n\t\tthis.ee.emit(EVENTS[EVENTS.CHANGE]);\n\t}\n\n\n\tprivate calclulateMarksPositions() {\n\t\tthis.rects = {};\n\t\tfor (let markName in this.items) {\n\t\t\tthis.createMarkRect(this.items[markName]);\n\t\t}\n\t}\n\n\tprivate createMarkRect(mark: TrendMark) {\n\t\tif (!mark.segment) return;\n\n\t\tlet state = this.chartState;\n\t\tlet options = mark.options;\n\t\tlet {width, height, offset, name} = options;\n\t\tlet left = state.getPointOnXAxis(mark.xVal) - width / 2;\n\t\tlet top = state.getPointOnYAxis(mark.yVal);\n\t\tlet isTopSideMark = options.orientation == TREND_MARK_SIDE.TOP;\n\t\tlet newOffset: number;\n\t\tlet row = 0;\n\n\t\tif (isTopSideMark) {\n\t\t\ttop += offset + height;\n\t\t} else {\n\t\t\ttop -= offset;\n\t\t}\n\n\t\tlet markRect = [left, top, width, height];\n\t\tlet hasIntersection = false;\n\t\tdo {\n\t\t\tfor (let markName in this.rects) {\n\t\t\t\tlet rect = this.rects[markName];\n\t\t\t\thasIntersection = Utils.rectsIntersect(rect, markRect);\n\t\t\t\tif (!hasIntersection) continue;\n\t\t\t\tif (isTopSideMark) {\n\t\t\t\t\tmarkRect[1] = rect[1] + markRect[3] + options.margin;\n\t\t\t\t} else {\n\t\t\t\t\tmarkRect[1] = rect[1] - rect[3] - options.margin;\n\t\t\t\t}\n\t\t\t\trow++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (hasIntersection);\n\n\t\tif (isTopSideMark) {\n\t\t\tnewOffset = markRect[1] - markRect[3] - state.getPointOnYAxis(mark.yVal);\n\t\t} else {\n\t\t\tnewOffset = state.getPointOnYAxis(mark.yVal) - markRect[1];\n\t\t}\n\n\t\tmark._setOffset(newOffset);\n\t\tmark._setRow(row);\n\t\tthis.rects[name] = markRect;\n\t}\n\n\tprivate updateMarksSegments() {\n\t\tlet chartState = this.chartState;\n\t\tlet trends = chartState.trendsManager.trends;\n\t\tfor (let trendName in trends) {\n\t\t\tvar marks = this.getTrendMarks(trendName);\n\t\t\tvar marksArr: TrendMark[] = [];\n\t\t\tvar xVals: number[] = [];\n\t\t\tfor (let markName in marks) {\n\t\t\t\tlet mark = marks[markName];\n\t\t\t\txVals.push(mark.options.value);\n\t\t\t\tmarksArr.push(mark);\n\t\t\t\tmark._setSegment(null);\n\t\t\t}\n\t\t\tmarksArr.sort((a, b) => a.options.value - b.options.value);\n\t\t\tlet trend = chartState.getTrend(trendName);\n\t\t\tlet points = trend.segmentsManager.getSegmentsForXValues(xVals.sort((a, b) => a - b));\n\t\t\tfor (let markInd = 0; markInd < marksArr.length; markInd++) {\n\t\t\t\tmarksArr[markInd]._setSegment(points[markInd]);\n\t\t\t}\n\t\t}\n\t\tthis.calclulateMarksPositions();\n\t}\n\n\tprivate getTrendMarks(trendName: string): TrendMark[] {\n\t\tlet trendMarks: TrendMark[] = [];\n\t\tfor (let markName in this.items) {\n\t\t\tif (this.items[markName].options.trendName != trendName) continue;\n\t\t\ttrendMarks.push(this.items[markName]);\n\t\t}\n\t\treturn trendMarks;\n\t}\n\n}\n\nexport class TrendMark {\n\toptions: ITrendMarkOptions;\n\tsegment: TrendSegment;\n\txVal: number;\n\tyVal: number;\n\toffset: number;\n\trow = 0;\n\tprotected chartState: ChartState;\n\n\tconstructor(chartState: ChartState, options: ITrendMarkOptions) {\n\t\tthis.options = options;\n\t\tthis.chartState = chartState;\n\t}\n\n\n\t/**\n\t * only for internal usage\n\t */\n\t_setSegment(segment: TrendSegment) {\n\t\tthis.segment = segment;\n\t\tif (!segment) return;\n\n\t\tlet trend = this.chartState.getTrend(this.options.trendName)\n\n\t\tif (trend.getOptions().type == TREND_TYPE.LINE) {\n\t\t\tthis.xVal = segment.endXVal;\n\t\t\tthis.yVal = segment.endYVal;\n\t\t} else if (this.options.orientation == TREND_MARK_SIDE.TOP) {\n\t\t\tthis.xVal = segment.xVal;\n\t\t\tthis.yVal = segment.maxYVal;\n\t\t} else {\n\t\t\tthis.xVal = segment.xVal;\n\t\t\tthis.yVal = segment.minYVal;\n\t\t}\n\t}\n\n\t_setOffset(offset: number) {\n\t\tthis.offset = offset;\n\t}\n\n\t_setRow(row: number) {\n\t\tthis.row = row;\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/src/TrendsMarksPlugin/TrendsMarksPlugin.ts\n **/","import {ChartState, Utils, TrendsWidget, TrendWidget } from 'three-charts';\nimport Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport LineSegments = THREE.LineSegments;\nimport LineDashedMaterial = THREE.LineDashedMaterial;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport { TrendMark, TREND_MARK_SIDE, TrendsMarksPlugin } from \"./TrendsMarksPlugin\";\n\n\nconst MAX_MARKS_IN_ROW = 3;\n\n/**\n * widget for drawing trends marks for all trends\n */\nexport class TrendsMarksWidget extends TrendsWidget<TrendMarksWidget> {\n\tstatic widgetName = \"TrendsMarks\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendMarksWidget;\n\t}\n}\n\n/**\n * widget for drawing trend marks for one trend\n */\nexport class TrendMarksWidget extends TrendWidget {\n\n\tprivate trendsMarksPlugin: TrendsMarksPlugin;\n\tprivate object3D: Object3D;\n\tprivate marksWidgets: {[name: string]: TrendMarkWidget} = {};\n\n\tconstructor (chartState: ChartState, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tthis.object3D = new Object3D();\n\t\tthis.onMarksChange();\n\t}\n\n\tgetObject3D() {\n\t\treturn this.object3D;\n\t}\n\t\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.getTrendsMarksPlugin().onChange(() => this.onMarksChange());\n\t}\n\n\tprivate getTrendsMarksPlugin(): TrendsMarksPlugin {\n\t\treturn this.chartState.getPlugin(TrendsMarksPlugin.NAME) as TrendsMarksPlugin;\n\t}\n\n\tprivate onMarksChange() {\n\t\tlet marksItems = this.getTrendsMarksPlugin().getItems();\n\t\tlet widgets = this.marksWidgets;\n\t\tlet actualMarksNames: string[] = [];\n\t\tfor (let markName in marksItems) {\n\t\t\tactualMarksNames.push(markName);\n\t\t\tif (!widgets[markName]) this.createMarkWidget(marksItems[markName]);\n\t\t}\n\t\tfor (let markName in this.marksWidgets) {\n\t\t\tif (actualMarksNames.indexOf(markName) !== -1) continue;\n\t\t\tthis.destroyMarkWidget(markName);\n\t\t}\n\n\t}\n\t\n\tprivate createMarkWidget(mark: TrendMark) {\n\t\tif (!mark.segment) return;\n\t\tlet markWidget = new TrendMarkWidget(this.chartState, mark);\n\t\tthis.marksWidgets[mark.options.name] = markWidget;\n\t\tthis.object3D.add(markWidget.getObject3D());\n\t}\n\n\tprivate destroyMarkWidget(markName: string) {\n\t\tthis.object3D.remove(this.marksWidgets[markName].getObject3D());\n\t\tdelete this.marksWidgets[markName];\n\t}\n\n\tprotected onZoomFrame() {\n\t\tvar widgets = this.marksWidgets;\n\t\tfor (let markName in widgets) {\n\t\t\twidgets[markName].onZoomFrameHandler();\n\t\t}\n\t}\n\n\tprotected onSegmentsAnimate() {\n\t\tvar widgets = this.marksWidgets;\n\t\tfor (let markName in widgets) {\n\t\t\twidgets[markName].onSegmentsAnimate();\n\t\t}\n\t}\n}\n\n/**\n * widget for drawing one trend mark\n */\nclass TrendMarkWidget {\n\tprivate chartState: ChartState;\n\tprivate mark: TrendMark;\n\tprivate object3D: Object3D;\n\tprivate line: Line;\n\tprivate markMesh: Mesh;\n\tprivate markHeight = 74;\n\tprivate markWidth = 150;\n\tprivate position = {lineHeight: 30, x: 0, y: 0};\n\n\tconstructor(chartState: ChartState, trendMark: TrendMark) {\n\t\tthis.chartState = chartState;\n\t\tthis.mark = trendMark;\n\t\tthis.initObject();\n\t\tthis.show();\n\t}\n\t\n\tprotected initObject() {\n\t\tthis.object3D = new Object3D();\n\t\tthis.markMesh = this.createMarkMesh();\n\t\tthis.line = this.createMarkLine();\n\t\tthis.object3D.add(this.markMesh);\n\t\tthis.object3D.add(this.line);\n\t}\n\n\tprotected createMarkMesh(): Mesh {\n\t\tvar {markHeight, markWidth} = this;\n\t\tvar mark = this.mark.options;\n\t\tvar isTopSide = mark.orientation == TREND_MARK_SIDE.TOP;\n\n\t\tvar texture = Utils.createPixelPerfectTexture(markWidth, markHeight, (ctx) => {\n\n\t\t\tvar circleOffset = isTopSide ? 30 : 0;\n\t\t\tvar circleR = 22;\n\t\t\tvar circleX = markWidth / 2;\n\t\t\tvar circleY = circleOffset + circleR;\n\t\t\tvar textOffset = isTopSide ? 10 : circleR * 2 + 15;\n\n\t\t\t// title and description\n\t\t\tctx.beginPath();\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.font = \"11px Arial\";\n\t\t\tctx.fillStyle = 'rgba(255,255,255, 0.6)';\n\t\t\tctx.fillText(mark.title, circleX, textOffset);\n\t\t\tctx.fillStyle = mark.descriptionColor;\n\t\t\tctx.fillText(mark.description, circleX, textOffset + 12);\n\n\t\t\t// icon circle\n\t\t\tctx.beginPath();\n\t\t\tctx.fillStyle = mark.iconColor;\n\t\t\tctx.arc(circleX, circleY, circleR, 0, 2 * Math.PI);\n\t\t\tctx.fill();\n\n\t\t\t// icon text\n\t\t\tctx.font = \"19px Arial\";\n\t\t\tctx.fillStyle = 'rgb(255, 255, 255)';\n\t\t\tctx.fillText(mark.icon, circleX, circleY + 7);\n\n\t\t});\n\n\t\tvar material = new THREE.MeshBasicMaterial( {map: texture, side: THREE.FrontSide} );\n\t\tmaterial.transparent = true;\n\n\t\tvar mesh = new Mesh(\n\t\t\tnew THREE.PlaneGeometry(markWidth, markHeight),\n\t\t\tmaterial\n\t\t);\n\n\t\tlet offset = this.mark.options.orientation == TREND_MARK_SIDE.TOP ? this.mark.offset : -this.mark.offset;\n\t\t// mesh.position.setY(markHeight / 2 + offset);\n\n\t\treturn mesh;\n\t}\n\n\tprotected createMarkLine() {\n\t\tlet lineGeometry = new Geometry();\n\t\tlineGeometry.vertices.push( new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, this.mark.offset, 0) );\n\t\tlineGeometry.computeLineDistances();\n\t\tlet lineMaterial = new THREE.LineDashedMaterial( {dashSize: 1, gapSize: 4, transparent: true, opacity: 0.6 } );\n\t\tlet line = new THREE.Line( lineGeometry, lineMaterial );\n\t\tline.position.setZ(-0.1);\n\t\treturn line\n\t}\n\n\tgetObject3D() {\n\t\treturn this.object3D;\n\t}\n\n\tonSegmentsAnimate() {\n\t\tthis.updatePosition();\n\t}\n\n\tonZoomFrameHandler() {\n\t\tthis.updatePosition();\n\t}\n\n\tprivate updatePosition() {\n\t\tif (!this.mark.segment) return;\n\t\tlet mark = this.mark;\n\t\tlet meshMaterial = this.markMesh.material as MeshBasicMaterial;\n\t\tlet lineMaterial = this.line.material as LineBasicMaterial;\n\t\tif (mark.row >= MAX_MARKS_IN_ROW - 1) {\n\t\t\tmeshMaterial.opacity = 0;\n\t\t\tlineMaterial.opacity = 0;\n\t\t} else {\n\t\t\tmeshMaterial.opacity = 1;\n\t\t\tlineMaterial.opacity = 1;\n\t\t}\n\n\t\tlet screen = this.chartState.screen;\n\t\tlet posX = screen.getPointOnXAxis(mark.xVal);\n\t\tlet posY = screen.getPointOnYAxis(mark.yVal);\n\t\tlet lineGeometry = this.line.geometry as Geometry;\n\n\t\tif (mark.options.orientation == TREND_MARK_SIDE.TOP) {\n\t\t\tthis.markMesh.position.setY(this.markHeight / 2 + mark.offset);\n\t\t\tlineGeometry.vertices[1].setY(mark.offset);\n\t\t} else {\n\t\t\tthis.markMesh.position.setY(-mark.offset - this.markHeight / 2);\n\t\t\tlineGeometry.vertices[1].setY(-mark.offset);\n\t\t}\n\t\tlineGeometry.verticesNeedUpdate = true;\n\t\tlineGeometry.lineDistancesNeedUpdate = true;\n\t\tlineGeometry.computeLineDistances();\n\t\tthis.object3D.position.set(posX, posY, 0);\n\t}\n\n\tprivate show() {\n\t\tif (!this.mark.segment) return;\n\t\tthis.updatePosition();\n\t\tvar animations = this.chartState.data.animations;\n\t\tvar time = animations.enabled ? 1 : 0;\n\t\tthis.object3D.scale.set(0.01, 0.01, 1);\n\t\tTweenLite.to(this.object3D.scale, time, {x: 1, y: 1, ease: Elastic.easeOut});\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/src/TrendsMarksPlugin/TrendsMarksWidget.ts\n **/"],"sourceRoot":""}