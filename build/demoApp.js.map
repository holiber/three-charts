{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///demoApp.js","webpack:///webpack/bootstrap 78dbd4b5273eed6036e9?5ab1","webpack:///./demo/demoApp.ts","webpack:///./src/index.ts?eac3","webpack:///./src/ChartView.ts?958f","webpack:///./src/Plugin.ts?e59a","webpack:///./src/Utils.ts?fbb5","webpack:///./src/deps/deps.ts?8fcc","webpack:///./~/three/examples/js/libs/stats.min.js?9b50","webpack:///./~/is-plain-object/index.js?2af1","webpack:///./~/isobject/index.js?cf96","webpack:///./~/eventemitter2/lib/eventemitter2.js?847a","webpack:///./src/polyfills/es6-promise.js?de39","webpack:///./~/css-element-queries/src/ResizeSensor.js?9f87","webpack:///./src/EventEmmiter.ts?e60a","webpack:///./src/Chart.ts?8278","webpack:///./src/Trend.ts?84c2","webpack:///./src/TrendSegmentsManager.ts?2220","webpack:///./src/TrendsManager.ts?c94d","webpack:///./src/Screen.ts?9286","webpack:///./src/AxisMarks.ts?f3fd","webpack:///./src/interfaces.ts?f1fb","webpack:///./src/Widget.ts?d904","webpack:///./src/widgets/AxisWidget.ts?5f76","webpack:///./src/widgets/GridWidget.ts?61b2","webpack:///./src/widgets/TrendsGradientWidget.ts?4409","webpack:///./src/widgets/TrendsWidget.ts?6f55","webpack:///./src/Color.ts?1948","webpack:///./src/widgets/TrendsLineWidget.ts?d378","webpack:///./src/widgets/TrendsCandleWidget.ts?9d04","webpack:///./src/deps/index.ts?3285"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","src_1","chart","DataSourse","data","sec","val","startTime","Date","now","push","xVal","yVal","Math","random","endTime","length","prototype","getData","Utils","deepCopy","getNext","lastVal","item","getPrev","firstVal","unshift","window","onload","initListeners","dsMain","dsRed","dsBlue","ChartView","yAxis","marks","value","name","title","lineColor","stickToEdges","range","padding","end","start","margin","zeroVal","xAxis","dataType","AXIS_DATA_TYPE","DATE","type","AXIS_RANGE_TYPE","FIXED","from","to","maxLength","minLength","showValue","trends","main","TREND_TYPE","LINE","dataset","hasBeacon","hasIndicator","hasBackground","showStats","trendDefaultState","settingsForTypes","minSegmentLengthInPx","document","querySelector","setState","animations","enabled","mainTrend","getTrend","deadlineMark","state","xAxisMarks","getItem","closeMark","onDataChange","closeValue","options","getLastItem","setOptions","i","onPrependRequest","requestedLength","resolve","reject","responseData","ticksCount","round","setTimeout","setInterval","appendData","$checkboxMaintrend","addEventListener","checked","$checkboxRedtrend","red","$checkboxBluetrend","blue","$switchLineBtn","$switchBarsBtn","CANDLE","currentRange","timeframeButtons","querySelectorAll","Number","getAttribute","segmentLength","autoScroll","zoomToRange","scrollToEnd","then","__export","hasOwnProperty","Plugin_1","PerspectiveCamera","THREE","Chart_1","Widget_1","Utils_1","AxisWidget_1","GridWidget_1","TrendsGradientWidget_1","TrendsLineWidget_1","TrendsCandleWidget_1","deps_1","$container","pluginsAndWidgets","_this","widgets","REVISION","error","style","getComputedStyle","width","parseInt","height","plugins","filter","pluginOrWidget","ChartPlugin","Chart","zoomThrottled","throttle","zoomValue","origin","zoom","init","_a","w","h","autoRender","scene","Scene","isStopped","renderer","renderers","antialias","alpha","setSize","setPixelRatio","devicePixelRatio","setClearColor","backgroundColor","backgroundOpacity","appendChild","domElement","$el","display","stats","Stats","setupCamera","initWidgets","bindEvents","renderLoop","preinstalledWidgetsClasses","constructor","preinstalledWidgets","customWidgets","forEach","ChartWidget","pluginWidgetClasses","providedWidgets","apply","concat","map","WidgetClass","widget","setupChartState","onReadyHandler","add","getObject3D","isDestroyed","begin","render","fpsLimit","fps","delay_1","requestAnimationFrame","camera","stop","run","destroy","unbindEvents","forceContextLoss","wtf","context","getState","trendName","controls","ev","onMouseWheel","onMouseMove","onMouseDown","onMouseUp","onTouchMove","onTouchEnd","autoResize","resizeSensor","ResizeSensor","onChartContainerResizeHandler","clientWidth","clientHeight","unsubscribers","onTrendsChange","autoscroll","screen","onTransformationFrame","onScreenTransformHandler","onResize","onChartResize","detach","e","remove","unsubscribe","camSettings","getCameraSettings","FOV","aspect","near","far","fov","updateProjectionMatrix","position","set","x","y","z","cameraInitialPosition","clone","scrollX","scrollX_1","setX","scrollY","scrollY_1","setY","oldTrendsMaxX","prevState","computedData","maxXVal","trendsMaxXDelta","maxVisibleX","getScreenRightVal","paddingRightX","getPaddingRight","currentScroll","scroll","scrollDelta","onScrollStop","cursor","dragMode","clientX","clientY","stopPropagation","preventDefault","zoomOrigin","layerX","wheelDeltaY","touches","MAX_ZOOM_VALUE","MIN_ZOOM_VALUE","min","max","autoScrollIsEnabled","CanvasRenderer","WebGLRenderer","TrendsLineWidget","TrendsCandlesWidget","AxisWidget","GridWidget","TrendsGradientWidget","EventEmmiter_1","DEFAULT_CONFIG","installPluginWidgets","config","initialState","deepMerge","NAME","chartState","ee","EventEmitter","bindEvent","onInitialStateApplied","onInitialStateAppliedHandler","onReady","onDestroy","onDestroyHandler","onPluginsStateChange","changedPluginsStates","onStateChanged","getOptions","pluginsState","changedState","removeAllListeners","args","_i","arguments","Array","isArray","unsubscriber","deepmerge","target","src","mergeArrays","array","dst","indexOf","Object","keys","key","obj1","obj2","obj","JSON","parse","stringify","toFixed","num","digitsCount","maxDigits","result","intVal","floor","intStr","toString","lengthDiff","repeat","afterPointDigitsCount","afterPointStr","split","substr","createTexture","fn","canvas","createElement","ctx","getContext","texture","Texture","needsUpdate","createPixelPerfectTexture","minFilter","NearestFilter","msg","console","warn","getUid","currentId","getDistance","num1","num2","binarySearchClosestInd","arr","mid","lo","hi","binarySearchClosest","ind","rectsIntersect","r1","r2","left1","top1","width1","height1","left2","top2","width2","height2","right1","right2","bottom1","bottom2","func","ms","isThrottled","savedArgs","savedThis","wrapper","msToTimeString","timestamp","s","getRandomItem","copyProps","srcObject","dstObject","props","excludeProps","isPlainObject","TweenLite","TweenMax","EE2","es6_promise_1","Promise","a","dom","k","d","children","l","cssText","g","performance","r","Panel","f","self","memory","t","addPanel","showPanel","update","usedJSHeapSize","jsHeapSizeLimit","setMode","Infinity","u","n","q","b","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","v","drawImage","isObject","isObjectObject","o","ctor","prot","__WEBPACK_AMD_DEFINE_RESULT__","undefined","_isArray","defaultMaxListeners","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","searchListenerTree","handlers","tree","listeners","leaf","len","branch","xTree","xxTree","isolatedBranch","endReached","typeLength","currentType","nextType","_listeners","**","growListenerTree","listener","slice","shift","warned","trace","setMaxListeners","event","once","many","ttl","Error","off","_origin","on","emit","_all","handler","ns","onAny","addListener","leafs","iLeaf","splice","offAny","fns","removeListener","listenersAny","EventEmitter2","element","callback","EventQueue","j","prop","currentStyle","getPropertyValue","attachResizeEvent","resized","resizedAttached","className","styleChild","innerHTML","fixed","absolute","expand","childNodes","expandChild","shrink","shrinkChild","lastWidth","lastHeight","reset","offsetWidth","offsetHeight","scrollLeft","scrollWidth","scrollTop","scrollHeight","changed","addEvent","el","cb","attachEvent","onScroll","elementType","isCollectionTyped","jQuery","Elements","removeChild","eventName","subscribe","listenersCount","Vector3","Trend_1","TrendsManager_1","Screen_1","AxisMarks_1","interfaces_1","CHART_STATE_EVENTS","INITIAL_STATE_APPLIED","READY","DESTROY","CHANGE","TREND_CHANGE","TRENDS_CHANGE","ZOOM","RESIZE","SCROLL","SCROLL_STOP","PLUGINS_STATE_CHANGED","ALL","NUMBER","grid","minSizePx","color","RELATIVE_END","trendChangeSpeed","trendChangeEase","zoomSpeed","zoomEase","scrollSpeed","scrollEase","Linear","easeNone","autoScrollSpeed","autoScrollEase","maxSegmentLength","lineWidth","maxSegmentLengthInPx","eventEmitterMaxListeners","maxVisibleSegments","isReady","trendsManager","TrendsManager","calculatedOptions","installPlugins","getComputedData","savePrevState","Screen","AxisMarks","AXIS_TYPE","X","yAxisMarks","Y","onChange","onTrendChange","onZoom","newState","eventData","silent","stateData","newStateObj","changedProps","trendsData","trendOptions","newStateContainsData","recalculateResult","recalculateState","emitChangedStateEvents","patch","actualData","cursorOptions","isMouseDrag","oldX","currentX","deltaXVal","pxToValueByXAxis","chartWasResized","scrollXChanged","needToRecalculateXAxis","xAxisPatch","recalculateXAxis","needToRecalculateYAxis","AUTO","isMirrorMode","yAxisPatch","recalculateYAxis","allChangedProps","computeAll","getEndXVal","minXVal","getStartXVal","scrollStopEventNeeded","scrollChangeEventsNeeded","zoomEventsNeeded","resizeEventNeeded","pluginStateChangedEventNeeded","plugin","PluginClass","pluginName","getPlugin","changedTrends","newData","handleTrendsChange","axisRange","isInitialize","scaleFactor","currentScaleFactor","rangeLength","needToRecalculateZoom","rangeMoreThenMaxValue","rangeLessThenMinValue","fixScale","yAxisRange","trendsEndXVal","trendsStartXVal","xRange","xFrom","xTo","xRangeLength","needToZoom","maxY","getMaxYVal","minY","getMinYVal","trendLastY","distanceFromZeroValForMaxY","abs","distanceFromZeroValForMinY","maxDistanceFromZeroVal","paddingTopInPercents","paddingBottomInPercents","rangeLengthInPercents","visibleRangeLength","fromVal","toVal","maxScreenY","getScreenYByValue","minScreenY","currentAxisRange","newZoom","nextRange","newScroll","animationTime","endXVal","getPointOnXAxis","getPointOnYAxis","getValueOnXAxis","valueToPxByXAxis","valueToPxByYAxis","pxToValueByYAxis","getValueByScreenX","getValueByScreenY","getScreenXByValue","getScreenXByPoint","getPointByScreenX","screenX","getPointOnChart","getScreenLeftVal","TrendSegmentsManager_1","EVENTS","PREPEND_REQUEST","Trend","minYVal","maxYVal","prepareData","segmentsManager","TrendSegmentsManager","checkForPrependRequest","changedOptions","getCalculatedOptions","rawData","updatedTrendData","changeData","prependData","allData","newData_1","statePatch","fromX","toX","filteredData","data_1","getFirstItem","onChangeCb","prependRequest","minScreenX","needToRequest","requestedDataLength","currentData","isPrepend","initialItem","MAX_ANIMATED_SEGMENTS","REBUILD","DISLPAYED_RANGE_CHANGED","ANIMATION_FRAME","trend","segmentsById","segments","animatedSegmentsIds","segmentsLength","animatedSegmentsForAppend","animatedSegmentsForPrepend","nextEmptyId","startSegmentId","endSegmentId","tryToRebuildSegments","onTrendChangeHandler","onZoomHandler","recalculateDisplayedRange","appendAnimation","kill","prependAnimation","segmentsRebuilded","needToRebuildSegments","isAppend","getSegment","getEndSegment","getStartSegment","force","trendTypeName","trendTypesSettings","trendTypeSettings","needToRebuild","currentSegmentLengthInPx","currentMaxSegmentLengthInPx","ceil","stopAllAnimations","segmentsAreRebuilded","_b","firstDisplayedSegment","lastDisplayedSegment","displayedRange","firstDisplayedSegmentInd","lastDisplayedSegmentInd","displayedRangeChanged","getSegmentsForXValues","values","valueInd","lastValueInd","results","segment","hasValue","startXVal","valueInPoint","onAnimationFrame","onRebuild","onDisplayedRangeChanged","allocateNextSegment","TrendSegment","prevSegment","nextId","prevId","allocatePrevSegment","nextSegment","needRebuildSegments","trendData","startItemInd","initialSegment","initialAnimationState","createAnimationState","itemInd","itemIsInserted","appendItem","isLastItem","isCompleted","complete","recalculateItems","segmentIsReadyForAnimate","startYVal","endYVal","targetAnimationState","prevItem","animationsOptions","time","segmentId","segment_1","currentAnimationState","animate","prependItem","nextItem","animation","isActive","onAnimationFrameHandler","ease","objectToAnimate","animationValue","eventCallback","coefficient","animatedSegmentsIds_1","targetValue","initialValue","currentValue","trendPoints","items","trendSegments","itemsLength","endItem","startItem","minX","maxX","middleXVal","middleYVal","yVals","nextPoint","prevPoint","getFrameVal","getFramePoint","frameVal","SEGMENTS_REBUILDED","trendsCalculatedOptions","createTrend","getEnabledTrends","enabledTrends","allTrends","firstTrendData","getExtremumYVal","extremumIsMax","compareFn","trends_1","trendYValues","dataItem","NaN","onSegmentsRebuilded","_loop_1","this_1","scrollXVal","scrollYVal","zoomX","zoomY","currentScrollX","currentScrollY","currentZoomX","currentZoomY","transform","vFOV","PI","tan","onZoomFrame","onScrollFrame","cameraIsMoving","scrollXAnimation","zoomXAnimation","onScrollXHandler","onZoomXHandler","onScrollYHandler","onZoomYHandler","scrollYAnimation","zoomYAnimation","isDragMode","canAnimate","zoomXChanged","isAutoscroll","pause","targetX","targetY","targetZoom","getPointByScreenY","screenY","getTop","getBottom","getLeft","getTopVal","getBottomVal","getCenterYVal","__extends","__","create","AXIS_MARK_DEFAULT_OPTIONS","axisType","axisMarksOptions","axisMarksOptions_1","axisMark","AxisTimeleftMark","AxisMark","startVal","endVal","markName","mark","markVal","markWasCrossed","getItems","renderOnTrendsChange","newOptions","getDisplayedVal","displayedValue","String","onMarkCrossed","onValueChange","onDisplayedValueChange","typeName","_super","unbindList","unbindEvent","widgetName","Mesh","Object3D","object3D","axisXObject","axisYObject","setupAxis","updateAxisXRequest","updateAxis","onScrollChange","orientation","isXAxis","visibleWidth","visibleHeight","canvasWidth","canvasHeight","traverse","beginPath","strokeStyle","material","MeshBasicMaterial","side","FrontSide","transparent","axisMesh","PlaneGeometry","axisOptions","axisGridParams","getGridParamsForAxis","geometry","parameters","image","clearRect","edgeOffset","segmentsCount","step","pxVal","textAlign","getDateStr","stroke","closePath","gridParams","hour","day","tf","getHours","getMinutes","getSeconds","LineSegments","gridSizeH","gridSizeV","initGrid","updateGrid","updateGridThrottled","Geometry","LineBasicMaterial","linewidth","opacity","xLinesCount","yLinesCount","vertices","lineSegments","setZ","frustumCulled","axisXGrid","axisYGrid","scrollXInSegments","scrollYInSegments","gridScrollXVal","gridScrollYVal","lineInd","lineSegment","getVerticalLineSegment","getHorizontalLineSegment","verticesNeedUpdate","scale","localYVal","widthVal","localXVal","heightVal","axisWidth","axisLength","gridStep","gridStepInPixels","minGridStepInPixels","axisLengthStr","axisLengthPointPosition","intPartLength","gridStepFound","digitPos","power","multiplier","pow","dividers","dividerInd","nextGridStep","nextGridStepInPixels","gridStart","gridEnd","stepInPx","TrendsWidget_1","Color_1","getTrendWidgetClass","TrendGradient","TrendsWidget","visibleSegmentsCnt","segmentsIds","Uint16Array","initGradient","updateSegments","widgetIsEnabled","gradient","faces","Face3","ChartColor","scaleXFactor","scaleYFactor","currentScale","onSegmentsAnimate","trendSegmentsManager","includes","setupSegmentVertices","segmentInd","prevVisibleSegmentsCnt","segmentsToProcessCnt","segmentState","gradientSegmentInd","topLeft","bottomLeft","bottomRight","topRight","screenHeightVal","startX","toLocalX","startY","toLocalY","endX","endY","TrendWidget","trendsOptions","TrendWidgetClass","widgetCanBeEnabled","createTrendWidget","destroyTrendWidget","WidgetConstructor","widgetObject","getObjectByName","unbind","parseColor","cache","replace","exec","isNaN","colorStr","rgba","hexStr","rgbaStr","TrendLine","freeSegmentsInds","displayedSegments","initLine","destroySegments","setupSegments","segmentIsNotDisplayed","destroySegment","setupSegment","pop","lineStartVertex","lineEndVertex","toLocalVec","vec","Line","RISE_COLOR","FALL_COLOR","MARGIN_PERCENT","MAX_CANDLES","TrendCandlesWidget","freeCandlesInds","candlesPool","candles","initObject","destroyCandles","setupCandles","destroyCandle","setupCandle","candle","candleId","candleInd","CandleWidget","setSegment","rect","leftTop","rightTop","leftBottom","rightBottom","vLineGeometry","vLine","vLineMaterial","lineTop","lineBottom","hLineGeometry","hLine","hLineMaterial","lineLeft","lineRight"],"mappings":"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","file":"demoApp.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory();\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory();\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t// import { Chart, AXIS_RANGE_TYPE, ITrendItem, Utils, AXIS_DATA_TYPE, TREND_TYPE } from 'three-charts';\r\n\tvar src_1 = __webpack_require__(1);\r\n\t// import { TREND_MARK_SIDE, ITrendMarkOptions, TrendsMarksPlugin } from '../plugins/build/TrendsMarksPlugin';\r\n\t// import { TrendsBeaconWidget } from '../plugins/build/TrendsBeaconWidget';\r\n\t// import { TrendsLoadingWidget } from '../plugins/build/TrendsLoadingWidget';\r\n\t// import { TrendsIndicatorWidget } from '../plugins/build/TrendsIndicatorWidget';\r\n\t//\r\n\t//\r\n\t//\r\n\t// Chart.preinstalledWidgets.push(TrendsLoadingWidget, TrendsBeaconWidget, TrendsIndicatorWidget);\r\n\tvar chart;\r\n\tvar DataSourse = (function () {\r\n\t    function DataSourse() {\r\n\t        this.data = [];\r\n\t        var sec = 0;\r\n\t        var val = 70;\r\n\t        this.startTime = Date.now();\r\n\t        while (sec < 100) {\r\n\t            this.data.push({\r\n\t                xVal: this.startTime + sec * 1000,\r\n\t                yVal: val\r\n\t            });\r\n\t            val += Math.random() * 14 - 7;\r\n\t            sec++;\r\n\t        }\r\n\t        this.endTime = this.data[this.data.length - 1].xVal;\r\n\t    }\r\n\t    DataSourse.prototype.getData = function () {\r\n\t        return src_1.Utils.deepCopy(this.data);\r\n\t    };\r\n\t    DataSourse.prototype.getNext = function () {\r\n\t        var lastVal = this.data[this.data.length - 1];\r\n\t        var yVal = lastVal.yVal + Math.random() * 14 - 7;\r\n\t        var xVal = this.endTime + 1000;\r\n\t        this.endTime = xVal;\r\n\t        var item = {\r\n\t            xVal: xVal,\r\n\t            yVal: yVal\r\n\t        };\r\n\t        this.data.push(item);\r\n\t        return item;\r\n\t    };\r\n\t    DataSourse.prototype.getPrev = function () {\r\n\t        var firstVal = this.data[0];\r\n\t        var yVal = firstVal.yVal + Math.random() * 14 - 7;\r\n\t        var xVal = this.startTime - 1000;\r\n\t        this.startTime = xVal;\r\n\t        var item = {\r\n\t            xVal: xVal,\r\n\t            yVal: yVal\r\n\t        };\r\n\t        this.data.unshift(item);\r\n\t        return item;\r\n\t    };\r\n\t    return DataSourse;\r\n\t}());\r\n\t// class MarksSource {\r\n\t// \tstatic getNext(val: number): ITrendMarkOptions {\r\n\t// \t\tif (Math.random() > 0.2) return null;\r\n\t// \t\treturn this.generate(val);\r\n\t// \t}\r\n\t//\r\n\t// \tstatic generate(val: number): ITrendMarkOptions {\r\n\t// \t\tlet descriptionColor = 'rgb(40,136,75)';\r\n\t// \t\tlet orientation =  Utils.getRandomItem([TREND_MARK_SIDE.TOP, TREND_MARK_SIDE.BOTTOM]);\r\n\t// \t\tif (orientation == TREND_MARK_SIDE.BOTTOM) {\r\n\t// \t\t\tdescriptionColor = 'rgb(219,73,49)';\r\n\t// \t\t}\r\n\t//\r\n\t// \t\treturn {\r\n\t// \t\t\ttrendName: 'main',\r\n\t// \t\t\tvalue: val,\r\n\t// \t\t\ttitle: Utils.getRandomItem(['Alex Malcon', 'Serg Morrs', 'Harry Potter']),\r\n\t// \t\t\tdescription: Utils.getRandomItem(['$10 -> 20$', '$15 -> 30$', '40$ -> 80$']),\r\n\t// \t\t\ticon: Utils.getRandomItem(['AM', 'SM', 'HP']),\r\n\t// \t\t\ticonColor: Utils.getRandomItem(['rgb(69,67,130)', 'rgb(124,39,122)']),\r\n\t// \t\t\torientation: orientation,\r\n\t// \t\t\tdescriptionColor: descriptionColor\r\n\t// \t\t}\r\n\t// \t}\r\n\t// }\r\n\twindow.onload = function () {\r\n\t    initListeners();\r\n\t    var dsMain = new DataSourse();\r\n\t    var dsRed = new DataSourse();\r\n\t    var dsBlue = new DataSourse();\r\n\t    var now = Date.now();\r\n\t    chart = new src_1.ChartView({\r\n\t        yAxis: {\r\n\t            marks: [\r\n\t                { value: dsMain.data[0].yVal, name: 'openprice', title: 'OPEN PRICE', lineColor: '#29874b', stickToEdges: true },\r\n\t            ],\r\n\t            range: {\r\n\t                padding: { end: 100, start: 100 },\r\n\t                margin: { end: 50, start: 50 },\r\n\t                zeroVal: 70\r\n\t            }\r\n\t        },\r\n\t        xAxis: {\r\n\t            //range: {type: AXIS_RANGE_TYPE.FIXED, from: 10, to: 30},\r\n\t            dataType: src_1.AXIS_DATA_TYPE.DATE,\r\n\t            range: {\r\n\t                type: src_1.AXIS_RANGE_TYPE.FIXED,\r\n\t                from: Date.now(),\r\n\t                to: Date.now() + 20000,\r\n\t                padding: { end: 200, start: 0 },\r\n\t                maxLength: 5000000,\r\n\t                minLength: 5000\r\n\t            },\r\n\t            marks: [\r\n\t                { value: dsMain.endTime + 30000, name: 'deadline', title: 'DEADLINE', lineColor: '#ff6600', type: 'timeleft', showValue: true },\r\n\t                { value: dsMain.endTime + 40000, name: 'close', title: 'CLOSE', lineColor: '#005187', type: 'timeleft', showValue: true }\r\n\t            ]\r\n\t        },\r\n\t        trends: {\r\n\t            'main': {\r\n\t                type: src_1.TREND_TYPE.LINE,\r\n\t                dataset: dsMain.getData(),\r\n\t                hasBeacon: true,\r\n\t                hasIndicator: true,\r\n\t                hasBackground: true,\r\n\t            },\r\n\t        },\r\n\t        showStats: true,\r\n\t        // autoRender: {fps: 100},\r\n\t        // animations: {enabled: false},\r\n\t        trendDefaultState: {\r\n\t            settingsForTypes: {\r\n\t                LINE: {\r\n\t                    minSegmentLengthInPx: 10\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }, document.querySelector('.chart'));\r\n\t    chart.setState({ animations: { enabled: false } });\r\n\t    chart.setState({ animations: { enabled: true } });\r\n\t    window['chart'] = chart;\r\n\t    var mainTrend = chart.getTrend('main');\r\n\t    var deadlineMark = chart.state.xAxisMarks.getItem('deadline');\r\n\t    var closeMark = chart.state.xAxisMarks.getItem('close');\r\n\t    mainTrend.onDataChange(function () {\r\n\t        var closeValue = closeMark.options.value;\r\n\t        if (mainTrend.getLastItem().xVal >= closeValue) {\r\n\t            deadlineMark.setOptions({ value: closeValue + 10000 });\r\n\t            closeMark.setOptions({ value: closeValue + 20000 });\r\n\t        }\r\n\t        // var markOptions = MarksSource.getNext(mainTrend.getLastItem().xVal);\r\n\t        // if (markOptions) setTimeout(() => {\r\n\t        // \tlet trendsMarks = chart.state.getPlugin(TrendsMarksPlugin.NAME) as TrendsMarksPlugin;\r\n\t        // \ttrendsMarks.createMark(markOptions);\r\n\t        // }, 500);\r\n\t    });\r\n\t    // var previewChart1 = ChartView.createPreviewChart({\r\n\t    // \t$el: document.querySelectorAll('.preview-chart')[0],\r\n\t    // \tyAxis: {\r\n\t    // \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 20, to: 150}\r\n\t    // \t},\r\n\t    // \txAxis: {\r\n\t    // \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 100}\r\n\t    // \t},\r\n\t    // \ttrends: {\r\n\t    // \t\t'main': {dataset: dsMain.data, hasBeacon: true}\r\n\t    // \t}\r\n\t    // });\r\n\t    //\r\n\t    // var previewChart2 = ChartView.createPreviewChart({\r\n\t    // \t$el: document.querySelectorAll('.preview-chart')[1],\r\n\t    // \tyAxis: {\r\n\t    // \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 200}\r\n\t    // \t},\r\n\t    // \txAxis: {\r\n\t    // \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 200}\r\n\t    // \t},\r\n\t    // \ttrends: {\r\n\t    // \t\t'main': {dataset: dsMain.data, hasBeacon: true}\r\n\t    // \t},\r\n\t    //\r\n\t    // });\r\n\t    //\r\n\t    // var previewChart3 = ChartView.createPreviewChart({\r\n\t    // \t$el: document.querySelectorAll('.preview-chart')[2],\r\n\t    // \tyAxis: {\r\n\t    // \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 100}\r\n\t    // \t},\r\n\t    // \txAxis: {\r\n\t    // \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 80}\r\n\t    // \t},\r\n\t    // \ttrends: {\r\n\t    // \t\t'main': {dataset: dsMain.data, hasBeacon: true},\r\n\t    // \t\t'red': {dataset: dsRed.data, lineColor: 0xFF2222},\r\n\t    // \t}\r\n\t    // });\r\n\t    //\r\n\t    var i = 0;\r\n\t    chart.getTrend('main').onPrependRequest(function (requestedLength, resolve, reject) {\r\n\t        var responseData = [];\r\n\t        var ticksCount = Math.round(requestedLength / 1000);\r\n\t        while (ticksCount--)\r\n\t            responseData.unshift(dsMain.getPrev());\r\n\t        setTimeout(function () {\r\n\t            resolve(responseData);\r\n\t        }, 2000);\r\n\t    });\r\n\t    setInterval(function () {\r\n\t        i++;\r\n\t        var val = dsMain.getNext();\r\n\t        // [i % 2 ? 10 : 20]\r\n\t        chart.getTrend('main').appendData([val]);\r\n\t        // chart.getTrend('main').prependData([dsMain.getPrev(), dsMain.getPrev()].reverse());\r\n\t        // chart.getTrend('main').appendData([val, dsMain.getNext(), dsMain.getNext(), dsMain.getNext(), dsMain.getNext()]);\r\n\t        // chart.getTrend('main').prependData([val, dsMain.getNext(), dsMain.getNext(), dsMain.getNext()]);\r\n\t        // chart.getTrend('red').appendData([val + 10 + Math.random() * 20]);\r\n\t        // chart.getTrend('blue').appendData([val + 20 + Math.random() * 20]);\r\n\t        // previewChart1.getTrend('main').appendData([val]);\r\n\t        // previewChart2.getTrend('main').appendData([val + 10 + Math.random() * 20]);\r\n\t        // previewChart3.getTrend('red').appendData([val + 20 + Math.random() * 20]);\r\n\t        // previewChart1.appendData(dataToAppend1);\r\n\t        //\r\n\t        // var chartData2 = previewChart2.state.data.trends[0].data;\r\n\t        // var lastItem2 = chartData2[chartData.length - 1];\r\n\t        // var dataToAppend2 = [\r\n\t        // \t{xVal: lastItem2.xVal + 1, yVal: lastItem2.yVal + Math.random() * 14 - 7 },\r\n\t        // ];\r\n\t        // previewChart2.appendData(dataToAppend2);\r\n\t        // previewChart3.appendData(dataToAppend2);\r\n\t    }, 1000);\r\n\t};\r\n\tfunction initListeners() {\r\n\t    var $checkboxMaintrend = document.querySelector('input[name=\"maintrend\"]');\r\n\t    $checkboxMaintrend.addEventListener('change', function () {\r\n\t        chart.setState({ trends: { main: { enabled: $checkboxMaintrend.checked } } });\r\n\t    });\r\n\t    var $checkboxRedtrend = document.querySelector('input[name=\"redtrend\"]');\r\n\t    $checkboxRedtrend.addEventListener('change', function () {\r\n\t        chart.setState({ trends: { red: { enabled: $checkboxRedtrend.checked } } });\r\n\t    });\r\n\t    var $checkboxBluetrend = document.querySelector('input[name=\"bluetrend\"]');\r\n\t    $checkboxBluetrend.addEventListener('change', function () {\r\n\t        chart.setState({ trends: { blue: { enabled: $checkboxBluetrend.checked } } });\r\n\t    });\r\n\t    var $switchLineBtn = document.querySelector('[name=\"switch-line\"]');\r\n\t    $switchLineBtn.addEventListener('click', function () {\r\n\t        chart.getTrend('main').setOptions({ type: src_1.TREND_TYPE.LINE });\r\n\t    });\r\n\t    var $switchBarsBtn = document.querySelector('[name=\"switch-bars\"]');\r\n\t    $switchBarsBtn.addEventListener('click', function () {\r\n\t        chart.getTrend('main').setOptions({ type: src_1.TREND_TYPE.CANDLE });\r\n\t    });\r\n\t    document.querySelector('[name=\"move-left\"]').addEventListener('click', function () {\r\n\t        var currentRange = chart.state.data.xAxis.range;\r\n\t        chart.setState({ xAxis: { range: { from: currentRange.from - 2000 } } });\r\n\t    });\r\n\t    document.querySelector('[name=\"move-right\"]').addEventListener('click', function () {\r\n\t        var currentRange = chart.state.data.xAxis.range;\r\n\t        chart.setState({ xAxis: { range: { to: currentRange.to + 2000 } } });\r\n\t    });\r\n\t    var timeframeButtons = document.querySelectorAll(\".timeframe\");\r\n\t    for (var i = 0; i < timeframeButtons.length; i++) {\r\n\t        timeframeButtons[i].addEventListener(\"click\", function () {\r\n\t            var range = Number(this.getAttribute('data-range'));\r\n\t            var segmentLength = Number(this.getAttribute('data-segment-length'));\r\n\t            chart.state.setState({ autoScroll: false });\r\n\t            chart.state.zoomToRange(range);\r\n\t            chart.state.scrollToEnd().then(function () {\r\n\t                chart.state.setState({ autoScroll: true });\r\n\t            });\r\n\t        });\r\n\t    }\r\n\t}\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(2));\r\n\t__export(__webpack_require__(19));\r\n\t__export(__webpack_require__(18));\r\n\t__export(__webpack_require__(17));\r\n\t__export(__webpack_require__(13));\r\n\t__export(__webpack_require__(14));\r\n\t__export(__webpack_require__(15));\r\n\t__export(__webpack_require__(16));\r\n\t__export(__webpack_require__(4));\r\n\t__export(__webpack_require__(20));\r\n\t__export(__webpack_require__(3));\r\n\t__export(__webpack_require__(25));\r\n\t__export(__webpack_require__(24));\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t// deps must be always on top\r\n\tvar Plugin_1 = __webpack_require__(3);\r\n\t__webpack_require__(5);\r\n\tvar PerspectiveCamera = THREE.PerspectiveCamera;\r\n\tvar Chart_1 = __webpack_require__(13);\r\n\tvar Widget_1 = __webpack_require__(20);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar AxisWidget_1 = __webpack_require__(21);\r\n\tvar GridWidget_1 = __webpack_require__(22);\r\n\tvar TrendsGradientWidget_1 = __webpack_require__(23);\r\n\tvar TrendsLineWidget_1 = __webpack_require__(26);\r\n\tvar TrendsCandleWidget_1 = __webpack_require__(27);\r\n\tvar deps_1 = __webpack_require__(28);\r\n\tvar ChartView = (function () {\r\n\t    function ChartView(state, $container, pluginsAndWidgets) {\r\n\t        var _this = this;\r\n\t        if (pluginsAndWidgets === void 0) { pluginsAndWidgets = []; }\r\n\t        this.widgets = [];\r\n\t        if (!THREE || !THREE.REVISION)\r\n\t            Utils_1.Utils.error('three.js not found');\r\n\t        if (!$container) {\r\n\t            Utils_1.Utils.error('$el must be set');\r\n\t        }\r\n\t        // calculate chart size\r\n\t        var style = getComputedStyle($container);\r\n\t        state.width = parseInt(style.width);\r\n\t        state.height = parseInt(style.height);\r\n\t        var plugins = pluginsAndWidgets.filter(function (pluginOrWidget) { return pluginOrWidget instanceof Plugin_1.ChartPlugin; });\r\n\t        this.state = new Chart_1.Chart(state, plugins);\r\n\t        this.pluginsAndWidgets = pluginsAndWidgets;\r\n\t        this.zoomThrottled = Utils_1.Utils.throttle(function (zoomValue, origin) { return _this.zoom(zoomValue, origin); }, 200);\r\n\t        this.$container = $container;\r\n\t        this.init($container);\r\n\t    }\r\n\t    ;\r\n\t    ChartView.prototype.init = function ($container) {\r\n\t        var state = this.state;\r\n\t        var _a = state.data, w = _a.width, h = _a.height, showStats = _a.showStats, autoRender = _a.autoRender;\r\n\t        this.scene = new THREE.Scene();\r\n\t        this.isStopped = !autoRender.enabled;\r\n\t        var renderer = this.renderer = new ChartView.renderers[this.state.data.renderer]({\r\n\t            antialias: true,\r\n\t            alpha: true\r\n\t        });\r\n\t        renderer.setSize(w, h);\r\n\t        renderer.setPixelRatio(ChartView.devicePixelRatio);\r\n\t        renderer.setClearColor(state.data.backgroundColor, state.data.backgroundOpacity);\r\n\t        $container.appendChild(renderer.domElement);\r\n\t        this.$el = renderer.domElement;\r\n\t        this.$el.style.display = 'block';\r\n\t        if (showStats) {\r\n\t            this.stats = new Stats();\r\n\t            $container.appendChild(this.stats.domElement);\r\n\t        }\r\n\t        this.setupCamera();\r\n\t        this.initWidgets();\r\n\t        this.bindEvents();\r\n\t        this.renderLoop();\r\n\t    };\r\n\t    /**\r\n\t     * collect and init widgets from preinstalled widgets, plugins widgets and custom widgets\r\n\t     */\r\n\t    ChartView.prototype.initWidgets = function () {\r\n\t        var _this = this;\r\n\t        var preinstalledWidgetsClasses = this.constructor.preinstalledWidgets;\r\n\t        var customWidgets = [];\r\n\t        this.pluginsAndWidgets.forEach(function (pluginOrWidget) {\r\n\t            if (pluginOrWidget instanceof Widget_1.ChartWidget) {\r\n\t                customWidgets.push(pluginOrWidget);\r\n\t                return;\r\n\t            }\r\n\t            if (!(pluginOrWidget instanceof Plugin_1.ChartPlugin))\r\n\t                return;\r\n\t            var pluginWidgetClasses = pluginOrWidget.constructor.providedWidgets;\r\n\t            preinstalledWidgetsClasses.push.apply(preinstalledWidgetsClasses, pluginWidgetClasses);\r\n\t        });\r\n\t        this.widgets = customWidgets.concat(preinstalledWidgetsClasses.map(function (WidgetClass) { return new WidgetClass(); }));\r\n\t        this.widgets.forEach(function (widget) {\r\n\t            widget.setupChartState(_this.state);\r\n\t            widget.onReadyHandler();\r\n\t            _this.scene.add(widget.getObject3D());\r\n\t        });\r\n\t    };\r\n\t    ChartView.prototype.renderLoop = function () {\r\n\t        var _this = this;\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        this.stats && this.stats.begin();\r\n\t        this.render();\r\n\t        if (this.isStopped)\r\n\t            return;\r\n\t        var fpsLimit = this.state.data.autoRender.fps;\r\n\t        if (fpsLimit) {\r\n\t            var delay_1 = 1000 / fpsLimit;\r\n\t            setTimeout(function () { return requestAnimationFrame(function () { return _this.renderLoop(); }); }, delay_1);\r\n\t        }\r\n\t        else {\r\n\t            requestAnimationFrame(function () { return _this.renderLoop(); });\r\n\t        }\r\n\t        this.stats && this.stats.end();\r\n\t    };\r\n\t    ChartView.prototype.render = function () {\r\n\t        this.renderer.render(this.scene, this.camera);\r\n\t    };\r\n\t    ChartView.prototype.stop = function () {\r\n\t        this.isStopped = true;\r\n\t    };\r\n\t    ChartView.prototype.run = function () {\r\n\t        this.isStopped = false;\r\n\t        this.renderLoop();\r\n\t    };\r\n\t    /**\r\n\t     * call to destroy chart an init garbage collection\r\n\t     */\r\n\t    ChartView.prototype.destroy = function () {\r\n\t        this.isDestroyed = true;\r\n\t        this.stop();\r\n\t        this.state.destroy();\r\n\t        this.unbindEvents();\r\n\t        // WARNING! undocumented method for free webgl context\r\n\t        try {\r\n\t            this.renderer.forceContextLoss();\r\n\t        }\r\n\t        catch (wtf) {\r\n\t        }\r\n\t        this.renderer.context = null;\r\n\t        this.renderer.domElement = null;\r\n\t        this.renderer = null;\r\n\t    };\r\n\t    ChartView.prototype.getState = function () {\r\n\t        return this.state.data;\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for ChartView.state.getTrend\r\n\t     */\r\n\t    ChartView.prototype.getTrend = function (trendName) {\r\n\t        return this.state.getTrend(trendName);\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for ChartView.state.setState\r\n\t     */\r\n\t    ChartView.prototype.setState = function (state) {\r\n\t        return this.state.setState(state);\r\n\t    };\r\n\t    ChartView.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var $el = this.$el;\r\n\t        if (this.state.data.controls.enabled) {\r\n\t            $el.addEventListener('mousewheel', function (ev) {\r\n\t                _this.onMouseWheel(ev);\r\n\t            });\r\n\t            $el.addEventListener('mousemove', function (ev) {\r\n\t                _this.onMouseMove(ev);\r\n\t            });\r\n\t            $el.addEventListener('mousedown', function (ev) { return _this.onMouseDown(ev); });\r\n\t            $el.addEventListener('mouseup', function (ev) { return _this.onMouseUp(ev); });\r\n\t            $el.addEventListener('touchmove', function (ev) {\r\n\t                _this.onTouchMove(ev);\r\n\t            });\r\n\t            $el.addEventListener('touchend', function (ev) {\r\n\t                _this.onTouchEnd(ev);\r\n\t            });\r\n\t        }\r\n\t        if (this.state.data.autoResize) {\r\n\t            this.resizeSensor = new deps_1.ResizeSensor(this.$container, function () {\r\n\t                _this.onChartContainerResizeHandler(_this.$container.clientWidth, _this.$container.clientHeight);\r\n\t            });\r\n\t        }\r\n\t        this.unsubscribers = [\r\n\t            this.state.onTrendsChange(function () { return _this.autoscroll(); }),\r\n\t            this.state.screen.onTransformationFrame(function (options) { return _this.onScreenTransformHandler(options); }),\r\n\t            this.state.onResize(function (options) { return _this.onChartResize(); })\r\n\t        ];\r\n\t    };\r\n\t    ChartView.prototype.unbindEvents = function () {\r\n\t        // TODO: unbind events correctly\r\n\t        try {\r\n\t            this.resizeSensor && this.resizeSensor.detach();\r\n\t        }\r\n\t        catch (e) {\r\n\t        }\r\n\t        this.$el.remove();\r\n\t        this.unsubscribers.forEach(function (unsubscribe) { return unsubscribe(); });\r\n\t    };\r\n\t    ChartView.prototype.setupCamera = function () {\r\n\t        var camSettings = this.state.screen.getCameraSettings();\r\n\t        if (!this.camera) {\r\n\t            this.camera = new PerspectiveCamera(camSettings.FOV, camSettings.aspect, camSettings.near, camSettings.far);\r\n\t            this.scene.add(this.camera);\r\n\t        }\r\n\t        else {\r\n\t            this.camera.fov = camSettings.FOV;\r\n\t            this.camera.aspect = camSettings.aspect;\r\n\t            this.camera.far = camSettings.far;\r\n\t            this.camera.near = camSettings.near;\r\n\t            this.camera.updateProjectionMatrix();\r\n\t        }\r\n\t        this.camera.position.set(camSettings.x, camSettings.y, camSettings.z);\r\n\t        this.cameraInitialPosition = this.camera.position.clone();\r\n\t        this.onScreenTransformHandler(this.state.screen.options);\r\n\t    };\r\n\t    ChartView.prototype.onScreenTransformHandler = function (options) {\r\n\t        if (options.scrollX != void 0) {\r\n\t            var scrollX_1 = this.cameraInitialPosition.x + options.scrollX;\r\n\t            // scrollX =  Math.round(scrollX); // prevent to set camera beetween pixels\r\n\t            this.camera.position.setX(scrollX_1);\r\n\t        }\r\n\t        if (options.scrollY != void 0) {\r\n\t            var scrollY_1 = this.cameraInitialPosition.y + options.scrollY;\r\n\t            // scrollY = Math.round(scrollY); // prevent to set camera beetween pixels\r\n\t            this.camera.position.setY(scrollY_1);\r\n\t        }\r\n\t    };\r\n\t    ChartView.prototype.autoscroll = function () {\r\n\t        var state = this.state;\r\n\t        if (!state.data.autoScroll)\r\n\t            return;\r\n\t        var oldTrendsMaxX = state.data.prevState.computedData.trends.maxXVal;\r\n\t        var trendsMaxXDelta = state.data.computedData.trends.maxXVal - oldTrendsMaxX;\r\n\t        if (trendsMaxXDelta > 0) {\r\n\t            var maxVisibleX = this.state.screen.getScreenRightVal();\r\n\t            var paddingRightX = this.state.getPaddingRight();\r\n\t            var currentScroll = state.data.xAxis.range.scroll;\r\n\t            if (oldTrendsMaxX < paddingRightX || oldTrendsMaxX > maxVisibleX) {\r\n\t                return;\r\n\t            }\r\n\t            var scrollDelta = trendsMaxXDelta;\r\n\t            this.setState({ xAxis: { range: { scroll: currentScroll + scrollDelta } } });\r\n\t        }\r\n\t    };\r\n\t    ChartView.prototype.onScrollStop = function () {\r\n\t        // var tendsXMax = this.state.data.computedData.trends.maxX;\r\n\t        // var paddingRightX = this.state.getPaddingRight();\r\n\t        // if (tendsXMax < paddingRightX) {\r\n\t        // \tthis.state.scrollToEnd();\r\n\t        // }\r\n\t    };\r\n\t    ChartView.prototype.onMouseDown = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: true, x: ev.clientX, y: ev.clientY } });\r\n\t    };\r\n\t    ChartView.prototype.onMouseUp = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: false } });\r\n\t    };\r\n\t    ChartView.prototype.onMouseMove = function (ev) {\r\n\t        if (this.state.data.cursor.dragMode) {\r\n\t            this.setState({ cursor: { dragMode: true, x: ev.clientX, y: ev.clientY } });\r\n\t        }\r\n\t    };\r\n\t    ChartView.prototype.onMouseWheel = function (ev) {\r\n\t        ev.stopPropagation();\r\n\t        ev.preventDefault();\r\n\t        var zoomOrigin = ev.layerX / this.state.data.width;\r\n\t        var zoomValue = 1 + ev.wheelDeltaY * 0.001;\r\n\t        this.zoom(zoomValue, zoomOrigin);\r\n\t    };\r\n\t    ChartView.prototype.onTouchMove = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: true, x: ev.touches[0].clientX, y: ev.touches[0].clientY } });\r\n\t    };\r\n\t    ChartView.prototype.onTouchEnd = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: false } });\r\n\t    };\r\n\t    ChartView.prototype.onChartContainerResizeHandler = function (width, height) {\r\n\t        this.setState({ width: width, height: height });\r\n\t    };\r\n\t    ChartView.prototype.onChartResize = function () {\r\n\t        var _a = this.state.data, width = _a.width, height = _a.height;\r\n\t        this.renderer.setSize(width, height);\r\n\t        this.setupCamera();\r\n\t    };\r\n\t    ChartView.prototype.zoom = function (zoomValue, zoomOrigin) {\r\n\t        var _this = this;\r\n\t        var MAX_ZOOM_VALUE = 1.5;\r\n\t        var MIN_ZOOM_VALUE = 0.7;\r\n\t        zoomValue = Math.min(zoomValue, MAX_ZOOM_VALUE);\r\n\t        zoomValue = Math.max(zoomValue, MIN_ZOOM_VALUE);\r\n\t        var autoScrollIsEnabled = this.state.data.autoScroll;\r\n\t        if (autoScrollIsEnabled)\r\n\t            this.state.setState({ autoScroll: false });\r\n\t        this.state.zoom(zoomValue, zoomOrigin).then(function () {\r\n\t            if (autoScrollIsEnabled)\r\n\t                _this.setState({ autoScroll: true });\r\n\t        });\r\n\t    };\r\n\t    ChartView.devicePixelRatio = window.devicePixelRatio;\r\n\t    ChartView.preinstalledWidgets = [];\r\n\t    ChartView.renderers = {\r\n\t        CanvasRenderer: THREE.CanvasRenderer,\r\n\t        WebGLRenderer: THREE.WebGLRenderer\r\n\t    };\r\n\t    return ChartView;\r\n\t}());\r\n\texports.ChartView = ChartView;\r\n\t// install built-in widgets\r\n\tChartView.preinstalledWidgets = [\r\n\t    TrendsLineWidget_1.TrendsLineWidget,\r\n\t    TrendsCandleWidget_1.TrendsCandlesWidget,\r\n\t    AxisWidget_1.AxisWidget,\r\n\t    GridWidget_1.GridWidget,\r\n\t    TrendsGradientWidget_1.TrendsGradientWidget\r\n\t];\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\texports.DEFAULT_CONFIG = {\r\n\t    installPluginWidgets: true\r\n\t};\r\n\t/**\r\n\t * base class for all plugins\r\n\t * NAME is mandatory\r\n\t */\r\n\tvar ChartPlugin = (function () {\r\n\t    function ChartPlugin(options, config) {\r\n\t        if (config === void 0) { config = {}; }\r\n\t        this.unsubscribers = [];\r\n\t        this.initialState = options;\r\n\t        this.config = Utils_1.Utils.deepMerge(exports.DEFAULT_CONFIG, config);\r\n\t        this.name = this.constructor.NAME;\r\n\t        if (!this.name)\r\n\t            Utils_1.Utils.error('Unnamed plugin detected');\r\n\t    }\r\n\t    ChartPlugin.prototype.setupChartState = function (chartState) {\r\n\t        var _this = this;\r\n\t        this.chartState = chartState;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.bindEvent(this.chartState.onInitialStateApplied(function (initialState) { return _this.onInitialStateAppliedHandler(initialState); }), this.chartState.onReady(function () { return _this.onReadyHandler(); }), this.chartState.onDestroy(function () { return _this.onDestroyHandler(); }), this.chartState.onPluginsStateChange(function (changedPluginsStates) { return changedPluginsStates[_this.name] && _this.onStateChanged(changedPluginsStates[_this.name]); }));\r\n\t    };\r\n\t    ChartPlugin.prototype.getOptions = function () {\r\n\t        return this.chartState.data.pluginsState[this.name];\r\n\t    };\r\n\t    ChartPlugin.prototype.onInitialStateAppliedHandler = function (initialState) {\r\n\t    };\r\n\t    ChartPlugin.prototype.onReadyHandler = function () {\r\n\t    };\r\n\t    ChartPlugin.prototype.onStateChanged = function (changedState) {\r\n\t    };\r\n\t    ChartPlugin.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t    };\r\n\t    ChartPlugin.prototype.bindEvent = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var unsubscribers = [];\r\n\t        if (!Array.isArray(args[0])) {\r\n\t            unsubscribers.push(args[0]);\r\n\t        }\r\n\t        else {\r\n\t            unsubscribers.push.apply(unsubscribers, (args));\r\n\t        }\r\n\t        (_a = this.unsubscribers).push.apply(_a, unsubscribers);\r\n\t        var _a;\r\n\t    };\r\n\t    ChartPlugin.prototype.unbindEvents = function () {\r\n\t        this.unsubscribers.forEach(function (unsubscriber) { return unsubscriber(); });\r\n\t        this.unsubscribers.length = 0;\r\n\t    };\r\n\t    ChartPlugin.NAME = '';\r\n\t    ChartPlugin.providedWidgets = [];\r\n\t    return ChartPlugin;\r\n\t}());\r\n\texports.ChartPlugin = ChartPlugin;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar deps_1 = __webpack_require__(5);\r\n\tfunction deepmerge(target, src, mergeArrays) {\r\n\t    if (mergeArrays === void 0) { mergeArrays = true; }\r\n\t    var array = Array.isArray(src);\r\n\t    var dst = array && [] || {};\r\n\t    if (array) {\r\n\t        target = target || [];\r\n\t        if (mergeArrays) {\r\n\t            dst = dst.concat(target);\r\n\t        }\r\n\t        src.forEach(function (e, i) {\r\n\t            if (typeof dst[i] === 'undefined') {\r\n\t                dst[i] = e;\r\n\t            }\r\n\t            else if (typeof e === 'object') {\r\n\t                dst[i] = deepmerge(target[i], e, mergeArrays);\r\n\t            }\r\n\t            else {\r\n\t                if (target.indexOf(e) === -1) {\r\n\t                    dst.push(e);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t    else {\r\n\t        if (target && typeof target === 'object') {\r\n\t            Object.keys(target).forEach(function (key) {\r\n\t                dst[key] = target[key];\r\n\t            });\r\n\t        }\r\n\t        Object.keys(src).forEach(function (key) {\r\n\t            if (typeof src[key] !== 'object' || !src[key]) {\r\n\t                dst[key] = src[key];\r\n\t            }\r\n\t            else {\r\n\t                if (!target[key]) {\r\n\t                    dst[key] = src[key];\r\n\t                }\r\n\t                else {\r\n\t                    dst[key] = deepmerge(target[key], src[key], mergeArrays);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t    return dst;\r\n\t}\r\n\t/**\r\n\t * project utils static class\r\n\t */\r\n\tvar Utils = (function () {\r\n\t    function Utils() {\r\n\t    }\r\n\t    /**\r\n\t     * deepMerge based on https://www.npmjs.com/package/deepmerge\r\n\t     */\r\n\t    Utils.deepMerge = function (obj1, obj2, mergeArrays) {\r\n\t        return deepmerge(obj1, obj2, mergeArrays);\r\n\t    };\r\n\t    /**\r\n\t     * deepCopy based on JSON.stringify function\r\n\t     * @deprecated\r\n\t     */\r\n\t    Utils.deepCopy = function (obj) {\r\n\t        // TODO: use deepMerge function to copy\r\n\t        return JSON.parse(JSON.stringify(obj));\r\n\t    };\r\n\t    /**\r\n\t     *\r\n\t     * @example\r\n\t     * // returns \"000015\"\r\n\t     * Utils.toFixed(15, 6);\r\n\t     */\r\n\t    Utils.toFixed = function (num, digitsCount) {\r\n\t        var maxDigits = 15;\r\n\t        var result = '';\r\n\t        var intVal = Math.floor(num);\r\n\t        var intStr = intVal.toString();\r\n\t        var lengthDiff = digitsCount - intStr.length;\r\n\t        if (lengthDiff > 0) {\r\n\t            result = '0'.repeat(lengthDiff) + intStr;\r\n\t        }\r\n\t        else {\r\n\t            result = intStr;\r\n\t        }\r\n\t        var afterPointDigitsCount = maxDigits - intStr.length;\r\n\t        var afterPointStr = num.toString().split('.')[1];\r\n\t        if (afterPointStr) {\r\n\t            result += '.' + afterPointStr.substr(0, afterPointDigitsCount);\r\n\t        }\r\n\t        return result;\r\n\t    };\r\n\t    Utils.bindEvent = function () {\r\n\t    };\r\n\t    /**\r\n\t     * generate texture from canvas context\r\n\t     * @example\r\n\t     * \t// create texture with rect\r\n\t     *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\r\n\t     */\r\n\t    Utils.createTexture = function (width, height, fn) {\r\n\t        var canvas = document.createElement('canvas');\r\n\t        canvas.width = width;\r\n\t        canvas.height = height;\r\n\t        var ctx = canvas.getContext('2d');\r\n\t        fn(ctx);\r\n\t        var texture = new THREE.Texture(canvas);\r\n\t        texture.needsUpdate = true;\r\n\t        return texture;\r\n\t    };\r\n\t    /**\r\n\t     * generate texture from canvas context with NearestFilter\r\n\t     * @example\r\n\t     * \t// create texture with rect\r\n\t     *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\r\n\t     */\r\n\t    Utils.createPixelPerfectTexture = function (width, height, fn) {\r\n\t        var texture = this.createTexture(width, height, fn);\r\n\t        // texture.magFilter = THREE.NearestFilter;\r\n\t        texture.minFilter = THREE.NearestFilter;\r\n\t        return texture;\r\n\t    };\r\n\t    /**\r\n\t     * throw error\r\n\t     */\r\n\t    Utils.error = function (msg) {\r\n\t        console.error('Chart error: ' + msg);\r\n\t        throw 'Chart: ' + msg;\r\n\t    };\r\n\t    /**\r\n\t     * throw error\r\n\t     */\r\n\t    Utils.warn = function (msg) {\r\n\t        console.warn('Chart warning: ' + msg);\r\n\t    };\r\n\t    /**\r\n\t     * @returns new unique id\r\n\t     */\r\n\t    Utils.getUid = function () {\r\n\t        return this.currentId++;\r\n\t    };\r\n\t    /**\r\n\t     * @returns distance between numbers\r\n\t     */\r\n\t    Utils.getDistance = function (num1, num2) {\r\n\t        return Math.max(num1, num2) - Math.min(num1, num2);\r\n\t    };\r\n\t    Utils.binarySearchClosestInd = function (arr, num, key) {\r\n\t        var mid;\r\n\t        var lo = 0;\r\n\t        var hi = arr.length - 1;\r\n\t        while (hi - lo > 1) {\r\n\t            mid = Math.floor((lo + hi) / 2);\r\n\t            if (arr[mid][key] < num) {\r\n\t                lo = mid;\r\n\t            }\r\n\t            else {\r\n\t                hi = mid;\r\n\t            }\r\n\t        }\r\n\t        if (num - arr[lo][key] <= arr[hi][key] - num) {\r\n\t            return lo;\r\n\t        }\r\n\t        return hi;\r\n\t    };\r\n\t    Utils.binarySearchClosest = function (arr, num, key) {\r\n\t        var ind = this.binarySearchClosestInd(arr, num, key);\r\n\t        return arr[ind];\r\n\t    };\r\n\t    Utils.rectsIntersect = function (r1, r2) {\r\n\t        var left1 = r1[0], top1 = r1[1], width1 = r1[2], height1 = r1[3];\r\n\t        var left2 = r2[0], top2 = r2[1], width2 = r2[2], height2 = r2[3];\r\n\t        var _a = [left1 + width1, left2 + width2, top1 + height1, top2 + height2], right1 = _a[0], right2 = _a[1], bottom1 = _a[2], bottom2 = _a[3];\r\n\t        return !(left2 > right1 ||\r\n\t            right2 < left1 ||\r\n\t            top2 > bottom1 ||\r\n\t            bottom2 < top1);\r\n\t    };\r\n\t    Utils.throttle = function (func, ms) {\r\n\t        var isThrottled = false, savedArgs, savedThis;\r\n\t        function wrapper() {\r\n\t            if (isThrottled) {\r\n\t                savedArgs = arguments;\r\n\t                savedThis = this;\r\n\t                return;\r\n\t            }\r\n\t            func.apply(this, arguments); // (1)\r\n\t            isThrottled = true;\r\n\t            setTimeout(function () {\r\n\t                isThrottled = false; // (3)\r\n\t                if (savedArgs) {\r\n\t                    wrapper.apply(savedThis, savedArgs);\r\n\t                    savedArgs = savedThis = null;\r\n\t                }\r\n\t            }, ms);\r\n\t        }\r\n\t        return wrapper;\r\n\t    };\r\n\t    Utils.msToTimeString = function (timestamp) {\r\n\t        var h = Math.floor(timestamp / 360000);\r\n\t        var m = Math.floor(timestamp / 60000);\r\n\t        var s = Math.floor(timestamp / 1000);\r\n\t        return h + ':' + m + ':' + s;\r\n\t    };\r\n\t    Utils.getRandomItem = function (arr) {\r\n\t        var ind = Math.floor(Math.random() * arr.length);\r\n\t        return arr[ind];\r\n\t    };\r\n\t    Utils.copyProps = function (srcObject, dstObject, props, excludeProps) {\r\n\t        if (excludeProps === void 0) { excludeProps = []; }\r\n\t        for (var key in props) {\r\n\t            if (excludeProps.indexOf(key) !== -1)\r\n\t                continue;\r\n\t            if (srcObject[key] == void 0)\r\n\t                continue;\r\n\t            if (deps_1.isPlainObject(props[key]) && dstObject[key] !== void 0) {\r\n\t                this.copyProps(srcObject[key], dstObject[key], props[key]);\r\n\t            }\r\n\t            else {\r\n\t                dstObject[key] = this.deepCopy(srcObject[key]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    Utils.currentId = 1;\r\n\t    return Utils;\r\n\t}());\r\n\texports.Utils = Utils;\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"./ResizeSensor.ts\" />\r\n\t\"use strict\";\r\n\twindow.TweenLite = TweenMax;\r\n\twindow.Stats = __webpack_require__(6);\r\n\t// require('gsap/src/uncompressed/easing/EasePack.js');\r\n\t// require('three/examples/js/renderers/CanvasRenderer.js');\r\n\t// require('three/examples/js/renderers/Projector.js');\r\n\texports.isPlainObject = __webpack_require__(7);\r\n\texports.EE2 = __webpack_require__(9);\r\n\tvar es6_promise_1 = __webpack_require__(10);\r\n\texports.Promise = es6_promise_1.Promise;\r\n\texports.ResizeSensor = __webpack_require__(11);\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// stats.js - http://github.com/mrdoob/stats.js\n\tvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\n\tif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\n\tStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\n\tv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n\t *\n\t * Copyright (c) 2014-2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\tvar isObject = __webpack_require__(8);\n\t\n\tfunction isObjectObject(o) {\n\t  return isObject(o) === true\n\t    && Object.prototype.toString.call(o) === '[object Object]';\n\t}\n\t\n\tmodule.exports = function isPlainObject(o) {\n\t  var ctor,prot;\n\t  \n\t  if (isObjectObject(o) === false) return false;\n\t  \n\t  // If has modified constructor\n\t  ctor = o.constructor;\n\t  if (typeof ctor !== 'function') return false;\n\t  \n\t  // If has modified prototype\n\t  prot = ctor.prototype;\n\t  if (isObjectObject(prot) === false) return false;\n\t  \n\t  // If constructor does not have an Object-specific method\n\t  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n\t    return false;\n\t  }\n\t  \n\t  // Most likely a plain Object\n\t  return true;\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * isobject <https://github.com/jonschlinkert/isobject>\n\t *\n\t * Copyright (c) 2014-2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\tmodule.exports = function isObject(val) {\n\t  return val != null && typeof val === 'object'\n\t    && !Array.isArray(val);\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * EventEmitter2\n\t * https://github.com/hij1nx/EventEmitter2\n\t *\n\t * Copyright (c) 2013 hij1nx\n\t * Licensed under the MIT license.\n\t */\n\t;!function(undefined) {\n\t\n\t  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n\t    return Object.prototype.toString.call(obj) === \"[object Array]\";\n\t  };\n\t  var defaultMaxListeners = 10;\n\t\n\t  function init() {\n\t    this._events = {};\n\t    if (this._conf) {\n\t      configure.call(this, this._conf);\n\t    }\n\t  }\n\t\n\t  function configure(conf) {\n\t    if (conf) {\n\t\n\t      this._conf = conf;\n\t\n\t      conf.delimiter && (this.delimiter = conf.delimiter);\n\t      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n\t      conf.wildcard && (this.wildcard = conf.wildcard);\n\t      conf.newListener && (this.newListener = conf.newListener);\n\t\n\t      if (this.wildcard) {\n\t        this.listenerTree = {};\n\t      }\n\t    }\n\t  }\n\t\n\t  function EventEmitter(conf) {\n\t    this._events = {};\n\t    this.newListener = false;\n\t    configure.call(this, conf);\n\t  }\n\t\n\t  //\n\t  // Attention, function return type now is array, always !\n\t  // It has zero elements if no any matches found and one or more\n\t  // elements (leafs) if there are matches\n\t  //\n\t  function searchListenerTree(handlers, type, tree, i) {\n\t    if (!tree) {\n\t      return [];\n\t    }\n\t    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n\t        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n\t    if (i === typeLength && tree._listeners) {\n\t      //\n\t      // If at the end of the event(s) list and the tree has listeners\n\t      // invoke those listeners.\n\t      //\n\t      if (typeof tree._listeners === 'function') {\n\t        handlers && handlers.push(tree._listeners);\n\t        return [tree];\n\t      } else {\n\t        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n\t          handlers && handlers.push(tree._listeners[leaf]);\n\t        }\n\t        return [tree];\n\t      }\n\t    }\n\t\n\t    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n\t      //\n\t      // If the event emitted is '*' at this part\n\t      // or there is a concrete match at this patch\n\t      //\n\t      if (currentType === '*') {\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n\t          }\n\t        }\n\t        return listeners;\n\t      } else if(currentType === '**') {\n\t        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n\t        if(endReached && tree._listeners) {\n\t          // The next element has a _listeners, add it to the handlers.\n\t          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n\t        }\n\t\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            if(branch === '*' || branch === '**') {\n\t              if(tree[branch]._listeners && !endReached) {\n\t                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n\t              }\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            } else if(branch === nextType) {\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n\t            } else {\n\t              // No match on this one, shift into the tree but not in the type array.\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            }\n\t          }\n\t        }\n\t        return listeners;\n\t      }\n\t\n\t      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n\t    }\n\t\n\t    xTree = tree['*'];\n\t    if (xTree) {\n\t      //\n\t      // If the listener tree will allow any match for this part,\n\t      // then recursively explore all branches of the tree\n\t      //\n\t      searchListenerTree(handlers, type, xTree, i+1);\n\t    }\n\t\n\t    xxTree = tree['**'];\n\t    if(xxTree) {\n\t      if(i < typeLength) {\n\t        if(xxTree._listeners) {\n\t          // If we have a listener on a '**', it will catch all, so add its handler.\n\t          searchListenerTree(handlers, type, xxTree, typeLength);\n\t        }\n\t\n\t        // Build arrays of matching next branches and others.\n\t        for(branch in xxTree) {\n\t          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n\t            if(branch === nextType) {\n\t              // We know the next element will match, so jump twice.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+2);\n\t            } else if(branch === currentType) {\n\t              // Current node matches, move into the tree.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+1);\n\t            } else {\n\t              isolatedBranch = {};\n\t              isolatedBranch[branch] = xxTree[branch];\n\t              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n\t            }\n\t          }\n\t        }\n\t      } else if(xxTree._listeners) {\n\t        // We have reached the end and still on a '**'\n\t        searchListenerTree(handlers, type, xxTree, typeLength);\n\t      } else if(xxTree['*'] && xxTree['*']._listeners) {\n\t        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n\t      }\n\t    }\n\t\n\t    return listeners;\n\t  }\n\t\n\t  function growListenerTree(type, listener) {\n\t\n\t    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t\n\t    //\n\t    // Looks for two consecutive '**', if so, don't add the event at all.\n\t    //\n\t    for(var i = 0, len = type.length; i+1 < len; i++) {\n\t      if(type[i] === '**' && type[i+1] === '**') {\n\t        return;\n\t      }\n\t    }\n\t\n\t    var tree = this.listenerTree;\n\t    var name = type.shift();\n\t\n\t    while (name) {\n\t\n\t      if (!tree[name]) {\n\t        tree[name] = {};\n\t      }\n\t\n\t      tree = tree[name];\n\t\n\t      if (type.length === 0) {\n\t\n\t        if (!tree._listeners) {\n\t          tree._listeners = listener;\n\t        }\n\t        else if(typeof tree._listeners === 'function') {\n\t          tree._listeners = [tree._listeners, listener];\n\t        }\n\t        else if (isArray(tree._listeners)) {\n\t\n\t          tree._listeners.push(listener);\n\t\n\t          if (!tree._listeners.warned) {\n\t\n\t            var m = defaultMaxListeners;\n\t\n\t            if (typeof this._events.maxListeners !== 'undefined') {\n\t              m = this._events.maxListeners;\n\t            }\n\t\n\t            if (m > 0 && tree._listeners.length > m) {\n\t\n\t              tree._listeners.warned = true;\n\t              console.error('(node) warning: possible EventEmitter memory ' +\n\t                            'leak detected. %d listeners added. ' +\n\t                            'Use emitter.setMaxListeners() to increase limit.',\n\t                            tree._listeners.length);\n\t              console.trace();\n\t            }\n\t          }\n\t        }\n\t        return true;\n\t      }\n\t      name = type.shift();\n\t    }\n\t    return true;\n\t  }\n\t\n\t  // By default EventEmitters will print a warning if more than\n\t  // 10 listeners are added to it. This is a useful default which\n\t  // helps finding memory leaks.\n\t  //\n\t  // Obviously not all Emitters should be limited to 10. This function allows\n\t  // that to be increased. Set to zero for unlimited.\n\t\n\t  EventEmitter.prototype.delimiter = '.';\n\t\n\t  EventEmitter.prototype.setMaxListeners = function(n) {\n\t    this._events || init.call(this);\n\t    this._events.maxListeners = n;\n\t    if (!this._conf) this._conf = {};\n\t    this._conf.maxListeners = n;\n\t  };\n\t\n\t  EventEmitter.prototype.event = '';\n\t\n\t  EventEmitter.prototype.once = function(event, fn) {\n\t    this.many(event, 1, fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.many = function(event, ttl, fn) {\n\t    var self = this;\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('many only accepts instances of Function');\n\t    }\n\t\n\t    function listener() {\n\t      if (--ttl === 0) {\n\t        self.off(event, listener);\n\t      }\n\t      fn.apply(this, arguments);\n\t    }\n\t\n\t    listener._origin = fn;\n\t\n\t    this.on(event, listener);\n\t\n\t    return self;\n\t  };\n\t\n\t  EventEmitter.prototype.emit = function() {\n\t\n\t    this._events || init.call(this);\n\t\n\t    var type = arguments[0];\n\t\n\t    if (type === 'newListener' && !this.newListener) {\n\t      if (!this._events.newListener) { return false; }\n\t    }\n\t\n\t    // Loop through the *_all* functions and invoke them.\n\t    if (this._all) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t      for (i = 0, l = this._all.length; i < l; i++) {\n\t        this.event = type;\n\t        this._all[i].apply(this, args);\n\t      }\n\t    }\n\t\n\t    // If there is no 'error' event listener then throw.\n\t    if (type === 'error') {\n\t\n\t      if (!this._all &&\n\t        !this._events.error &&\n\t        !(this.wildcard && this.listenerTree.error)) {\n\t\n\t        if (arguments[1] instanceof Error) {\n\t          throw arguments[1]; // Unhandled 'error' event\n\t        } else {\n\t          throw new Error(\"Uncaught, unspecified 'error' event.\");\n\t        }\n\t        return false;\n\t      }\n\t    }\n\t\n\t    var handler;\n\t\n\t    if(this.wildcard) {\n\t      handler = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      handler = this._events[type];\n\t    }\n\t\n\t    if (typeof handler === 'function') {\n\t      this.event = type;\n\t      if (arguments.length === 1) {\n\t        handler.call(this);\n\t      }\n\t      else if (arguments.length > 1)\n\t        switch (arguments.length) {\n\t          case 2:\n\t            handler.call(this, arguments[1]);\n\t            break;\n\t          case 3:\n\t            handler.call(this, arguments[1], arguments[2]);\n\t            break;\n\t          // slower\n\t          default:\n\t            var l = arguments.length;\n\t            var args = new Array(l - 1);\n\t            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t            handler.apply(this, args);\n\t        }\n\t      return true;\n\t    }\n\t    else if (handler) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t\n\t      var listeners = handler.slice();\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\n\t        this.event = type;\n\t        listeners[i].apply(this, args);\n\t      }\n\t      return (listeners.length > 0) || !!this._all;\n\t    }\n\t    else {\n\t      return !!this._all;\n\t    }\n\t\n\t  };\n\t\n\t  EventEmitter.prototype.on = function(type, listener) {\n\t\n\t    if (typeof type === 'function') {\n\t      this.onAny(type);\n\t      return this;\n\t    }\n\t\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('on only accepts instances of Function');\n\t    }\n\t    this._events || init.call(this);\n\t\n\t    // To avoid recursion in the case that type == \"newListeners\"! Before\n\t    // adding it to the listeners, first emit \"newListeners\".\n\t    this.emit('newListener', type, listener);\n\t\n\t    if(this.wildcard) {\n\t      growListenerTree.call(this, type, listener);\n\t      return this;\n\t    }\n\t\n\t    if (!this._events[type]) {\n\t      // Optimize the case of one listener. Don't need the extra array object.\n\t      this._events[type] = listener;\n\t    }\n\t    else if(typeof this._events[type] === 'function') {\n\t      // Adding the second element, need to change to array.\n\t      this._events[type] = [this._events[type], listener];\n\t    }\n\t    else if (isArray(this._events[type])) {\n\t      // If we've already got an array, just append.\n\t      this._events[type].push(listener);\n\t\n\t      // Check for listener leak\n\t      if (!this._events[type].warned) {\n\t\n\t        var m = defaultMaxListeners;\n\t\n\t        if (typeof this._events.maxListeners !== 'undefined') {\n\t          m = this._events.maxListeners;\n\t        }\n\t\n\t        if (m > 0 && this._events[type].length > m) {\n\t\n\t          this._events[type].warned = true;\n\t          console.error('(node) warning: possible EventEmitter memory ' +\n\t                        'leak detected. %d listeners added. ' +\n\t                        'Use emitter.setMaxListeners() to increase limit.',\n\t                        this._events[type].length);\n\t          console.trace();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.onAny = function(fn) {\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('onAny only accepts instances of Function');\n\t    }\n\t\n\t    if(!this._all) {\n\t      this._all = [];\n\t    }\n\t\n\t    // Add the function to the event listener collection.\n\t    this._all.push(fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t  EventEmitter.prototype.off = function(type, listener) {\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('removeListener only takes instances of Function');\n\t    }\n\t\n\t    var handlers,leafs=[];\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      // does not use listeners(), so no side effect of creating _events[type]\n\t      if (!this._events[type]) return this;\n\t      handlers = this._events[type];\n\t      leafs.push({_listeners:handlers});\n\t    }\n\t\n\t    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t      var leaf = leafs[iLeaf];\n\t      handlers = leaf._listeners;\n\t      if (isArray(handlers)) {\n\t\n\t        var position = -1;\n\t\n\t        for (var i = 0, length = handlers.length; i < length; i++) {\n\t          if (handlers[i] === listener ||\n\t            (handlers[i].listener && handlers[i].listener === listener) ||\n\t            (handlers[i]._origin && handlers[i]._origin === listener)) {\n\t            position = i;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (position < 0) {\n\t          continue;\n\t        }\n\t\n\t        if(this.wildcard) {\n\t          leaf._listeners.splice(position, 1);\n\t        }\n\t        else {\n\t          this._events[type].splice(position, 1);\n\t        }\n\t\n\t        if (handlers.length === 0) {\n\t          if(this.wildcard) {\n\t            delete leaf._listeners;\n\t          }\n\t          else {\n\t            delete this._events[type];\n\t          }\n\t        }\n\t        return this;\n\t      }\n\t      else if (handlers === listener ||\n\t        (handlers.listener && handlers.listener === listener) ||\n\t        (handlers._origin && handlers._origin === listener)) {\n\t        if(this.wildcard) {\n\t          delete leaf._listeners;\n\t        }\n\t        else {\n\t          delete this._events[type];\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.offAny = function(fn) {\n\t    var i = 0, l = 0, fns;\n\t    if (fn && this._all && this._all.length > 0) {\n\t      fns = this._all;\n\t      for(i = 0, l = fns.length; i < l; i++) {\n\t        if(fn === fns[i]) {\n\t          fns.splice(i, 1);\n\t          return this;\n\t        }\n\t      }\n\t    } else {\n\t      this._all = [];\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\t\n\t  EventEmitter.prototype.removeAllListeners = function(type) {\n\t    if (arguments.length === 0) {\n\t      !this._events || init.call(this);\n\t      return this;\n\t    }\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t\n\t      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t        var leaf = leafs[iLeaf];\n\t        leaf._listeners = null;\n\t      }\n\t    }\n\t    else {\n\t      if (!this._events[type]) return this;\n\t      this._events[type] = null;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.listeners = function(type) {\n\t    if(this.wildcard) {\n\t      var handlers = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n\t      return handlers;\n\t    }\n\t\n\t    this._events || init.call(this);\n\t\n\t    if (!this._events[type]) this._events[type] = [];\n\t    if (!isArray(this._events[type])) {\n\t      this._events[type] = [this._events[type]];\n\t    }\n\t    return this._events[type];\n\t  };\n\t\n\t  EventEmitter.prototype.listenersAny = function() {\n\t\n\t    if(this._all) {\n\t      return this._all;\n\t    }\n\t    else {\n\t      return [];\n\t    }\n\t\n\t  };\n\t\n\t  if (true) {\n\t     // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return EventEmitter;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    // CommonJS\n\t    exports.EventEmitter2 = EventEmitter;\n\t  }\n\t  else {\n\t    // Browser global.\n\t    window.EventEmitter2 = EventEmitter;\n\t  }\n\t}();\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {Promise: window['Promise']}\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n\t * directory of this distribution and at\n\t * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n\t */\n\t;\n\t(function() {\n\t\n\t    /**\n\t     * Class for dimension change detection.\n\t     *\n\t     * @param {Element|Element[]|Elements|jQuery} element\n\t     * @param {Function} callback\n\t     *\n\t     * @constructor\n\t     */\n\t    var ResizeSensor = function(element, callback) {\n\t        /**\n\t         *\n\t         * @constructor\n\t         */\n\t        function EventQueue() {\n\t            this.q = [];\n\t            this.add = function(ev) {\n\t                this.q.push(ev);\n\t            };\n\t\n\t            var i, j;\n\t            this.call = function() {\n\t                for (i = 0, j = this.q.length; i < j; i++) {\n\t                    this.q[i].call();\n\t                }\n\t            };\n\t        }\n\t\n\t        /**\n\t         * @param {HTMLElement} element\n\t         * @param {String}      prop\n\t         * @returns {String|Number}\n\t         */\n\t        function getComputedStyle(element, prop) {\n\t            if (element.currentStyle) {\n\t                return element.currentStyle[prop];\n\t            } else if (window.getComputedStyle) {\n\t                return window.getComputedStyle(element, null).getPropertyValue(prop);\n\t            } else {\n\t                return element.style[prop];\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param {HTMLElement} element\n\t         * @param {Function}    resized\n\t         */\n\t        function attachResizeEvent(element, resized) {\n\t            if (!element.resizedAttached) {\n\t                element.resizedAttached = new EventQueue();\n\t                element.resizedAttached.add(resized);\n\t            } else if (element.resizedAttached) {\n\t                element.resizedAttached.add(resized);\n\t                return;\n\t            }\n\t\n\t            element.resizeSensor = document.createElement('div');\n\t            element.resizeSensor.className = 'resize-sensor';\n\t            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n\t            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\t\n\t            element.resizeSensor.style.cssText = style;\n\t            element.resizeSensor.innerHTML =\n\t                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n\t                    '<div style=\"' + styleChild + '\"></div>' +\n\t                '</div>' +\n\t                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n\t                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n\t                '</div>';\n\t            element.appendChild(element.resizeSensor);\n\t\n\t            if (!{fixed: 1, absolute: 1}[getComputedStyle(element, 'position')]) {\n\t                element.style.position = 'relative';\n\t            }\n\t\n\t            var expand = element.resizeSensor.childNodes[0];\n\t            var expandChild = expand.childNodes[0];\n\t            var shrink = element.resizeSensor.childNodes[1];\n\t            var shrinkChild = shrink.childNodes[0];\n\t\n\t            var lastWidth, lastHeight;\n\t\n\t            var reset = function() {\n\t                expandChild.style.width = expand.offsetWidth + 10 + 'px';\n\t                expandChild.style.height = expand.offsetHeight + 10 + 'px';\n\t                expand.scrollLeft = expand.scrollWidth;\n\t                expand.scrollTop = expand.scrollHeight;\n\t                shrink.scrollLeft = shrink.scrollWidth;\n\t                shrink.scrollTop = shrink.scrollHeight;\n\t                lastWidth = element.offsetWidth;\n\t                lastHeight = element.offsetHeight;\n\t            };\n\t\n\t            reset();\n\t\n\t            var changed = function() {\n\t                if (element.resizedAttached) {\n\t                    element.resizedAttached.call();\n\t                }\n\t            };\n\t\n\t            var addEvent = function(el, name, cb) {\n\t                if (el.attachEvent) {\n\t                    el.attachEvent('on' + name, cb);\n\t                } else {\n\t                    el.addEventListener(name, cb);\n\t                }\n\t            };\n\t\n\t            var onScroll = function() {\n\t              if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {\n\t                  changed();\n\t              }\n\t              reset();\n\t            };\n\t\n\t            addEvent(expand, 'scroll', onScroll);\n\t            addEvent(shrink, 'scroll', onScroll);\n\t        }\n\t\n\t        var elementType = Object.prototype.toString.call(element);\n\t        var isCollectionTyped = ('[object Array]' === elementType\n\t            || ('[object NodeList]' === elementType)\n\t            || ('[object HTMLCollection]' === elementType)\n\t            || ('undefined' !== typeof jQuery && element instanceof jQuery) //jquery\n\t            || ('undefined' !== typeof Elements && element instanceof Elements) //mootools\n\t        );\n\t\n\t        if (isCollectionTyped) {\n\t            var i = 0, j = element.length;\n\t            for (; i < j; i++) {\n\t                attachResizeEvent(element[i], callback);\n\t            }\n\t        } else {\n\t            attachResizeEvent(element, callback);\n\t        }\n\t\n\t        this.detach = function() {\n\t            if (isCollectionTyped) {\n\t                var i = 0, j = element.length;\n\t                for (; i < j; i++) {\n\t                    ResizeSensor.detach(element[i]);\n\t                }\n\t            } else {\n\t                ResizeSensor.detach(element);\n\t            }\n\t        };\n\t    };\n\t\n\t    ResizeSensor.detach = function(element) {\n\t        if (element.resizeSensor) {\n\t            element.removeChild(element.resizeSensor);\n\t            delete element.resizeSensor;\n\t            delete element.resizedAttached;\n\t        }\n\t    };\n\t\n\t    // make available to common module loader\n\t    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t        module.exports = ResizeSensor;\n\t    }\n\t    else {\n\t        window.ResizeSensor = ResizeSensor;\n\t    }\n\t\n\t})();\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar deps_1 = __webpack_require__(5);\r\n\t/**\r\n\t * this class uses as proxy for EventEmitter2\r\n\t */\r\n\tvar EventEmitter = (function () {\r\n\t    function EventEmitter() {\r\n\t        this.ee = new deps_1.EE2();\r\n\t    }\r\n\t    EventEmitter.prototype.emit = function (eventName) {\r\n\t        var args = [];\r\n\t        for (var _i = 1; _i < arguments.length; _i++) {\r\n\t            args[_i - 1] = arguments[_i];\r\n\t        }\r\n\t        (_a = this.ee).emit.apply(_a, [eventName].concat(args));\r\n\t        var _a;\r\n\t    };\r\n\t    EventEmitter.prototype.on = function (eventName, callback) {\r\n\t        return this.ee.on(eventName, callback);\r\n\t    };\r\n\t    EventEmitter.prototype.off = function (eventName, callback) {\r\n\t        return this.ee.off(eventName, callback);\r\n\t    };\r\n\t    EventEmitter.prototype.subscribe = function (eventName, callback) {\r\n\t        var _this = this;\r\n\t        this.on(eventName, callback);\r\n\t        return function () { return _this.off(eventName, callback); };\r\n\t    };\r\n\t    EventEmitter.prototype.setMaxListeners = function (listenersCount) {\r\n\t        this.ee.setMaxListeners(listenersCount);\r\n\t    };\r\n\t    EventEmitter.prototype.removeAllListeners = function (eventName) {\r\n\t        this.ee.removeAllListeners(eventName);\r\n\t    };\r\n\t    return EventEmitter;\r\n\t}());\r\n\texports.EventEmitter = EventEmitter;\r\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Trend_1 = __webpack_require__(14);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar TrendsManager_1 = __webpack_require__(16);\r\n\tvar Screen_1 = __webpack_require__(17);\r\n\tvar AxisMarks_1 = __webpack_require__(18);\r\n\tvar interfaces_1 = __webpack_require__(19);\r\n\tvar deps_1 = __webpack_require__(5);\r\n\tvar CHART_STATE_EVENTS = {\r\n\t    INITIAL_STATE_APPLIED: 'initialStateApplied',\r\n\t    READY: 'ready',\r\n\t    DESTROY: 'destroy',\r\n\t    CHANGE: 'change',\r\n\t    TREND_CHANGE: 'trendChange',\r\n\t    TRENDS_CHANGE: 'trendsChange',\r\n\t    ZOOM: 'zoom',\r\n\t    RESIZE: 'resize',\r\n\t    SCROLL: 'scroll',\r\n\t    SCROLL_STOP: 'scrollStop',\r\n\t    PLUGINS_STATE_CHANGED: 'pluginsStateChanged'\r\n\t};\r\n\t/**\r\n\t *  all state changes caused only by Chart.setState method\r\n\t */\r\n\tvar Chart = (function () {\r\n\t    function Chart(initialState, plugins) {\r\n\t        if (plugins === void 0) { plugins = []; }\r\n\t        this.data = {\r\n\t            prevState: {},\r\n\t            zoom: 0,\r\n\t            xAxis: {\r\n\t                range: {\r\n\t                    type: interfaces_1.AXIS_RANGE_TYPE.ALL,\r\n\t                    from: 0,\r\n\t                    to: 0,\r\n\t                    scroll: 0,\r\n\t                    zoom: 1,\r\n\t                    padding: { start: 0, end: 5 },\r\n\t                    margin: { start: 0, end: 5 }\r\n\t                },\r\n\t                dataType: interfaces_1.AXIS_DATA_TYPE.NUMBER,\r\n\t                grid: { enabled: true, minSizePx: 100 },\r\n\t                autoScroll: true,\r\n\t                marks: [],\r\n\t                color: '#5273bd'\r\n\t            },\r\n\t            yAxis: {\r\n\t                range: {\r\n\t                    type: interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END,\r\n\t                    from: 0,\r\n\t                    to: 0,\r\n\t                    zoom: 1,\r\n\t                    padding: { start: 5, end: 5 },\r\n\t                    margin: { start: 5, end: 5 },\r\n\t                },\r\n\t                grid: { enabled: true, minSizePx: 50 },\r\n\t                dataType: interfaces_1.AXIS_DATA_TYPE.NUMBER,\r\n\t                marks: [],\r\n\t                color: '#5273bd'\r\n\t            },\r\n\t            animations: {\r\n\t                enabled: true,\r\n\t                trendChangeSpeed: 0.5,\r\n\t                trendChangeEase: void 0,\r\n\t                zoomSpeed: 0.25,\r\n\t                zoomEase: void 0,\r\n\t                scrollSpeed: 0.5,\r\n\t                scrollEase: Linear.easeNone,\r\n\t                autoScrollSpeed: 1,\r\n\t                autoScrollEase: Linear.easeNone,\r\n\t            },\r\n\t            autoRender: { enabled: true, fps: 0 },\r\n\t            autoResize: true,\r\n\t            renderer: 'WebGLRenderer',\r\n\t            autoScroll: true,\r\n\t            controls: { enabled: true },\r\n\t            trendDefaultState: {\r\n\t                enabled: true,\r\n\t                type: Trend_1.TREND_TYPE.LINE,\r\n\t                data: [],\r\n\t                maxSegmentLength: 1000,\r\n\t                lineWidth: 2,\r\n\t                lineColor: 0xFFFFFF,\r\n\t                hasBackground: false,\r\n\t                backgroundColor: 'rgba(#5273BD, 0.15)',\r\n\t                hasBeacon: false,\r\n\t                settingsForTypes: {\r\n\t                    CANDLE: {\r\n\t                        minSegmentLengthInPx: 20,\r\n\t                        maxSegmentLengthInPx: 40,\r\n\t                    },\r\n\t                    LINE: {\r\n\t                        minSegmentLengthInPx: 2,\r\n\t                        maxSegmentLengthInPx: 10,\r\n\t                    }\r\n\t                }\r\n\t            },\r\n\t            cursor: {\r\n\t                dragMode: false,\r\n\t                x: 0,\r\n\t                y: 0\r\n\t            },\r\n\t            font: {\r\n\t                s: '11px Arial',\r\n\t                m: '12px Arial',\r\n\t                l: '13px Arial'\r\n\t            },\r\n\t            backgroundColor: 0x000000,\r\n\t            backgroundOpacity: 1,\r\n\t            showStats: false,\r\n\t            pluginsState: {},\r\n\t            eventEmitterMaxListeners: 20,\r\n\t            maxVisibleSegments: 1280\r\n\t        };\r\n\t        this.plugins = {};\r\n\t        /**\r\n\t         * true then chart was initialized and ready to use\r\n\t         */\r\n\t        this.isReady = false;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.ee.setMaxListeners(initialState.eventEmitterMaxListeners || this.data.eventEmitterMaxListeners);\r\n\t        this.data = Utils_1.Utils.deepMerge(this.data, initialState);\r\n\t        this.trendsManager = new TrendsManager_1.TrendsManager(this, initialState);\r\n\t        initialState.trends = this.trendsManager.calculatedOptions;\r\n\t        initialState = this.installPlugins(plugins, initialState);\r\n\t        this.setState(initialState);\r\n\t        this.setState({ computedData: this.getComputedData() });\r\n\t        this.savePrevState();\r\n\t        this.screen = new Screen_1.Screen(this);\r\n\t        this.xAxisMarks = new AxisMarks_1.AxisMarks(this, interfaces_1.AXIS_TYPE.X);\r\n\t        this.yAxisMarks = new AxisMarks_1.AxisMarks(this, interfaces_1.AXIS_TYPE.Y);\r\n\t        this.initListeners();\r\n\t        // message to other modules that Chart.data is ready for use\r\n\t        this.ee.emit(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, initialState);\r\n\t        // message to other modules that Chart is ready for use\r\n\t        this.isReady = true;\r\n\t        this.ee.emit(CHART_STATE_EVENTS.READY, initialState);\r\n\t    }\r\n\t    /**\r\n\t     * destroy state, use ChartView.destroy to completely destroy chart\r\n\t     */\r\n\t    Chart.prototype.destroy = function () {\r\n\t        this.ee.emit(CHART_STATE_EVENTS.DESTROY);\r\n\t        this.ee.removeAllListeners();\r\n\t        this.data = {};\r\n\t    };\r\n\t    Chart.prototype.onDestroy = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.DESTROY, cb);\r\n\t    };\r\n\t    Chart.prototype.onInitialStateApplied = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, cb);\r\n\t    };\r\n\t    Chart.prototype.onReady = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.READY, cb);\r\n\t    };\r\n\t    Chart.prototype.onChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.CHANGE, cb);\r\n\t    };\r\n\t    Chart.prototype.onTrendChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.TREND_CHANGE, cb);\r\n\t    };\r\n\t    Chart.prototype.onTrendsChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.TRENDS_CHANGE, cb);\r\n\t    };\r\n\t    Chart.prototype.onScrollStop = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.SCROLL_STOP, cb);\r\n\t    };\r\n\t    Chart.prototype.onScroll = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.SCROLL, cb);\r\n\t    };\r\n\t    Chart.prototype.onZoom = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.ZOOM, cb);\r\n\t    };\r\n\t    Chart.prototype.onResize = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.RESIZE, cb);\r\n\t    };\r\n\t    Chart.prototype.onPluginsStateChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, cb);\r\n\t    };\r\n\t    Chart.prototype.getTrend = function (trendName) {\r\n\t        return this.trendsManager.getTrend(trendName);\r\n\t    };\r\n\t    Chart.prototype.setState = function (newState, eventData, silent) {\r\n\t        if (silent === void 0) { silent = false; }\r\n\t        var stateData = this.data;\r\n\t        var newStateObj = newState;\r\n\t        var changedProps = {};\r\n\t        for (var key in newStateObj) {\r\n\t            if (stateData[key] !== newStateObj[key]) {\r\n\t                changedProps[key] = newStateObj[key];\r\n\t            }\r\n\t        }\r\n\t        this.savePrevState(changedProps);\r\n\t        // temporary remove trends data from newState by performance reasons\r\n\t        var trendsData = {};\r\n\t        if (newState.trends)\r\n\t            for (var trendName in newState.trends) {\r\n\t                var trendOptions = newState.trends[trendName];\r\n\t                if (trendOptions.data)\r\n\t                    trendsData[trendName] = trendOptions.data;\r\n\t                delete trendOptions.data;\r\n\t            }\r\n\t        var newStateContainsData = Object.keys(trendsData).length > 0;\r\n\t        this.data = Utils_1.Utils.deepMerge(this.data, newState, false);\r\n\t        // return data to state\r\n\t        if (newStateContainsData)\r\n\t            for (var trendName in trendsData) {\r\n\t                this.data.trends[trendName].data = trendsData[trendName];\r\n\t            }\r\n\t        if (silent)\r\n\t            return;\r\n\t        // recalculate all dynamic state props\r\n\t        var recalculateResult = this.recalculateState(changedProps);\r\n\t        changedProps = recalculateResult.changedProps;\r\n\t        this.emitChangedStateEvents(changedProps, eventData);\r\n\t    };\r\n\t    /**\r\n\t     * recalculate all computed state props\r\n\t     */\r\n\t    Chart.prototype.recalculateState = function (changedProps) {\r\n\t        var data = this.data;\r\n\t        var patch = {};\r\n\t        var actualData = Utils_1.Utils.deepMerge({}, data);\r\n\t        // recalculate scroll position by changed cursor options\r\n\t        var cursorOptions = changedProps.cursor;\r\n\t        var isMouseDrag = cursorOptions && data.cursor.dragMode && data.prevState.cursor.dragMode;\r\n\t        if (isMouseDrag) {\r\n\t            var oldX = data.prevState.cursor.x;\r\n\t            var currentX = cursorOptions.x;\r\n\t            var currentScroll = data.xAxis.range.scroll;\r\n\t            var deltaXVal = this.pxToValueByXAxis(oldX - currentX);\r\n\t            patch.xAxis = { range: { scroll: currentScroll + deltaXVal } };\r\n\t            actualData = Utils_1.Utils.deepMerge(actualData, { xAxis: patch.xAxis });\r\n\t        }\r\n\t        var chartWasResized = changedProps.width != void 0 || changedProps.height != void 0;\r\n\t        var scrollXChanged = false;\r\n\t        var needToRecalculateXAxis = (isMouseDrag ||\r\n\t            chartWasResized ||\r\n\t            (changedProps.xAxis && (changedProps.xAxis.range)) ||\r\n\t            this.data.xAxis.range.zeroVal == void 0);\r\n\t        if (needToRecalculateXAxis) {\r\n\t            var xAxisPatch = this.recalculateXAxis(actualData, changedProps);\r\n\t            if (xAxisPatch) {\r\n\t                scrollXChanged = true;\r\n\t                patch = Utils_1.Utils.deepMerge(patch, { xAxis: xAxisPatch });\r\n\t                actualData = Utils_1.Utils.deepMerge(actualData, { xAxis: xAxisPatch });\r\n\t            }\r\n\t        }\r\n\t        // recalculate axis \"from\" and \"to\" for dynamics AXIS_RANGE_TYPE\r\n\t        var needToRecalculateYAxis = (chartWasResized ||\r\n\t            (data.yAxis.range.type === interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END ||\r\n\t                data.yAxis.range.type === interfaces_1.AXIS_RANGE_TYPE.AUTO ||\r\n\t                data.yAxis.range.isMirrorMode) &&\r\n\t                (scrollXChanged || changedProps.trends || changedProps.yAxis) ||\r\n\t            this.data.yAxis.range.zeroVal == void 0);\r\n\t        if (needToRecalculateYAxis) {\r\n\t            var yAxisPatch = this.recalculateYAxis(actualData);\r\n\t            if (yAxisPatch) {\r\n\t                patch = Utils_1.Utils.deepMerge(patch, { yAxis: yAxisPatch });\r\n\t                actualData = Utils_1.Utils.deepMerge(actualData, { yAxis: yAxisPatch });\r\n\t            }\r\n\t        }\r\n\t        this.savePrevState(patch);\r\n\t        var allChangedProps = Utils_1.Utils.deepMerge(changedProps, patch);\r\n\t        patch.computedData = this.getComputedData(allChangedProps);\r\n\t        this.savePrevState(patch);\r\n\t        this.data = Utils_1.Utils.deepMerge(this.data, patch);\r\n\t        return { changedProps: allChangedProps, patch: patch };\r\n\t    };\r\n\t    Chart.prototype.getComputedData = function (changedProps) {\r\n\t        var computeAll = !changedProps;\r\n\t        var computedData = {};\r\n\t        if (computeAll || changedProps.trends && this.trendsManager) {\r\n\t            computedData.trends = {\r\n\t                maxXVal: this.trendsManager.getEndXVal(),\r\n\t                minXVal: this.trendsManager.getStartXVal()\r\n\t            };\r\n\t        }\r\n\t        return computedData;\r\n\t    };\r\n\t    Chart.prototype.savePrevState = function (changedProps) {\r\n\t        if (!changedProps)\r\n\t            changedProps = this.data;\r\n\t        var prevState = this.data.prevState;\r\n\t        // prevent to store prev trend data by performance reasons\r\n\t        Utils_1.Utils.copyProps(this.data, prevState, changedProps, ['trends']);\r\n\t    };\r\n\t    Chart.prototype.emitChangedStateEvents = function (changedProps, eventData) {\r\n\t        var prevState = this.data.prevState;\r\n\t        // emit common change event\r\n\t        this.ee.emit(CHART_STATE_EVENTS.CHANGE, changedProps, eventData);\r\n\t        // emit event for each changed state property\r\n\t        for (var key in changedProps) {\r\n\t            this.ee.emit(key + 'Change', changedProps[key], eventData);\r\n\t        }\r\n\t        if (!this.isReady)\r\n\t            return;\r\n\t        // emit special events based on changed state\r\n\t        var scrollStopEventNeeded = (changedProps.cursor &&\r\n\t            changedProps.cursor.dragMode === false &&\r\n\t            prevState.cursor.dragMode === true);\r\n\t        scrollStopEventNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL_STOP, changedProps);\r\n\t        var scrollChangeEventsNeeded = (changedProps.xAxis &&\r\n\t            changedProps.xAxis.range &&\r\n\t            changedProps.xAxis.range.scroll !== void 0);\r\n\t        scrollChangeEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL, changedProps);\r\n\t        var zoomEventsNeeded = ((changedProps.xAxis && changedProps.xAxis.range && changedProps.xAxis.range.zoom) ||\r\n\t            (changedProps.yAxis && changedProps.yAxis.range && changedProps.yAxis.range.zoom));\r\n\t        zoomEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.ZOOM, changedProps);\r\n\t        var resizeEventNeeded = (changedProps.width || changedProps.height);\r\n\t        resizeEventNeeded && this.ee.emit(CHART_STATE_EVENTS.RESIZE, changedProps);\r\n\t        var pluginStateChangedEventNeeded = !!(changedProps.pluginsState);\r\n\t        pluginStateChangedEventNeeded && this.ee.emit(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, changedProps.pluginsState);\r\n\t    };\r\n\t    /**\r\n\t     * init plugins and save plugins options in initialState\r\n\t     */\r\n\t    Chart.prototype.installPlugins = function (plugins, initialState) {\r\n\t        var _this = this;\r\n\t        initialState.pluginsState = {};\r\n\t        plugins.forEach(function (plugin) {\r\n\t            var PluginClass = plugin.constructor;\r\n\t            var pluginName = PluginClass.NAME;\r\n\t            initialState.pluginsState[pluginName] = Utils_1.Utils.deepMerge({}, plugin.initialState);\r\n\t            _this.plugins[pluginName] = plugin;\r\n\t            plugin.setupChartState(_this);\r\n\t        });\r\n\t        return initialState;\r\n\t    };\r\n\t    /**\r\n\t     * returns plugin instance by plugin name\r\n\t     * @example\r\n\t     */\r\n\t    Chart.prototype.getPlugin = function (pluginName) {\r\n\t        return this.plugins[pluginName];\r\n\t    };\r\n\t    Chart.prototype.initListeners = function () {\r\n\t        var _this = this;\r\n\t        this.ee.on(CHART_STATE_EVENTS.TRENDS_CHANGE, function (changedTrends, newData) {\r\n\t            _this.handleTrendsChange(changedTrends, newData);\r\n\t        });\r\n\t    };\r\n\t    Chart.prototype.handleTrendsChange = function (changedTrends, newData) {\r\n\t        for (var trendName in changedTrends) {\r\n\t            this.ee.emit(CHART_STATE_EVENTS.TREND_CHANGE, trendName, changedTrends[trendName], newData);\r\n\t        }\r\n\t    };\r\n\t    Chart.prototype.recalculateXAxis = function (actualData, changedProps) {\r\n\t        var axisRange = actualData.xAxis.range;\r\n\t        var patch = { range: {} };\r\n\t        var isInitialize = axisRange.zeroVal == void 0;\r\n\t        var zeroVal, scaleFactor;\r\n\t        var zoom = axisRange.zoom;\r\n\t        if (axisRange.isMirrorMode) {\r\n\t            Utils_1.Utils.error('range.isMirrorMode available only for yAxis.range');\r\n\t        }\r\n\t        if (isInitialize) {\r\n\t            zeroVal = axisRange.from;\r\n\t            scaleFactor = actualData.width / (axisRange.to - axisRange.from);\r\n\t            patch = { range: { zeroVal: zeroVal, scaleFactor: scaleFactor } };\r\n\t        }\r\n\t        else {\r\n\t            zeroVal = axisRange.zeroVal;\r\n\t            scaleFactor = axisRange.scaleFactor;\r\n\t            // recalculate range.zoom and range.scroll then range.from or range.to was changed\r\n\t            if (changedProps.xAxis &&\r\n\t                (changedProps.xAxis.range.from != void 0 || changedProps.xAxis.range.to)) {\r\n\t                if (changedProps.xAxis.range.zoom) {\r\n\t                    Utils_1.Utils.error('Impossible to change \"range.zoom\" then \"range.from\" or \"range.to\" present');\r\n\t                }\r\n\t                var currentScaleFactor = actualData.width / (axisRange.to - axisRange.from);\r\n\t                patch.range.scroll = axisRange.from - zeroVal;\r\n\t                patch.range.zoom = currentScaleFactor / scaleFactor;\r\n\t                return patch;\r\n\t            }\r\n\t        }\r\n\t        // recalculate range.from and range.to then range.zoom or range.scroll was changed\r\n\t        do {\r\n\t            var from = zeroVal + axisRange.scroll;\r\n\t            var to = from + actualData.width / (scaleFactor * zoom);\r\n\t            var rangeLength = to - from;\r\n\t            var needToRecalculateZoom = false;\r\n\t            var rangeMoreThenMaxValue = (axisRange.maxLength && rangeLength > axisRange.maxLength);\r\n\t            var rangeLessThenMinValue = (axisRange.minLength && rangeLength < axisRange.minLength);\r\n\t            needToRecalculateZoom = rangeMoreThenMaxValue || rangeLessThenMinValue;\r\n\t            if (needToRecalculateZoom) {\r\n\t                var fixScale = rangeLength > axisRange.maxLength ?\r\n\t                    rangeLength / axisRange.maxLength :\r\n\t                    rangeLength / axisRange.minLength;\r\n\t                var zoom = zoom * fixScale;\r\n\t                patch.range.zoom = zoom;\r\n\t            }\r\n\t        } while (needToRecalculateZoom);\r\n\t        patch.range.from = from;\r\n\t        patch.range.to = to;\r\n\t        return patch;\r\n\t    };\r\n\t    Chart.prototype.recalculateYAxis = function (actualData) {\r\n\t        var patch = { range: {} };\r\n\t        var yAxisRange = actualData.yAxis.range;\r\n\t        var isInitialize = yAxisRange.scaleFactor == void 0;\r\n\t        var trends = this.trendsManager;\r\n\t        var trendsEndXVal = trends.getEndXVal();\r\n\t        var trendsStartXVal = trends.getStartXVal();\r\n\t        var xRange = actualData.xAxis.range;\r\n\t        var xFrom = xRange.from, xTo = xRange.to;\r\n\t        var xRangeLength = xTo - xFrom;\r\n\t        var zeroVal, scaleFactor, scroll, zoom, needToZoom;\r\n\t        // check situation when chart was scrolled behind trends end or before trends start\r\n\t        if (xTo > trendsEndXVal) {\r\n\t            xTo = trendsEndXVal;\r\n\t            xFrom = xTo - xRangeLength;\r\n\t        }\r\n\t        else if (xFrom < trendsStartXVal) {\r\n\t            xFrom = trendsStartXVal;\r\n\t            xTo = xFrom + xRangeLength;\r\n\t        }\r\n\t        var maxY = trends.getMaxYVal(xFrom, xTo);\r\n\t        var minY = trends.getMinYVal(xFrom, xTo);\r\n\t        var trendLastY = trends.getMaxYVal(trendsEndXVal, trendsEndXVal);\r\n\t        if (yAxisRange.type == interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END) {\r\n\t            if (trendLastY > maxY)\r\n\t                maxY = trendLastY;\r\n\t            if (trendLastY < minY)\r\n\t                minY = trendLastY;\r\n\t        }\r\n\t        if (yAxisRange.isMirrorMode) {\r\n\t            if (yAxisRange.zeroVal == void 0)\r\n\t                Utils_1.Utils.error('range.zeroVal must be set when range.isMirrorMode');\r\n\t            var distanceFromZeroValForMaxY = Math.abs(yAxisRange.zeroVal - maxY);\r\n\t            var distanceFromZeroValForMinY = Math.abs(yAxisRange.zeroVal - minY);\r\n\t            var maxDistanceFromZeroVal = Math.max(distanceFromZeroValForMaxY, distanceFromZeroValForMinY);\r\n\t            maxY = yAxisRange.zeroVal + maxDistanceFromZeroVal;\r\n\t            minY = yAxisRange.zeroVal - maxDistanceFromZeroVal;\r\n\t        }\r\n\t        var margin = yAxisRange.margin;\r\n\t        var padding = {\r\n\t            start: yAxisRange.padding.start + margin.start,\r\n\t            end: yAxisRange.padding.end + margin.end\r\n\t        };\r\n\t        if (padding.end + padding.start >= actualData.height) {\r\n\t            Utils_1.Utils.warn('Sum of padding and margins of yAxi more then available chart height. Trends can be rendered incorrectly');\r\n\t        }\r\n\t        var rangeLength = maxY - minY;\r\n\t        var paddingTopInPercents = padding.end / actualData.height;\r\n\t        var paddingBottomInPercents = padding.start / actualData.height;\r\n\t        var rangeLengthInPercents = 1 - paddingTopInPercents - paddingBottomInPercents;\r\n\t        var visibleRangeLength = rangeLength / rangeLengthInPercents;\r\n\t        var fromVal = minY - visibleRangeLength * paddingBottomInPercents;\r\n\t        var toVal = maxY + visibleRangeLength * paddingTopInPercents;\r\n\t        if (isInitialize) {\r\n\t            zeroVal = yAxisRange.zeroVal != void 0 ? yAxisRange.zeroVal : fromVal;\r\n\t            scaleFactor = actualData.height / (toVal - fromVal);\r\n\t            patch = { range: { zeroVal: zeroVal, scaleFactor: scaleFactor } };\r\n\t            needToZoom = true;\r\n\t        }\r\n\t        else {\r\n\t            scaleFactor = yAxisRange.scaleFactor;\r\n\t            zeroVal = yAxisRange.zeroVal;\r\n\t            var maxScreenY = Math.round(this.getScreenYByValue(maxY));\r\n\t            var minScreenY = Math.round(this.getScreenYByValue(minY));\r\n\t            needToZoom = (maxScreenY > actualData.height - margin.end ||\r\n\t                maxScreenY < actualData.height - padding.end ||\r\n\t                minScreenY < margin.start ||\r\n\t                minScreenY > padding.start);\r\n\t        }\r\n\t        if (!needToZoom)\r\n\t            return null;\r\n\t        scroll = fromVal - zeroVal;\r\n\t        zoom = (actualData.height / (toVal - fromVal)) / scaleFactor;\r\n\t        var currentAxisRange = this.data.yAxis.range;\r\n\t        if (currentAxisRange.from !== fromVal)\r\n\t            patch.range.from = fromVal;\r\n\t        if (currentAxisRange.to !== toVal)\r\n\t            patch.range.to = toVal;\r\n\t        if (currentAxisRange.scroll !== scroll)\r\n\t            patch.range.scroll = scroll;\r\n\t        if (currentAxisRange.zoom !== zoom)\r\n\t            patch.range.zoom = zoom;\r\n\t        return patch;\r\n\t    };\r\n\t    Chart.prototype.zoom = function (zoomValue, origin) {\r\n\t        var _this = this;\r\n\t        if (origin === void 0) { origin = 0.5; }\r\n\t        var _a = this.data.xAxis.range, zoom = _a.zoom, scroll = _a.scroll, scaleFactor = _a.scaleFactor;\r\n\t        var newZoom = zoom * zoomValue;\r\n\t        var currentRange = this.data.width / (scaleFactor * zoom);\r\n\t        var nextRange = this.data.width / (scaleFactor * newZoom);\r\n\t        var newScroll = scroll + (currentRange - nextRange) * origin;\r\n\t        this.setState({ xAxis: { range: { zoom: newZoom, scroll: newScroll } } });\r\n\t        return new deps_1.Promise(function (resolve) {\r\n\t            var animationTime = _this.data.animations.enabled ? _this.data.animations.zoomSpeed : 0;\r\n\t            setTimeout(resolve, animationTime * 1000);\r\n\t        });\r\n\t    };\r\n\t    Chart.prototype.zoomToRange = function (range, origin) {\r\n\t        var _a = this.data.xAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom;\r\n\t        var currentRange = this.data.width / (scaleFactor * zoom);\r\n\t        return this.zoom(currentRange / range, origin);\r\n\t    };\r\n\t    Chart.prototype.scrollToEnd = function () {\r\n\t        var _this = this;\r\n\t        var state = this.data;\r\n\t        var endXVal = this.trendsManager.getEndXVal();\r\n\t        var range = state.xAxis.range;\r\n\t        var scroll = endXVal - this.pxToValueByXAxis(state.width) + this.pxToValueByXAxis(range.padding.end) - range.zeroVal;\r\n\t        this.setState({ xAxis: { range: { scroll: scroll } } });\r\n\t        return new deps_1.Promise(function (resolve) {\r\n\t            var animationTime = _this.data.animations.enabled ? _this.data.animations.scrollSpeed : 0;\r\n\t            setTimeout(resolve, animationTime * 1000);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal to xVal\r\n\t     */\r\n\t    Chart.prototype.getPointOnXAxis = function (xVal) {\r\n\t        var _a = this.data.xAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom, zeroVal = _a.zeroVal;\r\n\t        return (xVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from yAxis.range.zeroVal to yVal\r\n\t     */\r\n\t    Chart.prototype.getPointOnYAxis = function (yVal) {\r\n\t        var _a = this.data.yAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom, zeroVal = _a.zeroVal;\r\n\t        return (yVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     * returns value by offset in pixels from xAxis.range.zeroVal\r\n\t     */\r\n\t    Chart.prototype.getValueOnXAxis = function (x) {\r\n\t        return this.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from xAxis.range\r\n\t     */\r\n\t    Chart.prototype.valueToPxByXAxis = function (xVal) {\r\n\t        return xVal * this.data.xAxis.range.scaleFactor * this.data.xAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from yAxis.range\r\n\t     */\r\n\t    Chart.prototype.valueToPxByYAxis = function (yVal) {\r\n\t        return yVal * this.data.yAxis.range.scaleFactor * this.data.yAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from xAxis.range\r\n\t     */\r\n\t    Chart.prototype.pxToValueByXAxis = function (xVal) {\r\n\t        return xVal / this.data.xAxis.range.scaleFactor / this.data.xAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from yAxis.range\r\n\t     */\r\n\t    Chart.prototype.pxToValueByYAxis = function (yVal) {\r\n\t        return yVal / this.data.yAxis.range.scaleFactor / this.data.yAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns x value by screen x coordinate\r\n\t     */\r\n\t    Chart.prototype.getValueByScreenX = function (x) {\r\n\t        var _a = this.data.xAxis.range, zeroVal = _a.zeroVal, scroll = _a.scroll;\r\n\t        return zeroVal + scroll + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  returns y value by screen y coordinate\r\n\t     */\r\n\t    Chart.prototype.getValueByScreenY = function (y) {\r\n\t        var _a = this.data.yAxis.range, zeroVal = _a.zeroVal, scroll = _a.scroll;\r\n\t        return zeroVal + scroll + this.pxToValueByYAxis(y);\r\n\t    };\r\n\t    /**\r\n\t     *  returns screen x value by screen y coordinate\r\n\t     */\r\n\t    Chart.prototype.getScreenXByValue = function (xVal) {\r\n\t        var _a = this.data.xAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByXAxis(xVal - zeroVal - scroll);\r\n\t    };\r\n\t    /**\r\n\t     *  returns screen y value by screen y coordinate\r\n\t     */\r\n\t    Chart.prototype.getScreenYByValue = function (yVal) {\r\n\t        var _a = this.data.yAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByYAxis(yVal - zeroVal - scroll);\r\n\t    };\r\n\t    /**\r\n\t     * returns screen x coordinate by offset in pixels from xAxis.range.zeroVal value\r\n\t     */\r\n\t    Chart.prototype.getScreenXByPoint = function (xVal) {\r\n\t        return this.getScreenXByValue(this.getValueOnXAxis(xVal));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from xAxis.range.zeroVal value by screen x coordinate\r\n\t     */\r\n\t    Chart.prototype.getPointByScreenX = function (screenX) {\r\n\t        return this.getPointOnXAxis(this.getValueByScreenX(screenX));\r\n\t    };\r\n\t    Chart.prototype.getPointOnChart = function (xVal, yVal) {\r\n\t        return new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\r\n\t    };\r\n\t    Chart.prototype.getScreenLeftVal = function () {\r\n\t        return this.getValueByScreenX(0);\r\n\t    };\r\n\t    Chart.prototype.getScreenRightVal = function () {\r\n\t        return this.getValueByScreenX(this.data.width);\r\n\t    };\r\n\t    Chart.prototype.getPaddingRight = function () {\r\n\t        return this.getValueByScreenX(this.data.width - this.data.xAxis.range.padding.end);\r\n\t    };\r\n\t    return Chart;\r\n\t}());\r\n\texports.Chart = Chart;\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar TrendSegmentsManager_1 = __webpack_require__(15);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar deps_1 = __webpack_require__(5);\r\n\tvar EVENTS = {\r\n\t    CHANGE: 'Change',\r\n\t    PREPEND_REQUEST: 'prependRequest'\r\n\t};\r\n\t(function (TREND_TYPE) {\r\n\t    TREND_TYPE[TREND_TYPE[\"LINE\"] = 0] = \"LINE\";\r\n\t    TREND_TYPE[TREND_TYPE[\"CANDLE\"] = 1] = \"CANDLE\";\r\n\t})(exports.TREND_TYPE || (exports.TREND_TYPE = {}));\r\n\tvar TREND_TYPE = exports.TREND_TYPE;\r\n\tvar Trend = (function () {\r\n\t    function Trend(chartState, trendName, initialState) {\r\n\t        this.minXVal = Infinity;\r\n\t        this.minYVal = Infinity;\r\n\t        this.maxXVal = -Infinity;\r\n\t        this.maxYVal = -Infinity;\r\n\t        var options = initialState.trends[trendName];\r\n\t        this.name = trendName;\r\n\t        this.chartState = chartState;\r\n\t        this.calculatedOptions = Utils_1.Utils.deepMerge(this.chartState.data.trendDefaultState, options);\r\n\t        this.calculatedOptions.name = trendName;\r\n\t        if (options.dataset)\r\n\t            this.calculatedOptions.data = Trend.prepareData(options.dataset);\r\n\t        this.calculatedOptions.dataset = [];\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    Trend.prototype.onInitialStateApplied = function () {\r\n\t        this.segmentsManager = new TrendSegmentsManager_1.TrendSegmentsManager(this.chartState, this);\r\n\t    };\r\n\t    Trend.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var chartState = this.chartState;\r\n\t        chartState.onInitialStateApplied(function () { return _this.onInitialStateApplied(); });\r\n\t        chartState.onScrollStop(function () { return _this.checkForPrependRequest(); });\r\n\t        chartState.onZoom(function () { return _this.checkForPrependRequest(); });\r\n\t        chartState.onTrendChange(function (trendName, changedOptions, newData) { return _this.ee.emit(EVENTS.CHANGE, changedOptions, newData); });\r\n\t        chartState.onDestroy(function () { return _this.ee.removeAllListeners(); });\r\n\t    };\r\n\t    Trend.prototype.getCalculatedOptions = function () {\r\n\t        return this.calculatedOptions;\r\n\t    };\r\n\t    Trend.prototype.appendData = function (rawData) {\r\n\t        var options = this.getOptions();\r\n\t        var newData = Trend.prepareData(rawData, this.getData());\r\n\t        var updatedTrendData = options.data.concat(newData);\r\n\t        this.changeData(updatedTrendData, newData);\r\n\t    };\r\n\t    Trend.prototype.prependData = function (rawData) {\r\n\t        var options = this.getOptions();\r\n\t        var newData = Trend.prepareData(rawData, this.getData(), true);\r\n\t        var updatedTrendData = newData.concat(options.data);\r\n\t        this.changeData(updatedTrendData, newData);\r\n\t    };\r\n\t    Trend.prototype.changeData = function (allData, newData) {\r\n\t        for (var _i = 0, newData_1 = newData; _i < newData_1.length; _i++) {\r\n\t            var item = newData_1[_i];\r\n\t            if (item.xVal < this.minXVal)\r\n\t                this.minXVal = item.xVal;\r\n\t            if (item.xVal > this.maxXVal)\r\n\t                this.maxXVal = item.xVal;\r\n\t            if (item.yVal < this.minYVal)\r\n\t                this.minYVal = item.yVal;\r\n\t            if (item.yVal > this.maxYVal)\r\n\t                this.maxYVal = item.yVal;\r\n\t        }\r\n\t        var options = this.getOptions();\r\n\t        var statePatch = { trends: (_a = {}, _a[options.name] = { data: allData }, _a) };\r\n\t        this.chartState.setState(statePatch, newData);\r\n\t        var _a;\r\n\t    };\r\n\t    Trend.prototype.getData = function (fromX, toX) {\r\n\t        var data = this.getOptions().data;\r\n\t        if (fromX == void 0 && toX == void 0)\r\n\t            return data;\r\n\t        fromX = fromX !== void 0 ? fromX : data[0].xVal;\r\n\t        toX = toX !== void 0 ? toX : data[data.length].xVal;\r\n\t        var filteredData = [];\r\n\t        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\r\n\t            var item = data_1[_i];\r\n\t            if (item.xVal < fromX)\r\n\t                continue;\r\n\t            if (item.xVal > toX)\r\n\t                break;\r\n\t            filteredData.push(item);\r\n\t        }\r\n\t        return filteredData;\r\n\t    };\r\n\t    Trend.prototype.getFirstItem = function () {\r\n\t        return this.getOptions().data[0];\r\n\t    };\r\n\t    Trend.prototype.getLastItem = function () {\r\n\t        var data = this.getOptions().data;\r\n\t        return data[data.length - 1];\r\n\t    };\r\n\t    Trend.prototype.getOptions = function () {\r\n\t        return this.chartState.data.trends[this.name];\r\n\t    };\r\n\t    Trend.prototype.setOptions = function (options) {\r\n\t        this.chartState.setState({ trends: (_a = {}, _a[this.name] = options, _a) });\r\n\t        var _a;\r\n\t    };\r\n\t    Trend.prototype.onPrependRequest = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on(EVENTS.PREPEND_REQUEST, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(EVENTS.PREPEND_REQUEST, cb);\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for Chart.onTrendChange\r\n\t     */\r\n\t    Trend.prototype.onChange = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on(EVENTS.CHANGE, cb);\r\n\t        return function () { _this.ee.off(EVENTS.CHANGE, cb); };\r\n\t    };\r\n\t    Trend.prototype.onDataChange = function (cb) {\r\n\t        var _this = this;\r\n\t        var onChangeCb = function (changedOptions, newData) {\r\n\t            if (newData)\r\n\t                cb(newData);\r\n\t        };\r\n\t        this.ee.on(EVENTS.CHANGE, onChangeCb);\r\n\t        return function () {\r\n\t            _this.ee.off(EVENTS.CHANGE, onChangeCb);\r\n\t        };\r\n\t    };\r\n\t    Trend.prototype.checkForPrependRequest = function () {\r\n\t        var _this = this;\r\n\t        if (this.prependRequest)\r\n\t            return;\r\n\t        var chartState = this.chartState;\r\n\t        var minXVal = chartState.data.computedData.trends.minXVal;\r\n\t        var minScreenX = chartState.getScreenXByValue(minXVal);\r\n\t        var needToRequest = minScreenX > 0;\r\n\t        var _a = chartState.data.xAxis.range, from = _a.from, to = _a.to;\r\n\t        var requestedDataLength = to - from;\r\n\t        if (!needToRequest)\r\n\t            return;\r\n\t        this.prependRequest = new deps_1.Promise(function (resolve, reject) {\r\n\t            _this.ee.emit(EVENTS.PREPEND_REQUEST, requestedDataLength, resolve, reject);\r\n\t        });\r\n\t        this.prependRequest.then(function (newData) {\r\n\t            _this.prependData(newData);\r\n\t            _this.prependRequest = null;\r\n\t        }, function () {\r\n\t            _this.prependRequest = null;\r\n\t        });\r\n\t    };\r\n\t    Trend.prepareData = function (newData, currentData, isPrepend) {\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var data = [];\r\n\t        if (typeof newData[0] == 'number') {\r\n\t            currentData = currentData || [];\r\n\t            var initialItem = void 0;\r\n\t            var xVal = void 0;\r\n\t            if (isPrepend) {\r\n\t                initialItem = currentData[0];\r\n\t                xVal = initialItem.xVal - newData.length;\r\n\t            }\r\n\t            else {\r\n\t                initialItem = currentData[currentData.length - 1];\r\n\t                xVal = initialItem ? initialItem.xVal + 1 : 0;\r\n\t            }\r\n\t            for (var _i = 0, _a = newData; _i < _a.length; _i++) {\r\n\t                var yVal = _a[_i];\r\n\t                data.push({ xVal: xVal, yVal: yVal, id: Utils_1.Utils.getUid() });\r\n\t                xVal++;\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            data = newData;\r\n\t        }\r\n\t        return data;\r\n\t    };\r\n\t    return Trend;\r\n\t}());\r\n\texports.Trend = Trend;\r\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Trend_1 = __webpack_require__(14);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar MAX_ANIMATED_SEGMENTS = 100;\r\n\tvar EVENTS = {\r\n\t    REBUILD: 'rebuild',\r\n\t    DISLPAYED_RANGE_CHANGED: 'displayedRangeChanged',\r\n\t    ANIMATION_FRAME: 'animationFrame'\r\n\t};\r\n\t/**\r\n\t *  Class helps to display and animate trends segments\r\n\t */\r\n\tvar TrendSegmentsManager = (function () {\r\n\t    function TrendSegmentsManager(chartState, trend) {\r\n\t        this.segmentsById = {};\r\n\t        this.segments = [];\r\n\t        this.animatedSegmentsIds = [];\r\n\t        this.segmentsLength = 0;\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        this.animatedSegmentsForPrepend = [];\r\n\t        this.nextEmptyId = 0;\r\n\t        this.startSegmentId = 0;\r\n\t        this.endSegmentId = 0;\r\n\t        this.chartState = chartState;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.trend = trend;\r\n\t        this.maxSegmentLength = trend.getOptions().maxSegmentLength;\r\n\t        this.tryToRebuildSegments();\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendSegmentsManager.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.trend.onChange(function (changedOptions, newData) { return _this.onTrendChangeHandler(changedOptions, newData); });\r\n\t        this.chartState.onZoom(function () { return _this.onZoomHandler(); });\r\n\t        this.chartState.onScroll(function () { return _this.recalculateDisplayedRange(); });\r\n\t        this.chartState.onDestroy(function () { return _this.onDestroyHandler(); });\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t        this.appendAnimation && this.appendAnimation.kill();\r\n\t        this.prependAnimation && this.prependAnimation.kill();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onZoomHandler = function () {\r\n\t        var segmentsRebuilded = this.tryToRebuildSegments();\r\n\t        if (!segmentsRebuilded) {\r\n\t            this.recalculateDisplayedRange();\r\n\t        }\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onTrendChangeHandler = function (changedOptions, newData) {\r\n\t        var needToRebuildSegments = (changedOptions.type != void 0 ||\r\n\t            changedOptions.maxSegmentLength != void 0);\r\n\t        if (needToRebuildSegments) {\r\n\t            this.tryToRebuildSegments(true);\r\n\t            return;\r\n\t        }\r\n\t        if (!newData)\r\n\t            return;\r\n\t        var data = this.trend.getData();\r\n\t        var isAppend = (!data.length || data[0].xVal < newData[0].xVal);\r\n\t        isAppend ? this.appendData(newData) : this.prependData(newData);\r\n\t        this.recalculateDisplayedRange();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getSegment = function (id) {\r\n\t        return this.segmentsById[id];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getEndSegment = function () {\r\n\t        return this.segmentsById[this.endSegmentId];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getStartSegment = function () {\r\n\t        return this.segmentsById[this.startSegmentId];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.tryToRebuildSegments = function (force) {\r\n\t        if (force === void 0) { force = false; }\r\n\t        var options = this.trend.getOptions();\r\n\t        var trendTypeName = Trend_1.TREND_TYPE[options.type];\r\n\t        var trendTypesSettings = options.settingsForTypes;\r\n\t        var trendTypeSettings = trendTypesSettings[trendTypeName];\r\n\t        var minSegmentLengthInPx = trendTypeSettings.minSegmentLengthInPx, maxSegmentLengthInPx = trendTypeSettings.maxSegmentLengthInPx;\r\n\t        var needToRebuild = this.segments.length === 0 || force;\r\n\t        var segmentLength = this.maxSegmentLength;\r\n\t        // call toFixed(2) to prevent floating segment error compare\r\n\t        var currentSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(segmentLength).toFixed(2));\r\n\t        var currentMaxSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(this.maxSegmentLength).toFixed(2));\r\n\t        if (currentSegmentLengthInPx < minSegmentLengthInPx) {\r\n\t            needToRebuild = true;\r\n\t            segmentLength = Math.ceil(this.chartState.pxToValueByXAxis(maxSegmentLengthInPx));\r\n\t        }\r\n\t        else if (currentMaxSegmentLengthInPx > maxSegmentLengthInPx) {\r\n\t            needToRebuild = true;\r\n\t            segmentLength = this.chartState.pxToValueByXAxis(minSegmentLengthInPx);\r\n\t        }\r\n\t        if (!needToRebuild)\r\n\t            return false;\r\n\t        this.maxSegmentLength = segmentLength;\r\n\t        this.segmentsById = {};\r\n\t        this.segments = [];\r\n\t        this.nextEmptyId = 0;\r\n\t        this.startSegmentId = 0;\r\n\t        this.endSegmentId = 0;\r\n\t        this.segmentsLength = 0;\r\n\t        this.stopAllAnimations();\r\n\t        this.appendData(null, true);\r\n\t        this.recalculateDisplayedRange(true);\r\n\t        this.ee.emit(EVENTS.REBUILD);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.stopAllAnimations = function () {\r\n\t        this.animatedSegmentsIds = [];\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        if (this.prependAnimation)\r\n\t            this.prependAnimation.kill();\r\n\t        if (this.appendAnimation)\r\n\t            this.appendAnimation.kill();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.recalculateDisplayedRange = function (segmentsAreRebuilded) {\r\n\t        if (segmentsAreRebuilded === void 0) { segmentsAreRebuilded = false; }\r\n\t        var _a = this.chartState.data.xAxis.range, from = _a.from, to = _a.to;\r\n\t        var _b = this, firstDisplayedSegment = _b.firstDisplayedSegment, lastDisplayedSegment = _b.lastDisplayedSegment;\r\n\t        var displayedRange = to - from;\r\n\t        this.firstDisplayedSegmentInd = Utils_1.Utils.binarySearchClosestInd(this.segments, from - displayedRange, 'startXVal');\r\n\t        this.firstDisplayedSegment = this.segments[this.firstDisplayedSegmentInd];\r\n\t        this.lastDisplayedSegmentInd = Utils_1.Utils.binarySearchClosestInd(this.segments, to + displayedRange, 'endXVal');\r\n\t        this.lastDisplayedSegment = this.segments[this.lastDisplayedSegmentInd];\r\n\t        if (segmentsAreRebuilded)\r\n\t            return;\r\n\t        var displayedRangeChanged = (firstDisplayedSegment.id !== this.firstDisplayedSegment.id ||\r\n\t            lastDisplayedSegment.id !== this.lastDisplayedSegment.id);\r\n\t        if (displayedRangeChanged)\r\n\t            this.ee.emit(EVENTS.DISLPAYED_RANGE_CHANGED);\r\n\t    };\r\n\t    // getSegments(fromX?: number, toX?: number): TrendSegment[] {\r\n\t    // \tvar segments = this.segments;\r\n\t    // \tif (fromX == void 0 && toX == void 0) return segments;\r\n\t    // \tfromX = fromX !== void 0 ? fromX : segments[0].startXVal;\r\n\t    // \ttoX = toX !== void 0 ? toX : segments[this.segmentsLength].endXVal;\r\n\t    // \tvar startSegmentInd = Utils.closestBinarySearch(segments, fromX, 'xVal');\r\n\t    // \tvar endSegmentInd = Utils.closestBinarySearch(segments, toX, 'xVal');\r\n\t    // \treturn segments.slice(startSegmentInd, endSegmentInd);\r\n\t    // }\r\n\t    /**\r\n\t     * returns array of segments for values array\r\n\t     * values must be sorted!\r\n\t     */\r\n\t    TrendSegmentsManager.prototype.getSegmentsForXValues = function (values) {\r\n\t        var valueInd = 0;\r\n\t        var value = values[valueInd];\r\n\t        var lastValueInd = values.length - 1;\r\n\t        var results = [];\r\n\t        var segment = this.getStartSegment();\r\n\t        if (!segment.hasValue)\r\n\t            return [];\r\n\t        while (segment) {\r\n\t            while (value < segment.startXVal) {\r\n\t                results.push(void 0);\r\n\t                value = values[++valueInd];\r\n\t            }\r\n\t            while (value > segment.endXVal) {\r\n\t                segment = segment.getNext();\r\n\t                if (!segment)\r\n\t                    break;\r\n\t            }\r\n\t            var valueInPoint = (segment.startXVal == value || segment.endXVal == value ||\r\n\t                (segment.startXVal < value && segment.endXVal > value));\r\n\t            if (valueInPoint) {\r\n\t                results.push(segment);\r\n\t                value = values[++valueInd];\r\n\t            }\r\n\t            if (valueInd > lastValueInd)\r\n\t                break;\r\n\t        }\r\n\t        return results;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onAnimationFrame = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.ANIMATION_FRAME, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onRebuild = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.REBUILD, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onDisplayedRangeChanged = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.DISLPAYED_RANGE_CHANGED, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.allocateNextSegment = function () {\r\n\t        var id = this.nextEmptyId++;\r\n\t        var segment = new TrendSegment(this, id);\r\n\t        var prevSegment = this.segmentsById[this.endSegmentId];\r\n\t        if (prevSegment && prevSegment.hasValue) {\r\n\t            prevSegment.nextId = id;\r\n\t            segment.prevId = prevSegment.id;\r\n\t        }\r\n\t        this.endSegmentId = id;\r\n\t        this.segmentsLength++;\r\n\t        this.segmentsById[id] = segment;\r\n\t        this.segments.push(segment);\r\n\t        return segment;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.allocatePrevSegment = function () {\r\n\t        var id = this.nextEmptyId++;\r\n\t        var segment = new TrendSegment(this, id);\r\n\t        var nextSegment = this.segmentsById[this.startSegmentId];\r\n\t        if (nextSegment && nextSegment.hasValue) {\r\n\t            nextSegment.prevId = id;\r\n\t            segment.nextId = nextSegment.id;\r\n\t        }\r\n\t        this.startSegmentId = id;\r\n\t        this.segmentsLength++;\r\n\t        this.segmentsById[id] = segment;\r\n\t        this.segments.unshift(segment);\r\n\t        return segment;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.appendData = function (newData, needRebuildSegments) {\r\n\t        // WARNING: bottleneck method!\r\n\t        if (needRebuildSegments === void 0) { needRebuildSegments = false; }\r\n\t        // var t1 = performance.now();\r\n\t        var trendData = this.trend.getData();\r\n\t        if (needRebuildSegments) {\r\n\t            newData = trendData;\r\n\t            this.animatedSegmentsForAppend = [];\r\n\t        }\r\n\t        var startItemInd = trendData.length - newData.length;\r\n\t        var segment = this.getEndSegment() || this.allocateNextSegment();\r\n\t        var initialSegment = segment.hasValue ? segment : null;\r\n\t        var initialAnimationState = segment.createAnimationState();\r\n\t        var itemInd = 0;\r\n\t        while (itemInd < newData.length) {\r\n\t            var item = newData[itemInd];\r\n\t            var itemIsInserted = segment.appendItem(item);\r\n\t            var isLastItem = itemInd == newData.length - 1;\r\n\t            if (itemIsInserted) {\r\n\t                if (!isLastItem)\r\n\t                    itemInd++;\r\n\t            }\r\n\t            else {\r\n\t                if (!segment.isCompleted)\r\n\t                    segment.complete();\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted) {\r\n\t                segment.recalculateItems();\r\n\t            }\r\n\t            var segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\r\n\t            if (segmentIsReadyForAnimate) {\r\n\t                var id = segment.id;\r\n\t                if (!initialSegment)\r\n\t                    initialSegment = segment;\r\n\t                if (!initialAnimationState)\r\n\t                    initialAnimationState = initialSegment.createAnimationState();\r\n\t                segment.initialAnimationState = Utils_1.Utils.deepMerge({}, initialAnimationState);\r\n\t                if (this.animatedSegmentsForAppend.length > 0) {\r\n\t                    segment.initialAnimationState.startXVal = initialAnimationState.endXVal;\r\n\t                    segment.initialAnimationState.startYVal = initialAnimationState.endYVal;\r\n\t                }\r\n\t                segment.targetAnimationState = segment.createAnimationState();\r\n\t                this.animatedSegmentsForAppend.push(id);\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted)\r\n\t                break;\r\n\t            if (!segment.isCompleted)\r\n\t                continue;\r\n\t            segment = this.allocateNextSegment();\r\n\t            var prevItem = trendData[startItemInd + itemInd - 1];\r\n\t            segment.appendItem(prevItem);\r\n\t        }\r\n\t        var animationsOptions = this.chartState.data.animations;\r\n\t        var time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\r\n\t        // var t2 = performance.now();\r\n\t        // console.log(t2 - t1);\r\n\t        // do not create animation if segments was rebuilded\r\n\t        if (needRebuildSegments) {\r\n\t            for (var _i = 0, _a = this.animatedSegmentsForAppend; _i < _a.length; _i++) {\r\n\t                var segmentId = _a[_i];\r\n\t                var segment_1 = this.segmentsById[segmentId];\r\n\t                segment_1.currentAnimationState = segment_1.createAnimationState();\r\n\t            }\r\n\t            this.animatedSegmentsForAppend = [];\r\n\t            return;\r\n\t        }\r\n\t        if (this.animatedSegmentsForAppend.length > MAX_ANIMATED_SEGMENTS)\r\n\t            time = 0;\r\n\t        this.animate(time);\r\n\t    };\r\n\t    // TODO: refactor duplicated code from appendData\r\n\t    TrendSegmentsManager.prototype.prependData = function (newData) {\r\n\t        var trendData = this.trend.getData();\r\n\t        var segment = this.getStartSegment() || this.segmentsById[0];\r\n\t        var initialSegment = segment.hasValue ? segment : null;\r\n\t        var itemInd = newData.length - 1;\r\n\t        var initialAnimationState = segment.createAnimationState();\r\n\t        while (itemInd >= 0) {\r\n\t            var item = newData[itemInd];\r\n\t            var itemIsInserted = segment.prependItem(item);\r\n\t            var isLastItem = itemInd == 0;\r\n\t            if (itemIsInserted) {\r\n\t                if (!isLastItem)\r\n\t                    itemInd--;\r\n\t            }\r\n\t            else {\r\n\t                if (!segment.isCompleted)\r\n\t                    segment.complete();\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted) {\r\n\t                segment.recalculateItems();\r\n\t            }\r\n\t            var segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\r\n\t            if (segmentIsReadyForAnimate) {\r\n\t                var id = segment.id;\r\n\t                if (!initialSegment)\r\n\t                    initialSegment = segment;\r\n\t                if (!initialAnimationState)\r\n\t                    initialAnimationState = initialSegment.createAnimationState();\r\n\t                segment.initialAnimationState = Utils_1.Utils.deepMerge({}, initialAnimationState);\r\n\t                if (this.animatedSegmentsForPrepend.length > 0) {\r\n\t                    segment.initialAnimationState.endXVal = initialAnimationState.startXVal;\r\n\t                    segment.initialAnimationState.endYVal = initialAnimationState.startYVal;\r\n\t                }\r\n\t                segment.targetAnimationState = segment.createAnimationState();\r\n\t                this.animatedSegmentsForPrepend.push(id);\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted)\r\n\t                break;\r\n\t            if (!segment.isCompleted)\r\n\t                continue;\r\n\t            segment = this.allocatePrevSegment();\r\n\t            var nextItem = trendData[itemInd + 1];\r\n\t            segment.prependItem(nextItem);\r\n\t        }\r\n\t        var animationsOptions = this.chartState.data.animations;\r\n\t        var time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\r\n\t        if (this.animatedSegmentsForPrepend.length > MAX_ANIMATED_SEGMENTS)\r\n\t            time = 0;\r\n\t        this.animate(time, true);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.animate = function (time, isPrepend) {\r\n\t        var _this = this;\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\r\n\t        var animation = isPrepend ? this.prependAnimation : this.appendAnimation;\r\n\t        if ((animation && animation.isActive()) || time == 0) {\r\n\t            if (animation)\r\n\t                animation.kill();\r\n\t            this.onAnimationFrameHandler(1, isPrepend);\r\n\t            animatedSegmentsIds.length = 0;\r\n\t            return;\r\n\t        }\r\n\t        var animationsOptions = this.chartState.data.animations;\r\n\t        var ease = animationsOptions.trendChangeEase;\r\n\t        var objectToAnimate = { animationValue: 0 };\r\n\t        animation = TweenLite.to(objectToAnimate, time, { animationValue: 1, ease: ease });\r\n\t        animation.eventCallback('onUpdate', function () { return _this.onAnimationFrameHandler(objectToAnimate.animationValue, isPrepend); });\r\n\t        animation.eventCallback('onComplete', function () {\r\n\t            animatedSegmentsIds.length = 0;\r\n\t            _this.appendAnimation = null;\r\n\t        });\r\n\t        if (isPrepend) {\r\n\t            this.prependAnimation = animation;\r\n\t        }\r\n\t        else {\r\n\t            this.appendAnimation = animation;\r\n\t        }\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onAnimationFrameHandler = function (coefficient, isPrepend) {\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\r\n\t        for (var _i = 0, animatedSegmentsIds_1 = animatedSegmentsIds; _i < animatedSegmentsIds_1.length; _i++) {\r\n\t            var segmentId = animatedSegmentsIds_1[_i];\r\n\t            var segment = this.segmentsById[segmentId];\r\n\t            for (var key in segment.targetAnimationState) {\r\n\t                var targetValue = segment.targetAnimationState[key];\r\n\t                var initialValue = segment.initialAnimationState[key];\r\n\t                var currentValue = initialValue + (targetValue - initialValue) * coefficient;\r\n\t                segment.currentAnimationState[key] = currentValue;\r\n\t            }\r\n\t        }\r\n\t        this.animatedSegmentsIds = this.animatedSegmentsForAppend.concat(this.animatedSegmentsForPrepend);\r\n\t        this.ee.emit(EVENTS.ANIMATION_FRAME, this);\r\n\t    };\r\n\t    return TrendSegmentsManager;\r\n\t}());\r\n\texports.TrendSegmentsManager = TrendSegmentsManager;\r\n\tvar TrendSegment = (function () {\r\n\t    function TrendSegment(trendPoints, id) {\r\n\t        this.isCompleted = false;\r\n\t        this.items = [];\r\n\t        this.initialAnimationState = {};\r\n\t        this.targetAnimationState = {};\r\n\t        this.currentAnimationState = {};\r\n\t        this.trendSegments = trendPoints;\r\n\t        this.id = id;\r\n\t        this.maxLength = trendPoints.maxSegmentLength;\r\n\t    }\r\n\t    TrendSegment.prototype.createAnimationState = function () {\r\n\t        var _a = this, xVal = _a.xVal, yVal = _a.yVal, startXVal = _a.startXVal, startYVal = _a.startYVal, endXVal = _a.endXVal, endYVal = _a.endYVal, maxYVal = _a.maxYVal, minYVal = _a.minYVal, maxLength = _a.maxLength;\r\n\t        return {\r\n\t            xVal: xVal,\r\n\t            yVal: yVal,\r\n\t            startXVal: startXVal,\r\n\t            startYVal: startYVal,\r\n\t            endXVal: endXVal,\r\n\t            endYVal: endYVal,\r\n\t            maxYVal: maxYVal,\r\n\t            minYVal: minYVal,\r\n\t            maxLength: maxLength\r\n\t        };\r\n\t    };\r\n\t    ;\r\n\t    TrendSegment.prototype.appendItem = function (item) {\r\n\t        if (this.isCompleted)\r\n\t            return false;\r\n\t        var items = this.items;\r\n\t        if (items.length < 2) {\r\n\t            this.items.push(item);\r\n\t            this.hasValue = true;\r\n\t            return true;\r\n\t        }\r\n\t        var startXVal = items[0].xVal;\r\n\t        if (item.xVal - startXVal > this.maxLength)\r\n\t            return false;\r\n\t        items.push(item);\r\n\t        return true;\r\n\t    };\r\n\t    TrendSegment.prototype.prependItem = function (item) {\r\n\t        if (this.isCompleted)\r\n\t            return false;\r\n\t        var items = this.items;\r\n\t        if (items.length < 2) {\r\n\t            this.items.unshift(item);\r\n\t            this.hasValue = true;\r\n\t            return true;\r\n\t        }\r\n\t        var endXVal = items[items.length - 1].xVal;\r\n\t        if (endXVal - item.xVal > this.maxLength)\r\n\t            return false;\r\n\t        items.unshift(item);\r\n\t        return true;\r\n\t    };\r\n\t    TrendSegment.prototype.complete = function () {\r\n\t        this.isCompleted = true;\r\n\t        this.recalculateItems();\r\n\t        this.items = []; // free memory for completed ranges\r\n\t    };\r\n\t    TrendSegment.prototype.recalculateItems = function () {\r\n\t        var items = this.items;\r\n\t        var itemsLength = items.length;\r\n\t        if (itemsLength === 0)\r\n\t            Utils_1.Utils.error('Unable to create TrendSegment without TrendItems');\r\n\t        var endItem = items[itemsLength - 1];\r\n\t        var endXVal = endItem.xVal, endYVal = endItem.yVal;\r\n\t        var startXVal, startYVal;\r\n\t        var startItem = items[0];\r\n\t        startXVal = startItem.xVal;\r\n\t        startYVal = startItem.yVal;\r\n\t        var minX = Math.min(startXVal, endXVal);\r\n\t        var maxX = Math.max(startXVal, endXVal);\r\n\t        var middleXVal = minX + (maxX - minX) / 2;\r\n\t        var minY = Math.min(startYVal, endYVal);\r\n\t        var maxY = Math.max(startYVal, endYVal);\r\n\t        var middleYVal = minY + (maxY - minY) / 2;\r\n\t        var yVals = items.map(function (item) { return item.yVal; });\r\n\t        this.startXVal = startXVal;\r\n\t        this.startYVal = startYVal;\r\n\t        this.endXVal = endXVal;\r\n\t        this.endYVal = endYVal;\r\n\t        this.xVal = middleXVal;\r\n\t        this.yVal = middleYVal;\r\n\t        this.maxYVal = Math.max.apply(Math, yVals);\r\n\t        this.minYVal = Math.min.apply(Math, yVals);\r\n\t        if (!this.currentAnimationState)\r\n\t            this.currentAnimationState = this.createAnimationState();\r\n\t    };\r\n\t    TrendSegment.prototype.getNext = function () {\r\n\t        var nextPoint = this.trendSegments.segmentsById[this.nextId];\r\n\t        return nextPoint && nextPoint.hasValue ? nextPoint : null;\r\n\t    };\r\n\t    TrendSegment.prototype.getPrev = function () {\r\n\t        var prevPoint = this.trendSegments.segmentsById[this.prevId];\r\n\t        return prevPoint && prevPoint.hasValue ? prevPoint : null;\r\n\t    };\r\n\t    TrendSegment.prototype.getFrameVal = function () {\r\n\t        var _a = this.createAnimationState(), xVal = _a.xVal, yVal = _a.yVal;\r\n\t        return new Vector3(xVal, yVal, 0);\r\n\t    };\r\n\t    TrendSegment.prototype.getFramePoint = function () {\r\n\t        var frameVal = this.getFrameVal();\r\n\t        return this.trendSegments.chartState.screen.getPointOnChart(frameVal.x, frameVal.y);\r\n\t    };\r\n\t    return TrendSegment;\r\n\t}());\r\n\texports.TrendSegment = TrendSegment;\r\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Trend_1 = __webpack_require__(14);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar EVENTS = {\r\n\t    SEGMENTS_REBUILDED: 'segmentsRebuilded'\r\n\t};\r\n\t/**\r\n\t * Trends manager\r\n\t */\r\n\tvar TrendsManager = (function () {\r\n\t    function TrendsManager(state, initialState) {\r\n\t        this.trends = {};\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.chartState = state;\r\n\t        var trendsCalculatedOptions = {};\r\n\t        for (var trendName in initialState.trends) {\r\n\t            var trend = this.createTrend(state, trendName, initialState);\r\n\t            trendsCalculatedOptions[trendName] = trend.getCalculatedOptions();\r\n\t        }\r\n\t        this.calculatedOptions = trendsCalculatedOptions;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendsManager.prototype.getTrend = function (trendName) {\r\n\t        return this.trends[trendName];\r\n\t    };\r\n\t    TrendsManager.prototype.getEnabledTrends = function () {\r\n\t        var enabledTrends = [];\r\n\t        var allTrends = this.trends;\r\n\t        for (var trendName in allTrends) {\r\n\t            var trend = allTrends[trendName];\r\n\t            trend.getOptions().enabled && enabledTrends.push(trend);\r\n\t        }\r\n\t        return enabledTrends;\r\n\t    };\r\n\t    TrendsManager.prototype.getStartXVal = function () {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        return trends[0].getData()[0].xVal;\r\n\t    };\r\n\t    TrendsManager.prototype.getEndXVal = function () {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        var firstTrendData = trends[0].getData();\r\n\t        return firstTrendData[firstTrendData.length - 1].xVal;\r\n\t    };\r\n\t    TrendsManager.prototype.getExtremumYVal = function (extremumIsMax, fromX, toX) {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        var compareFn;\r\n\t        var result;\r\n\t        if (extremumIsMax) {\r\n\t            result = -Infinity;\r\n\t            compareFn = Math.max;\r\n\t        }\r\n\t        else {\r\n\t            result = Infinity;\r\n\t            compareFn = Math.min;\r\n\t        }\r\n\t        for (var _i = 0, trends_1 = trends; _i < trends_1.length; _i++) {\r\n\t            var trend = trends_1[_i];\r\n\t            var trendData = trend.getData(fromX, toX);\r\n\t            var trendYValues = trendData.map(function (dataItem) { return dataItem.yVal; });\r\n\t            result = compareFn.apply(void 0, [result].concat(trendYValues));\r\n\t        }\r\n\t        if (result == Infinity || result == -Infinity)\r\n\t            result = NaN;\r\n\t        return result;\r\n\t    };\r\n\t    TrendsManager.prototype.getMaxYVal = function (fromX, toX) { return this.getExtremumYVal(true, fromX, toX); };\r\n\t    TrendsManager.prototype.getMinYVal = function (fromX, toX) { return this.getExtremumYVal(false, fromX, toX); };\r\n\t    TrendsManager.prototype.onSegmentsRebuilded = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.SEGMENTS_REBUILDED, cb);\r\n\t    };\r\n\t    TrendsManager.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chartState.onInitialStateApplied(function () { return _this.onInitialStateAppliedHandler(); });\r\n\t    };\r\n\t    TrendsManager.prototype.onInitialStateAppliedHandler = function () {\r\n\t        var _this = this;\r\n\t        var _loop_1 = function(trendName) {\r\n\t            this_1.trends[trendName].segmentsManager.onRebuild(function () { return _this.ee.emit(EVENTS.SEGMENTS_REBUILDED, trendName); });\r\n\t        };\r\n\t        var this_1 = this;\r\n\t        for (var trendName in this.trends) {\r\n\t            _loop_1(trendName);\r\n\t        }\r\n\t    };\r\n\t    TrendsManager.prototype.createTrend = function (state, trendName, initialState) {\r\n\t        var trend = new Trend_1.Trend(state, trendName, initialState);\r\n\t        this.trends[trendName] = trend;\r\n\t        return trend;\r\n\t    };\r\n\t    return TrendsManager;\r\n\t}());\r\n\texports.TrendsManager = TrendsManager;\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\t/**\r\n\t * manage camera, and contains methods for transforming pixels to values\r\n\t */\r\n\tvar Screen = (function () {\r\n\t    function Screen(chartState) {\r\n\t        this.options = { scrollXVal: 0, scrollX: 0, scrollYVal: 0, scrollY: 0, zoomX: 1, zoomY: 1 };\r\n\t        this.currentScrollX = { x: 0 };\r\n\t        this.currentScrollY = { y: 0 };\r\n\t        this.currentZoomX = { val: 1 };\r\n\t        this.currentZoomY = { val: 1 };\r\n\t        this.chartState = chartState;\r\n\t        var _a = chartState.data, w = _a.width, h = _a.height;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.transform({\r\n\t            scrollY: this.valueToPxByYAxis(this.chartState.data.yAxis.range.scroll),\r\n\t            zoomY: 1\r\n\t        });\r\n\t        this.bindEvents();\r\n\t        //camera.position.z = 1500;\r\n\t    }\r\n\t    Screen.prototype.getCameraSettings = function () {\r\n\t        var _a = this.chartState.data, w = _a.width, h = _a.height;\r\n\t        // settings for pixel-perfect camera\r\n\t        var FOV = 75;\r\n\t        var vFOV = FOV * (Math.PI / 180);\r\n\t        return {\r\n\t            FOV: FOV,\r\n\t            aspect: w / h,\r\n\t            near: 0.1,\r\n\t            far: 5000,\r\n\t            z: h / (2 * Math.tan(vFOV / 2)),\r\n\t            // move 0,0 to left-bottom corner\r\n\t            x: w / 2,\r\n\t            y: h / 2\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.onZoomFrame = function (cb) {\r\n\t        var _this = this;\r\n\t        var eventName = 'zoomFrame';\r\n\t        this.ee.on(eventName, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(eventName, cb);\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.onScrollFrame = function (cb) {\r\n\t        var _this = this;\r\n\t        var eventName = 'scrollFrame';\r\n\t        this.ee.on(eventName, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(eventName, cb);\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.onTransformationFrame = function (cb) {\r\n\t        var _this = this;\r\n\t        var eventName = 'transformationFrame';\r\n\t        this.ee.on(eventName, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(eventName, cb);\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.cameraIsMoving = function () {\r\n\t        return !!(this.scrollXAnimation && this.scrollXAnimation.isActive() ||\r\n\t            this.zoomXAnimation && this.zoomXAnimation.isActive());\r\n\t    };\r\n\t    Screen.prototype.transform = function (options, silent) {\r\n\t        if (silent === void 0) { silent = false; }\r\n\t        var scrollX = options.scrollX, scrollY = options.scrollY, zoomX = options.zoomX, zoomY = options.zoomY;\r\n\t        if (scrollX != void 0)\r\n\t            this.options.scrollX = scrollX;\r\n\t        if (scrollY != void 0)\r\n\t            this.options.scrollY = scrollY;\r\n\t        if (zoomX != void 0)\r\n\t            this.options.zoomX = zoomX;\r\n\t        if (zoomY != void 0)\r\n\t            this.options.zoomY = zoomY;\r\n\t        if (scrollX != void 0 || zoomX) {\r\n\t            options.scrollXVal = this.pxToValueByXAxis(scrollX != void 0 ? scrollX : this.options.scrollX);\r\n\t            this.options.scrollXVal = options.scrollXVal;\r\n\t        }\r\n\t        if (scrollY != void 0 || zoomY) {\r\n\t            options.scrollYVal = this.pxToValueByYAxis(scrollY != void 0 ? scrollY : this.options.scrollY);\r\n\t            this.options.scrollYVal = options.scrollYVal;\r\n\t        }\r\n\t        if (silent)\r\n\t            return;\r\n\t        this.ee.emit('transformationFrame', options);\r\n\t        if (options.scrollXVal != void 0 || options.scrollYVal != void 0) {\r\n\t            this.ee.emit('scrollFrame', options);\r\n\t        }\r\n\t        if (options.zoomX != void 0 || options.zoomY != void 0) {\r\n\t            this.ee.emit('zoomFrame', options);\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        // handle scroll and zoom\r\n\t        state.onChange(function (changedProps) {\r\n\t            if (changedProps.xAxis && changedProps.xAxis.range) {\r\n\t                if (changedProps.xAxis.range.scroll != void 0)\r\n\t                    _this.onScrollXHandler(changedProps);\r\n\t                if (changedProps.xAxis.range.zoom)\r\n\t                    _this.onZoomXHandler();\r\n\t            }\r\n\t            if (changedProps.yAxis && changedProps.yAxis.range) {\r\n\t                if (changedProps.yAxis.range.scroll != void 0)\r\n\t                    _this.onScrollYHandler();\r\n\t                if (changedProps.yAxis.range.zoom)\r\n\t                    _this.onZoomYHandler();\r\n\t            }\r\n\t        });\r\n\t        state.onDestroy(function () { return _this.onDestroyHandler(); });\r\n\t    };\r\n\t    Screen.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t        this.scrollXAnimation && this.scrollXAnimation.kill();\r\n\t        this.scrollYAnimation && this.scrollYAnimation.kill();\r\n\t        this.zoomXAnimation && this.zoomXAnimation.kill();\r\n\t        this.zoomYAnimation && this.zoomYAnimation.kill();\r\n\t    };\r\n\t    Screen.prototype.onScrollXHandler = function (changedProps) {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var isDragMode = state.data.cursor.dragMode;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled && !isDragMode;\r\n\t        var zoomXChanged = changedProps.xAxis.range.zoom;\r\n\t        var isAutoscroll = state.data.autoScroll && !isDragMode && !zoomXChanged;\r\n\t        var time = isAutoscroll ? animations.autoScrollSpeed : animations.zoomSpeed;\r\n\t        var ease = isAutoscroll ? animations.autoScrollEase : animations.zoomEase;\r\n\t        if (this.scrollXAnimation)\r\n\t            this.scrollXAnimation.pause();\r\n\t        var range = state.data.xAxis.range;\r\n\t        var targetX = range.scroll * range.scaleFactor * range.zoom;\r\n\t        this.currentScrollX.x = this.options.scrollX;\r\n\t        var cb = function () {\r\n\t            _this.transform({ scrollX: _this.currentScrollX.x });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.scrollXAnimation = TweenLite.to(this.currentScrollX, time, {\r\n\t                x: targetX, ease: ease\r\n\t            });\r\n\t            this.scrollXAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentScrollX.x = targetX;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.onScrollYHandler = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled;\r\n\t        var time = animations.zoomSpeed;\r\n\t        if (this.scrollYAnimation)\r\n\t            this.scrollYAnimation.pause();\r\n\t        var range = state.data.yAxis.range;\r\n\t        var targetY = range.scroll * range.scaleFactor * range.zoom;\r\n\t        this.currentScrollY.y = this.options.scrollY;\r\n\t        var cb = function () {\r\n\t            _this.transform({ scrollY: _this.currentScrollY.y });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.scrollYAnimation = TweenLite.to(this.currentScrollY, time, {\r\n\t                y: targetY, ease: animations.zoomEase\r\n\t            });\r\n\t            this.scrollYAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentScrollY.y = targetY;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.onZoomXHandler = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled;\r\n\t        var time = animations.zoomSpeed;\r\n\t        var targetZoom = state.data.xAxis.range.zoom;\r\n\t        if (this.zoomXAnimation)\r\n\t            this.zoomXAnimation.pause();\r\n\t        var cb = function () {\r\n\t            _this.transform({ zoomX: _this.currentZoomX.val });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.zoomXAnimation = TweenLite.to(this.currentZoomX, time, {\r\n\t                val: targetZoom, ease: animations.zoomEase\r\n\t            });\r\n\t            this.zoomXAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentZoomX.val = targetZoom;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.onZoomYHandler = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled;\r\n\t        var time = animations.zoomSpeed;\r\n\t        var targetZoom = state.data.yAxis.range.zoom;\r\n\t        if (this.zoomYAnimation)\r\n\t            this.zoomYAnimation.pause();\r\n\t        var cb = function () {\r\n\t            _this.transform({ zoomY: _this.currentZoomY.val });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.zoomYAnimation = TweenLite.to(this.currentZoomY, time, {\r\n\t                val: targetZoom, ease: animations.zoomEase\r\n\t            });\r\n\t            this.zoomYAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentZoomY.val = targetZoom;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal to scrollXVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnXAxis = function (xVal) {\r\n\t        var _a = this.chartState.data.xAxis.range, scaleFactor = _a.scaleFactor, zeroVal = _a.zeroVal;\r\n\t        var zoom = this.options.zoomX;\r\n\t        return (xVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from yAxis.range.zeroVal to scrollYVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnYAxis = function (yVal) {\r\n\t        var _a = this.chartState.data.yAxis.range, scaleFactor = _a.scaleFactor, zeroVal = _a.zeroVal;\r\n\t        var zoom = this.options.zoomY;\r\n\t        return (yVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal and from yAxis.range.zeroVal to scrollXVal and scrollYVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnChart = function (xVal, yVal) {\r\n\t        return new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\r\n\t    };\r\n\t    /**\r\n\t     * returns value by offset in pixels from xAxis.range.zeroVal\r\n\t     */\r\n\t    Screen.prototype.getValueOnXAxis = function (x) {\r\n\t        return this.chartState.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from xAxis.range\r\n\t     */\r\n\t    Screen.prototype.valueToPxByXAxis = function (xVal) {\r\n\t        return xVal * this.chartState.data.xAxis.range.scaleFactor * this.options.zoomX;\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from yAxis.range\r\n\t     */\r\n\t    Screen.prototype.valueToPxByYAxis = function (yVal) {\r\n\t        return yVal * this.chartState.data.yAxis.range.scaleFactor * this.options.zoomY;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from xAxis.range\r\n\t     */\r\n\t    Screen.prototype.pxToValueByXAxis = function (xVal) {\r\n\t        return xVal / this.chartState.data.xAxis.range.scaleFactor / this.options.zoomX;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from yAxis.range\r\n\t     */\r\n\t    Screen.prototype.pxToValueByYAxis = function (yVal) {\r\n\t        return yVal / this.chartState.data.yAxis.range.scaleFactor / this.options.zoomY;\r\n\t    };\r\n\t    /**\r\n\t     *  returns scrollX value by screen scrollX coordinate\r\n\t     */\r\n\t    Screen.prototype.getValueByScreenX = function (x) {\r\n\t        return this.chartState.data.xAxis.range.zeroVal + this.options.scrollXVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  returns scrollY value by screen scrollY coordinate\r\n\t     */\r\n\t    Screen.prototype.getValueByScreenY = function (y) {\r\n\t        return this.chartState.data.yAxis.range.zeroVal + this.options.scrollYVal + this.pxToValueByYAxis(y);\r\n\t    };\r\n\t    //\r\n\t    /**\r\n\t     *  returns screen scrollX value by screen scrollY coordinate\r\n\t     */\r\n\t    Screen.prototype.getScreenXByValue = function (xVal) {\r\n\t        var _a = this.chartState.data.xAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByXAxis(xVal - zeroVal - scroll);\r\n\t    };\r\n\t    // /**\r\n\t    //  *  returns screen scrollY value by screen scrollY coordinate\r\n\t    //  */\r\n\t    // getScreenYByValue(scrollYVal: number): number {\r\n\t    // \tvar {scroll, zeroVal} = this.data.yAxis.range;\r\n\t    // \treturn this.valueToPxByYAxis(scrollYVal - zeroVal - scroll)\r\n\t    // }\r\n\t    //\r\n\t    //\r\n\t    /**\r\n\t     * returns screen scrollX coordinate by offset in pixels from xAxis.range.zeroVal value\r\n\t     */\r\n\t    Screen.prototype.getScreenXByPoint = function (xVal) {\r\n\t        return this.getScreenXByValue(this.getValueOnXAxis(xVal));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from xAxis.range.zeroVal value by screen scrollX coordinate\r\n\t     */\r\n\t    Screen.prototype.getPointByScreenX = function (screenX) {\r\n\t        return this.getPointOnXAxis(this.getValueByScreenX(screenX));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from yAxis.range.zeroVal value by screen scrollY coordinate\r\n\t     */\r\n\t    Screen.prototype.getPointByScreenY = function (screenY) {\r\n\t        return this.getPointOnYAxis(this.getValueByScreenY(screenY));\r\n\t    };\r\n\t    Screen.prototype.getTop = function () {\r\n\t        return this.getPointByScreenY(this.chartState.data.height);\r\n\t    };\r\n\t    Screen.prototype.getBottom = function () {\r\n\t        return this.getPointByScreenY(0);\r\n\t    };\r\n\t    Screen.prototype.getLeft = function () {\r\n\t        return this.getPointByScreenX(0);\r\n\t    };\r\n\t    Screen.prototype.getScreenRightVal = function () {\r\n\t        return this.getValueByScreenX(this.chartState.data.width);\r\n\t    };\r\n\t    Screen.prototype.getTopVal = function () {\r\n\t        return this.getValueByScreenY(this.chartState.data.height);\r\n\t    };\r\n\t    Screen.prototype.getBottomVal = function () {\r\n\t        return this.getValueByScreenY(0);\r\n\t    };\r\n\t    Screen.prototype.getCenterYVal = function () {\r\n\t        return this.getValueByScreenY(this.chartState.data.height / 2);\r\n\t    };\r\n\t    return Screen;\r\n\t}());\r\n\texports.Screen = Screen;\r\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar interfaces_1 = __webpack_require__(19);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar AXIS_MARK_DEFAULT_OPTIONS = {\r\n\t    type: 'simple',\r\n\t    lineWidth: 1,\r\n\t    value: 0,\r\n\t    showValue: false,\r\n\t    stickToEdges: false,\r\n\t    lineColor: '#FFFFFF',\r\n\t    title: ''\r\n\t};\r\n\tvar AxisMarks = (function () {\r\n\t    function AxisMarks(chartState, axisType) {\r\n\t        this.items = {};\r\n\t        this.chartState = chartState;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.axisType = axisType;\r\n\t        var marks = this.items;\r\n\t        var axisMarksOptions = axisType == interfaces_1.AXIS_TYPE.X ? chartState.data.xAxis.marks : chartState.data.yAxis.marks;\r\n\t        for (var _i = 0, axisMarksOptions_1 = axisMarksOptions; _i < axisMarksOptions_1.length; _i++) {\r\n\t            var options = axisMarksOptions_1[_i];\r\n\t            var axisMark = void 0;\r\n\t            options = Utils_1.Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\r\n\t            // set mark name\r\n\t            if (!options.name)\r\n\t                options.name = Utils_1.Utils.getUid().toString();\r\n\t            if (marks[options.name])\r\n\t                Utils_1.Utils.error('duplicated mark name ' + options.name);\r\n\t            // create mark instance based on type option\r\n\t            if (options.type == 'timeleft') {\r\n\t                axisMark = new AxisTimeleftMark(chartState, axisType, options);\r\n\t            }\r\n\t            else {\r\n\t                axisMark = new AxisMark(chartState, axisType, options);\r\n\t            }\r\n\t            marks[options.name] = axisMark;\r\n\t        }\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    AxisMarks.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chartState.onTrendChange(function (trendName, changedOptions, newData) {\r\n\t            _this.onTrendChange(trendName, newData);\r\n\t        });\r\n\t        this.chartState.onDestroy(function () { return _this.ee.removeAllListeners(); });\r\n\t    };\r\n\t    AxisMarks.prototype.onTrendChange = function (trendName, newData) {\r\n\t        if (!newData)\r\n\t            return;\r\n\t        var startVal = newData[0].xVal;\r\n\t        var endVal = newData[newData.length - 1].xVal;\r\n\t        var marks = this.items;\r\n\t        for (var markName in marks) {\r\n\t            var mark = marks[markName];\r\n\t            var markVal = mark.options.value;\r\n\t            var markWasCrossed = (startVal == markVal || endVal == markVal || (startVal < markVal && endVal > markVal));\r\n\t            if (markWasCrossed)\r\n\t                this.ee.emit('markCrossed', trendName, newData);\r\n\t        }\r\n\t    };\r\n\t    AxisMarks.prototype.getItems = function () {\r\n\t        return this.items;\r\n\t    };\r\n\t    AxisMarks.prototype.getItem = function (markName) {\r\n\t        return this.items[markName];\r\n\t    };\r\n\t    return AxisMarks;\r\n\t}());\r\n\texports.AxisMarks = AxisMarks;\r\n\tvar AxisMark = (function () {\r\n\t    function AxisMark(chartState, axisType, options) {\r\n\t        this.renderOnTrendsChange = false;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.options = options;\r\n\t        this.axisType = axisType;\r\n\t        this.chartState = chartState;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    AxisMark.prototype.bindEvents = function () { };\r\n\t    AxisMark.prototype.setOptions = function (newOptions) {\r\n\t        var value = this.options.value;\r\n\t        this.options = Utils_1.Utils.deepMerge(this.options, newOptions);\r\n\t        if (this.options.value !== value)\r\n\t            this.ee.emit('valueChange');\r\n\t        this.ee.emit('onDisplayedValueChange');\r\n\t    };\r\n\t    AxisMark.prototype.getDisplayedVal = function () {\r\n\t        var _a = this.options, value = _a.value, displayedValue = _a.displayedValue;\r\n\t        return String(displayedValue !== void 0 ? displayedValue : value);\r\n\t    };\r\n\t    AxisMark.prototype.onMarkCrossed = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on('markCrossed', cb);\r\n\t        return function () {\r\n\t            _this.ee.off('markCrossed', cb);\r\n\t        };\r\n\t    };\r\n\t    AxisMark.prototype.onValueChange = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on('valueChange', cb);\r\n\t        return function () {\r\n\t            _this.ee.off('valueChange', cb);\r\n\t        };\r\n\t    };\r\n\t    AxisMark.prototype.onDisplayedValueChange = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on('onDisplayedValueChange', cb);\r\n\t        return function () {\r\n\t            _this.ee.off('onDisplayedValueChange', cb);\r\n\t        };\r\n\t    };\r\n\t    AxisMark.typeName = 'simple';\r\n\t    return AxisMark;\r\n\t}());\r\n\texports.AxisMark = AxisMark;\r\n\tvar AxisTimeleftMark = (function (_super) {\r\n\t    __extends(AxisTimeleftMark, _super);\r\n\t    function AxisTimeleftMark() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.renderOnTrendsChange = true;\r\n\t    }\r\n\t    AxisTimeleftMark.prototype.getDisplayedVal = function () {\r\n\t        var markVal = this.options.value;\r\n\t        var maxXVal = this.chartState.data.computedData.trends.maxXVal;\r\n\t        var time = markVal - maxXVal;\r\n\t        if (time < 0)\r\n\t            time = 0;\r\n\t        return Utils_1.Utils.msToTimeString(time);\r\n\t    };\r\n\t    AxisTimeleftMark.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chartState.onTrendsChange(function () { return _this.onTrendsChange(); });\r\n\t    };\r\n\t    AxisTimeleftMark.prototype.onTrendsChange = function () {\r\n\t        this.ee.emit('onDisplayedValueChange');\r\n\t    };\r\n\t    AxisTimeleftMark.typeName = 'timeleft';\r\n\t    return AxisTimeleftMark;\r\n\t}(AxisMark));\r\n\texports.AxisTimeleftMark = AxisTimeleftMark;\r\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t(function (AXIS_RANGE_TYPE) {\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"FIXED\"] = 0] = \"FIXED\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"RELATIVE_END\"] = 1] = \"RELATIVE_END\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"AUTO\"] = 2] = \"AUTO\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"ALL\"] = 3] = \"ALL\"; // TODO: AXIS_RANGE_TYPE.ALL\r\n\t})(exports.AXIS_RANGE_TYPE || (exports.AXIS_RANGE_TYPE = {}));\r\n\tvar AXIS_RANGE_TYPE = exports.AXIS_RANGE_TYPE;\r\n\t;\r\n\t(function (AXIS_TYPE) {\r\n\t    AXIS_TYPE[AXIS_TYPE[\"X\"] = 0] = \"X\";\r\n\t    AXIS_TYPE[AXIS_TYPE[\"Y\"] = 1] = \"Y\";\r\n\t})(exports.AXIS_TYPE || (exports.AXIS_TYPE = {}));\r\n\tvar AXIS_TYPE = exports.AXIS_TYPE;\r\n\t(function (AXIS_DATA_TYPE) {\r\n\t    AXIS_DATA_TYPE[AXIS_DATA_TYPE[\"NUMBER\"] = 0] = \"NUMBER\";\r\n\t    AXIS_DATA_TYPE[AXIS_DATA_TYPE[\"DATE\"] = 1] = \"DATE\";\r\n\t})(exports.AXIS_DATA_TYPE || (exports.AXIS_DATA_TYPE = {}));\r\n\tvar AXIS_DATA_TYPE = exports.AXIS_DATA_TYPE;\r\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t/**\r\n\t * base class for all widgets\r\n\t * each widget must have widgetName static property\r\n\t */\r\n\tvar ChartWidget = (function () {\r\n\t    function ChartWidget() {\r\n\t        this.unbindList = [];\r\n\t    }\r\n\t    ChartWidget.prototype.setupChartState = function (chartState) {\r\n\t        this.chart = chartState;\r\n\t    };\r\n\t    ChartWidget.prototype.bindEvent = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var unbindList = [];\r\n\t        if (!Array.isArray(args[0])) {\r\n\t            unbindList.push(args[0]);\r\n\t        }\r\n\t        else {\r\n\t            unbindList.push.apply(unbindList, (args));\r\n\t        }\r\n\t        (_a = this.unbindList).push.apply(_a, unbindList);\r\n\t        var _a;\r\n\t    };\r\n\t    ChartWidget.prototype.unbindEvents = function () {\r\n\t        this.unbindList.forEach(function (unbindEvent) { return unbindEvent(); });\r\n\t        this.unbindList.length = 0;\r\n\t    };\r\n\t    ChartWidget.widgetName = '';\r\n\t    return ChartWidget;\r\n\t}());\r\n\texports.ChartWidget = ChartWidget;\r\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar Widget_1 = __webpack_require__(20);\r\n\tvar GridWidget_1 = __webpack_require__(22);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar interfaces_1 = __webpack_require__(19);\r\n\t/**\r\n\t * widget for drawing axis\r\n\t */\r\n\tvar AxisWidget = (function (_super) {\r\n\t    __extends(AxisWidget, _super);\r\n\t    function AxisWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.isDestroyed = false;\r\n\t    }\r\n\t    AxisWidget.prototype.onReadyHandler = function () {\r\n\t        var _this = this;\r\n\t        this.object3D = new Object3D();\r\n\t        this.axisXObject = new Object3D();\r\n\t        this.axisYObject = new Object3D();\r\n\t        this.object3D.add(this.axisXObject);\r\n\t        this.object3D.add(this.axisYObject);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t        // canvas drawing is expensive operation, so when we scroll, redraw must be called only once per second\r\n\t        this.updateAxisXRequest = Utils_1.Utils.throttle(function () { return _this.updateAxis(interfaces_1.AXIS_TYPE.X); }, 1000);\r\n\t        this.onScrollChange(this.chart.screen.options.scrollX, this.chart.screen.options.scrollY);\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    AxisWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chart;\r\n\t        this.bindEvent(state.screen.onTransformationFrame(function (options) {\r\n\t            _this.onScrollChange(options.scrollX, options.scrollY);\r\n\t        }), state.screen.onZoomFrame(function (options) { _this.onZoomFrame(options); }), state.onDestroy(function () { return _this.onDestroy(); }), state.onResize(function () { return _this.onResize(); }));\r\n\t    };\r\n\t    AxisWidget.prototype.onDestroy = function () {\r\n\t        this.isDestroyed = true;\r\n\t        this.unbindEvents();\r\n\t    };\r\n\t    AxisWidget.prototype.onScrollChange = function (x, y) {\r\n\t        if (y != void 0) {\r\n\t            this.axisYObject.position.y = y;\r\n\t            this.axisXObject.position.y = y;\r\n\t        }\r\n\t        if (x != void 0) {\r\n\t            this.axisYObject.position.x = x;\r\n\t            this.updateAxisXRequest();\r\n\t        }\r\n\t    };\r\n\t    AxisWidget.prototype.onResize = function () {\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t    };\r\n\t    AxisWidget.prototype.setupAxis = function (orientation) {\r\n\t        var _this = this;\r\n\t        var isXAxis = orientation == interfaces_1.AXIS_TYPE.X;\r\n\t        var _a = this.chart.data, visibleWidth = _a.width, visibleHeight = _a.height;\r\n\t        var canvasWidth = 0, canvasHeight = 0;\r\n\t        // clean meshes\r\n\t        if (isXAxis) {\r\n\t            this.axisXObject.traverse(function (obj) { return _this.axisXObject.remove(obj); });\r\n\t            canvasWidth = visibleWidth * 3;\r\n\t            canvasHeight = 50;\r\n\t        }\r\n\t        else {\r\n\t            this.axisYObject.traverse(function (obj) { return _this.axisYObject.remove(obj); });\r\n\t            canvasWidth = 50;\r\n\t            canvasHeight = visibleHeight * 3;\r\n\t        }\r\n\t        var texture = Utils_1.Utils.createPixelPerfectTexture(canvasWidth, canvasHeight, function (ctx) {\r\n\t            ctx.beginPath();\r\n\t            ctx.font = \"10px Arial\";\r\n\t            ctx.fillStyle = \"rgba(255,255,255,0.5)\";\r\n\t            ctx.strokeStyle = \"rgba(255,255,255,0.1)\";\r\n\t        });\r\n\t        var material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });\r\n\t        material.transparent = true;\r\n\t        var axisMesh = new Mesh(new THREE.PlaneGeometry(canvasWidth, canvasHeight), material);\r\n\t        if (isXAxis) {\r\n\t            axisMesh.position.set(canvasWidth / 2, canvasHeight / 2, 0);\r\n\t            this.axisXObject.add(axisMesh);\r\n\t        }\r\n\t        else {\r\n\t            axisMesh.position.set(visibleWidth - canvasWidth / 2, canvasHeight / 2, 0);\r\n\t            this.axisYObject.add(axisMesh);\r\n\t        }\r\n\t        this.updateAxis(orientation);\r\n\t    };\r\n\t    AxisWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    AxisWidget.prototype.updateAxis = function (orientation) {\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        var isXAxis = orientation == interfaces_1.AXIS_TYPE.X;\r\n\t        var _a = this.chart.data, visibleWidth = _a.width, visibleHeight = _a.height;\r\n\t        var _b = this.chart.screen.options, scrollX = _b.scrollX, scrollY = _b.scrollY, zoomX = _b.zoomX, zoomY = _b.zoomY;\r\n\t        var axisOptions;\r\n\t        var axisMesh;\r\n\t        var axisGridParams;\r\n\t        if (isXAxis) {\r\n\t            axisMesh = this.axisXObject.children[0];\r\n\t            axisOptions = this.chart.data.xAxis;\r\n\t            axisGridParams = GridWidget_1.GridWidget.getGridParamsForAxis(axisOptions, visibleWidth, zoomX);\r\n\t        }\r\n\t        else {\r\n\t            axisMesh = this.axisYObject.children[0];\r\n\t            axisOptions = this.chart.data.yAxis;\r\n\t            axisGridParams = GridWidget_1.GridWidget.getGridParamsForAxis(axisOptions, visibleHeight, zoomY);\r\n\t        }\r\n\t        var geometry = axisMesh.geometry;\r\n\t        var canvasWidth = geometry.parameters.width;\r\n\t        var canvasHeight = geometry.parameters.height;\r\n\t        var texture = axisMesh.material.map;\r\n\t        var ctx = texture.image.getContext('2d');\r\n\t        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\t        if (isXAxis) {\r\n\t            axisMesh.position.x = canvasWidth / 2 - visibleWidth + scrollX;\r\n\t        }\r\n\t        // TODO: draw text and lines in different loops\r\n\t        var edgeOffset = axisGridParams.segmentsCount * axisGridParams.step;\r\n\t        var startVal = axisGridParams.start - edgeOffset;\r\n\t        var endVal = axisGridParams.end + edgeOffset;\r\n\t        ctx.beginPath();\r\n\t        for (var val = startVal; val <= endVal; val += axisGridParams.step) {\r\n\t            var displayedValue = '';\r\n\t            if (isXAxis) {\r\n\t                var pxVal = this.chart.screen.getPointOnXAxis(val) - scrollX + visibleWidth;\r\n\t                ctx.textAlign = \"center\";\r\n\t                // uncomment for dots\r\n\t                // ctx.moveTo(pxVal + 0.5, canvasHeight);\r\n\t                // ctx.lineTo(pxVal + 0.5, canvasHeight - 5);\r\n\t                if (axisOptions.dataType == interfaces_1.AXIS_DATA_TYPE.DATE) {\r\n\t                    displayedValue = AxisWidget.getDateStr(val, axisGridParams);\r\n\t                }\r\n\t                else {\r\n\t                    displayedValue = Number(val.toFixed(14)).toString();\r\n\t                }\r\n\t                ctx.fillText(displayedValue, pxVal, canvasHeight - 10);\r\n\t            }\r\n\t            else {\r\n\t                var pxVal = canvasHeight - this.chart.screen.getPointOnYAxis(val) + scrollY;\r\n\t                ctx.textAlign = \"right\";\r\n\t                // uncomment for dots\r\n\t                // ctx.moveTo(canvasWidth, pxVal + 0.5);\r\n\t                // ctx.lineTo(canvasWidth - 5, pxVal + 0.5);\r\n\t                displayedValue = Number(val.toFixed(14)).toString();\r\n\t                ctx.fillText(displayedValue, canvasWidth - 15, pxVal + 3);\r\n\t            }\r\n\t            ctx.stroke();\r\n\t        }\r\n\t        // uncomment to preview canvas borders\r\n\t        // ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\t        ctx.stroke();\r\n\t        ctx.closePath();\r\n\t        texture.needsUpdate = true;\r\n\t    };\r\n\t    AxisWidget.prototype.onZoomFrame = function (options) {\r\n\t        if (options.zoomX) {\r\n\t            this.updateAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        }\r\n\t        if (options.zoomY) {\r\n\t            this.updateAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t        }\r\n\t    };\r\n\t    // private temporaryHideAxis(orientation: AXIS_TYPE) {\r\n\t    // \tvar isXAxis = orientation == AXIS_TYPE.X;\r\n\t    // \tvar timeoutId = setTimeout(() => {\r\n\t    // \t\t\tthis.showAxis(orientation);\r\n\t    // \t}, 200);\r\n\t    //\r\n\t    // \tif (isXAxis) {\r\n\t    // \t\t(this.axisXObject.children[0] as Mesh).material.opacity = 0;\r\n\t    // \t\tclearTimeout(this.showAxisXTimeout);\r\n\t    // \t\tthis.showAxisXTimeout =\ttimeoutId;\r\n\t    // \t} else {\r\n\t    // \t\tclearTimeout(this.showAxisYTimeout);\r\n\t    // \t\t(this.axisYObject.children[0] as Mesh).material.opacity = 0;\r\n\t    // \t\tthis.showAxisYTimeout = timeoutId;\r\n\t    // \t}\r\n\t    // }\r\n\t    // private showAxis(orientation: AXIS_TYPE) {\r\n\t    // \tvar isXAxis = orientation == AXIS_TYPE.X;\r\n\t    // \tvar material: MeshBasicMaterial;\r\n\t    // \tif (isXAxis) {\r\n\t    // \t\tmaterial = (this.axisXObject.children[0] as Mesh).material as MeshBasicMaterial;\r\n\t    // \t} else {\r\n\t    // \t\tmaterial = (this.axisYObject.children[0] as Mesh).material as MeshBasicMaterial;\r\n\t    // \t}\r\n\t    // \tthis.updateAxis(orientation);\r\n\t    // \tTweenLite.to(material, 0.3, {opacity: 1});\r\n\t    // }\r\n\t    AxisWidget.getDateStr = function (timestamp, gridParams) {\r\n\t        var sec = 1000;\r\n\t        var min = sec * 60;\r\n\t        var hour = min * 60;\r\n\t        var day = hour * 60;\r\n\t        var step = gridParams.step;\r\n\t        var d = new Date(timestamp);\r\n\t        var tf = function (num) { return Utils_1.Utils.toFixed(num, 2); };\r\n\t        return tf(d.getHours()) + ':' + tf(d.getMinutes()) + ':' + tf(d.getSeconds());\r\n\t    };\r\n\t    AxisWidget.widgetName = 'Axis';\r\n\t    return AxisWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.AxisWidget = AxisWidget;\r\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Widget_1 = __webpack_require__(20);\r\n\tvar LineSegments = THREE.LineSegments;\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\t/**\r\n\t * widget for drawing chart grid\r\n\t */\r\n\tvar GridWidget = (function (_super) {\r\n\t    __extends(GridWidget, _super);\r\n\t    function GridWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.isDestroyed = false;\r\n\t    }\r\n\t    GridWidget.prototype.onReadyHandler = function () {\r\n\t        var _a = this.chart.data, width = _a.width, height = _a.height, xAxis = _a.xAxis, yAxis = _a.yAxis;\r\n\t        this.gridSizeH = Math.floor(width / xAxis.grid.minSizePx) * 3;\r\n\t        this.gridSizeV = Math.floor(height / yAxis.grid.minSizePx) * 3;\r\n\t        this.initGrid();\r\n\t        this.updateGrid();\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    GridWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        // grid is bigger then screen, so it's no need to update it on each scroll event\r\n\t        var updateGridThrottled = Utils_1.Utils.throttle(function () { return _this.updateGrid(); }, 1000);\r\n\t        this.bindEvent(this.chart.onScroll(function () { return updateGridThrottled(); }), this.chart.screen.onZoomFrame(function (options) {\r\n\t            updateGridThrottled();\r\n\t            _this.onZoomFrame(options);\r\n\t        }), this.chart.onDestroy(function () {\r\n\t            _this.isDestroyed = true;\r\n\t            _this.unbindEvents();\r\n\t        }), this.chart.onResize(function () {\r\n\t            _this.updateGrid();\r\n\t        }));\r\n\t    };\r\n\t    GridWidget.prototype.initGrid = function () {\r\n\t        var geometry = new THREE.Geometry();\r\n\t        var material = new THREE.LineBasicMaterial({ linewidth: 1, opacity: 0.1, transparent: true });\r\n\t        var xLinesCount = this.gridSizeH;\r\n\t        var yLinesCount = this.gridSizeV;\r\n\t        while (xLinesCount--)\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t        while (yLinesCount--)\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t        this.lineSegments = new LineSegments(geometry, material);\r\n\t        this.lineSegments.position.setZ(-1);\r\n\t        this.lineSegments.frustumCulled = false;\r\n\t    };\r\n\t    GridWidget.prototype.updateGrid = function () {\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        var _a = this.chart.data, yAxis = _a.yAxis, xAxis = _a.xAxis, width = _a.width, height = _a.height;\r\n\t        var axisXGrid = GridWidget.getGridParamsForAxis(xAxis, width, xAxis.range.zoom);\r\n\t        var axisYGrid = GridWidget.getGridParamsForAxis(yAxis, height, yAxis.range.zoom);\r\n\t        var scrollXInSegments = Math.ceil(xAxis.range.scroll / axisXGrid.step);\r\n\t        var scrollYInSegments = Math.ceil(yAxis.range.scroll / axisYGrid.step);\r\n\t        var gridScrollXVal = scrollXInSegments * axisXGrid.step;\r\n\t        var gridScrollYVal = scrollYInSegments * axisYGrid.step;\r\n\t        var startXVal = axisXGrid.start + gridScrollXVal;\r\n\t        var startYVal = axisYGrid.start + gridScrollYVal;\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        var vertices = geometry.vertices;\r\n\t        var lineInd = 0;\r\n\t        for (var i = -this.gridSizeH / 3; i < this.gridSizeH * 2 / 3; i++) {\r\n\t            var value = startXVal + i * axisXGrid.step;\r\n\t            var lineSegment = this.getVerticalLineSegment(value, gridScrollXVal, gridScrollYVal);\r\n\t            vertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\r\n\t            vertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\r\n\t            lineInd++;\r\n\t        }\r\n\t        for (var i = -this.gridSizeV / 3; i < this.gridSizeV * 2 / 3; i++) {\r\n\t            var value = startYVal + i * axisYGrid.step;\r\n\t            var lineSegment = this.getHorizontalLineSegment(value, gridScrollXVal, gridScrollYVal);\r\n\t            vertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\r\n\t            vertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\r\n\t            lineInd++;\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t        this.lineSegments.scale.set(xAxis.range.scaleFactor * xAxis.range.zoom, yAxis.range.scaleFactor * yAxis.range.zoom, 1);\r\n\t    };\r\n\t    GridWidget.prototype.getHorizontalLineSegment = function (yVal, scrollXVal, scrollYVal) {\r\n\t        var chartState = this.chart;\r\n\t        var localYVal = yVal - chartState.data.yAxis.range.zeroVal - scrollYVal;\r\n\t        var widthVal = chartState.pxToValueByXAxis(chartState.data.width);\r\n\t        return [\r\n\t            new THREE.Vector3(widthVal * 2 + scrollXVal, localYVal, 0),\r\n\t            new THREE.Vector3(-widthVal + scrollXVal, localYVal, 0)\r\n\t        ];\r\n\t    };\r\n\t    GridWidget.prototype.getVerticalLineSegment = function (xVal, scrollXVal, scrollYVal) {\r\n\t        var chartState = this.chart;\r\n\t        var localXVal = xVal - chartState.data.xAxis.range.zeroVal - scrollXVal;\r\n\t        var heightVal = chartState.pxToValueByYAxis(chartState.data.height);\r\n\t        return [\r\n\t            new THREE.Vector3(localXVal, heightVal * 2 + scrollYVal, 0),\r\n\t            new THREE.Vector3(localXVal, -heightVal + scrollYVal, 0)\r\n\t        ];\r\n\t    };\r\n\t    GridWidget.prototype.onZoomFrame = function (options) {\r\n\t        var _a = this.chart.data, xAxis = _a.xAxis, yAxis = _a.yAxis;\r\n\t        if (options.zoomX)\r\n\t            this.lineSegments.scale.setX(xAxis.range.scaleFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            this.lineSegments.scale.setY(yAxis.range.scaleFactor * options.zoomY);\r\n\t    };\r\n\t    // TODO: move this code to core\r\n\t    GridWidget.getGridParamsForAxis = function (axisOptions, axisWidth, zoom) {\r\n\t        var axisRange = axisOptions.range;\r\n\t        var from = axisRange.from;\r\n\t        var to = axisRange.to;\r\n\t        var axisLength = to - from;\r\n\t        var gridStep = 0;\r\n\t        var gridStepInPixels = 0;\r\n\t        var minGridStepInPixels = axisOptions.grid.minSizePx;\r\n\t        var axisLengthStr = String(axisLength);\r\n\t        var axisLengthPointPosition = axisLengthStr.indexOf('.');\r\n\t        var intPartLength = axisLengthPointPosition !== -1 ? axisLengthPointPosition : axisLengthStr.length;\r\n\t        var gridStepFound = false;\r\n\t        var digitPos = 0;\r\n\t        while (!gridStepFound) {\r\n\t            var power = intPartLength - digitPos - 1;\r\n\t            var multiplier = (Math.pow(10, power) || 1);\r\n\t            var dividers = [1, 2, 5];\r\n\t            for (var dividerInd = 0; dividerInd < dividers.length; dividerInd++) {\r\n\t                var nextGridStep = multiplier / dividers[dividerInd];\r\n\t                var nextGridStepInPixels = nextGridStep / axisLength * axisWidth;\r\n\t                if (nextGridStepInPixels >= minGridStepInPixels) {\r\n\t                    gridStep = nextGridStep;\r\n\t                    gridStepInPixels = nextGridStepInPixels;\r\n\t                }\r\n\t                else {\r\n\t                    gridStepFound = true;\r\n\t                    if (gridStep === 0) {\r\n\t                        gridStep = nextGridStep;\r\n\t                        gridStepInPixels = nextGridStepInPixels;\r\n\t                    }\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (!gridStepFound)\r\n\t                digitPos++;\r\n\t        }\r\n\t        var gridStart = Math.floor(from / gridStep) * gridStep;\r\n\t        var gridEnd = Math.floor(to / gridStep) * gridStep;\r\n\t        return {\r\n\t            start: gridStart,\r\n\t            end: gridEnd,\r\n\t            step: gridStep,\r\n\t            stepInPx: gridStepInPixels,\r\n\t            length: gridEnd - gridStart,\r\n\t            segmentsCount: Math.round((gridEnd - gridStart) / gridStep)\r\n\t        };\r\n\t    };\r\n\t    GridWidget.prototype.getObject3D = function () {\r\n\t        return this.lineSegments;\r\n\t    };\r\n\t    GridWidget.widgetName = 'Grid';\r\n\t    return GridWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.GridWidget = GridWidget;\r\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar TrendsWidget_1 = __webpack_require__(24);\r\n\tvar Color_1 = __webpack_require__(25);\r\n\tvar TrendsGradientWidget = (function (_super) {\r\n\t    __extends(TrendsGradientWidget, _super);\r\n\t    function TrendsGradientWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsGradientWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendGradient;\r\n\t    };\r\n\t    TrendsGradientWidget.widgetName = \"TrendsGradient\";\r\n\t    return TrendsGradientWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsGradientWidget = TrendsGradientWidget;\r\n\tvar TrendGradient = (function (_super) {\r\n\t    __extends(TrendGradient, _super);\r\n\t    function TrendGradient(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        this.visibleSegmentsCnt = 0;\r\n\t        this.trend = chartState.trendsManager.getTrend(trendName);\r\n\t        this.segmentsIds = new Uint16Array(chartState.data.maxVisibleSegments);\r\n\t        this.initGradient();\r\n\t        this.updateSegments();\r\n\t    }\r\n\t    TrendGradient.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.hasBackground;\r\n\t    };\r\n\t    TrendGradient.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            // TODO: optimize updateSegments for onDisplayedRangeChanged\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.chart.onZoom(function () {\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t    };\r\n\t    TrendGradient.prototype.getObject3D = function () {\r\n\t        return this.gradient;\r\n\t    };\r\n\t    TrendGradient.prototype.initGradient = function () {\r\n\t        var geometry = new Geometry();\r\n\t        for (var i = 0; i < this.segmentsIds.length; i++) {\r\n\t            geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3());\r\n\t            var ind = i * 4;\r\n\t            // gradient segment scheme\r\n\t            //\r\n\t            // vert0 +---+ vert3\r\n\t            //       |\\  |\r\n\t            // face1 | \\ | face2\r\n\t            // \t     |  \\|\r\n\t            // vert1 +---+ vert2\r\n\t            geometry.faces.push(new THREE.Face3(ind, ind + 1, ind + 2), new THREE.Face3(ind + 3, ind, ind + 2));\r\n\t        }\r\n\t        var color = new Color_1.ChartColor(this.trend.getOptions().backgroundColor);\r\n\t        this.gradient = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: color.value, transparent: true, opacity: color.a }));\r\n\t        var _a = this.chart.data.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = this.chart.data.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.gradient.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.gradient.frustumCulled = false;\r\n\t    };\r\n\t    TrendGradient.prototype.onZoomFrame = function (options) {\r\n\t        var state = this.chart.data;\r\n\t        var scaleXFactor = state.xAxis.range.scaleFactor;\r\n\t        var scaleYFactor = state.yAxis.range.scaleFactor;\r\n\t        var currentScale = this.gradient.scale;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendGradient.prototype.onSegmentsAnimate = function (trendSegmentsManager) {\r\n\t        var animatedSegmentsIds = trendSegmentsManager.animatedSegmentsIds;\r\n\t        for (var i = 0; i < this.visibleSegmentsCnt; i++) {\r\n\t            var segmentId = this.segmentsIds[i];\r\n\t            if (!animatedSegmentsIds.includes(segmentId))\r\n\t                continue;\r\n\t            this.setupSegmentVertices(i, trendSegmentsManager.getSegment(segmentId).currentAnimationState);\r\n\t        }\r\n\t        this.gradient.geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendGradient.prototype.updateSegments = function () {\r\n\t        var geometry = this.gradient.geometry;\r\n\t        var _a = this.trend.segmentsManager, trendSegments = _a.segments, segmentInd = _a.firstDisplayedSegmentInd, lastDisplayedSegmentInd = _a.lastDisplayedSegmentInd;\r\n\t        var prevVisibleSegmentsCnt = this.visibleSegmentsCnt;\r\n\t        this.visibleSegmentsCnt = lastDisplayedSegmentInd - segmentInd + 1;\r\n\t        var segmentsToProcessCnt = Math.max(prevVisibleSegmentsCnt, this.visibleSegmentsCnt);\r\n\t        if (segmentsToProcessCnt > this.segmentsIds.length) {\r\n\t            Utils_1.Utils.error(TrendsGradientWidget.widgetName + ': MAX_SEGMENTS reached');\r\n\t        }\r\n\t        // setup visible segments and collapse invisible\r\n\t        for (var i = 0; i <= segmentsToProcessCnt; i++) {\r\n\t            if (segmentInd <= lastDisplayedSegmentInd) {\r\n\t                var segment = trendSegments[segmentInd];\r\n\t                this.setupSegmentVertices(i, segment.currentAnimationState);\r\n\t                this.segmentsIds[i] = segment.id;\r\n\t                segmentInd++;\r\n\t            }\r\n\t            else {\r\n\t                this.setupSegmentVertices(i);\r\n\t            }\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    /**\r\n\t     * setup gradient segment by segmentState\r\n\t     * if segmentState is undefined, then collapse vertices to 0,0,0\r\n\t     */\r\n\t    TrendGradient.prototype.setupSegmentVertices = function (segmentInd, segmentState) {\r\n\t        var gradientSegmentInd = segmentInd * 4;\r\n\t        var vertices = this.gradient.geometry.vertices;\r\n\t        var topLeft = vertices[gradientSegmentInd];\r\n\t        var bottomLeft = vertices[gradientSegmentInd + 1];\r\n\t        var bottomRight = vertices[gradientSegmentInd + 2];\r\n\t        var topRight = vertices[gradientSegmentInd + 3];\r\n\t        var screenHeightVal = Math.max(this.chart.pxToValueByYAxis(this.chart.data.height), this.chart.screen.pxToValueByYAxis(this.chart.data.height));\r\n\t        if (segmentState) {\r\n\t            var startX = this.toLocalX(segmentState.startXVal);\r\n\t            var startY = this.toLocalY(segmentState.startYVal);\r\n\t            var endX = this.toLocalX(segmentState.endXVal);\r\n\t            var endY = this.toLocalY(segmentState.endYVal);\r\n\t            topLeft.set(startX, startY, 0);\r\n\t            topRight.set(endX, endY, 0);\r\n\t            bottomLeft.set(topLeft.x, topLeft.y - screenHeightVal, 0);\r\n\t            bottomRight.set(topRight.x, topRight.y - screenHeightVal, 0);\r\n\t        }\r\n\t        else {\r\n\t            topLeft.set(0, 0, 0);\r\n\t            topRight.set(0, 0, 0);\r\n\t            bottomLeft.set(0, 0, 0);\r\n\t            bottomRight.set(0, 0, 0);\r\n\t        }\r\n\t    };\r\n\t    TrendGradient.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chart.data.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendGradient.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chart.data.yAxis.range.zeroVal;\r\n\t    };\r\n\t    return TrendGradient;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendGradient = TrendGradient;\r\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Widget_1 = __webpack_require__(20);\r\n\tvar Object3D = THREE.Object3D;\r\n\t/**\r\n\t * abstract manager class for all trends widgets\r\n\t */\r\n\tvar TrendsWidget = (function (_super) {\r\n\t    __extends(TrendsWidget, _super);\r\n\t    function TrendsWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.widgets = {};\r\n\t    }\r\n\t    TrendsWidget.prototype.onReadyHandler = function () {\r\n\t        this.object3D = new Object3D();\r\n\t        this.onTrendsChange();\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    TrendsWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chart;\r\n\t        state.onTrendsChange(function () { return _this.onTrendsChange(); });\r\n\t        state.onTrendChange(function (trendName, changedOptions, newData) {\r\n\t            _this.onTrendChange(trendName, changedOptions, newData);\r\n\t        });\r\n\t    };\r\n\t    TrendsWidget.prototype.onTrendsChange = function () {\r\n\t        var trendsOptions = this.chart.data.trends;\r\n\t        var TrendWidgetClass = this.getTrendWidgetClass();\r\n\t        for (var trendName in trendsOptions) {\r\n\t            var trendOptions = trendsOptions[trendName];\r\n\t            var widgetCanBeEnabled = TrendWidgetClass.widgetIsEnabled(trendOptions, this.chart);\r\n\t            if (widgetCanBeEnabled && !this.widgets[trendName]) {\r\n\t                this.createTrendWidget(trendName);\r\n\t            }\r\n\t            else if (!widgetCanBeEnabled && this.widgets[trendName]) {\r\n\t                this.destroyTrendWidget(trendName);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    TrendsWidget.prototype.onTrendChange = function (trendName, changedOptions, newData) {\r\n\t        var widget = this.widgets[trendName];\r\n\t        if (!widget)\r\n\t            return;\r\n\t        widget.onTrendChange(changedOptions);\r\n\t        if (newData) {\r\n\t            var data = this.chart.getTrend(trendName).getData();\r\n\t            var isAppend = (!data.length || data[0].xVal < newData[0].xVal);\r\n\t            isAppend ? widget.appendData(newData) : widget.prependData(newData);\r\n\t        }\r\n\t    };\r\n\t    TrendsWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendsWidget.prototype.createTrendWidget = function (trendName) {\r\n\t        var WidgetConstructor = this.getTrendWidgetClass();\r\n\t        var widget = new WidgetConstructor(this.chart, trendName);\r\n\t        this.widgets[trendName] = widget;\r\n\t        var widgetObject = widget.getObject3D();\r\n\t        widgetObject.name = trendName;\r\n\t        this.object3D.add(widget.getObject3D());\r\n\t    };\r\n\t    TrendsWidget.prototype.destroyTrendWidget = function (trendName) {\r\n\t        this.widgets[trendName].onDestroy();\r\n\t        delete this.widgets[trendName];\r\n\t        var widgetObject = this.object3D.getObjectByName(trendName);\r\n\t        this.object3D.remove(widgetObject);\r\n\t    };\r\n\t    return TrendsWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.TrendsWidget = TrendsWidget;\r\n\t/**\r\n\t * based class for all trends widgets\r\n\t */\r\n\tvar TrendWidget = (function () {\r\n\t    function TrendWidget(chart, trendName) {\r\n\t        this.chart = chart;\r\n\t        this.trendName = trendName;\r\n\t        this.unbindList = [];\r\n\t        this.trend = chart.trendsManager.getTrend(trendName);\r\n\t        this.chart = chart;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendWidget.widgetIsEnabled = function (trendOptions, chart) {\r\n\t        return trendOptions.enabled;\r\n\t    };\r\n\t    TrendWidget.prototype.appendData = function (newData) { };\r\n\t    ;\r\n\t    TrendWidget.prototype.prependData = function (newData) { };\r\n\t    ;\r\n\t    TrendWidget.prototype.onTrendChange = function (changedOptions) { };\r\n\t    TrendWidget.prototype.onDestroy = function () {\r\n\t        for (var _i = 0, _a = this.unbindList; _i < _a.length; _i++) {\r\n\t            var unsubscriber = _a[_i];\r\n\t            unsubscriber();\r\n\t        }\r\n\t    };\r\n\t    TrendWidget.prototype.onSegmentsAnimate = function (segments) {\r\n\t    };\r\n\t    TrendWidget.prototype.onZoomFrame = function (options) {\r\n\t    };\r\n\t    TrendWidget.prototype.onTransformationFrame = function (options) {\r\n\t    };\r\n\t    TrendWidget.prototype.onZoom = function () {\r\n\t    };\r\n\t    TrendWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.bindEvent(this.trend.segmentsManager.onAnimationFrame(function (trendPoints) { return _this.onSegmentsAnimate(trendPoints); }));\r\n\t        this.bindEvent(this.chart.screen.onTransformationFrame(function (options) { return _this.onTransformationFrame(options); }));\r\n\t        this.bindEvent(this.chart.screen.onZoomFrame(function (options) { return _this.onZoomFrame(options); }));\r\n\t        this.bindEvent(this.chart.onZoom(function () { return _this.onZoom(); }));\r\n\t    };\r\n\t    ;\r\n\t    TrendWidget.prototype.bindEvent = function (unbind) {\r\n\t        this.unbindList.push(unbind);\r\n\t    };\r\n\t    return TrendWidget;\r\n\t}());\r\n\texports.TrendWidget = TrendWidget;\r\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar ChartColor = (function () {\r\n\t    function ChartColor(color) {\r\n\t        this.set(color);\r\n\t    }\r\n\t    /**!\r\n\t     * @preserve $.parseColor\r\n\t     * Copyright 2011 THEtheChad Elliott\r\n\t     * Released under the MIT and GPL licenses.\r\n\t     */\r\n\t    /**\r\n\t     * Parse hex/rgb{a} color syntax.\r\n\t     * @input string\r\n\t     * @returns array [r,g,b{,o}]\r\n\t     */\r\n\t    ChartColor.parseColor = function (color) {\r\n\t        var cache, p = parseInt // Use p as a byte saving reference to parseInt\r\n\t        , color = color.replace(/\\s\\s*/g, ''); //var\r\n\t        // Checks for 6 digit hex and converts string to integer\r\n\t        if (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\r\n\t        else if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\r\n\t            cache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\r\n\t        else if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\r\n\t        else if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3], +cache[4]];\r\n\t        else if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3]];\r\n\t        else\r\n\t            throw Error(color + ' is not supported by parseColor');\r\n\t        // Performs RGBA conversion by default\r\n\t        isNaN(cache[3]) && (cache[3] = 1);\r\n\t        return cache;\r\n\t        // Adds or removes 4th value based on rgba support\r\n\t        // Support is flipped twice to prevent erros if\r\n\t        // it's not defined\r\n\t        //return cache.slice(0,3 + !!$.support.rgba);\r\n\t    };\r\n\t    ChartColor.prototype.set = function (color) {\r\n\t        if (typeof color == 'number')\r\n\t            color = '#' + color.toString(16);\r\n\t        var colorStr = color;\r\n\t        var rgba = ChartColor.parseColor(colorStr);\r\n\t        this.r = rgba[0];\r\n\t        this.g = rgba[1];\r\n\t        this.b = rgba[2];\r\n\t        this.a = rgba[3];\r\n\t        this.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\r\n\t        this.hexStr = '#' + this.value.toString(16);\r\n\t        this.rgbaStr = \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.a + \")\";\r\n\t    };\r\n\t    return ChartColor;\r\n\t}());\r\n\texports.ChartColor = ChartColor;\r\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar LineBasicMaterial = THREE.LineBasicMaterial;\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar TrendsWidget_1 = __webpack_require__(24);\r\n\tvar LineSegments = THREE.LineSegments;\r\n\tvar Trend_1 = __webpack_require__(14);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\t/**\r\n\t * widget for drawing trends lines\r\n\t */\r\n\tvar TrendsLineWidget = (function (_super) {\r\n\t    __extends(TrendsLineWidget, _super);\r\n\t    function TrendsLineWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsLineWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendLine;\r\n\t    };\r\n\t    TrendsLineWidget.widgetName = \"TrendsLine\";\r\n\t    return TrendsLineWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsLineWidget = TrendsLineWidget;\r\n\tvar TrendLine = (function (_super) {\r\n\t    __extends(TrendLine, _super);\r\n\t    function TrendLine(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        // contains indexes of free segments\r\n\t        this.freeSegmentsInds = [];\r\n\t        // contains segments to display\r\n\t        this.displayedSegments = {};\r\n\t        var options = this.trend.getOptions();\r\n\t        this.material = new LineBasicMaterial({ color: options.lineColor, linewidth: options.lineWidth });\r\n\t        this.initLine();\r\n\t    }\r\n\t    TrendLine.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.type == Trend_1.TREND_TYPE.LINE;\r\n\t    };\r\n\t    TrendLine.prototype.getObject3D = function () {\r\n\t        return this.lineSegments;\r\n\t    };\r\n\t    TrendLine.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.destroySegments();\r\n\t            _this.setupSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            _this.setupSegments();\r\n\t        }));\r\n\t    };\r\n\t    TrendLine.prototype.initLine = function () {\r\n\t        var geometry = new Geometry();\r\n\t        var _a = this.chart.data.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = this.chart.data.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.lineSegments = new LineSegments(geometry, this.material);\r\n\t        this.lineSegments.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.lineSegments.frustumCulled = false;\r\n\t        for (var i = 0; i < this.chart.data.maxVisibleSegments; i++) {\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t            this.freeSegmentsInds.push(i);\r\n\t        }\r\n\t        this.vertices = geometry.vertices;\r\n\t        this.setupSegments();\r\n\t    };\r\n\t    TrendLine.prototype.setupSegments = function () {\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        var _a = this.trend.segmentsManager, firstDisplayedSegment = _a.firstDisplayedSegment, lastDisplayedSegment = _a.lastDisplayedSegment;\r\n\t        for (var segmentId in this.displayedSegments) {\r\n\t            var lineSegment = this.displayedSegments[segmentId];\r\n\t            var segment_1 = this.trend.segmentsManager.segments[lineSegment.segmentId];\r\n\t            var segmentIsNotDisplayed = (segment_1.startXVal < firstDisplayedSegment.startXVal ||\r\n\t                segment_1.endXVal > lastDisplayedSegment.endXVal);\r\n\t            if (segmentIsNotDisplayed)\r\n\t                this.destroySegment(Number(segmentId));\r\n\t        }\r\n\t        var segment = firstDisplayedSegment;\r\n\t        while (segment && segment.xVal <= lastDisplayedSegment.xVal) {\r\n\t            this.setupSegment(segment.id, segment.currentAnimationState);\r\n\t            segment = segment.getNext();\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendLine.prototype.setupSegment = function (segmentId, segmentState) {\r\n\t        var lineSegment = this.displayedSegments[segmentId];\r\n\t        if (!lineSegment) {\r\n\t            if (this.freeSegmentsInds.length == 0)\r\n\t                Utils_1.Utils.error('Max allocated segments reached');\r\n\t            var ind = this.freeSegmentsInds.pop();\r\n\t            lineSegment = this.displayedSegments[segmentId] = { segmentId: segmentId, ind: ind };\r\n\t        }\r\n\t        var segmentInd = lineSegment.ind;\r\n\t        var lineStartVertex = this.vertices[segmentInd * 2];\r\n\t        var lineEndVertex = this.vertices[segmentInd * 2 + 1];\r\n\t        lineStartVertex.set(this.toLocalX(segmentState.startXVal), this.toLocalY(segmentState.startYVal), 0);\r\n\t        lineEndVertex.set(this.toLocalX(segmentState.endXVal), this.toLocalY(segmentState.endYVal), 0);\r\n\t    };\r\n\t    TrendLine.prototype.destroySegments = function () {\r\n\t        for (var segmentId in this.displayedSegments)\r\n\t            this.destroySegment(Number(segmentId));\r\n\t    };\r\n\t    TrendLine.prototype.destroySegment = function (segmentId) {\r\n\t        var lineSegment = this.displayedSegments[segmentId];\r\n\t        var lineStartVertex = this.vertices[lineSegment.ind * 2];\r\n\t        var lineEndVertex = this.vertices[lineSegment.ind * 2 + 1];\r\n\t        lineStartVertex.set(0, 0, 0);\r\n\t        lineEndVertex.set(0, 0, 0);\r\n\t        delete this.displayedSegments[segmentId];\r\n\t        this.freeSegmentsInds.push(lineSegment.ind);\r\n\t    };\r\n\t    TrendLine.prototype.onZoomFrame = function (options) {\r\n\t        var currentScale = this.lineSegments.scale;\r\n\t        var state = this.chart.data;\r\n\t        var scaleXFactor = state.xAxis.range.scaleFactor;\r\n\t        var scaleYFactor = state.yAxis.range.scaleFactor;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendLine.prototype.onSegmentsAnimate = function (trendSegments) {\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        for (var _i = 0, _a = trendSegments.animatedSegmentsIds; _i < _a.length; _i++) {\r\n\t            var segmentId = _a[_i];\r\n\t            if (!this.displayedSegments[segmentId])\r\n\t                continue;\r\n\t            this.setupSegment(segmentId, trendSegments.segmentsById[segmentId].currentAnimationState);\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chart.data.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chart.data.yAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalVec = function (vec) {\r\n\t        return new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\r\n\t    };\r\n\t    return TrendLine;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendLine = TrendLine;\r\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar TrendsWidget_1 = __webpack_require__(24);\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Line = THREE.Line;\r\n\tvar MeshBasicMaterial = THREE.MeshBasicMaterial;\r\n\tvar PlaneGeometry = THREE.PlaneGeometry;\r\n\tvar Trend_1 = __webpack_require__(14);\r\n\tvar LineBasicMaterial = THREE.LineBasicMaterial;\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar RISE_COLOR = 0x2CAC40;\r\n\tvar FALL_COLOR = 0xEE5533;\r\n\tvar MARGIN_PERCENT = 0.3;\r\n\tvar MAX_CANDLES = 100;\r\n\t/**\r\n\t * widget for drawing trends candles\r\n\t */\r\n\tvar TrendsCandlesWidget = (function (_super) {\r\n\t    __extends(TrendsCandlesWidget, _super);\r\n\t    function TrendsCandlesWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsCandlesWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendCandlesWidget;\r\n\t    };\r\n\t    TrendsCandlesWidget.widgetName = \"TrendsCandles\";\r\n\t    return TrendsCandlesWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsCandlesWidget = TrendsCandlesWidget;\r\n\tvar TrendCandlesWidget = (function (_super) {\r\n\t    __extends(TrendCandlesWidget, _super);\r\n\t    function TrendCandlesWidget(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        // contains indexes of free candles\r\n\t        this.freeCandlesInds = [];\r\n\t        this.candlesPool = [];\r\n\t        this.candles = {};\r\n\t        this.initObject();\r\n\t    }\r\n\t    TrendCandlesWidget.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.type == Trend_1.TREND_TYPE.CANDLE;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.destroyCandles();\r\n\t            _this.setupCandles();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            _this.setupCandles();\r\n\t        }));\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.initObject = function () {\r\n\t        var stateData = this.chart.data;\r\n\t        var _a = stateData.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = stateData.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.scaleXFactor = scaleXFactor;\r\n\t        this.scaleYFactor = scaleYFactor;\r\n\t        this.object3D = new Object3D();\r\n\t        this.object3D.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.object3D.frustumCulled = false;\r\n\t        for (var i = 0; i < MAX_CANDLES; i++)\r\n\t            this.freeCandlesInds.push(i);\r\n\t        this.setupCandles();\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.setupCandles = function () {\r\n\t        // remove invisible\r\n\t        var _a = this.trend.segmentsManager, firstDisplayedSegment = _a.firstDisplayedSegment, lastDisplayedSegment = _a.lastDisplayedSegment;\r\n\t        for (var segmentId in this.candles) {\r\n\t            var segment_1 = this.candles[segmentId].segment;\r\n\t            var segmentIsNotDisplayed = (segment_1.startXVal < firstDisplayedSegment.startXVal ||\r\n\t                segment_1.endXVal > lastDisplayedSegment.endXVal);\r\n\t            if (segmentIsNotDisplayed)\r\n\t                this.destroyCandle(Number(segmentId));\r\n\t        }\r\n\t        var segment = firstDisplayedSegment;\r\n\t        while (segment && segment.xVal <= lastDisplayedSegment.xVal) {\r\n\t            this.setupCandle(segment.id, segment.currentAnimationState);\r\n\t            segment = segment.getNext();\r\n\t        }\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.destroyCandles = function () {\r\n\t        for (var segmentId in this.candles)\r\n\t            this.destroyCandle(Number(segmentId));\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.destroyCandle = function (segmentId) {\r\n\t        var candle = this.candles[segmentId];\r\n\t        this.object3D.remove(candle.getObject3D());\r\n\t        delete this.candles[segmentId];\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.onZoomFrame = function (options) {\r\n\t        var currentScale = this.object3D.scale;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(this.scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(this.scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.onSegmentsAnimate = function (trendSegments) {\r\n\t        for (var _i = 0, _a = trendSegments.animatedSegmentsIds; _i < _a.length; _i++) {\r\n\t            var segmentId = _a[_i];\r\n\t            if (!this.candles[segmentId])\r\n\t                continue;\r\n\t            var segmentState = trendSegments.segmentsById[segmentId].currentAnimationState;\r\n\t            this.setupCandle(segmentId, segmentState);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * create or modify candle\r\n\t     */\r\n\t    TrendCandlesWidget.prototype.setupCandle = function (candleId, segmentState) {\r\n\t        var candleInd = candleId % MAX_CANDLES;\r\n\t        // get candle from candlesPool to avoid creating new Objects by performance reasons\r\n\t        var candle = this.candlesPool[candleInd];\r\n\t        if (!candle) {\r\n\t            candle = this.candlesPool[candleInd] = new CandleWidget();\r\n\t        }\r\n\t        if (!this.candles[candleId]) {\r\n\t            this.candles[candleId] = candle;\r\n\t            this.object3D.add(candle.getObject3D());\r\n\t        }\r\n\t        candle.getObject3D().position.set(this.toLocalX(segmentState.xVal), this.toLocalY(segmentState.yVal), 0);\r\n\t        candle.setSegment(segmentState);\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chart.data.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chart.data.yAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalVec = function (vec) {\r\n\t        return new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\r\n\t    };\r\n\t    return TrendCandlesWidget;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendCandlesWidget = TrendCandlesWidget;\r\n\tvar CandleWidget = (function () {\r\n\t    function CandleWidget() {\r\n\t        this.initObject();\r\n\t    }\r\n\t    CandleWidget.prototype.getObject3D = function () {\r\n\t        return this.rect;\r\n\t    };\r\n\t    CandleWidget.prototype.setSegment = function (segment) {\r\n\t        this.segment = segment;\r\n\t        var color = segment.endYVal < segment.startYVal ? FALL_COLOR : RISE_COLOR;\r\n\t        // update rect\r\n\t        var geometry = this.rect.geometry;\r\n\t        var material = this.rect.material;\r\n\t        var width = segment.endXVal - segment.startXVal;\r\n\t        width -= width * MARGIN_PERCENT;\r\n\t        var height = Math.max(segment.startYVal, segment.endYVal) - Math.min(segment.startYVal, segment.endYVal);\r\n\t        var _a = geometry.vertices, leftTop = _a[0], rightTop = _a[1], leftBottom = _a[2], rightBottom = _a[3];\r\n\t        leftTop.set(-width / 2, height / 2, 0);\r\n\t        rightTop.set(width / 2, height / 2, 0);\r\n\t        leftBottom.set(-width / 2, -height / 2, 0);\r\n\t        rightBottom.set(width / 2, -height / 2, 0);\r\n\t        // prevent to draw bars with height < 1px\r\n\t        if (Utils_1.Utils.getDistance(leftTop.y, leftBottom.y) < 1) {\r\n\t            leftBottom.setY(leftBottom.y + 1);\r\n\t            rightBottom.setY(rightBottom.y + 1);\r\n\t        }\r\n\t        material.color.set(color);\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t        // update lines\r\n\t        var vLineGeometry = this.vLine.geometry;\r\n\t        var vLineMaterial = this.vLine.material;\r\n\t        var lineTop = segment.maxYVal - segment.yVal;\r\n\t        var lineBottom = segment.minYVal - segment.yVal;\r\n\t        vLineGeometry.vertices[0].set(0, lineTop, 0);\r\n\t        vLineGeometry.vertices[1].set(0, lineBottom, 0);\r\n\t        vLineMaterial.color.set(color);\r\n\t        vLineGeometry.verticesNeedUpdate = true;\r\n\t        var hLineGeometry = this.hLine.geometry;\r\n\t        var hLineMaterial = this.hLine.material;\r\n\t        var lineLeft = (-width) / 2;\r\n\t        var lineRight = width / 2;\r\n\t        hLineGeometry.vertices[0].set(lineLeft, 0, 0);\r\n\t        hLineGeometry.vertices[1].set(lineRight, 0, 0);\r\n\t        hLineMaterial.color.set(color);\r\n\t        hLineGeometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    CandleWidget.prototype.initObject = function () {\r\n\t        this.rect = new Mesh(new PlaneGeometry(1, 1), new MeshBasicMaterial());\r\n\t        var vLineGeometry = new Geometry();\r\n\t        var hLineGeometry = new Geometry();\r\n\t        vLineGeometry.vertices.push(new Vector3(), new Vector3);\r\n\t        hLineGeometry.vertices.push(new Vector3(), new Vector3);\r\n\t        this.vLine = new Line(vLineGeometry, new LineBasicMaterial({ linewidth: 1 }));\r\n\t        this.hLine = new Line(hLineGeometry, new LineBasicMaterial({ linewidth: 1 }));\r\n\t        this.rect.add(this.vLine);\r\n\t        this.rect.add(this.hLine);\r\n\t    };\r\n\t    return CandleWidget;\r\n\t}());\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(5));\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** demoApp.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 78dbd4b5273eed6036e9\n **/","// import { Chart, AXIS_RANGE_TYPE, ITrendItem, Utils, AXIS_DATA_TYPE, TREND_TYPE } from 'three-charts';\nimport { ChartView, AXIS_RANGE_TYPE, ITrendItem, Utils, AXIS_DATA_TYPE, TREND_TYPE } from '../src';\n// import { TREND_MARK_SIDE, ITrendMarkOptions, TrendsMarksPlugin } from '../plugins/build/TrendsMarksPlugin';\n// import { TrendsBeaconWidget } from '../plugins/build/TrendsBeaconWidget';\n// import { TrendsLoadingWidget } from '../plugins/build/TrendsLoadingWidget';\n// import { TrendsIndicatorWidget } from '../plugins/build/TrendsIndicatorWidget';\n//\n//\n//\n// Chart.preinstalledWidgets.push(TrendsLoadingWidget, TrendsBeaconWidget, TrendsIndicatorWidget);\n\nvar chart: ChartView;\n\nclass DataSourse {\n\tdata: ITrendItem[] = [];\n\tstartTime: number;\n\tendTime: number;\n\n\tconstructor() {\n\t\tlet sec = 0;\n\t\tlet val = 70;\n\t\tthis.startTime = Date.now();\n\n\t\twhile (sec < 100) { //2592000\n\t\t\tthis.data.push({\n\t\t\t\txVal: this.startTime + sec * 1000,\n\t\t\t\tyVal: val\n\t\t\t});\n\t\t\tval += Math.random() * 14 - 7;\n\t\t\tsec++;\n\t\t}\n\t\tthis.endTime = this.data[this.data.length - 1].xVal;\n\t}\n\n\tgetData() {\n\t\treturn Utils.deepCopy(this.data);\n\t}\n\n\tgetNext() {\n\t\tvar lastVal = this.data[this.data.length - 1];\n\t\tvar yVal = lastVal.yVal + Math.random() * 14 - 7;\n\t\tvar xVal = this.endTime + 1000;\n\t\tthis.endTime = xVal;\n\t\tvar item = {\n\t\t\txVal: xVal,\n\t\t\tyVal: yVal\n\t\t};\n\t\tthis.data.push(item);\n\t\treturn item;\n\t}\n\n\tgetPrev() {\n\t\tvar firstVal = this.data[0];\n\t\tvar yVal = firstVal.yVal + Math.random() * 14 - 7;\n\t\tvar xVal = this.startTime - 1000;\n\t\tthis.startTime = xVal;\n\t\tvar item = {\n\t\t\txVal: xVal,\n\t\t\tyVal: yVal\n\t\t};\n\t\tthis.data.unshift(item);\n\t\treturn item;\n\t}\n}\n\n// class MarksSource {\n// \tstatic getNext(val: number): ITrendMarkOptions {\n// \t\tif (Math.random() > 0.2) return null;\n// \t\treturn this.generate(val);\n// \t}\n//\n// \tstatic generate(val: number): ITrendMarkOptions {\n// \t\tlet descriptionColor = 'rgb(40,136,75)';\n// \t\tlet orientation =  Utils.getRandomItem([TREND_MARK_SIDE.TOP, TREND_MARK_SIDE.BOTTOM]);\n// \t\tif (orientation == TREND_MARK_SIDE.BOTTOM) {\n// \t\t\tdescriptionColor = 'rgb(219,73,49)';\n// \t\t}\n//\n// \t\treturn {\n// \t\t\ttrendName: 'main',\n// \t\t\tvalue: val,\n// \t\t\ttitle: Utils.getRandomItem(['Alex Malcon', 'Serg Morrs', 'Harry Potter']),\n// \t\t\tdescription: Utils.getRandomItem(['$10 -> 20$', '$15 -> 30$', '40$ -> 80$']),\n// \t\t\ticon: Utils.getRandomItem(['AM', 'SM', 'HP']),\n// \t\t\ticonColor: Utils.getRandomItem(['rgb(69,67,130)', 'rgb(124,39,122)']),\n// \t\t\torientation: orientation,\n// \t\t\tdescriptionColor: descriptionColor\n// \t\t}\n// \t}\n// }\n\nwindow.onload = function () {\n\n\tinitListeners();\n\n\tvar dsMain = new DataSourse();\n\tvar dsRed = new DataSourse();\n\tvar dsBlue = new DataSourse();\n\tvar now = Date.now();\n\n\n\n\tchart = new ChartView({\n\t\tyAxis: {\n\t\t\tmarks: [\n\t\t\t\t{value: dsMain.data[0].yVal, name: 'openprice', title: 'OPEN PRICE', lineColor: '#29874b', stickToEdges: true},\n\t\t\t],\n\t\t\trange: {\n\n\t\t\t\tpadding: {end: 100, start: 100},\n\t\t\t\tmargin: {end: 50, start: 50},\n\t\t\t\tzeroVal: 70\n\t\t\t}\n\t\t},\n\t\txAxis: {\n\t\t\t//range: {type: AXIS_RANGE_TYPE.FIXED, from: 10, to: 30},\n\t\t\tdataType: AXIS_DATA_TYPE.DATE,\n\t\t\trange: {\n\t\t\t\ttype: AXIS_RANGE_TYPE.FIXED,\n\t\t\t\tfrom: Date.now(),\n\t\t\t\tto: Date.now() + 20000,\n\t\t\t\tpadding: {end: 200, start: 0},\n\t\t\t\tmaxLength: 5000000,\n\t\t\t\tminLength: 5000\n\t\t\t},\n\t\t\tmarks: [\n\t\t\t\t{value: dsMain.endTime + 30000, name: 'deadline', title: 'DEADLINE', lineColor: '#ff6600', type: 'timeleft', showValue: true},\n\t\t\t\t{value: dsMain.endTime + 40000, name: 'close', title: 'CLOSE', lineColor: '#005187', type: 'timeleft', showValue: true}\n\t\t\t]\n\t\t\t// range: {\n\t\t\t// \tfrom: 80,\n\t\t\t// \tto: 90\n\t\t\t// }\n\t\t},\n\t\ttrends: {\n\t\t\t'main': {\n\t\t\t\ttype: TREND_TYPE.LINE,\n\t\t\t\tdataset: dsMain.getData(),\n\t\t\t\thasBeacon: true,\n\t\t\t\thasIndicator: true,\n\t\t\t\thasBackground: true,\n\t\t\t},\n\t\t\t// 'red': {dataset: dsRed.data, lineColor: 0xFF2222, lineWidth: 2, hasGradient: false, hasIndicator: true, enabled: false},\n\t\t\t// 'blue': {dataset: dsBlue.data, lineColor: 0x2222FF, lineWidth: 2, hasGradient: false, hasIndicator: true, enabled: false},\n\t\t},\n\t\tshowStats: true,\n\t\t// autoRender: {fps: 100},\n\t\t// animations: {enabled: false},\n\n\t\ttrendDefaultState: {\n\t\t\tsettingsForTypes: {\n\t\t\t\tLINE: {\n\t\t\t\t\tminSegmentLengthInPx: 10\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tdocument.querySelector('.chart')\n\t// \t,\n\t// [\n\t// \tnew TrendsMarksPlugin({items: [MarksSource.generate(now + 3000), MarksSource.generate(now + 3000), MarksSource.generate(now + 4000)]})\n\t// ]\n\t);\n\n\tchart.setState({animations: {enabled: false}});\n\tchart.setState({animations: {enabled: true}});\n\t\n\t(<any>window)['chart'] = chart;\n\n\tvar mainTrend = chart.getTrend('main');\n\tvar deadlineMark = chart.state.xAxisMarks.getItem('deadline');\n\tvar closeMark = chart.state.xAxisMarks.getItem('close');\n\n\tmainTrend.onDataChange(() => {\n\t\tvar closeValue = closeMark.options.value;\n\t\tif (mainTrend.getLastItem().xVal >= closeValue) {\n\t\t\tdeadlineMark.setOptions({value: closeValue + 10000});\n\t\t\tcloseMark.setOptions({value: closeValue + 20000})\n\t\t}\n\t\t// var markOptions = MarksSource.getNext(mainTrend.getLastItem().xVal);\n\t\t// if (markOptions) setTimeout(() => {\n\t\t// \tlet trendsMarks = chart.state.getPlugin(TrendsMarksPlugin.NAME) as TrendsMarksPlugin;\n\t\t// \ttrendsMarks.createMark(markOptions);\n\t\t// }, 500);\n\t});\n\n\n\t// var previewChart1 = ChartView.createPreviewChart({\n\t// \t$el: document.querySelectorAll('.preview-chart')[0],\n\t// \tyAxis: {\n\t// \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 20, to: 150}\n\t// \t},\n\t// \txAxis: {\n\t// \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 100}\n\t// \t},\n\t// \ttrends: {\n\t// \t\t'main': {dataset: dsMain.data, hasBeacon: true}\n\t// \t}\n\t// });\n\t//\n\t// var previewChart2 = ChartView.createPreviewChart({\n\t// \t$el: document.querySelectorAll('.preview-chart')[1],\n\t// \tyAxis: {\n\t// \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 200}\n\t// \t},\n\t// \txAxis: {\n\t// \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 200}\n\t// \t},\n\t// \ttrends: {\n\t// \t\t'main': {dataset: dsMain.data, hasBeacon: true}\n\t// \t},\n\t//\n\t// });\n\t//\n\t// var previewChart3 = ChartView.createPreviewChart({\n\t// \t$el: document.querySelectorAll('.preview-chart')[2],\n\t// \tyAxis: {\n\t// \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 100}\n\t// \t},\n\t// \txAxis: {\n\t// \t\trange: {type: AXIS_RANGE_TYPE.FIXED, from: 0, to: 80}\n\t// \t},\n\t// \ttrends: {\n\t// \t\t'main': {dataset: dsMain.data, hasBeacon: true},\n\t// \t\t'red': {dataset: dsRed.data, lineColor: 0xFF2222},\n\t// \t}\n\t// });\n\t//\n\n\tvar i = 0;\n\n\tchart.getTrend('main').onPrependRequest((requestedLength, resolve, reject) => {\n\t\tvar responseData: ITrendItem[] = [];\n\t\tvar ticksCount = Math.round(requestedLength / 1000) ;\n\t\twhile (ticksCount--) responseData.unshift(dsMain.getPrev());\n\t\tsetTimeout(() => {\n\t\t\tresolve(responseData);\n\t\t}, 2000)\n\t});\n\n\tsetInterval(() => {\n\t\ti++;\n\t\tvar val = dsMain.getNext();\n\n\t\t// [i % 2 ? 10 : 20]\n\n\t\t chart.getTrend('main').appendData([val]);\n\t\t// chart.getTrend('main').prependData([dsMain.getPrev(), dsMain.getPrev()].reverse());\n\t\t// chart.getTrend('main').appendData([val, dsMain.getNext(), dsMain.getNext(), dsMain.getNext(), dsMain.getNext()]);\n\t\t// chart.getTrend('main').prependData([val, dsMain.getNext(), dsMain.getNext(), dsMain.getNext()]);\n\t\t// chart.getTrend('red').appendData([val + 10 + Math.random() * 20]);\n\t\t// chart.getTrend('blue').appendData([val + 20 + Math.random() * 20]);\n\n\n\n\t\t// previewChart1.getTrend('main').appendData([val]);\n\t\t// previewChart2.getTrend('main').appendData([val + 10 + Math.random() * 20]);\n\t\t// previewChart3.getTrend('red').appendData([val + 20 + Math.random() * 20]);\n\t\t\n\t\t// previewChart1.appendData(dataToAppend1);\n\t\t//\n\t\t// var chartData2 = previewChart2.state.data.trends[0].data;\n\t\t// var lastItem2 = chartData2[chartData.length - 1];\n\t\t// var dataToAppend2 = [\n\t\t// \t{xVal: lastItem2.xVal + 1, yVal: lastItem2.yVal + Math.random() * 14 - 7 },\n\t\t// ];\n\t\t// previewChart2.appendData(dataToAppend2);\n\t\t// previewChart3.appendData(dataToAppend2);\n\t}, 1000);\n};\n\n\nfunction initListeners() {\n\tvar $checkboxMaintrend = document.querySelector('input[name=\"maintrend\"]') as HTMLInputElement;\n\t$checkboxMaintrend.addEventListener('change', () => {\n\t\tchart.setState({trends: {main: {enabled: $checkboxMaintrend.checked}}});\n\t});\n\tvar $checkboxRedtrend = document.querySelector('input[name=\"redtrend\"]') as HTMLInputElement;\n\t$checkboxRedtrend.addEventListener('change', () => {\n\t\tchart.setState({trends: {red: {enabled: $checkboxRedtrend.checked}}});\n\t});\n\tvar $checkboxBluetrend = document.querySelector('input[name=\"bluetrend\"]') as HTMLInputElement;\n\t$checkboxBluetrend.addEventListener('change', () => {\n\t\tchart.setState({trends: {blue: {enabled: $checkboxBluetrend.checked}}});\n\t});\n\n\tvar $switchLineBtn = document.querySelector('[name=\"switch-line\"]') as HTMLInputElement;\n\t$switchLineBtn.addEventListener('click', () => {\n\t\tchart.getTrend('main').setOptions({type: TREND_TYPE.LINE});\n\t});\n\n\tvar $switchBarsBtn = document.querySelector('[name=\"switch-bars\"]') as HTMLInputElement;\n\t$switchBarsBtn.addEventListener('click', () => {\n\t\tchart.getTrend('main').setOptions({type: TREND_TYPE.CANDLE});\n\t});\n\n\tdocument.querySelector('[name=\"move-left\"]').addEventListener('click', () => {\n\t\tlet currentRange = chart.state.data.xAxis.range;\n\t\tchart.setState({xAxis: {range: {from: currentRange.from - 2000}}});\n\t});\n\n\tdocument.querySelector('[name=\"move-right\"]').addEventListener('click', () => {\n\t\tlet currentRange = chart.state.data.xAxis.range;\n\t\tchart.setState({xAxis: {range: {to: currentRange.to + 2000}}});\n\t});\n\t\n\tvar timeframeButtons = document.querySelectorAll(\".timeframe\");\n\tfor (var i = 0; i < timeframeButtons.length; i++) {\n\t\ttimeframeButtons[i].addEventListener(\"click\", function() {\n\t\t\tvar range = Number(this.getAttribute('data-range'));\n\t\t\tvar segmentLength = Number(this.getAttribute('data-segment-length'));\n\n\n\t\t\tchart.state.setState({autoScroll: false});\n\t\t\tchart.state.zoomToRange(range);\n\t\t\tchart.state.scrollToEnd().then(() => {\n\t\t\t\tchart.state.setState({autoScroll: true});\n\t\t\t});\n\t\t});\n\t}\n}\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./demo/demoApp.ts\n **/","export * from './ChartView';\nexport * from './interfaces';\nexport * from './AxisMarks';\nexport * from './Screen';\nexport * from './Chart';\nexport * from './Trend';\nexport * from './TrendSegmentsManager';\nexport * from './TrendsManager';\nexport * from './Utils';\nexport * from './Widget';\nexport * from './Plugin';\nexport * from './Color';\nexport * from './widgets/TrendsWidget';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.ts\n **/","// deps must be always on top\nimport { ChartPlugin } from './Plugin';\nrequire('./deps/deps');\n\nimport { Trend } from \"./Trend\";\nimport Vector3 = THREE.Vector3;\nimport PerspectiveCamera = THREE.PerspectiveCamera;\nimport Scene = THREE.Scene;\nimport Renderer = THREE.Renderer;\nimport WebGLRenderer = THREE.WebGLRenderer;\nimport Object3D = THREE.Object3D;\nimport { Chart, IChartState } from \"./Chart\";\nimport { ChartWidget, IChartWidgetConstructor } from \"./Widget\";\nimport { Utils } from \"./Utils\";\nimport { IScreenTransformOptions } from \"./Screen\";\nimport { AxisWidget } from \"./widgets/AxisWidget\";\nimport { GridWidget } from \"./widgets/GridWidget\";\nimport { TrendsGradientWidget } from \"./widgets/TrendsGradientWidget\";\nimport { TrendsLineWidget } from \"./widgets/TrendsLineWidget\";\nimport { TrendsCandlesWidget } from './widgets/TrendsCandleWidget';\nimport { ResizeSensor, ResizeSensorType } from './deps';\nimport OrthographicCamera = THREE.OrthographicCamera;\n\n\nexport class ChartView {\n\n\tstatic devicePixelRatio = window.devicePixelRatio;\n\tstatic preinstalledWidgets: typeof ChartWidget[] = [];\n\tstatic renderers: {[rendererName: string]: any} = {\n\t\tCanvasRenderer: (THREE as any).CanvasRenderer,\n\t\tWebGLRenderer: THREE.WebGLRenderer\n\t};\n\n\tstate: Chart;\n\tisStopped: boolean;\n\tisDestroyed: boolean;\n\tprivate $container: Element;\n\tprivate $el: HTMLElement;\n\tprivate renderer: Renderer;\n\tprivate scene: Scene;\n\tprivate camera: PerspectiveCamera;\n\tprivate cameraInitialPosition: Vector3;\n\tprivate widgets: Array<ChartWidget> = [];\n\tprivate stats: Stats;\n\tprivate zoomThrottled: Function;\n\tprivate unsubscribers: Function[];\n\tprivate resizeSensor: ResizeSensorType;\n\tprivate pluginsAndWidgets: Array<ChartPlugin | ChartWidget>;\n\n\tconstructor(state: IChartState, $container: Element, pluginsAndWidgets: Array<ChartPlugin | ChartWidget> = []) {\n\n\t\tif (!THREE || !THREE.REVISION) Utils.error('three.js not found');\n\n\t\tif (!$container) {\n\t\t\tUtils.error('$el must be set');\n\t\t}\n\t\t// calculate chart size\n\t\tlet style = getComputedStyle($container);\n\t\tstate.width = parseInt(style.width);\n\t\tstate.height = parseInt(style.height);\n\n\t\tlet plugins = pluginsAndWidgets.filter(pluginOrWidget => pluginOrWidget instanceof ChartPlugin) as ChartPlugin[];\n\n\t\tthis.state = new Chart(state, plugins);\n\t\tthis.pluginsAndWidgets = pluginsAndWidgets;\n\t\tthis.zoomThrottled = Utils.throttle((zoomValue: number, origin: number) => this.zoom(zoomValue, origin), 200);\n\t\tthis.$container = $container;\n\t\tthis.init($container);\n\t};\n\n\tprivate init($container: Element) {\n\t\tvar state = this.state;\n\t\tvar {width: w, height: h, showStats, autoRender} = state.data;\n\t\tthis.scene = new THREE.Scene();\n\t\tthis.isStopped = !autoRender.enabled;\n\n\t\tvar renderer = this.renderer = new (ChartView.renderers[this.state.data.renderer] as any)({\n\t\t\tantialias: true,\n\t\t\talpha: true\n\t\t});\n\t\trenderer.setSize(w, h);\n\t\trenderer.setPixelRatio(ChartView.devicePixelRatio);\n\t\trenderer.setClearColor(state.data.backgroundColor, state.data.backgroundOpacity);\n\t\t$container.appendChild(renderer.domElement);\n\t\tthis.$el = renderer.domElement;\n\t\tthis.$el.style.display = 'block';\n\n\t\tif (showStats) {\n\t\t\tthis.stats = new Stats();\n\t\t\t$container.appendChild(this.stats.domElement);\n\t\t}\n\n\t\tthis.setupCamera();\n\t\tthis.initWidgets();\n\t\tthis.bindEvents();\n\t\tthis.renderLoop();\n\t}\n\n\t/**\n\t * collect and init widgets from preinstalled widgets, plugins widgets and custom widgets\n\t */\n\tprivate initWidgets() {\n\t\tlet preinstalledWidgetsClasses = (this.constructor as typeof ChartView).preinstalledWidgets;\n\t\tlet customWidgets: ChartWidget[] = [];\n\n\t\tthis.pluginsAndWidgets.forEach(pluginOrWidget => {\n\t\t\tif (pluginOrWidget instanceof ChartWidget) {\n\t\t\t\tcustomWidgets.push(pluginOrWidget);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(pluginOrWidget instanceof ChartPlugin)) return;\n\t\t\tlet pluginWidgetClasses = (pluginOrWidget.constructor as typeof ChartPlugin).providedWidgets;\n\t\t\tpreinstalledWidgetsClasses.push(...pluginWidgetClasses);\n\t\t});\n\n\t\tthis.widgets = customWidgets.concat(\n\t\t\tpreinstalledWidgetsClasses.map((WidgetClass: IChartWidgetConstructor) => new WidgetClass())\n\t\t);\n\n\t\tthis.widgets.forEach(widget => {\n\t\t\twidget.setupChartState(this.state);\n\t\t\twidget.onReadyHandler();\n\t\t\tthis.scene.add(widget.getObject3D());\n\t\t});\n\t}\n\n\tprivate renderLoop() {\n\t\tif (this.isDestroyed) return;\n\t\tthis.stats && this.stats.begin();\n\t\tthis.render();\n\t\tif (this.isStopped) return;\n\t\tvar fpsLimit = this.state.data.autoRender.fps;\n\n\t\tif (fpsLimit) {\n\t\t\tlet delay = 1000 / fpsLimit;\n\t\t\tsetTimeout(() => requestAnimationFrame(() => this.renderLoop()), delay);\n\t\t} else {\n\t\t\trequestAnimationFrame(() => this.renderLoop());\n\t\t}\n\t\tthis.stats && this.stats.end();\n\t}\n\n\trender() {\n\t\tthis.renderer.render(this.scene, this.camera);\n\t}\n\n\tstop() {\n\t\tthis.isStopped = true;\n\t}\n\n\trun() {\n\t\tthis.isStopped = false;\n\t\tthis.renderLoop();\n\t}\n\n\t/**\n\t * call to destroy chart an init garbage collection\n\t */\n\tdestroy() {\n\t\tthis.isDestroyed = true;\n\t\tthis.stop();\n\t\tthis.state.destroy();\n\t\tthis.unbindEvents();\n\t\t// WARNING! undocumented method for free webgl context\n\t\ttry {\n\t\t\t(this.renderer as any).forceContextLoss();\n\t\t} catch (wtf) {\n\t\t\t// sometimes with many chart instances forceContextLoss not working\n\t\t}\n\t\t(this.renderer as any).context = null;\n\t\tthis.renderer.domElement = null;\n\t\tthis.renderer = null;\n\t}\n\n\tgetState(): IChartState {\n\t\treturn this.state.data\n\t}\n\n\t/**\n\t * shortcut for ChartView.state.getTrend\n\t */\n\tgetTrend(trendName: string): Trend {\n\t\treturn this.state.getTrend(trendName);\n\t}\n\n\t/**\n\t * shortcut for ChartView.state.setState\n\t */\n\tsetState(state: IChartState) {\n\t\treturn this.state.setState(state);\n\t}\n\n\n\tprivate bindEvents() {\n\t\tvar $el = this.$el;\n\t\tif (this.state.data.controls.enabled) {\n\t\t\t$el.addEventListener('mousewheel', (ev: MouseWheelEvent) => {\n\t\t\t\tthis.onMouseWheel(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('mousemove', (ev: MouseEvent) => {\n\t\t\t\tthis.onMouseMove(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('mousedown', (ev: MouseEvent) => this.onMouseDown(ev));\n\t\t\t$el.addEventListener('mouseup', (ev: MouseEvent) => this.onMouseUp(ev));\n\t\t\t$el.addEventListener('touchmove', (ev: TouchEvent) => {\n\t\t\t\tthis.onTouchMove(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('touchend', (ev: TouchEvent) => {\n\t\t\t\tthis.onTouchEnd(ev)\n\t\t\t});\n\t\t}\n\t\tif (this.state.data.autoResize) {\n\t\t\tthis.resizeSensor = new ResizeSensor(this.$container, () => {\n\t\t\t\tthis.onChartContainerResizeHandler(this.$container.clientWidth, this.$container.clientHeight);\n\t\t\t});\n\t\t}\n\n\t\tthis.unsubscribers = [\n\t\t\tthis.state.onTrendsChange(() => this.autoscroll()),\n\t\t\tthis.state.screen.onTransformationFrame((options) => this.onScreenTransformHandler(options)),\n\t\t\tthis.state.onResize((options) => this.onChartResize())\n\t\t];\n\t}\n\n\tprivate unbindEvents() {\n\t\t// TODO: unbind events correctly\n\t\ttry {\n\t\t\tthis.resizeSensor && this.resizeSensor.detach();\n\t\t} catch (e) {\n\t\t\t// ups.. somebody already removed resizeSensor childNode\n\t\t\t// detected in angular2 apps\n\t\t}\n\t\tthis.$el.remove();\n\t\tthis.unsubscribers.forEach(unsubscribe => unsubscribe());\n\t}\n\n\tprivate setupCamera() {\n\t\tlet camSettings = this.state.screen.getCameraSettings();\n\t\tif (!this.camera) {\n\t\t\tthis.camera = new PerspectiveCamera(camSettings.FOV, camSettings.aspect, camSettings.near, camSettings.far);\n\t\t\tthis.scene.add(this.camera);\n\t\t} else {\n\t\t\tthis.camera.fov = camSettings.FOV;\n\t\t\tthis.camera.aspect = camSettings.aspect;\n\t\t\tthis.camera.far = camSettings.far;\n\t\t\tthis.camera.near = camSettings.near;\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t}\n\t\tthis.camera.position.set(camSettings.x, camSettings.y, camSettings.z);\n\t\tthis.cameraInitialPosition = this.camera.position.clone();\n\t\tthis.onScreenTransformHandler(this.state.screen.options);\n\t}\n\n\tprivate onScreenTransformHandler(options: IScreenTransformOptions) {\n\t\tif (options.scrollX != void 0) {\n\t\t\tlet scrollX = this.cameraInitialPosition.x + options.scrollX;\n\t\t\t// scrollX =  Math.round(scrollX); // prevent to set camera beetween pixels\n\t\t\tthis.camera.position.setX(scrollX);\n\t\t}\n\t\tif (options.scrollY != void 0) {\n\t\t\tlet scrollY = this.cameraInitialPosition.y + options.scrollY;\n\t\t\t// scrollY = Math.round(scrollY); // prevent to set camera beetween pixels\n\t\t\tthis.camera.position.setY(scrollY);\n\t\t}\n\t}\n\n\tprivate autoscroll() {\n\t\tvar state = this.state;\n\t\tif (!state.data.autoScroll) return;\n\t\tvar oldTrendsMaxX = state.data.prevState.computedData.trends.maxXVal;\n\t\tvar trendsMaxXDelta = state.data.computedData.trends.maxXVal - oldTrendsMaxX;\n\t\tif (trendsMaxXDelta > 0) {\n\t\t\tvar maxVisibleX = this.state.screen.getScreenRightVal();\n\t\t\tvar paddingRightX = this.state.getPaddingRight();\n\t\t\tvar currentScroll = state.data.xAxis.range.scroll;\n\t\t\tif (oldTrendsMaxX < paddingRightX || oldTrendsMaxX > maxVisibleX) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar scrollDelta = trendsMaxXDelta;\n\t\t\tthis.setState({xAxis: {range: {scroll: currentScroll + scrollDelta}}});\n\t\t}\n\t}\n\n\tprivate onScrollStop() {\n\t\t// var tendsXMax = this.state.data.computedData.trends.maxX;\n\t\t// var paddingRightX = this.state.getPaddingRight();\n\t\t// if (tendsXMax < paddingRightX) {\n\t\t// \tthis.state.scrollToEnd();\n\t\t// }\n\t}\n\n\tprivate onMouseDown(ev: MouseEvent) {\n\t\tthis.setState({cursor: {dragMode: true, x: ev.clientX, y: ev.clientY}});\n\t}\n\n\tprivate onMouseUp(ev: MouseEvent) {\n\t\tthis.setState({cursor: {dragMode: false}});\n\t}\n\n\tprivate onMouseMove(ev: MouseEvent) {\n\t\tif (this.state.data.cursor.dragMode) {\n\t\t\tthis.setState({cursor: {dragMode: true, x: ev.clientX, y: ev.clientY}});\n\t\t}\n\t}\n\n\tprivate onMouseWheel(ev: MouseWheelEvent) {\n\t\tev.stopPropagation();\n\t\tev.preventDefault();\n\t\tlet zoomOrigin = ev.layerX / this.state.data.width;\n\t\tlet zoomValue = 1 + ev.wheelDeltaY * 0.001;\n\t\tthis.zoom(zoomValue, zoomOrigin);\n\t}\n\n\tprivate onTouchMove(ev: TouchEvent) {\n\t\tthis.setState({cursor: {dragMode: true, x: ev.touches[0].clientX, y: ev.touches[0].clientY}});\n\t}\n\n\tprivate onTouchEnd(ev: TouchEvent) {\n\t\tthis.setState({cursor: {dragMode: false}});\n\t}\n\n\tprivate onChartContainerResizeHandler(width: number, height: number) {\n\t\tthis.setState({width, height});\n\t}\n\n\tprivate onChartResize() {\n\t\tlet {width, height} = this.state.data;\n\t\tthis.renderer.setSize(width, height);\n\t\tthis.setupCamera();\n\t}\n\n\tprivate zoom(zoomValue: number, zoomOrigin: number) {\n\t\tconst MAX_ZOOM_VALUE = 1.5;\n\t\tconst MIN_ZOOM_VALUE = 0.7;\n\t\tzoomValue = Math.min(zoomValue, MAX_ZOOM_VALUE);\n\t\tzoomValue = Math.max(zoomValue, MIN_ZOOM_VALUE);\n\t\tlet autoScrollIsEnabled = this.state.data.autoScroll;\n\t\tif (autoScrollIsEnabled) this.state.setState({autoScroll: false});\n\t\tthis.state.zoom(zoomValue, zoomOrigin).then(() => {\n\t\t\tif (autoScrollIsEnabled) this.setState({autoScroll: true});\n\t\t});\n\t}\n\n\n}\n\n// install built-in widgets\nChartView.preinstalledWidgets = [\n\tTrendsLineWidget,\n\tTrendsCandlesWidget,\n\tAxisWidget,\n\tGridWidget,\n\tTrendsGradientWidget\n];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ChartView.ts\n **/","import { Chart, IChartState } from \"./Chart\";\nimport { Utils } from './Utils';\nimport { EventEmitter } from './EventEmmiter';\nimport { ChartWidget } from './Widget';\n\nexport interface IChartPluginState {\n}\n\nexport interface IChartPluginConfig {\n\tinstallPluginWidgets?: boolean;\n}\n\nexport const DEFAULT_CONFIG: IChartPluginConfig = {\n\tinstallPluginWidgets: true\n};\n\n/**\n * base class for all plugins\n * NAME is mandatory\n */\nexport abstract class ChartPlugin {\n\tstatic NAME: string = '';\n\tstatic providedWidgets: typeof ChartWidget[] = [];\n\n\tinitialState: IChartPluginState;\n\tconfig: IChartPluginConfig;\n\tname: string;\n\tprotected chartState: Chart;\n\tprotected unsubscribers: Function[] = [];\n\tprotected ee: EventEmitter;\n\n\tconstructor (options?: IChartPluginState, config: IChartPluginConfig = {}) {\n\t\tthis.initialState = options;\n\t\tthis.config = Utils.deepMerge(DEFAULT_CONFIG, config);\n\t\tthis.name = (this.constructor as typeof ChartPlugin).NAME;\n\t\tif (!this.name) Utils.error('Unnamed plugin detected');\n\t}\n\n\tsetupChartState(chartState: Chart) {\n\t\tthis.chartState = chartState;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.bindEvent(\n\t\t\tthis.chartState.onInitialStateApplied(initialState => this.onInitialStateAppliedHandler(initialState)),\n\t\t\tthis.chartState.onReady(() => this.onReadyHandler()),\n\t\t\tthis.chartState.onDestroy(() => this.onDestroyHandler()),\n\t\t\tthis.chartState.onPluginsStateChange(changedPluginsStates => changedPluginsStates[this.name] && this.onStateChanged(changedPluginsStates[this.name]))\n\t\t)\n\t}\n\n\tgetOptions(): IChartPluginState {\n\t\treturn this.chartState.data.pluginsState[this.name];\n\t}\n\n\tprotected onInitialStateAppliedHandler(initialState: IChartState) {\n\t}\n\n\tprotected onReadyHandler() {\n\t}\n\n\tprotected onStateChanged(changedState: IChartPluginState) {\n\t}\n\n\tprotected onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t}\n\n\tprotected bindEvent(...args: Array<Function | Function[]>): void {\n\t\tlet unsubscribers: Function[] = [];\n\t\tif (!Array.isArray(args[0])) {\n\t\t\tunsubscribers.push(args[0] as Function);\n\t\t} else {\n\t\t\tunsubscribers.push(...args as Function[]);\n\t\t}\n\t\tthis.unsubscribers.push(...unsubscribers);\n\t}\n\n\n\tprotected unbindEvents() {\n\t\tthis.unsubscribers.forEach(unsubscriber => unsubscriber());\n\t\tthis.unsubscribers.length = 0;\n\t}\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Plugin.ts\n **/","import Texture = THREE.Texture;\nimport Color = THREE.Color;\nimport { TIteralable, IIteralable } from \"./interfaces\";\nimport { isPlainObject } from './deps/deps';\n\nfunction deepmerge(target: any, src: any, mergeArrays = true) {\n\tvar array = Array.isArray(src);\n\tvar dst: any = array && [] || {};\n\n\tif (array) {\n\t\ttarget = target || [];\n\t\tif (mergeArrays) {\n\t\t\tdst = dst.concat(target);\n\t\t}\n\t\tsrc.forEach(function(e: any, i: any) {\n\t\t\tif (typeof dst[i] === 'undefined') {\n\t\t\t\tdst[i] = e;\n\t\t\t} else if (typeof e === 'object') {\n\t\t\t\tdst[i] = deepmerge(target[i], e, mergeArrays);\n\t\t\t} else {\n\t\t\t\tif (target.indexOf(e) === -1) {\n\t\t\t\t\tdst.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} else {\n\t\tif (target && typeof target === 'object') {\n\t\t\tObject.keys(target).forEach(function (key) {\n\t\t\t\tdst[key] = target[key];\n\t\t\t})\n\t\t}\n\t\tObject.keys(src).forEach(function (key) {\n\t\t\tif (typeof src[key] !== 'object' || !src[key]) {\n\t\t\t\tdst[key] = src[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t} else {\n\t\t\t\t\tdst[key] = deepmerge(target[key], src[key], mergeArrays);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn dst;\n}\n\n\n\nexport declare type TUid = number;\n\n/**\n * project utils static class\n */\nexport class Utils {\n\n\tprivate static currentId: TUid = 1;\n\n\t/**\n\t * deepMerge based on https://www.npmjs.com/package/deepmerge\n\t */\n\tstatic deepMerge<T> (obj1: T, obj2: T, mergeArrays?: boolean) {\n\t\treturn deepmerge(obj1, obj2, mergeArrays) as T;\n\t}\n\n\t/**\n\t * deepCopy based on JSON.stringify function\n\t * @deprecated\n\t */\n\tstatic deepCopy<T> (obj: T) {\n\t\t// TODO: use deepMerge function to copy\n\t\treturn JSON.parse(JSON.stringify(obj)) as T;\n\t}\n\n\t/**\n\t *\n\t * @example\n\t * // returns \"000015\"\n\t * Utils.toFixed(15, 6);\n\t */\n\tstatic toFixed(num: number, digitsCount: number): string {\n\t\tvar maxDigits = 15;\n\t\tvar result = '';\n\t\tvar intVal = Math.floor(num);\n\t\tvar intStr = intVal.toString();\n\t\tvar lengthDiff = digitsCount - intStr.length;\n\t\tif (lengthDiff > 0 ) {\n\t\t\tresult = (<any>'0').repeat(lengthDiff) + intStr;\n\t\t} else {\n\t\t\tresult = intStr;\n\t\t}\n\t\tvar afterPointDigitsCount = maxDigits - intStr.length;\n\t\tvar afterPointStr = num.toString().split('.')[1];\n\t\tif (afterPointStr) {\n\t\t\tresult += '.' + afterPointStr.substr(0, afterPointDigitsCount);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic bindEvent() {\n\n\t}\n\n\t/**\n\t * generate texture from canvas context\n\t * @example\n\t * \t// create texture with rect\n\t *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\n\t */\n\tstatic createTexture(width: number, height: number, fn: (ctx: CanvasRenderingContext2D) => void ): Texture {\n\t\tvar canvas: HTMLCanvasElement = document.createElement('canvas');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\tvar ctx = canvas.getContext('2d');\n\t\tfn(ctx);\n\t\tvar texture = new THREE.Texture(canvas);\n\t\ttexture.needsUpdate = true;\n\t\treturn texture;\n\t}\n\n\t/**\n\t * generate texture from canvas context with NearestFilter\n\t * @example\n\t * \t// create texture with rect\n\t *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\n\t */\n\tstatic createPixelPerfectTexture(width: number, height: number, fn: (ctx: CanvasRenderingContext2D) => void ): Texture{\n\t\tvar texture = this.createTexture(width, height, fn);\n\t\t// texture.magFilter = THREE.NearestFilter;\n\t\ttexture.minFilter = THREE.NearestFilter;\n\t\treturn texture;\n\t}\n\n\t/**\n\t * throw error\n\t */\n\tstatic error(msg: string) {\n\t\tconsole.error('Chart error: ' + msg);\n\t\tthrow 'Chart: ' + msg;\n\t}\n\n\t/**\n\t * throw error\n\t */\n\tstatic warn(msg: string) {\n\t\tconsole.warn('Chart warning: ' + msg);\n\t}\n\n\t/**\n\t * @returns new unique id\n\t */\n\tstatic getUid(): TUid {\n\t\treturn this.currentId++;\n\t}\n\n\t/**\n\t * @returns distance between numbers\n\t */\n\tstatic getDistance(num1: number, num2: number) {\n\t\treturn Math.max(num1, num2) - Math.min(num1, num2);\n\t}\n\n\tstatic binarySearchClosestInd(arr: IIteralable[], num: number, key: string): number {\n\t\tvar mid: number;\n\t\tvar lo = 0;\n\t\tvar hi = arr.length - 1;\n\t\twhile (hi - lo > 1) {\n\t\t\tmid = Math.floor ((lo + hi) / 2);\n\t\t\tif (arr[mid][key] < num) {\n\t\t\t\tlo = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\tif (num - arr[lo][key] <= arr[hi][key] - num) {\n\t\t\treturn lo;\n\t\t}\n\t\treturn hi;\n\t}\n\t\n\tstatic binarySearchClosest<ArrayItem>(arr: ArrayItem[], num: number, key: string): ArrayItem {\n\t\tlet ind = this.binarySearchClosestInd(arr, num, key);\n\t\treturn arr[ind];\n\t}\n\n\n\tstatic rectsIntersect(r1: number[], r2: number[]) {\n\t\tlet [left1, top1, width1, height1] = r1;\n\t\tlet [left2, top2, width2, height2] = r2;\n\t\tlet [right1, right2, bottom1, bottom2] = [left1 + width1, left2 + width2, top1 + height1, top2 + height2];\n\t\treturn !(left2 > right1 ||\n\t\t\tright2 < left1 ||\n\t\t\ttop2 > bottom1 ||\n\t\t\tbottom2 < top1\n\t\t);\n\t}\n\n\n\tstatic throttle(func: Function, ms: number) {\n\n\t\tvar isThrottled = false,\n\t\t\tsavedArgs: any,\n\t\t\tsavedThis: any;\n\n\t\tfunction wrapper() {\n\n\t\t\tif (isThrottled) { // (2)\n\t\t\t\tsavedArgs = arguments;\n\t\t\t\tsavedThis = this;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfunc.apply(this, arguments); // (1)\n\n\t\t\tisThrottled = true;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tisThrottled = false; // (3)\n\t\t\t\tif (savedArgs) {\n\t\t\t\t\twrapper.apply(savedThis, savedArgs);\n\t\t\t\t\tsavedArgs = savedThis = null;\n\t\t\t\t}\n\t\t\t}, ms);\n\t\t}\n\n\t\treturn wrapper;\n\t}\n\n\tstatic msToTimeString(timestamp: number) {\n\t\tvar h = Math.floor(timestamp / 360000);\n\t\tvar m =  Math.floor(timestamp / 60000);\n\t\tvar s =  Math.floor(timestamp / 1000);\n\t\treturn h + ':' + m + ':' + s;\n\t}\n\t\n\tstatic getRandomItem<T>(arr: Array<T>): T {\n\t\tvar ind = Math.floor(Math.random() * arr.length);\n\t\treturn arr[ind];\n\t}\n\n\tstatic copyProps(srcObject: TIteralable, dstObject: TIteralable, props: TIteralable, excludeProps: string[] = []) {\n\t\tfor (var key in props) {\n\t\t\tif (excludeProps.indexOf(key) !== -1) continue;\n\t\t\tif (srcObject[key] == void 0) continue;\n\t\t\tif (isPlainObject(props[key]) && dstObject[key] !== void 0) {\n\t\t\t\tthis.copyProps(srcObject[key], dstObject[key], props[key])\n\t\t\t} else {\n\t\t\t\tdstObject[key] = this.deepCopy(srcObject[key]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Utils.ts\n **/","/// <reference path=\"./ResizeSensor.ts\" />\n\n// TODO: think about different bundles\n\nimport { ResizeSensorType } from './ResizeSensor';\n(<any>window).TweenLite = TweenMax;\n(<any>window).Stats = require('three/examples/js/libs/stats.min');\n\n// require('gsap/src/uncompressed/easing/EasePack.js');\n// require('three/examples/js/renderers/CanvasRenderer.js');\n// require('three/examples/js/renderers/Projector.js');\nexport const isPlainObject = require('is-plain-object') as Function;\nexport const EE2 = require('eventemitter2') as typeof EventEmitter2;\n\n\nexport { Promise } from '../polyfills/es6-promise';\n\nexport * from './ResizeSensor';\nexport const ResizeSensor = require('css-element-queries/src/ResizeSensor') as ResizeSensorType;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/deps/deps.ts\n **/","// stats.js - http://github.com/mrdoob/stats.js\nvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\nif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\nStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\nv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/examples/js/libs/stats.min.js\n ** module id = 6\n ** module chunks = 0 1\n **/","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n  \n  if (isObjectObject(o) === false) return false;\n  \n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n  \n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n  \n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n  \n  // Most likely a plain Object\n  return true;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-plain-object/index.js\n ** module id = 7\n ** module chunks = 0 1\n **/","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object'\n    && !Array.isArray(val);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isobject/index.js\n ** module id = 8\n ** module chunks = 0 1\n **/","/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || !!this._all;\n    }\n    else {\n      return !!this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  }\n  else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventemitter2/lib/eventemitter2.js\n ** module id = 9\n ** module chunks = 0 1\n **/","module.exports = {Promise: window['Promise']}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/polyfills/es6-promise.js\n ** module id = 10\n ** module chunks = 0 1\n **/","/**\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n;\n(function() {\n\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n    var ResizeSensor = function(element, callback) {\n        /**\n         *\n         * @constructor\n         */\n        function EventQueue() {\n            this.q = [];\n            this.add = function(ev) {\n                this.q.push(ev);\n            };\n\n            var i, j;\n            this.call = function() {\n                for (i = 0, j = this.q.length; i < j; i++) {\n                    this.q[i].call();\n                }\n            };\n        }\n\n        /**\n         * @param {HTMLElement} element\n         * @param {String}      prop\n         * @returns {String|Number}\n         */\n        function getComputedStyle(element, prop) {\n            if (element.currentStyle) {\n                return element.currentStyle[prop];\n            } else if (window.getComputedStyle) {\n                return window.getComputedStyle(element, null).getPropertyValue(prop);\n            } else {\n                return element.style[prop];\n            }\n        }\n\n        /**\n         *\n         * @param {HTMLElement} element\n         * @param {Function}    resized\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element.resizedAttached) {\n                element.resizedAttached = new EventQueue();\n                element.resizedAttached.add(resized);\n            } else if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.className = 'resize-sensor';\n            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n            element.resizeSensor.style.cssText = style;\n            element.resizeSensor.innerHTML =\n                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + '\"></div>' +\n                '</div>' +\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n                '</div>';\n            element.appendChild(element.resizeSensor);\n\n            if (!{fixed: 1, absolute: 1}[getComputedStyle(element, 'position')]) {\n                element.style.position = 'relative';\n            }\n\n            var expand = element.resizeSensor.childNodes[0];\n            var expandChild = expand.childNodes[0];\n            var shrink = element.resizeSensor.childNodes[1];\n            var shrinkChild = shrink.childNodes[0];\n\n            var lastWidth, lastHeight;\n\n            var reset = function() {\n                expandChild.style.width = expand.offsetWidth + 10 + 'px';\n                expandChild.style.height = expand.offsetHeight + 10 + 'px';\n                expand.scrollLeft = expand.scrollWidth;\n                expand.scrollTop = expand.scrollHeight;\n                shrink.scrollLeft = shrink.scrollWidth;\n                shrink.scrollTop = shrink.scrollHeight;\n                lastWidth = element.offsetWidth;\n                lastHeight = element.offsetHeight;\n            };\n\n            reset();\n\n            var changed = function() {\n                if (element.resizedAttached) {\n                    element.resizedAttached.call();\n                }\n            };\n\n            var addEvent = function(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent('on' + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            var onScroll = function() {\n              if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {\n                  changed();\n              }\n              reset();\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n        }\n\n        var elementType = Object.prototype.toString.call(element);\n        var isCollectionTyped = ('[object Array]' === elementType\n            || ('[object NodeList]' === elementType)\n            || ('[object HTMLCollection]' === elementType)\n            || ('undefined' !== typeof jQuery && element instanceof jQuery) //jquery\n            || ('undefined' !== typeof Elements && element instanceof Elements) //mootools\n        );\n\n        if (isCollectionTyped) {\n            var i = 0, j = element.length;\n            for (; i < j; i++) {\n                attachResizeEvent(element[i], callback);\n            }\n        } else {\n            attachResizeEvent(element, callback);\n        }\n\n        this.detach = function() {\n            if (isCollectionTyped) {\n                var i = 0, j = element.length;\n                for (; i < j; i++) {\n                    ResizeSensor.detach(element[i]);\n                }\n            } else {\n                ResizeSensor.detach(element);\n            }\n        };\n    };\n\n    ResizeSensor.detach = function(element) {\n        if (element.resizeSensor) {\n            element.removeChild(element.resizeSensor);\n            delete element.resizeSensor;\n            delete element.resizedAttached;\n        }\n    };\n\n    // make available to common module loader\n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n        module.exports = ResizeSensor;\n    }\n    else {\n        window.ResizeSensor = ResizeSensor;\n    }\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-element-queries/src/ResizeSensor.js\n ** module id = 11\n ** module chunks = 0 1\n **/","import {EE2} from './deps/deps';\n\n/**\n * this class uses as proxy for EventEmitter2\n */\nexport class EventEmitter {\n\tprivate ee: EventEmitter2;\n\tconstructor() {\n\t\tthis.ee = new EE2();\n\t}\n\temit(eventName: string, ...args: any[]) {\n\t\tthis.ee.emit(eventName, ...args)\n\t}\n\ton(eventName: string, callback: Function) {\n\t\treturn this.ee.on(eventName, callback)\n\t}\n\toff(eventName: string, callback: Function) {\n\t\treturn this.ee.off(eventName, callback);\n\t}\n\tsubscribe(eventName: string, callback: Function): Function {\n\t\tthis.on(eventName, callback);\n\t\treturn () => this.off(eventName, callback);\n\t}\n\tsetMaxListeners(listenersCount: number) {\n\t\tthis.ee.setMaxListeners(listenersCount);\n\t}\n\tremoveAllListeners(eventName?: string) {\n\t\tthis.ee.removeAllListeners(eventName);\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/EventEmmiter.ts\n **/","import Vector3 = THREE.Vector3;\nimport { ITrendOptions, Trend, ITrendData, TREND_TYPE } from \"./Trend\";\nimport {EventEmitter} from './EventEmmiter';\nimport {Utils} from './Utils';\nimport {TrendsManager, ITrendsOptions} from \"./TrendsManager\";\nimport {Screen} from \"./Screen\";\nimport {AxisMarks} from \"./AxisMarks\";\nimport {\n\tAXIS_TYPE, AXIS_DATA_TYPE, IAxisOptions, IAnimationsOptions, AXIS_RANGE_TYPE\n} from \"./interfaces\";\nimport { Promise } from './deps/deps';\nimport { ChartPlugin } from './Plugin';\n\n\ninterface IRecalculatedStateResult {\n\tchangedProps: IChartState,\n\tpatch: IChartState\n}\n\nconst CHART_STATE_EVENTS = {\n\tINITIAL_STATE_APPLIED: 'initialStateApplied',\n\tREADY: 'ready',\n\tDESTROY: 'destroy',\n\tCHANGE: 'change',\n\tTREND_CHANGE: 'trendChange',\n\tTRENDS_CHANGE: 'trendsChange',\n\tZOOM: 'zoom',\n\tRESIZE: 'resize',\n\tSCROLL: 'scroll',\n\tSCROLL_STOP: 'scrollStop',\n\tPLUGINS_STATE_CHANGED: 'pluginsStateChanged'\n};\n\n/**\n * readonly computed state data\n * calculated after recalculateState() call\n * contains cached values\n */\nexport interface IChartStateComputedData {\n\ttrends?: {\n\t\tmaxXVal: number,\n\t\tminXVal: number\n\t}\n}\n\nexport interface IChartState {\n\tprevState?: IChartState,\n\twidth?: number;\n\theight?: number;\n\tzoom?: number;\n\txAxis?: IAxisOptions,\n\tyAxis?: IAxisOptions,\n\tanimations?: IAnimationsOptions,\n\ttrends?: ITrendsOptions,\n\ttrendDefaultState?: ITrendOptions;\n\tcursor?: {\n\t\tdragMode?: boolean,\n\t\tx?: number,\n\t\ty?: number\n\t},\n\n\t/**\n\t * use fps = 0 for no limits\n\t */\n\tautoRender?: {enabled?: boolean, fps?: number};\n\n\t/**\n\t * by default 'WebGLRenderer'\n\t * also available 'CanvasRenderer'\n\t */\n\trenderer?: 'WebGLRenderer' | 'CanvasRenderer';\n\tfont?: {s?: string, m?: string, l?:string}\n\n\n\t/**\n\t * buffer size for displayed segments\n\t * used by widgets\n\t */\n\tmaxVisibleSegments?: number;\n\tautoResize?: boolean;\n\tcontrols?: {enabled: boolean};\n\tautoScroll?: boolean;\n\tshowStats?: boolean;\n\tbackgroundColor?: number;\n\tbackgroundOpacity?: number;\n\tcomputedData?: IChartStateComputedData,\n\tpluginsState?: {[pluginName: string]: any};\n\teventEmitterMaxListeners?: number;\n}\n\n/**\n *  all state changes caused only by Chart.setState method\n */\nexport class Chart {\n\n\tdata: IChartState = {\n\t\tprevState: {},\n\t\tzoom: 0,\n\t\txAxis: {\n\t\t\trange: {\n\t\t\t\ttype: AXIS_RANGE_TYPE.ALL,\n\t\t\t\tfrom: 0,\n\t\t\t\tto: 0,\n\t\t\t\tscroll: 0,\n\t\t\t\tzoom: 1,\n\t\t\t\tpadding: {start: 0, end: 5},\n\t\t\t\tmargin: {start: 0, end: 5}\n\t\t\t},\n\t\t\tdataType: AXIS_DATA_TYPE.NUMBER,\n\t\t\tgrid: {enabled: true, minSizePx:  100},\n\t\t\tautoScroll: true,\n\t\t\tmarks: [],\n\t\t\tcolor: '#5273bd'\n\t\t},\n\t\tyAxis: {\n\t\t\trange: {\n\t\t\t\ttype: AXIS_RANGE_TYPE.RELATIVE_END,\n\t\t\t\tfrom: 0,\n\t\t\t\tto: 0,\n\t\t\t\tzoom: 1,\n\t\t\t\tpadding: {start: 5, end: 5},\n\t\t\t\tmargin: {start: 5, end: 5},\n\t\t\t},\n\t\t\tgrid: {enabled: true, minSizePx:  50},\n\t\t\tdataType: AXIS_DATA_TYPE.NUMBER,\n\t\t\tmarks: [],\n\t\t\tcolor: '#5273bd'\n\t\t},\n\t\tanimations: {\n\t\t\tenabled: true,\n\t\t\ttrendChangeSpeed: 0.5,\n\t\t\ttrendChangeEase: void 0,\n\t\t\tzoomSpeed: 0.25,\n\t\t\tzoomEase:  void 0,\n\t\t\tscrollSpeed: 0.5,\n\t\t\tscrollEase: Linear.easeNone,\n\t\t\tautoScrollSpeed: 1,\n\t\t\tautoScrollEase: Linear.easeNone,\n\t\t},\n\t\tautoRender: {enabled: true, fps: 0},\n\t\tautoResize: true,\n\t\trenderer: 'WebGLRenderer',\n\t\tautoScroll: true,\n\t\tcontrols: {enabled: true},\n\t\ttrendDefaultState: {\n\t\t\tenabled: true,\n\t\t\ttype: TREND_TYPE.LINE,\n\t\t\tdata: [],\n\t\t\tmaxSegmentLength: 1000,\n\t\t\tlineWidth: 2,\n\t\t\tlineColor: 0xFFFFFF,\n\t\t\thasBackground: false,\n\t\t\tbackgroundColor: 'rgba(#5273BD, 0.15)',\n\t\t\thasBeacon: false,\n\t\t\tsettingsForTypes: {\n\t\t\t\tCANDLE: {\n\t\t\t\t\tminSegmentLengthInPx: 20,\n\t\t\t\t\tmaxSegmentLengthInPx: 40,\n\t\t\t\t},\n\t\t\t\tLINE: {\n\t\t\t\t\tminSegmentLengthInPx: 2,\n\t\t\t\t\tmaxSegmentLengthInPx: 10,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcursor: {\n\t\t\tdragMode: false,\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t},\n\t\tfont: {\n\t\t\ts: '11px Arial',\n\t\t\tm: '12px Arial',\n\t\t\tl: '13px Arial'\n\t\t},\n\t\tbackgroundColor: 0x000000,\n\t\tbackgroundOpacity: 1,\n\t\tshowStats: false,\n\t\tpluginsState: {},\n\t\teventEmitterMaxListeners: 20,\n\t\tmaxVisibleSegments: 1280\n\t};\n\tplugins: {[pluginName: string]: ChartPlugin} = {};\n\ttrendsManager: TrendsManager;\n\tscreen: Screen;\n\txAxisMarks: AxisMarks;\n\tyAxisMarks: AxisMarks;\n\n\t/**\n\t * true then chart was initialized and ready to use\n\t */\n\tisReady = false;\n\n\n\tprivate ee: EventEmitter;\n\n\tconstructor(\n\t\tinitialState: IChartState,\n\t\tplugins: ChartPlugin[] = []\n\t) {\n\t\tthis.ee = new EventEmitter();\n\t\tthis.ee.setMaxListeners(initialState.eventEmitterMaxListeners || this.data.eventEmitterMaxListeners);\n\n\t\tthis.data = Utils.deepMerge(this.data, initialState);\n\t\tthis.trendsManager = new TrendsManager(this, initialState);\n\t\tinitialState.trends = this.trendsManager.calculatedOptions;\n\t\tinitialState = this.installPlugins(plugins, initialState);\n\t\tthis.setState(initialState);\n\t\tthis.setState({computedData: this.getComputedData()});\n\t\tthis.savePrevState();\n\n\t\tthis.screen = new Screen(this);\n\t\tthis.xAxisMarks = new AxisMarks(this, AXIS_TYPE.X);\n\t\tthis.yAxisMarks = new AxisMarks(this, AXIS_TYPE.Y);\n\t\tthis.initListeners();\n\t\t\n\t\t// message to other modules that Chart.data is ready for use\n\t\tthis.ee.emit(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, initialState);\n\n\t\t// message to other modules that Chart is ready for use\n\t\tthis.isReady = true;\n\t\tthis.ee.emit(CHART_STATE_EVENTS.READY, initialState);\n\t}\n\n\t/**\n\t * destroy state, use ChartView.destroy to completely destroy chart\n\t */\n\tdestroy() {\n\t\tthis.ee.emit(CHART_STATE_EVENTS.DESTROY);\n\t\tthis.ee.removeAllListeners();\n\t\tthis.data = {};\n\t}\n\n\tonDestroy(cb: Function) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.DESTROY, cb);\n\t}\n\n\tonInitialStateApplied(cb: (initialState: IChartState) => void ): Function {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, cb);\n\t}\n\n\tonReady(cb: (initialState: IChartState) => void ): Function {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.READY, cb);\n\t}\n\n\tonChange(cb: (changedProps: IChartState) => void ) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.CHANGE, cb);\n\t}\n\n\tonTrendChange(cb: (trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.TREND_CHANGE, cb);\n\t}\n\n\tonTrendsChange(cb: (trendsOptions: ITrendsOptions) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.TRENDS_CHANGE, cb);\n\t}\n\n\tonScrollStop(cb: () => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.SCROLL_STOP, cb);\n\t}\n\n\tonScroll(cb: (scrollOptions: {deltaX: number}) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.SCROLL, cb);\n\t}\n\n\tonZoom(cb: (changedProps: IChartState) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.ZOOM, cb);\n\t}\n\n\tonResize(cb: (changedProps: IChartState) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.RESIZE, cb);\n\t}\n\n\tonPluginsStateChange(cb: (changedPluginsStates: {[pluginName: string]: Plugin}) => any) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, cb);\n\t}\n\t\n\tgetTrend(trendName: string): Trend {\n\t\treturn this.trendsManager.getTrend(trendName);\n\t}\n\n\tsetState(newState: IChartState, eventData?: any, silent = false) {\n\t\tlet stateData = this.data as {[key: string]: any};\n\t\tlet newStateObj = newState as {[key: string]: any};\n\n\t\tvar changedProps: {[key: string]: any} = {};\n\t\tfor (let key in newStateObj) {\n\t\t\tif (stateData[key] !== newStateObj[key]) {\n\t\t\t\tchangedProps[key] = newStateObj[key] as any;\n\t\t\t}\n\t\t}\n\n\t\tthis.savePrevState(changedProps as IChartState);\n\n\n\t\t// temporary remove trends data from newState by performance reasons\n\t\tlet trendsData: {[trendName: string]: ITrendData} = {};\n\t\tif (newState.trends) for (let trendName in newState.trends) {\n\t\t\tlet trendOptions = newState.trends[trendName];\n\t\t\tif (trendOptions.data) trendsData[trendName] = trendOptions.data;\n\t\t\tdelete trendOptions.data;\n\t\t}\n\t\tlet newStateContainsData = Object.keys(trendsData).length > 0;\n\t\t\n\n\t\tthis.data = Utils.deepMerge(this.data, newState, false);\n\n\t\t// return data to state\n\t\tif (newStateContainsData) for (let trendName in trendsData) {\n\t\t\tthis.data.trends[trendName].data = trendsData[trendName];\n\t\t}\n\n\t\tif (silent) return;\n\n\t\t// recalculate all dynamic state props\n\t\tvar recalculateResult = this.recalculateState(changedProps);\n\t\tchangedProps = recalculateResult.changedProps;\n\t\t\n\t\tthis.emitChangedStateEvents(changedProps, eventData);\n\n\t}\n\n\t/**\n\t * recalculate all computed state props\n\t */\n\tprivate recalculateState(changedProps?: IChartState): IRecalculatedStateResult {\n\t\tvar data = this.data;\n\t\tvar patch: IChartState = {};\n\t\tvar actualData = Utils.deepMerge({}, data);\n\n\t\t// recalculate scroll position by changed cursor options\n\t\tvar cursorOptions = changedProps.cursor;\n\t\tvar isMouseDrag = cursorOptions && data.cursor.dragMode && data.prevState.cursor.dragMode;\n\t\tif (isMouseDrag) {\n\t\t\tvar oldX = data.prevState.cursor.x;\n\t\t\tvar currentX =  cursorOptions.x;\n\t\t\tvar currentScroll = data.xAxis.range.scroll;\n\t\t\tvar deltaXVal = this.pxToValueByXAxis(oldX - currentX);\n\t\t\tpatch.xAxis = {range: {scroll: currentScroll + deltaXVal}};\n\t\t\tactualData = Utils.deepMerge(actualData, {xAxis: patch.xAxis} as IChartState)\n\t\t}\n\n\t\tlet chartWasResized = changedProps.width != void 0 || changedProps.height != void 0;\n\n\t\tlet scrollXChanged = false;\n\t\tlet needToRecalculateXAxis = (\n\t\t\tisMouseDrag ||\n\t\t\tchartWasResized ||\n\t\t\t(changedProps.xAxis && (changedProps.xAxis.range)) ||\n\t\t\tthis.data.xAxis.range.zeroVal == void 0\n\t\t);\n\t\tif (needToRecalculateXAxis) {\n\t\t\tlet xAxisPatch = this.recalculateXAxis(actualData, changedProps);\n\t\t\tif (xAxisPatch) {\n\t\t\t\tscrollXChanged = true;\n\t\t\t\tpatch = Utils.deepMerge(patch, {xAxis: xAxisPatch});\n\t\t\t\tactualData = Utils.deepMerge(actualData, {xAxis: xAxisPatch} as IChartState);\n\t\t\t}\n\t\t}\n\n\n\n\t\t// recalculate axis \"from\" and \"to\" for dynamics AXIS_RANGE_TYPE\n\t\tlet needToRecalculateYAxis = (\n\t\t\tchartWasResized ||\n\t\t\t(\n\t\t\t\tdata.yAxis.range.type === AXIS_RANGE_TYPE.RELATIVE_END ||\n\t\t\t\tdata.yAxis.range.type === AXIS_RANGE_TYPE.AUTO ||\n\t\t\t\tdata.yAxis.range.isMirrorMode\n\t\t\t) &&\n\t\t\t(scrollXChanged || changedProps.trends || changedProps.yAxis) ||\n\t\t\tthis.data.yAxis.range.zeroVal == void 0\n\t\t);\n\t\tif (needToRecalculateYAxis){\n\t\t\tlet yAxisPatch = this.recalculateYAxis(actualData);\n\t\t\tif (yAxisPatch) {\n\t\t\t\tpatch = Utils.deepMerge(patch, {yAxis: yAxisPatch});\n\t\t\t\tactualData = Utils.deepMerge(actualData, {yAxis: yAxisPatch} as IChartState);\n\t\t\t}\n\t\t}\n\n\t\tthis.savePrevState(patch);\n\t\tlet allChangedProps = Utils.deepMerge(changedProps, patch);\n\t\tpatch.computedData = this.getComputedData(allChangedProps);\n\t\tthis.savePrevState(patch);\n\t\tthis.data = Utils.deepMerge(this.data, patch);\n\t\treturn {changedProps: allChangedProps, patch: patch}\n\t}\n\n\tprivate getComputedData(changedProps?: IChartState): IChartStateComputedData {\n\t\tvar computeAll = !changedProps;\n\t\tvar computedData: IChartStateComputedData = {};\n\n\t\tif (computeAll || changedProps.trends && this.trendsManager) {\n\t\t\tcomputedData.trends = {\n\t\t\t\tmaxXVal: this.trendsManager.getEndXVal(),\n\t\t\t\tminXVal: this.trendsManager.getStartXVal()\n\t\t\t}\n\t\t}\n\t\treturn computedData;\n\t}\n\n\tprivate savePrevState(changedProps?: IChartState) {\n\t\tif (!changedProps) changedProps = this.data;\n\t\tvar prevState = this.data.prevState;\n\n\t\t// prevent to store prev trend data by performance reasons\n\t\tUtils.copyProps(this.data, prevState, changedProps, ['trends']);\n\n\t}\n\n\tprivate emitChangedStateEvents(changedProps: IChartState, eventData: any) {\n\t\tvar prevState = this.data.prevState;\n\n\t\t// emit common change event\n\t\tthis.ee.emit(CHART_STATE_EVENTS.CHANGE, changedProps, eventData);\n\n\t\t// emit event for each changed state property\n\t\tfor (let key in changedProps) {\n\t\t\tthis.ee.emit(key + 'Change', (changedProps as {[key: string]: any})[key], eventData);\n\t\t}\n\n\t\tif (!this.isReady) return;\n\n\t\t// emit special events based on changed state\n\t\tlet scrollStopEventNeeded = (\n\t\t\tchangedProps.cursor &&\n\t\t\tchangedProps.cursor.dragMode === false &&\n\t\t\tprevState.cursor.dragMode === true\n\t\t);\n\t\tscrollStopEventNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL_STOP, changedProps);\n\n\t\tlet scrollChangeEventsNeeded = (\n\t\t\tchangedProps.xAxis &&\n\t\t\tchangedProps.xAxis.range &&\n\t\t\tchangedProps.xAxis.range.scroll !== void 0\n\t\t);\n\t\tscrollChangeEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL, changedProps);\n\n\t\tlet zoomEventsNeeded = (\n\t\t\t(changedProps.xAxis && changedProps.xAxis.range && changedProps.xAxis.range.zoom) ||\n\t\t\t(changedProps.yAxis && changedProps.yAxis.range && changedProps.yAxis.range.zoom)\n\t\t);\n\t\tzoomEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.ZOOM, changedProps);\n\n\t\tlet resizeEventNeeded = (changedProps.width || changedProps.height);\n\t\tresizeEventNeeded && this.ee.emit(CHART_STATE_EVENTS.RESIZE, changedProps);\n\n\t\tlet pluginStateChangedEventNeeded = !!(changedProps.pluginsState);\n\t\tpluginStateChangedEventNeeded && this.ee.emit(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, changedProps.pluginsState);\n\t}\n\n\n\t/**\n\t * init plugins and save plugins options in initialState\n\t */\n\tprivate installPlugins(plugins: ChartPlugin[], initialState: IChartState): IChartState {\n\t\tinitialState.pluginsState = {};\n\t\tplugins.forEach(plugin => {\n\t\t\tlet PluginClass = plugin.constructor as typeof ChartPlugin;\n\t\t\tlet pluginName = PluginClass.NAME;\n\t\t\tinitialState.pluginsState[pluginName] = Utils.deepMerge({}, plugin.initialState);\n\t\t\tthis.plugins[pluginName] = plugin;\n\t\t\tplugin.setupChartState(this);\n\t\t});\n\t\treturn initialState;\n\t}\n\n\n\t/**\n\t * returns plugin instance by plugin name\n\t * @example\n\t */\n\tgetPlugin(pluginName: string): ChartPlugin {\n\t\treturn this.plugins[pluginName];\n\t}\n\n\n\tprivate initListeners() {\n\t\tthis.ee.on(CHART_STATE_EVENTS.TRENDS_CHANGE, (changedTrends: ITrendsOptions, newData: ITrendData) => {\n\t\t\tthis.handleTrendsChange(changedTrends, newData)\n\t\t});\n\t}\n\n\tprivate handleTrendsChange(changedTrends: ITrendsOptions, newData: ITrendData) {\n\t\tfor (let trendName in changedTrends) {\n\t\t\tthis.ee.emit(CHART_STATE_EVENTS.TREND_CHANGE, trendName, changedTrends[trendName], newData);\n\t\t}\n\t}\n\n\tprivate recalculateXAxis(actualData: IChartState, changedProps: IChartState): IAxisOptions {\n\t\tvar axisRange = actualData.xAxis.range;\n\t\tvar patch: IAxisOptions = {range: {}};\n\t\tvar isInitialize = axisRange.zeroVal == void 0;\n\t\tvar zeroVal: number, scaleFactor: number;\n\t\tvar zoom = axisRange.zoom;\n\n\t\tif (axisRange.isMirrorMode) {\n\t\t\tUtils.error('range.isMirrorMode available only for yAxis.range');\n\t\t}\n\n\t\tif (isInitialize) {\n\t\t\tzeroVal = axisRange.from;\n\t\t\tscaleFactor = actualData.width / (axisRange.to - axisRange.from);\n\t\t\tpatch = { range: {zeroVal: zeroVal, scaleFactor: scaleFactor}};\n\t\t} else {\n\t\t\tzeroVal = axisRange.zeroVal;\n\t\t\tscaleFactor = axisRange.scaleFactor;\n\n\t\t\t// recalculate range.zoom and range.scroll then range.from or range.to was changed\n\t\t\tif (\n\t\t\t\tchangedProps.xAxis &&\n\t\t\t\t(changedProps.xAxis.range.from != void 0 || changedProps.xAxis.range.to)\n\t\t\t) {\n\t\t\t\tif (changedProps.xAxis.range.zoom) {\n\t\t\t\t\tUtils.error('Impossible to change \"range.zoom\" then \"range.from\" or \"range.to\" present');\n\t\t\t\t}\n\t\t\t\tlet currentScaleFactor = actualData.width / (axisRange.to - axisRange.from);\n\t\t\t\tpatch.range.scroll = axisRange.from - zeroVal;\n\t\t\t\tpatch.range.zoom = currentScaleFactor / scaleFactor;\n\t\t\t\treturn patch;\n\t\t\t}\n\t\t}\n\n\n\t\t// recalculate range.from and range.to then range.zoom or range.scroll was changed\n\t\tdo {\n\t\t\tvar from = zeroVal + axisRange.scroll;\n\t\t\tvar to = from + actualData.width / (scaleFactor * zoom);\n\t\t\tvar rangeLength = to - from;\n\t\t\tvar needToRecalculateZoom = false;\n\t\t\tvar rangeMoreThenMaxValue = (axisRange.maxLength && rangeLength > axisRange.maxLength);\n\t\t\tvar rangeLessThenMinValue = (axisRange.minLength && rangeLength < axisRange.minLength);\n\t\t\tneedToRecalculateZoom = rangeMoreThenMaxValue || rangeLessThenMinValue;\n\t\t\tif (needToRecalculateZoom) {\n\t\t\t\tvar fixScale = rangeLength > axisRange.maxLength ?\n\t\t\t\t\trangeLength / axisRange.maxLength :\n\t\t\t\t\trangeLength / axisRange.minLength;\n\t\t\t\tvar zoom = zoom * fixScale;\n\t\t\t\tpatch.range.zoom = zoom;\n\t\t\t}\n\t\t} while (needToRecalculateZoom);\n\n\t\tpatch.range.from = from;\n\t\tpatch.range.to = to;\n\t\treturn patch;\n\t}\n\n\n\tprivate recalculateYAxis(actualData: IChartState): IAxisOptions {\n\t\tvar patch: IAxisOptions = {range: {}};\n\t\tvar yAxisRange = actualData.yAxis.range;\n\t\tvar isInitialize = yAxisRange.scaleFactor == void 0;\n\t\tvar trends = this.trendsManager;\n\t\tvar trendsEndXVal = trends.getEndXVal();\n\t\tvar trendsStartXVal = trends.getStartXVal();\n\t\tvar xRange = actualData.xAxis.range;\n\t\tvar {from: xFrom, to: xTo} = xRange;\n\t\tvar xRangeLength = xTo - xFrom;\n\t\tvar zeroVal: number, scaleFactor: number, scroll: number, zoom: number, needToZoom: boolean;\n\n\t\t// check situation when chart was scrolled behind trends end or before trends start\n\t\tif (xTo > trendsEndXVal) {\n\t\t\txTo = trendsEndXVal;\n\t\t\txFrom = xTo - xRangeLength;\n\t\t} else if (xFrom < trendsStartXVal) {\n\t\t\txFrom = trendsStartXVal;\n\t\t\txTo = xFrom + xRangeLength;\n\t\t}\n\n\t\tvar maxY = trends.getMaxYVal(xFrom, xTo);\n\t\tvar minY = trends.getMinYVal(xFrom, xTo);\n\n\t\tvar trendLastY = trends.getMaxYVal(trendsEndXVal, trendsEndXVal);\n\t\tif (yAxisRange.type == AXIS_RANGE_TYPE.RELATIVE_END) {\n\t\t\tif (trendLastY > maxY) maxY = trendLastY;\n\t\t\tif (trendLastY < minY) minY = trendLastY;\n\t\t}\n\n\t\tif (yAxisRange.isMirrorMode) {\n\t\t\tif (yAxisRange.zeroVal == void 0) Utils.error('range.zeroVal must be set when range.isMirrorMode');\n\t\t\tlet distanceFromZeroValForMaxY = Math.abs(yAxisRange.zeroVal - maxY);\n\t\t\tlet distanceFromZeroValForMinY = Math.abs(yAxisRange.zeroVal - minY);\n\t\t\tlet maxDistanceFromZeroVal = Math.max(distanceFromZeroValForMaxY, distanceFromZeroValForMinY);\n\t\t\tmaxY = yAxisRange.zeroVal + maxDistanceFromZeroVal;\n\t\t\tminY = yAxisRange.zeroVal - maxDistanceFromZeroVal;\n\t\t}\n\t\tlet margin = yAxisRange.margin;\n\t\tlet padding = {\n\t\t\tstart: yAxisRange.padding.start + margin.start,\n\t\t\tend: yAxisRange.padding.end + margin.end\n\t\t};\n\n\t\tif (padding.end + padding.start >= actualData.height) {\n\t\t\tUtils.warn('Sum of padding and margins of yAxi more then available chart height. Trends can be rendered incorrectly');\n\t\t}\n\n\t\tlet rangeLength = maxY - minY;\n\t\tlet paddingTopInPercents = padding.end / actualData.height;\n\t\tlet paddingBottomInPercents = padding.start / actualData.height;\n\t\tlet rangeLengthInPercents = 1 - paddingTopInPercents - paddingBottomInPercents;\n\t\tlet visibleRangeLength = rangeLength / rangeLengthInPercents;\n\t\tlet fromVal = minY - visibleRangeLength * paddingBottomInPercents;\n\t\tlet toVal = maxY + visibleRangeLength * paddingTopInPercents;\n\t\t\n\t\tif (isInitialize) {\n\t\t\tzeroVal = yAxisRange.zeroVal != void 0 ? yAxisRange.zeroVal : fromVal;\n\t\t\tscaleFactor = actualData.height / (toVal - fromVal);\n\t\t\tpatch = { range: {zeroVal: zeroVal, scaleFactor: scaleFactor}};\n\t\t\tneedToZoom = true;\n\t\t} else {\n\t\t\tscaleFactor = yAxisRange.scaleFactor;\n\t\t\tzeroVal = yAxisRange.zeroVal;\n\n\t\t\tlet maxScreenY = Math.round(this.getScreenYByValue(maxY));\n\t\t\tlet minScreenY = Math.round(this.getScreenYByValue(minY));\n\t\t\tneedToZoom = (\n\t\t\t\tmaxScreenY > actualData.height - margin.end ||\n\t\t\t\tmaxScreenY < actualData.height - padding.end ||\n\t\t\t\tminScreenY < margin.start ||\n\t\t\t\tminScreenY > padding.start\n\t\t\t);\n\t\t}\n\n\t\tif (!needToZoom) return null;\n\n\t\tscroll = fromVal - zeroVal;\n\t\tzoom = (actualData.height / (toVal - fromVal)) / scaleFactor ;\n\n\t\tvar currentAxisRange = this.data.yAxis.range;\n\t\tif (currentAxisRange.from !== fromVal) patch.range.from = fromVal;\n\t\tif (currentAxisRange.to !== toVal) patch.range.to = toVal;\n\t\tif (currentAxisRange.scroll !== scroll) patch.range.scroll = scroll;\n\t\tif (currentAxisRange.zoom !== zoom) patch.range.zoom = zoom;\n\t\t\n\t\treturn patch;\n\t}\n\n\tzoom(zoomValue: number, origin = 0.5): Promise<void> {\n\t\tlet {zoom, scroll, scaleFactor} = this.data.xAxis.range;\n\t\tlet newZoom = zoom * zoomValue;\n\t\tlet currentRange = this.data.width / (scaleFactor * zoom);\n\t\tlet nextRange = this.data.width / (scaleFactor * newZoom);\n\t\tlet newScroll = scroll + (currentRange - nextRange) * origin;\n\t\tthis.setState({xAxis: {range: {zoom: newZoom, scroll: newScroll}}});\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tlet animationTime = this.data.animations.enabled ? this.data.animations.zoomSpeed : 0;\n\t\t\tsetTimeout(resolve, animationTime * 1000);\n\t\t});\n\t}\n\t\n\tzoomToRange(range: number, origin?: number): Promise<void> {\n\t\tvar {scaleFactor, zoom} = this.data.xAxis.range;\n\t\tlet currentRange = this.data.width / (scaleFactor * zoom);\n\t\treturn this.zoom(currentRange / range, origin);\n\t}\n\n\tscrollToEnd(): Promise<void> {\n\t\tlet state = this.data;\n\t\tlet endXVal = this.trendsManager.getEndXVal();\n\t\tlet range = state.xAxis.range;\n\t\tvar scroll = endXVal - this.pxToValueByXAxis(state.width) + this.pxToValueByXAxis(range.padding.end) - range.zeroVal;\n\t\tthis.setState({xAxis: {range: {scroll: scroll}}});\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tlet animationTime = this.data.animations.enabled ? this.data.animations.scrollSpeed : 0;\n\t\t\tsetTimeout(resolve, animationTime * 1000);\n\t\t});\n\t}\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal to xVal\n\t */\n\tgetPointOnXAxis(xVal: number): number {\n\t\tvar {scaleFactor, zoom, zeroVal} = this.data.xAxis.range;\n\t\treturn (xVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from yAxis.range.zeroVal to yVal\n\t */\n\tgetPointOnYAxis(yVal: number): number {\n\t\tvar {scaleFactor, zoom, zeroVal} = this.data.yAxis.range;\n\t\treturn (yVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t * returns value by offset in pixels from xAxis.range.zeroVal\n\t */\n\tgetValueOnXAxis(x: number): number {\n\t\treturn this.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from xAxis.range\n\t */\n\tvalueToPxByXAxis(xVal: number) {\n\t\treturn xVal * this.data.xAxis.range.scaleFactor * this.data.xAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from yAxis.range\n\t */\n\tvalueToPxByYAxis(yVal: number) {\n\t\treturn yVal * this.data.yAxis.range.scaleFactor * this.data.yAxis.range.zoom;\n\t}\n\n\t/**\n\t *  convert pixels to value by using settings from xAxis.range\n\t */\n\tpxToValueByXAxis(xVal: number) {\n\t\treturn xVal / this.data.xAxis.range.scaleFactor / this.data.xAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  convert pixels to value by using settings from yAxis.range\n\t */\n\tpxToValueByYAxis(yVal: number) {\n\t\treturn yVal / this.data.yAxis.range.scaleFactor / this.data.yAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  returns x value by screen x coordinate\n\t */\n\tgetValueByScreenX(x: number): number {\n\t\tvar {zeroVal, scroll} = this.data.xAxis.range;\n\t\treturn zeroVal + scroll + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  returns y value by screen y coordinate\n\t */\n\tgetValueByScreenY(y: number): number {\n\t\tvar {zeroVal, scroll} = this.data.yAxis.range;\n\t\treturn zeroVal + scroll + this.pxToValueByYAxis(y);\n\t}\n\n\n\t/**\n\t *  returns screen x value by screen y coordinate\n\t */\n\tgetScreenXByValue(xVal: number): number {\n\t\tvar {scroll, zeroVal} = this.data.xAxis.range;\n\t\treturn this.valueToPxByXAxis(xVal - zeroVal - scroll)\n\t}\n\n\t/**\n\t *  returns screen y value by screen y coordinate\n\t */\n\tgetScreenYByValue(yVal: number): number {\n\t\tvar {scroll, zeroVal} = this.data.yAxis.range;\n\t\treturn this.valueToPxByYAxis(yVal - zeroVal - scroll)\n\t}\n\n\n\t/**\n\t * returns screen x coordinate by offset in pixels from xAxis.range.zeroVal value\n\t */\n\tgetScreenXByPoint(xVal: number): number {\n\t\treturn this.getScreenXByValue(this.getValueOnXAxis(xVal));\n\t}\n\n\n\t/**\n\t * returns offset in pixels from xAxis.range.zeroVal value by screen x coordinate\n\t */\n\tgetPointByScreenX(screenX: number): number {\n\t\treturn this.getPointOnXAxis(this.getValueByScreenX(screenX));\n\t}\n\n\n\tgetPointOnChart(xVal: number, yVal: number): Vector3 {\n\t\treturn new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\n\t}\n\n\n\tgetScreenLeftVal() {\n\t\treturn this.getValueByScreenX(0);\n\t}\n\n\n\tgetScreenRightVal() {\n\t\treturn this.getValueByScreenX(this.data.width);\n\t}\n\n\n\tgetPaddingRight(): number {\n\t\treturn this.getValueByScreenX(this.data.width - this.data.xAxis.range.padding.end);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Chart.ts\n **/","import {Chart, IChartState} from \"./Chart\";\nimport {Utils} from \"./Utils\";\nimport {TrendSegmentsManager} from \"./TrendSegmentsManager\";\nimport {EventEmitter} from './EventEmmiter';\nimport {Promise} from './deps/deps';\nimport { TChartColor } from './Color';\n\nexport interface IPrependPromiseExecutor {\n\t(requestedDataLength: number, resolve: (data: TTrendRawData) => void, reject: () => void): void;\n}\nconst EVENTS = {\n\tCHANGE: 'Change',\n\tPREPEND_REQUEST: 'prependRequest'\n};\nexport enum TREND_TYPE {LINE, CANDLE}\nexport type TTrendRawData = ITrendData | number[];\nexport interface ITrendItem {xVal: number, yVal: number, id?: number}\nexport interface ITrendData extends Array<ITrendItem>{}\nexport interface ITrendTypeSettings {\n\tminSegmentLengthInPx?: number;\n\tmaxSegmentLengthInPx?: number;\n}\nexport interface ITrendOptions {\n\tenabled?: boolean,\n\tdata?: ITrendData\n\tdataset?: ITrendData | number[];\n\tname?: string;\n\ttype?: TREND_TYPE;\n\tlineWidth?: number;\n\tlineColor?: TChartColor;\n\tbackgroundColor?: TChartColor;\n\thasIndicator?: boolean;\n\thasBackground?: boolean;\n\thasBeacon?: boolean;\n\tmaxSegmentLength?: number;\n\tsettingsForTypes?: {\n\t\tCANDLE?: ITrendTypeSettings,\n\t\tLINE?: ITrendTypeSettings\n\t}\n}\n\nexport class Trend {\n\tname: string;\n\tsegmentsManager: TrendSegmentsManager;\n\tminXVal = Infinity;\n\tminYVal = Infinity;\n\tmaxXVal = -Infinity;\n\tmaxYVal = -Infinity;\n\tprivate chartState: Chart;\n\tprivate calculatedOptions: ITrendOptions;\n\tprivate prependRequest: Promise<TTrendRawData>;\n\tprivate ee: EventEmitter;\n\t\n\tconstructor(chartState: Chart, trendName: string, initialState: IChartState) {\n\t\tvar options = initialState.trends[trendName];\n\t\tthis.name = trendName;\n\t\tthis.chartState = chartState;\n\t\tthis.calculatedOptions = Utils.deepMerge(this.chartState.data.trendDefaultState, options);\n\t\tthis.calculatedOptions.name = trendName;\n\t\tif (options.dataset) this.calculatedOptions.data = Trend.prepareData(options.dataset);\n\t\tthis.calculatedOptions.dataset = [];\n\t\tthis.ee = new EventEmitter();\n\t\tthis.bindEvents();\n\t}\n\n\tprivate onInitialStateApplied() {\n\t\tthis.segmentsManager = new TrendSegmentsManager(this.chartState, this);\n\t}\n\n\tprivate bindEvents() {\n\t\tvar chartState = this.chartState;\n\t\tchartState.onInitialStateApplied(() => this.onInitialStateApplied());\n\t\tchartState.onScrollStop(() => this.checkForPrependRequest());\n\t\tchartState.onZoom(() => this.checkForPrependRequest());\n\t\tchartState.onTrendChange((trendName, changedOptions, newData) => this.ee.emit(EVENTS.CHANGE, changedOptions, newData));\n\t\tchartState.onDestroy(() => this.ee.removeAllListeners());\n\t}\n\n\tgetCalculatedOptions() {\n\t\treturn this.calculatedOptions;\n\t}\n\n\tappendData(rawData: TTrendRawData) {\n\t\tvar options = this.getOptions();\n\t\tvar newData = Trend.prepareData(rawData, this.getData());\n\t\tvar updatedTrendData = options.data.concat(newData);\n\t\tthis.changeData(updatedTrendData, newData);\n\t}\n\n\tprependData(rawData: TTrendRawData) {\n\t\tvar options = this.getOptions();\n\t\tvar newData = Trend.prepareData(rawData, this.getData(), true);\n\t\tvar updatedTrendData = newData.concat(options.data);\n\t\tthis.changeData(updatedTrendData, newData);\n\t}\n\n\tprivate changeData(allData: ITrendData, newData: ITrendData) {\n\t\tfor (let item of newData) {\n\t\t\tif (item.xVal < this.minXVal) this.minXVal = item.xVal;\n\t\t\tif (item.xVal > this.maxXVal) this.maxXVal = item.xVal;\n\t\t\tif (item.yVal < this.minYVal) this.minYVal = item.yVal;\n\t\t\tif (item.yVal > this.maxYVal) this.maxYVal = item.yVal;\n\t\t}\n\t\tvar options = this.getOptions();\n\t\tvar statePatch: IChartState = {trends: {[options.name]: {data: allData}}};\n\t\tthis.chartState.setState(statePatch, newData);\n\t}\n\t\n\tgetData(fromX?: number, toX?: number): ITrendData {\n\t\tvar data = this.getOptions().data;\n\t\tif (fromX == void 0 && toX == void 0) return data;\n\n\t\tfromX = fromX !== void 0 ? fromX : data[0].xVal;\n\t\ttoX = toX !== void 0 ? toX : data[data.length].xVal;\n\t\tvar filteredData: ITrendData = [];\n\t\tfor (let item of data) {\n\t\t\tif (item.xVal < fromX) continue;\n\t\t\tif (item.xVal > toX) break;\n\t\t\tfilteredData.push(item)\n\t\t}\n\t\treturn filteredData;\n\t}\n\n\tgetFirstItem(): ITrendItem {\n\t\treturn this.getOptions().data[0];\n\t}\n\t\n\tgetLastItem(): ITrendItem {\n\t\tvar data = this.getOptions().data;\n\t\treturn data[data.length - 1];\n\t}\n\n\tgetOptions() {\n\t\treturn this.chartState.data.trends[this.name]\n\t}\n\n\tsetOptions(options: ITrendOptions) {\n\t\tthis.chartState.setState({trends: {[this.name]: options}});\n\t}\n\n\tonPrependRequest(cb: IPrependPromiseExecutor): Function {\n\t\tthis.ee.on(EVENTS.PREPEND_REQUEST, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(EVENTS.PREPEND_REQUEST, cb);\n\t\t}\n\t}\n\n\t/**\n\t * shortcut for Chart.onTrendChange\n\t */\n\tonChange(cb: (changedOptions: ITrendOptions, newData: ITrendData) => void): Function {\n\t\tthis.ee.on(EVENTS.CHANGE, cb);\n\t\treturn () => { this.ee.off(EVENTS.CHANGE, cb);}\n\t}\n\n\tonDataChange(cb: (newData: ITrendData) => void): Function {\n\t\tvar onChangeCb = (changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tif (newData) cb(newData);\n\t\t};\n\t\tthis.ee.on(EVENTS.CHANGE, onChangeCb);\n\t\treturn () => {\n\t\t\tthis.ee.off(EVENTS.CHANGE, onChangeCb);\n\t\t}\n\t}\n\n\tprivate checkForPrependRequest() {\n\t\tif (this.prependRequest) return;\n\t\tvar chartState = this.chartState;\n\t\tvar minXVal = chartState.data.computedData.trends.minXVal;\n\t\tvar minScreenX = chartState.getScreenXByValue(minXVal);\n\t\tvar needToRequest = minScreenX > 0;\n\t\tvar {from, to} = chartState.data.xAxis.range;\n\t\tvar requestedDataLength = to - from;\n\t\tif (!needToRequest) return;\n\t\t\n\t\tthis.prependRequest = new Promise<TTrendRawData>((resolve: Function, reject: Function) => {\n\t\t\tthis.ee.emit(EVENTS.PREPEND_REQUEST, requestedDataLength, resolve, reject);\n\t\t});\n\n\t\tthis.prependRequest.then((newData: TTrendRawData) => {\n\t\t\tthis.prependData(newData);\n\t\t\tthis.prependRequest = null;\n\t\t}, () => {\n\t\t\tthis.prependRequest = null;\n\t\t})\n\t\n\t}\n\n\tstatic prepareData (newData: TTrendRawData, currentData?: ITrendData, isPrepend = false): ITrendData {\n\t\tvar data: ITrendData = [];\n\t\tif (typeof newData[0] == 'number') {\n\t\t\tcurrentData = currentData || [];\n\t\t\tlet initialItem: ITrendItem;\n\t\t\tlet xVal: number;\n\t\t\tif (isPrepend) {\n\t\t\t\tinitialItem = currentData[0];\n\t\t\t\txVal = initialItem.xVal - newData.length;\n\t\t\t} else {\n\t\t\t\tinitialItem = currentData[currentData.length - 1];\n\t\t\t\txVal = initialItem ? initialItem.xVal + 1 : 0;\n\t\t\t}\n\t\t\tfor (let yVal of newData as number[]) {\n\t\t\t\tdata.push({xVal: xVal, yVal: yVal, id: Utils.getUid()});\n\t\t\t\txVal++;\n\t\t\t}\n\t\t} else {\n\t\t\tdata = newData as ITrendData;\n\t\t}\n\t\treturn data;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Trend.ts\n **/","import { IIteralable } from \"./interfaces\";\nimport { EventEmitter } from './EventEmmiter';\nimport { Chart } from \"./Chart\";\nimport Vector3 = THREE.Vector3;\nimport { ITrendData, ITrendOptions, ITrendItem, Trend, TREND_TYPE, ITrendTypeSettings } from \"./Trend\";\nimport { Utils } from \"./Utils\";\n\nconst MAX_ANIMATED_SEGMENTS = 100;\nconst EVENTS = {\n\tREBUILD: 'rebuild',\n\tDISLPAYED_RANGE_CHANGED: 'displayedRangeChanged',\n\tANIMATION_FRAME: 'animationFrame'\n};\n\n/**\n *  Class helps to display and animate trends segments\n */\nexport class TrendSegmentsManager {\n\tsegmentsById: {[id: string]: TrendSegment} = {};\n\tsegments: TrendSegment[] = [];\n\tchartState: Chart;\n\tanimatedSegmentsIds: number[] = [];\n\tmaxSegmentLength: number;\n\tsegmentsLength = 0;\n\tfirstDisplayedSegmentInd: number;\n\tfirstDisplayedSegment: TrendSegment;\n\tlastDisplayedSegmentInd: number;\n\tlastDisplayedSegment: TrendSegment;\n\tprivate appendAnimation: TweenLite;\n\tprivate prependAnimation: TweenLite;\n\tprivate animatedSegmentsForAppend: number[] = [];\n\tprivate animatedSegmentsForPrepend: number[] = [];\n\tprivate nextEmptyId = 0;\n\tprivate startSegmentId = 0;\n\tprivate endSegmentId = 0;\n\tprivate trend: Trend;\n\tprivate ee: EventEmitter;\n\n\tconstructor (chartState: Chart, trend: Trend) {\n\t\tthis.chartState = chartState;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.trend = trend;\n\t\tthis.maxSegmentLength = trend.getOptions().maxSegmentLength;\n\t\tthis.tryToRebuildSegments();\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.trend.onChange((changedOptions, newData) => this.onTrendChangeHandler(changedOptions, newData));\n\t\tthis.chartState.onZoom(() => this.onZoomHandler());\n\t\tthis.chartState.onScroll(() => this.recalculateDisplayedRange());\n\t\tthis.chartState.onDestroy(() => this.onDestroyHandler());\n\t}\n\n\tprivate onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t\tthis.appendAnimation && this.appendAnimation.kill();\n\t\tthis.prependAnimation && this.prependAnimation.kill();\n\t}\n\n\tprivate onZoomHandler() {\n\t\tlet segmentsRebuilded = this.tryToRebuildSegments();\n\t\tif (!segmentsRebuilded) {\n\t\t\tthis.recalculateDisplayedRange()\n\t\t}\n\t}\n\n\tprivate onTrendChangeHandler(changedOptions: ITrendOptions, newData: ITrendData) {\n\t\tvar needToRebuildSegments = (\n\t\t\tchangedOptions.type != void 0 ||\n\t\t\tchangedOptions.maxSegmentLength != void 0\n\t\t);\n\n\n\t\tif (needToRebuildSegments) {\n\t\t\tthis.tryToRebuildSegments(true);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!newData) return;\n\n\t\tvar data = this.trend.getData();\n\t\tvar isAppend = (!data.length || data[0].xVal < newData[0].xVal);\n\t\tisAppend ? this.appendData(newData) : this.prependData(newData);\n\t\tthis.recalculateDisplayedRange();\n\t}\n\n\tgetSegment(id: number) {\n\t\treturn this.segmentsById[id];\n\t}\n\n\tgetEndSegment(): TrendSegment {\n\t\treturn this.segmentsById[this.endSegmentId];\n\t}\n\n\tgetStartSegment(): TrendSegment {\n\t\treturn this.segmentsById[this.startSegmentId];\n\t}\n\t\n\tprivate tryToRebuildSegments(force = false): boolean {\n\t\tlet options = this.trend.getOptions();\n\t\tlet trendTypeName = TREND_TYPE[options.type] as string;\n\t\tlet trendTypesSettings =  options.settingsForTypes as IIteralable;\n\t\tlet trendTypeSettings = trendTypesSettings[trendTypeName] as ITrendTypeSettings;\n\t\tlet {\n\t\t\tminSegmentLengthInPx,\n\t\t\tmaxSegmentLengthInPx\n\t\t} = trendTypeSettings;\n\n\t\tlet needToRebuild = this.segments.length === 0 || force;\n\t\tlet segmentLength = this.maxSegmentLength;\n\n\t\t// call toFixed(2) to prevent floating segment error compare\n\t\tlet currentSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(segmentLength).toFixed(2));\n\t\tlet currentMaxSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(this.maxSegmentLength).toFixed(2));\n\n\t\tif (currentSegmentLengthInPx < minSegmentLengthInPx) {\n\t\t\tneedToRebuild = true;\n\t\t\tsegmentLength = Math.ceil(this.chartState.pxToValueByXAxis(maxSegmentLengthInPx));\n\t\t} else if (currentMaxSegmentLengthInPx > maxSegmentLengthInPx) {\n\t\t\tneedToRebuild = true;\n\t\t\tsegmentLength = this.chartState.pxToValueByXAxis(minSegmentLengthInPx);\n\t\t}\n\n\t\tif (!needToRebuild) return false;\n\n\t\tthis.maxSegmentLength = segmentLength;\n\t\tthis.segmentsById = {};\n\t\tthis.segments = [];\n\t\tthis.nextEmptyId = 0;\n\t\tthis.startSegmentId = 0;\n\t\tthis.endSegmentId = 0;\n\t\tthis.segmentsLength = 0;\n\t\tthis.stopAllAnimations();\n\t\tthis.appendData(null, true);\n\t\tthis.recalculateDisplayedRange(true);\n\t\tthis.ee.emit(EVENTS.REBUILD);\n\t}\n\n\tprivate stopAllAnimations() {\n\t\tthis.animatedSegmentsIds = [];\n\t\tthis.animatedSegmentsForAppend = [];\n\t\tthis.animatedSegmentsForAppend = [];\n\t\tif (this.prependAnimation) this.prependAnimation.kill();\n\t\tif (this.appendAnimation) this.appendAnimation.kill();\n\t}\n\t\n\tprivate recalculateDisplayedRange(segmentsAreRebuilded = false) {\n\t\tvar {from, to} = this.chartState.data.xAxis.range;\n\t\tvar {firstDisplayedSegment, lastDisplayedSegment} = this;\n\t\tvar displayedRange = to - from;\n\n\t\tthis.firstDisplayedSegmentInd = Utils.binarySearchClosestInd(this.segments, from - displayedRange, 'startXVal');\n\t\tthis.firstDisplayedSegment = this.segments[this.firstDisplayedSegmentInd];\n\t\tthis.lastDisplayedSegmentInd = Utils.binarySearchClosestInd(this.segments, to + displayedRange, 'endXVal');\n\t\tthis.lastDisplayedSegment = this.segments[this.lastDisplayedSegmentInd];\n\t\tif (segmentsAreRebuilded) return;\n\n\t\tvar displayedRangeChanged = (\n\t\t\tfirstDisplayedSegment.id !== this.firstDisplayedSegment.id ||\n\t\t\tlastDisplayedSegment.id !== this.lastDisplayedSegment.id\n\t\t);\n\t\tif (displayedRangeChanged) this.ee.emit(EVENTS.DISLPAYED_RANGE_CHANGED);\n\t}\n\n\t// getSegments(fromX?: number, toX?: number): TrendSegment[] {\n\t// \tvar segments = this.segments;\n\t// \tif (fromX == void 0 && toX == void 0) return segments;\n\t// \tfromX = fromX !== void 0 ? fromX : segments[0].startXVal;\n\t// \ttoX = toX !== void 0 ? toX : segments[this.segmentsLength].endXVal;\n\t// \tvar startSegmentInd = Utils.closestBinarySearch(segments, fromX, 'xVal');\n\t// \tvar endSegmentInd = Utils.closestBinarySearch(segments, toX, 'xVal');\n\t// \treturn segments.slice(startSegmentInd, endSegmentInd);\n\t// }\n\n\t/**\n\t * returns array of segments for values array\n\t * values must be sorted!\n\t */\n\tgetSegmentsForXValues(values: number[]): TrendSegment[] {\n\t\tvar valueInd = 0;\n\t\tvar value = values[valueInd];\n\t\tvar lastValueInd = values.length - 1;\n\t\tvar results: TrendSegment[] = [];\n\t\tvar segment = this.getStartSegment();\n\t\tif (!segment.hasValue) return [];\n\t\twhile (segment) {\n\t\t\n\t\t\twhile (value < segment.startXVal) {\n\t\t\t\tresults.push(void 0);\n\t\t\t\tvalue = values[++valueInd];\n\t\t\t}\n\t\t\n\t\t\twhile (value > segment.endXVal) {\n\t\t\t\tsegment = segment.getNext();\n\t\t\t\tif (!segment) break;\n\t\t\t}\n\t\t\n\t\t\tvar valueInPoint = (\n\t\t\t\tsegment.startXVal == value || segment.endXVal == value ||\n\t\t\t\t(segment.startXVal < value && segment.endXVal > value)\n\t\t\t);\n\t\t\tif (valueInPoint) {\n\t\t\t\tresults.push(segment);\n\t\t\t\tvalue = values[++valueInd];\n\t\t\t}\n\t\t\tif (valueInd > lastValueInd) break;\n\t\t}\n\t\treturn results;\n\t}\n\n\tonAnimationFrame(cb: (animationState: TrendSegmentsManager) => void): Function {\n\t\treturn this.ee.subscribe(EVENTS.ANIMATION_FRAME, cb);\n\t}\n\n\tonRebuild(cb: Function) {\n\t\treturn this.ee.subscribe(EVENTS.REBUILD, cb);\n\t}\n\n\tonDisplayedRangeChanged(cb: Function) {\n\t\treturn this.ee.subscribe(EVENTS.DISLPAYED_RANGE_CHANGED, cb);\n\t}\n\t\n\tallocateNextSegment() {\n\t\tvar id = this.nextEmptyId++;\n\t\tvar segment = new TrendSegment(this, id);\n\t\tvar prevSegment = this.segmentsById[this.endSegmentId];\n\t\tif (prevSegment && prevSegment.hasValue) {\n\t\t\tprevSegment.nextId = id;\n\t\t\tsegment.prevId = prevSegment.id;\n\t\t}\n\t\tthis.endSegmentId = id;\n\t\tthis.segmentsLength++;\n\t\tthis.segmentsById[id] = segment;\n\t\tthis.segments.push(segment);\n\t\treturn segment;\n\t}\n\n\tallocatePrevSegment() {\n\t\tvar id = this.nextEmptyId++;\n\t\tvar segment = new TrendSegment(this, id);\n\t\tvar nextSegment = this.segmentsById[this.startSegmentId];\n\t\tif (nextSegment && nextSegment.hasValue) {\n\t\t\tnextSegment.prevId = id;\n\t\t\tsegment.nextId = nextSegment.id;\n\t\t}\n\t\tthis.startSegmentId = id;\n\t\tthis.segmentsLength++;\n\t\tthis.segmentsById[id] = segment;\n\t\tthis.segments.unshift(segment);\n\t\treturn segment;\n\t}\n\n\tprivate appendData(newData: ITrendData, needRebuildSegments = false) {\n\n\t\t// WARNING: bottleneck method!\n\n\t\t// var t1 = performance.now();\n\t\tvar trendData = this.trend.getData();\n\t\tif (needRebuildSegments) {\n\t\t\tnewData = trendData;\n\t\t\tthis.animatedSegmentsForAppend = [];\n\t\t}\n\n\t\tvar startItemInd = trendData.length - newData.length;\n\t\tvar segment = this.getEndSegment() || this.allocateNextSegment();\n\t\tvar initialSegment = segment.hasValue ? segment : null;\n\t\tvar initialAnimationState = segment.createAnimationState();\n\t\tvar itemInd = 0;\n\t\twhile (itemInd < newData.length) {\n\t\t\tlet item = newData[itemInd];\n\t\t\tlet itemIsInserted = segment.appendItem(item);\n\t\t\tlet isLastItem = itemInd == newData.length - 1;\n\n\t\t\tif (itemIsInserted) {\n\t\t\t\tif (!isLastItem) itemInd++;\n\t\t\t} else {\n\t\t\t\tif (!segment.isCompleted) segment.complete();\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) {\n\t\t\t\tsegment.recalculateItems();\n\t\t\t}\n\n\t\t\tlet segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\n\t\t\tif (segmentIsReadyForAnimate) {\n\t\t\t\tlet id = segment.id;\n\t\t\t\tif (!initialSegment) initialSegment = segment;\n\t\t\t\tif (!initialAnimationState) initialAnimationState = initialSegment.createAnimationState();\n\n\t\t\t\tsegment.initialAnimationState = Utils.deepMerge({}, initialAnimationState);\n\t\t\t\tif (this.animatedSegmentsForAppend.length > 0) {\n\t\t\t\t\tsegment.initialAnimationState.startXVal = initialAnimationState.endXVal;\n\t\t\t\t\tsegment.initialAnimationState.startYVal = initialAnimationState.endYVal;\n\t\t\t\t}\n\n\t\t\t\tsegment.targetAnimationState = segment.createAnimationState();\n\t\t\t\tthis.animatedSegmentsForAppend.push(id);\n\n\t\t\t}\n\n\n\t\t\tif (isLastItem && itemIsInserted) break;\n\t\t\tif (!segment.isCompleted) continue;\n\n\t\t\tsegment = this.allocateNextSegment();\n\t\t\tlet prevItem = trendData[startItemInd + itemInd - 1];\n\t\t\tsegment.appendItem(prevItem);\n\n\t\t}\n\n\t\tvar animationsOptions = this.chartState.data.animations;\n\t\tvar time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\n\n\t\t// var t2 = performance.now();\n\t\t// console.log(t2 - t1);\n\n\t\t// do not create animation if segments was rebuilded\n\t\tif (needRebuildSegments) {\n\t\t\tfor (let segmentId of this.animatedSegmentsForAppend) {\n\t\t\t\tlet segment = this.segmentsById[segmentId];\n\t\t\t\tsegment.currentAnimationState = segment.createAnimationState();\n\t\t\t}\n\t\t\tthis.animatedSegmentsForAppend = [];\n\t\t\treturn;\n\t\t}\n\t\tif (this.animatedSegmentsForAppend.length > MAX_ANIMATED_SEGMENTS) time = 0;\n\t\tthis.animate(time);\n\t}\n\n\n\t// TODO: refactor duplicated code from appendData\n\tprivate prependData(newData: ITrendData) {\n\t\tvar trendData = this.trend.getData();\n\t\tvar segment = this.getStartSegment() || this.segmentsById[0];\n\t\tvar initialSegment = segment.hasValue ? segment : null;\n\t\tvar itemInd = newData.length - 1;\n\t\tvar initialAnimationState = segment.createAnimationState();\n\t\twhile (itemInd >= 0) {\n\t\t\tlet item = newData[itemInd];\n\t\t\tlet itemIsInserted = segment.prependItem(item);\n\t\t\tlet isLastItem = itemInd == 0;\n\n\t\t\tif (itemIsInserted) {\n\t\t\t\tif (!isLastItem) itemInd--;\n\t\t\t} else {\n\t\t\t\tif (!segment.isCompleted) segment.complete();\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) {\n\t\t\t\tsegment.recalculateItems();\n\t\t\t}\n\n\t\t\tlet segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\n\t\t\tif (segmentIsReadyForAnimate) {\n\t\t\t\tlet id = segment.id;\n\t\t\t\tif (!initialSegment) initialSegment = segment;\n\t\t\t\tif (!initialAnimationState) initialAnimationState = initialSegment.createAnimationState();\n\n\t\t\t\tsegment.initialAnimationState = Utils.deepMerge({}, initialAnimationState);\n\t\t\t\tif (this.animatedSegmentsForPrepend.length > 0) {\n\t\t\t\t\tsegment.initialAnimationState.endXVal = initialAnimationState.startXVal;\n\t\t\t\t\tsegment.initialAnimationState.endYVal =  initialAnimationState.startYVal;\n\t\t\t\t}\n\n\t\t\t\tsegment.targetAnimationState = segment.createAnimationState();\n\t\t\t\tthis.animatedSegmentsForPrepend.push(id);\n\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) break;\n\t\t\tif (!segment.isCompleted) continue;\n\n\t\t\tsegment = this.allocatePrevSegment();\n\t\t\tlet nextItem = trendData[itemInd + 1];\n\t\t\tsegment.prependItem(nextItem);\n\n\t\t}\n\n\t\tvar animationsOptions = this.chartState.data.animations;\n\t\tvar time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\n\n\t\tif (this.animatedSegmentsForPrepend.length > MAX_ANIMATED_SEGMENTS) time = 0;\n\t\tthis.animate(time, true);\n\t}\n\n\tprivate animate(time: number, isPrepend = false) {\n\n\t\tvar animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\n\t\tvar animation = isPrepend ? this.prependAnimation : this.appendAnimation;\n\n\t\tif ((animation && animation.isActive()) || time == 0) {\n\t\t\tif (animation) animation.kill();\n\t\t\tthis.onAnimationFrameHandler(1, isPrepend);\n\t\t\tanimatedSegmentsIds.length = 0;\n\t\t\treturn;\n\t\t}\n\t\tvar animationsOptions = this.chartState.data.animations;\n\t\tvar ease = animationsOptions.trendChangeEase;\n\t\tvar objectToAnimate = {animationValue: 0};\n\t\tanimation = TweenLite.to(objectToAnimate, time, {animationValue: 1, ease});\n\t\tanimation.eventCallback('onUpdate', () => this.onAnimationFrameHandler(objectToAnimate.animationValue, isPrepend));\n\t\tanimation.eventCallback('onComplete', () => {\n\t\t\tanimatedSegmentsIds.length = 0;\n\t\t\tthis.appendAnimation = null;\n\t\t});\n\n\t\tif (isPrepend) {\n\t\t\tthis.prependAnimation = animation;\n\t\t} else {\n\t\t\tthis.appendAnimation = animation;\n\t\t}\n\t}\n\n\tprivate onAnimationFrameHandler(coefficient: number, isPrepend = false) {\n\t\tlet animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\n\t\tfor (let segmentId of animatedSegmentsIds) {\n\t\t\tlet segment = this.segmentsById[segmentId];\n\t\t\tfor (let key in segment.targetAnimationState) {\n\t\t\t\tlet targetValue = segment.targetAnimationState[key] as number;\n\t\t\t\tlet initialValue = segment.initialAnimationState[key] as number;\n\t\t\t\tlet currentValue = initialValue + (targetValue - initialValue) * coefficient;\n\t\t\t\tsegment.currentAnimationState[key] = currentValue;\n\t\t\t}\n\t\t}\n\t\tthis.animatedSegmentsIds = this.animatedSegmentsForAppend.concat(this.animatedSegmentsForPrepend);\n\t\tthis.ee.emit(EVENTS.ANIMATION_FRAME, this);\n\t}\n\n}\n\nexport interface ITrendSegmentState extends IIteralable {\n\txVal?: number;\n\tyVal?: number;\n\tstartXVal?: number;\n\tstartYVal?: number;\n\tendXVal?: number;\n\tendYVal?: number;\n\tmaxYVal?: number;\n\tminYVal?: number;\n\tmaxLength?: number;\n}\n\nexport class TrendSegment implements ITrendSegmentState {\n\tid: number;\n\tprevId: number;\n\tnextId: number;\n\thasValue: boolean;\n\txVal: number;\n\tyVal: number;\n\tstartXVal: number;\n\tstartYVal: number;\n\tendXVal: number;\n\tendYVal: number;\n\tmaxYVal: number;\n\tminYVal: number;\n\tisCompleted = false;\n\tmaxLength: number;\n\titems: ITrendItem[] = [];\n\n\tinitialAnimationState: ITrendSegmentState = {};\n\ttargetAnimationState: ITrendSegmentState = {};\n\tcurrentAnimationState: ITrendSegmentState = {};\n\n\tprivate trendSegments: TrendSegmentsManager;\n\t\n\tconstructor(trendPoints: TrendSegmentsManager, id: number) {\n\t\tthis.trendSegments = trendPoints;\n\t\tthis.id = id;\n\t\tthis.maxLength = trendPoints.maxSegmentLength;\n\t}\n\n\tcreateAnimationState(): ITrendSegmentState {\n\t\tvar {\n\t\t\txVal,\n\t\t\tyVal,\n\t\t\tstartXVal,\n\t\t\tstartYVal,\n\t\t\tendXVal,\n\t\t\tendYVal,\n\t\t\tmaxYVal,\n\t\t\tminYVal,\n\t\t\tmaxLength\n\t\t} = this;\n\t\treturn {\n\t\t\txVal,\n\t\t\tyVal,\n\t\t\tstartXVal,\n\t\t\tstartYVal,\n\t\t\tendXVal,\n\t\t\tendYVal,\n\t\t\tmaxYVal,\n\t\t\tminYVal,\n\t\t\tmaxLength\n\t\t}\n\t};\n\t\n\tappendItem(item: ITrendItem): boolean {\n\t\tif (this.isCompleted) return false;\n\n\t\tvar items = this.items;\n\t\tif (items.length < 2) {\n\t\t\tthis.items.push(item);\n\t\t\tthis.hasValue = true;\n\t\t\treturn true;\n\t\t}\n\t\tvar startXVal = items[0].xVal;\n\t\tif (item.xVal - startXVal > this.maxLength) return false;\n\t\titems.push(item);\n\t\treturn true;\n\t}\n\n\tprependItem(item: ITrendItem): boolean {\n\t\tif (this.isCompleted) return false;\n\t\tvar items = this.items;\n\t\tif (items.length < 2) {\n\t\t\tthis.items.unshift(item);\n\t\t\tthis.hasValue = true;\n\t\t\treturn true;\n\t\t}\n\t\tvar endXVal = items[items.length - 1].xVal;\n\t\tif (endXVal - item.xVal > this.maxLength) return false;\n\t\titems.unshift(item);\n\t\treturn true;\n\t}\n\n\tcomplete() {\n\t\tthis.isCompleted = true;\n\t\tthis.recalculateItems();\n\t\tthis.items = []; // free memory for completed ranges\n\t}\n\n\trecalculateItems() {\n\t\tlet items = this.items;\n\t\tlet itemsLength = items.length;\n\t\tif (itemsLength === 0) Utils.error('Unable to create TrendSegment without TrendItems');\n\t\tlet endItem = items[itemsLength - 1];\n\t\tlet {xVal: endXVal, yVal: endYVal} = endItem;\n\t\tlet startXVal: number, startYVal: number;\n\n\n\t\tlet startItem = items[0];\n\t\tstartXVal = startItem.xVal;\n\t\tstartYVal = startItem.yVal;\n\n\t\tlet minX = Math.min(startXVal, endXVal);\n\t\tlet maxX = Math.max(startXVal, endXVal);\n\t\tlet middleXVal = minX + (maxX - minX) / 2;\n\n\t\tlet minY = Math.min(startYVal, endYVal);\n\t\tlet maxY = Math.max(startYVal, endYVal);\n\t\tlet middleYVal = minY + (maxY - minY) / 2;\n\n\t\tlet yVals = items.map(item => item.yVal);\n\n\t\tthis.startXVal = startXVal;\n\t\tthis.startYVal = startYVal;\n\t\tthis.endXVal = endXVal;\n\t\tthis.endYVal = endYVal;\n\t\tthis.xVal = middleXVal;\n\t\tthis.yVal = middleYVal;\n\t\tthis.maxYVal = Math.max(...yVals);\n\t\tthis.minYVal = Math.min(...yVals);\n\t\tif (!this.currentAnimationState) this.currentAnimationState = this.createAnimationState();\n\t}\n\n\tgetNext() {\n\t\tvar nextPoint = this.trendSegments.segmentsById[this.nextId];\n\t\treturn nextPoint && nextPoint.hasValue ? nextPoint : null;\n\t}\n\n\tgetPrev() {\n\t\tvar prevPoint = this.trendSegments.segmentsById[this.prevId];\n\t\treturn prevPoint && prevPoint.hasValue ? prevPoint : null;\n\t}\n\t\n\tgetFrameVal(): Vector3 {\n\t\tlet {xVal, yVal} = this.createAnimationState();\n\t\treturn new Vector3(xVal, yVal, 0);\n\t}\n\n\tgetFramePoint(): Vector3 {\n\t\tvar frameVal = this.getFrameVal();\n\t\treturn this.trendSegments.chartState.screen.getPointOnChart(frameVal.x, frameVal.y);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/TrendSegmentsManager.ts\n **/","\nimport {Trend, ITrendOptions} from \"./Trend\";\nimport {Chart, IChartState} from \"./Chart\";\nimport { EventEmitter } from './EventEmmiter';\n\nexport interface ITrendsOptions {\n\t[trendName: string]: ITrendOptions;\n}\n\nconst EVENTS = {\n\tSEGMENTS_REBUILDED: 'segmentsRebuilded'\n};\n\n/**\n * Trends manager\n */\nexport class TrendsManager {\n\ttrends: {[name: string]: Trend} = {};\n\tcalculatedOptions: ITrendsOptions;\n\tprivate ee = new EventEmitter();\n\tprivate chartState: Chart;\n\t\n\tconstructor(state: Chart, initialState: IChartState) {\n\t\tthis.chartState = state;\n\t\tvar trendsCalculatedOptions: ITrendsOptions = {};\n\t\tfor (let trendName in initialState.trends) {\n\t\t\tlet trend = this.createTrend(state, trendName, initialState);\n\t\t\ttrendsCalculatedOptions[trendName] = trend.getCalculatedOptions();\n\t\t}\n\t\tthis.calculatedOptions = trendsCalculatedOptions;\n\t\tthis.bindEvents();\n\t}\n\n\tgetTrend(trendName: string) {\n\t\treturn this.trends[trendName];\n\t}\n\t\n\tgetEnabledTrends(): Trend[] {\n\t\tvar enabledTrends: Trend[] = [];\n\t\tvar allTrends = this.trends;\n\t\tfor (let trendName in allTrends) {\n\t\t\tlet trend = allTrends[trendName];\n\t\t\ttrend.getOptions().enabled && enabledTrends.push(trend);\n\t\t}\n\t\treturn enabledTrends;\n\t}\n\n\n\tgetStartXVal() {\n\t\tvar trends = this.getEnabledTrends();\n\t\treturn trends[0].getData()[0].xVal;\n\t}\n\n\n\tgetEndXVal(): number {\n\t\tvar trends = this.getEnabledTrends();\n\t\tvar firstTrendData = trends[0].getData();\n\t\treturn firstTrendData[firstTrendData.length - 1].xVal;\n\t}\n\t\n\t\n\tgetExtremumYVal(extremumIsMax: boolean, fromX?: number, toX?: number) {\n\t\tvar trends = this.getEnabledTrends();\n\t\tvar compareFn: Function;\n\t\tvar result: number;\n\t\tif (extremumIsMax) {\n\t\t\tresult = -Infinity;\n\t\t\tcompareFn = Math.max;\n\t\t} else {\n\t\t\tresult = Infinity;\n\t\t\tcompareFn = Math.min;\n\t\t}\n\t\tfor (let trend of trends) {\n\t\t\tvar trendData = trend.getData(fromX, toX);\n\t\t\tvar trendYValues = trendData.map((dataItem) => dataItem.yVal);\n\t\t\tresult = compareFn(result, ...trendYValues);\n\t\t}\n\t\tif (result == Infinity || result == -Infinity) result = NaN;\n\t\treturn result;\n\t}\n\n\tgetMaxYVal(fromX?: number, toX?: number) {return this.getExtremumYVal(true, fromX, toX)}\n\tgetMinYVal(fromX?: number, toX?: number) {return this.getExtremumYVal(false, fromX, toX)}\n\n\tonSegmentsRebuilded(cb: (trendName: string) => any) {\n\t\treturn this.ee.subscribe(EVENTS.SEGMENTS_REBUILDED, cb);\n\t}\n\n\tprivate bindEvents() {\n\t\tthis.chartState.onInitialStateApplied(() => this.onInitialStateAppliedHandler());\n\t}\n\n\tprivate onInitialStateAppliedHandler() {\n\t\tfor (let trendName in this.trends) {\n\t\t\tthis.trends[trendName].segmentsManager.onRebuild(() => this.ee.emit(EVENTS.SEGMENTS_REBUILDED, trendName));\n\t\t}\n\t}\n\n\tprivate createTrend(state: Chart, trendName: string, initialState: IChartState): Trend {\n\t\tlet trend = new Trend(state, trendName, initialState);\n\t\tthis.trends[trendName] = trend;\n\t\treturn trend;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/TrendsManager.ts\n **/","import PerspectiveCamera = THREE.PerspectiveCamera;\nimport Vector3 = THREE.Vector3;\nimport {Chart, IChartState} from \"./Chart\";\nimport forestgreen = THREE.ColorKeywords.forestgreen;\nimport {EventEmitter} from './EventEmmiter';\n\nexport interface IScreenTransformOptions {\n\tscrollXVal?: number,\n\tscrollYVal?: number,\n\tscrollX?: number,\n\tscrollY?: number,\n\tzoomX?: number,\n\tzoomY?: number\n}\n\n/**\n * manage camera, and contains methods for transforming pixels to values\n */\nexport class Screen {\n\toptions: IScreenTransformOptions = {scrollXVal: 0, scrollX: 0, scrollYVal: 0, scrollY: 0, zoomX: 1, zoomY: 1};\n\tprivate chartState: Chart;\n\tprivate scrollXAnimation: TweenLite;\n\tprivate scrollYAnimation: TweenLite;\n\tprivate zoomXAnimation: TweenLite;\n\tprivate zoomYAnimation: TweenLite;\n\tprivate currentScrollX = {x: 0};\n\tprivate currentScrollY = {y: 0};\n\tprivate currentZoomX = {val: 1};\n\tprivate currentZoomY = {val: 1};\n\tprivate ee: EventEmitter;\n\n\tconstructor(chartState: Chart) {\n\t\tthis.chartState = chartState;\n\t\tvar {width: w, height: h} = chartState.data;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.transform({\n\t\t\tscrollY: this.valueToPxByYAxis(this.chartState.data.yAxis.range.scroll),\n\t\t\tzoomY: 1\n\t\t});\n\t\tthis.bindEvents();\n\n\t\t//camera.position.z = 1500;\n\t}\n\t\n\tgetCameraSettings() {\n\n\t\tvar {width: w, height: h} = this.chartState.data;\n\n\t\t// settings for pixel-perfect camera\n\t\tvar FOV = 75;\n\t\tvar vFOV = FOV * (Math.PI / 180);\n\t\t\n\t\treturn {\n\t\t\tFOV: FOV,\n\t\t\taspect: w / h,\n\t\t\tnear: 0.1,\n\t\t\tfar: 5000,\n\t\t\tz: h / (2 * Math.tan(vFOV / 2) ),\n\n\t\t\t// move 0,0 to left-bottom corner\n\t\t\tx: w / 2,\n\t\t\ty: h / 2\n\t\t}\n\t}\n\n\tonZoomFrame(cb: (zoomX: number, zoomY: number) => void): Function {\n\t\tvar eventName = 'zoomFrame';\n\t\tthis.ee.on(eventName, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(eventName, cb);\n\t\t}\n\t}\n\n\tonScrollFrame(cb: (options: IScreenTransformOptions) => void): Function {\n\t\tvar eventName = 'scrollFrame';\n\t\tthis.ee.on(eventName, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(eventName, cb);\n\t\t}\n\t}\n\n\tonTransformationFrame(cb: (options: IScreenTransformOptions) => void): Function {\n\t\tvar eventName = 'transformationFrame';\n\t\tthis.ee.on(eventName, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(eventName, cb);\n\t\t}\n\t}\n\n\tcameraIsMoving(): boolean {\n\t\treturn !!(\n\t\t\tthis.scrollXAnimation && this.scrollXAnimation.isActive() ||\n\t\t\t\tthis.zoomXAnimation && this.zoomXAnimation.isActive()\n\t\t);\n\t}\n\n\tprivate transform (options: IScreenTransformOptions, silent = false) {\n\t\tvar {scrollX, scrollY, zoomX, zoomY} = options;\n\t\t\n\t\tif (scrollX != void 0) this.options.scrollX = scrollX;\n\t\tif (scrollY != void 0) this.options.scrollY = scrollY;\n\t\tif (zoomX != void 0) this.options.zoomX = zoomX;\n\t\tif (zoomY != void 0) this.options.zoomY = zoomY;\n\n\t\tif (scrollX != void 0 || zoomX) {\n\t\t\toptions.scrollXVal = this.pxToValueByXAxis(scrollX != void 0 ? scrollX : this.options.scrollX);\n\t\t\tthis.options.scrollXVal = options.scrollXVal;\n\t\t}\n\n\t\tif (scrollY != void 0 || zoomY) {\n\t\t\toptions.scrollYVal = this.pxToValueByYAxis(scrollY != void 0 ? scrollY : this.options.scrollY);\n\t\t\tthis.options.scrollYVal = options.scrollYVal;\n\t\t}\n\n\t\tif (silent) return;\n\n\t\tthis.ee.emit('transformationFrame', options);\n\t\t\n\t\tif (options.scrollXVal != void 0 || options.scrollYVal != void 0) {\n\t\t\tthis.ee.emit('scrollFrame', options);\n\t\t}\n\t\t\n\t\tif (options.zoomX != void 0 || options.zoomY != void 0) {\n\t\t\tthis.ee.emit('zoomFrame', options);\n\t\t}\n\t}\n\n\n\tprivate bindEvents() {\n\t\tvar state = this.chartState;\n\n\t\t// handle scroll and zoom\n\t\tstate.onChange((changedProps) => {\n\t\t\tif (changedProps.xAxis && changedProps.xAxis.range) {\n\t\t\t\tif (changedProps.xAxis.range.scroll != void 0) this.onScrollXHandler(changedProps);\n\t\t\t\tif (changedProps.xAxis.range.zoom) this.onZoomXHandler();\n\t\t\t}\n\t\t\tif (changedProps.yAxis && changedProps.yAxis.range){\n\t\t\t\tif (changedProps.yAxis.range.scroll != void 0) this.onScrollYHandler();\n\t\t\t\tif (changedProps.yAxis.range.zoom) this.onZoomYHandler();\n\t\t\t}\n\t\t});\n\t\tstate.onDestroy(() => this.onDestroyHandler());\n\t}\n\n\tprivate onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t\tthis.scrollXAnimation && this.scrollXAnimation.kill();\n\t\tthis.scrollYAnimation && this.scrollYAnimation.kill();\n\t\tthis.zoomXAnimation && this.zoomXAnimation.kill();\n\t\tthis.zoomYAnimation && this.zoomYAnimation.kill();\n\t}\n\n\tprivate onScrollXHandler(changedProps: IChartState) {\n\t\tvar state = this.chartState;\n\t\tvar isDragMode = state.data.cursor.dragMode;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled && !isDragMode;\n\t\tvar zoomXChanged = changedProps.xAxis.range.zoom;\n\t\tvar isAutoscroll = state.data.autoScroll && !isDragMode && !zoomXChanged;\n\t\tvar time = isAutoscroll ? animations.autoScrollSpeed : animations.zoomSpeed;\n\t\tvar ease = isAutoscroll ? animations.autoScrollEase : animations.zoomEase;\n\t\tif (this.scrollXAnimation) this.scrollXAnimation.pause();\n\n\t\tvar range = state.data.xAxis.range;\n\t\tvar targetX = range.scroll * range.scaleFactor * range.zoom;\n\t\tthis.currentScrollX.x = this.options.scrollX;\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({scrollX: this.currentScrollX.x});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.scrollXAnimation = TweenLite.to(this.currentScrollX, time, {\n\t\t\t\tx: targetX, ease: ease\n\t\t\t});\n\t\t\tthis.scrollXAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentScrollX.x = targetX;\n\t\t\tcb();\n\t\t}\n\n\t}\n\n\tprivate onScrollYHandler() {\n\t\tvar state = this.chartState;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled;\n\t\tvar time = animations.zoomSpeed;\n\t\tif (this.scrollYAnimation) this.scrollYAnimation.pause();\n\t\tvar range = state.data.yAxis.range;\n\t\tvar targetY = range.scroll * range.scaleFactor * range.zoom;\n\n\t\tthis.currentScrollY.y = this.options.scrollY;\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({scrollY: this.currentScrollY.y});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.scrollYAnimation = TweenLite.to(this.currentScrollY, time, {\n\t\t\t\ty: targetY, ease: animations.zoomEase\n\t\t\t});\n\t\t\tthis.scrollYAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentScrollY.y = targetY;\n\t\t\tcb();\n\t\t}\n\t}\n\n\tprivate onZoomXHandler() {\n\t\tvar state = this.chartState;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled;\n\t\tvar time = animations.zoomSpeed;\n\t\tvar targetZoom = state.data.xAxis.range.zoom;\n\t\tif (this.zoomXAnimation) this.zoomXAnimation.pause();\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({zoomX: this.currentZoomX.val});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.zoomXAnimation = TweenLite.to(this.currentZoomX, time, {\n\t\t\t\tval: targetZoom, ease: animations.zoomEase\n\t\t\t});\n\t\t\tthis.zoomXAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentZoomX.val = targetZoom;\n\t\t\tcb();\n\t\t}\n\t}\n\n\tprivate onZoomYHandler() {\n\t\tvar state = this.chartState;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled;\n\t\tvar time = animations.zoomSpeed;\n\t\tvar targetZoom = state.data.yAxis.range.zoom;\n\t\tif (this.zoomYAnimation) this.zoomYAnimation.pause();\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({zoomY: this.currentZoomY.val});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.zoomYAnimation = TweenLite.to(this.currentZoomY, time, {\n\t\t\t\tval: targetZoom, ease: animations.zoomEase\n\t\t\t});\n\t\t\tthis.zoomYAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentZoomY.val = targetZoom;\n\t\t\tcb();\n\t\t}\n\t}\n\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal to scrollXVal\n\t */\n\tgetPointOnXAxis(xVal: number): number {\n\t\tvar {scaleFactor, zeroVal} = this.chartState.data.xAxis.range;\n\t\tvar zoom = this.options.zoomX;\n\t\treturn (xVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from yAxis.range.zeroVal to scrollYVal\n\t */\n\tgetPointOnYAxis(yVal: number): number {\n\t\tvar {scaleFactor, zeroVal} =  this.chartState.data.yAxis.range;\n\t\tvar zoom = this.options.zoomY;\n\t\treturn (yVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal and from yAxis.range.zeroVal to scrollXVal and scrollYVal\n\t */\n\tgetPointOnChart(xVal: number, yVal: number): Vector3 {\n\t\treturn new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\n\t}\n\t\n\t/**\n\t * returns value by offset in pixels from xAxis.range.zeroVal\n\t */\n\tgetValueOnXAxis(x: number): number {\n\t\treturn this.chartState.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from xAxis.range\n\t */\n\tvalueToPxByXAxis(xVal: number) {\n\t\treturn xVal * this.chartState.data.xAxis.range.scaleFactor * this.options.zoomX;\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from yAxis.range\n\t */\n\tvalueToPxByYAxis(yVal: number) {\n\t\treturn yVal * this.chartState.data.yAxis.range.scaleFactor * this.options.zoomY;\n\t}\n\t\n\t/**\n\t *  convert pixels to value by using settings from xAxis.range\n\t */\n\tpxToValueByXAxis(xVal: number) {\n\t\treturn xVal / this.chartState.data.xAxis.range.scaleFactor / this.options.zoomX;\n\t}\n\n\n\t/**\n\t *  convert pixels to value by using settings from yAxis.range\n\t */\n\tpxToValueByYAxis(yVal: number) {\n\t\treturn yVal / this.chartState.data.yAxis.range.scaleFactor / this.options.zoomY;\n\t}\n\n\n\t/**\n\t *  returns scrollX value by screen scrollX coordinate\n\t */\n\tgetValueByScreenX(x: number): number {\n\t\treturn this.chartState.data.xAxis.range.zeroVal + this.options.scrollXVal + this.pxToValueByXAxis(x);\n\t}\n\t\n\t\n\t/**\n\t *  returns scrollY value by screen scrollY coordinate\n\t */\n\tgetValueByScreenY(y: number): number {\n\t\treturn this.chartState.data.yAxis.range.zeroVal + this.options.scrollYVal + this.pxToValueByYAxis(y);\n\t}\n\t\n\t//\n\t/**\n\t *  returns screen scrollX value by screen scrollY coordinate\n\t */\n\tgetScreenXByValue(xVal: number): number {\n\t\tvar {scroll, zeroVal} = this.chartState.data.xAxis.range;\n\t\treturn this.valueToPxByXAxis(xVal - zeroVal - scroll)\n\t}\n\n\t// /**\n\t//  *  returns screen scrollY value by screen scrollY coordinate\n\t//  */\n\t// getScreenYByValue(scrollYVal: number): number {\n\t// \tvar {scroll, zeroVal} = this.data.yAxis.range;\n\t// \treturn this.valueToPxByYAxis(scrollYVal - zeroVal - scroll)\n\t// }\n\t//\n\t//\n\t/**\n\t * returns screen scrollX coordinate by offset in pixels from xAxis.range.zeroVal value\n\t */\n\tgetScreenXByPoint(xVal: number): number {\n\t\treturn this.getScreenXByValue(this.getValueOnXAxis(xVal));\n\t}\n\n\n\t/**\n\t * returns offset in pixels from xAxis.range.zeroVal value by screen scrollX coordinate\n\t */\n\tgetPointByScreenX(screenX: number): number {\n\t\treturn this.getPointOnXAxis(this.getValueByScreenX(screenX));\n\t}\n\n\t/**\n\t * returns offset in pixels from yAxis.range.zeroVal value by screen scrollY coordinate\n\t */\n\tgetPointByScreenY(screenY: number): number {\n\t\treturn this.getPointOnYAxis(this.getValueByScreenY(screenY));\n\t}\n\n\tgetTop(): number {\n\t\treturn this.getPointByScreenY(this.chartState.data.height);\n\t}\n\t\n\tgetBottom(): number {\n\t\treturn this.getPointByScreenY(0);\n\t}\n\n\tgetLeft(): number {\n\t\treturn this.getPointByScreenX(0);\n\t}\n\n\tgetScreenRightVal() {\n\t\treturn this.getValueByScreenX(this.chartState.data.width);\n\t}\n\n\tgetTopVal() {\n\t\treturn this.getValueByScreenY(this.chartState.data.height);\n\t}\n\t\n\tgetBottomVal() {\n\t\treturn this.getValueByScreenY(0);\n\t}\n\n\tgetCenterYVal() {\n\t\treturn this.getValueByScreenY(this.chartState.data.height / 2);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Screen.ts\n **/","\nimport {Chart} from \"./Chart\";\nimport {Utils} from \"./Utils\";\nimport {AXIS_TYPE} from \"./interfaces\";\nimport {ITrendData, ITrendOptions} from \"./Trend\";\nimport {EventEmitter} from './EventEmmiter';\n\nexport interface IAxisMarkUpdateOptions {\n\tvalue: number,\n\tdisplayedValue?: string\n}\n\nexport interface IAxisMarkOptions extends IAxisMarkUpdateOptions {\n\tname?: string;\n\ttitle?: string;\n\ttype?: string;\n\tlineColor?: string;\n\tlineWidth?: number;\n\tshowValue?: boolean;\n\tstickToEdges?: boolean;\n}\n\nconst AXIS_MARK_DEFAULT_OPTIONS: IAxisMarkOptions = {\n\ttype: 'simple',\n\tlineWidth: 1,\n\tvalue: 0,\n\tshowValue: false,\n\tstickToEdges: false,\n\tlineColor: '#FFFFFF',\n\ttitle: ''\n};\n\nexport class AxisMarks {\n\tprivate chartState: Chart;\n\tprivate axisType: AXIS_TYPE;\n\tprivate ee: EventEmitter;\n\tprivate items: {[name: string]: AxisMark} = {};\n\n\tconstructor(chartState: Chart, axisType: AXIS_TYPE) {\n\t\tthis.chartState = chartState;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.axisType = axisType;\n\t\tvar marks = this.items;\n\t\tvar axisMarksOptions = axisType == AXIS_TYPE.X ? chartState.data.xAxis.marks : chartState.data.yAxis.marks;\n\t\t\n\t\tfor (let options of axisMarksOptions) {\n\t\t\tlet axisMark: AxisMark;\n\t\t\toptions = Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\n\t\t\t\n\t\t\t// set mark name\n\t\t\tif (!options.name) options.name = Utils.getUid().toString();\n\t\t\tif (marks[options.name]) Utils.error('duplicated mark name ' + options.name);\n\t\t\t\n\t\t\t// create mark instance based on type option\n\t\t\tif (options.type == 'timeleft') {\n\t\t\t\taxisMark = new AxisTimeleftMark(chartState, axisType, options);\n\t\t\t} else {\n\t\t\t\taxisMark = new AxisMark(chartState, axisType, options);\n\t\t\t}\n\t\t\tmarks[options.name] = axisMark;\n\t\t}\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.chartState.onTrendChange((trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tthis.onTrendChange(trendName, newData)\n\t\t});\n\t\tthis.chartState.onDestroy(() => this.ee.removeAllListeners());\n\t}\n\n\tprivate onTrendChange(trendName: string, newData: ITrendData) {\n\t\tif (!newData) return;\n\t\tvar startVal = newData[0].xVal;\n\t\tvar endVal = newData[newData.length - 1].xVal;\n\t\tvar marks = this.items;\n\n\t\tfor (let markName in marks) {\n\t\t\tlet mark = marks[markName];\n\t\t\tlet markVal = mark.options.value;\n\t\t\tlet markWasCrossed = (startVal == markVal || endVal == markVal || (startVal < markVal && endVal > markVal));\n\t\t\tif (markWasCrossed) this.ee.emit('markCrossed', trendName, newData);\n\t\t}\n\t}\n\n\n\tgetItems() {\n\t\treturn this.items;\n\t}\n\t\n\tgetItem(markName: string) {\n\t\treturn this.items[markName];\n\t}\n\n}\n\nexport class AxisMark {\n\tstatic typeName = 'simple';\n\toptions: IAxisMarkOptions;\n\taxisType: AXIS_TYPE;\n\tprotected chartState: Chart;\n\tprotected renderOnTrendsChange = false;\n\tprotected ee: EventEmitter;\n\n\tconstructor(chartState: Chart, axisType: AXIS_TYPE, options: IAxisMarkOptions) {\n\t\tthis.ee = new EventEmitter();\n\t\tthis.options = options;\n\t\tthis.axisType = axisType;\n\t\tthis.chartState = chartState;\n\t\tthis.bindEvents();\n\t}\n\t\n\tprotected bindEvents() {}\n\n\tsetOptions(newOptions: IAxisMarkUpdateOptions) {\n\t\tvar value = this.options.value;\n\t\tthis.options = Utils.deepMerge(this.options, newOptions);\n\t\tif (this.options.value !== value) this.ee.emit('valueChange');\n\t\tthis.ee.emit('onDisplayedValueChange');\n\t}\n\n\tgetDisplayedVal(): string {\n\t\tlet {value, displayedValue} = this.options;\n\t\treturn String(displayedValue !== void 0 ? displayedValue : value);\n\t}\n\n\tonMarkCrossed(cb: (trendName: string, newData: ITrendData) => void): Function {\n\t\tthis.ee.on('markCrossed', cb);\n\t\treturn () => {\n\t\t\tthis.ee.off('markCrossed', cb);\n\t\t}\n\t}\n\n\tonValueChange(cb: () => void) {\n\t\tthis.ee.on('valueChange', cb);\n\t\treturn () => {\n\t\t\tthis.ee.off('valueChange', cb);\n\t\t}\n\t}\n\n\tonDisplayedValueChange(cb: () => void) {\n\t\tthis.ee.on('onDisplayedValueChange', cb);\n\t\treturn () => {\n\t\t\tthis.ee.off('onDisplayedValueChange', cb);\n\t\t}\n\t}\n}\n\nexport class AxisTimeleftMark extends AxisMark {\n\tstatic typeName = 'timeleft';\n\tprotected renderOnTrendsChange = true;\n\t\n\tgetDisplayedVal(): string {\n\t\tvar markVal = this.options.value;\n\t\tvar maxXVal = this.chartState.data.computedData.trends.maxXVal;\n\t\tvar time = markVal - maxXVal;\n\t\tif (time < 0) time = 0;\n\t\treturn Utils.msToTimeString(time);\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.chartState.onTrendsChange(() => this.onTrendsChange());\n\t}\n\n\tprotected onTrendsChange() {\n\t\tthis.ee.emit('onDisplayedValueChange');\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/AxisMarks.ts\n **/","\n\n/**\n * defines how axis range will be calculated\n * FIXED - directly use range.from and range.to value\n * AUTO - automatically sets range.from and range.to by visible part of opposite axis\n * RELATIVE_END - same as AUTO, but trend end always present in range\n * ALL - automatically sets range.from and range.to by all values of opposite axis\n *\n */\nimport {IAxisMarkOptions} from \"./AxisMarks\";\nimport {TChartColor} from \"./Color\";\nexport enum AXIS_RANGE_TYPE {\n\tFIXED,\n\tRELATIVE_END,\n\tAUTO,\n\tALL // TODO: AXIS_RANGE_TYPE.ALL\n}\n\n/**\n * Animation ease type\n */\nexport declare type TEase = Ease | Linear;\n\nexport declare type TIteralable = {[key: string]: any};\nexport interface IIteralable {[key: string]: any};\n\nexport enum AXIS_TYPE {X, Y}\n\nexport interface IAxisRange {\n\ttype?: AXIS_RANGE_TYPE,\n\tfrom?: number,\n\tto?: number,\n\tzoom?: number,\n\tscroll?: number,\n\n\t/**\n\t * Mode only for Y axis. When true displayed center of Y axis never changed. To use set range.zeroVal as center value.\n\t */\n\tisMirrorMode?: boolean,\n\n\tpadding?: {\n\t\tstart?: number,\n\t\tend?: number\n\t},\n\n\tmargin?: {\n\t\tstart?: number,\n\t\tend?: number\n\t},\n\n\tmaxLength?: number;\n\tminLength?: number;\n\n\t/**\n\t * value in world center coordinate\n\t */\n\tzeroVal?: number,\n\n\t/**\n\t * ratio between 1 pixel and 1 value for zoom = 1\n\t */\n\tscaleFactor?: number,\n}\n\nexport enum AXIS_DATA_TYPE {NUMBER, DATE}\n\nexport interface IAxisOptions {\n\trange?: IAxisRange;\n\tdataType?: AXIS_DATA_TYPE;\n\tautoScroll?: boolean;\n\tmarks?: IAxisMarkOptions[];\n\tgrid?: IGridOptions;\n\tcolor?: TChartColor;\n}\n\nexport interface IGridOptions {\n\tenabled: boolean;\n\tminSizePx?: number;\n}\n\nexport interface IAnimationsOptions {\n\tenabled?: boolean,\n\ttrendChangeSpeed?: number,\n\ttrendChangeEase?: TEase,\n\tscrollSpeed?: number,\n\tscrollEase?: TEase,\n\tautoScrollSpeed?: number,\n\tautoScrollEase?: TEase,\n\tzoomSpeed?: number,\n\tzoomEase?: TEase,\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/interfaces.ts\n **/","import {Chart} from \"./Chart\";\nimport Object3D = THREE.Object3D;\n\nexport interface IChartWidgetConstructor {\n\tnew (): ChartWidget;\n\twidgetName: string;\n}\n\n/**\n * base class for all widgets\n * each widget must have widgetName static property\n */\nexport abstract class ChartWidget {\n\tstatic widgetName = '';\n\tprotected chart: Chart;\n\tprivate unbindList: Function[] = [];\n\n\n\tsetupChartState(chartState: Chart) {\n\t\tthis.chart = chartState;\n\t}\n\n\tabstract onReadyHandler(): any;\n\tabstract getObject3D(): Object3D;\n\n\n\tprotected bindEvent(...args: Array<Function | Function[]>): void {\n\t\tlet unbindList: Function[] = [];\n\t\tif (!Array.isArray(args[0])) {\n\t\t\tunbindList.push(args[0] as Function);\n\t\t} else {\n\t\t\tunbindList.push(...args as Function[]);\n\t\t}\n\t\tthis.unbindList.push(...unbindList);\n\t}\n\tprotected unbindEvents() {\n\t\tthis.unbindList.forEach(unbindEvent => unbindEvent());\n\t\tthis.unbindList.length = 0;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Widget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport UVMapping = THREE.UVMapping;\nimport GridHelper = THREE.GridHelper;\nimport {ChartWidget} from \"../Widget\";\nimport {Chart} from \"../Chart\";\nimport {GridWidget, IGridParamsForAxis} from \"./GridWidget\";\nimport {Utils} from \"../Utils\";\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport OrthographicCamera = THREE.OrthographicCamera;\nimport {IScreenTransformOptions} from \"../Screen\";\nimport {AXIS_TYPE, AXIS_DATA_TYPE, IAxisOptions} from \"../interfaces\";\n\n/**\n * widget for drawing axis\n */\nexport class AxisWidget extends ChartWidget {\n\tstatic widgetName = 'Axis';\n\tprivate isDestroyed = false;\n\tprivate object3D: Object3D;\n\tprivate axisXObject: Object3D;\n\tprivate axisYObject: Object3D;\n\tprivate updateAxisXRequest: () => void;\n\n\tonReadyHandler() {\n\t\tthis.object3D = new Object3D();\n\t\tthis.axisXObject = new Object3D();\n\t\tthis.axisYObject = new Object3D();\n\t\tthis.object3D.add(this.axisXObject);\n\t\tthis.object3D.add(this.axisYObject);\n\t\tthis.setupAxis(AXIS_TYPE.X);\n\t\tthis.setupAxis(AXIS_TYPE.Y);\n\n\t\t// canvas drawing is expensive operation, so when we scroll, redraw must be called only once per second\n\t\tthis.updateAxisXRequest = Utils.throttle(() => this.updateAxis(AXIS_TYPE.X), 1000);\n\n\t\tthis.onScrollChange(\n\t\t\tthis.chart.screen.options.scrollX,\n\t\t\tthis.chart.screen.options.scrollY\n\t\t);\n\t\tthis.bindEvents();\n\t}\n\n\tbindEvents() {\n\t\tvar state = this.chart;\n\n\t\tthis.bindEvent(\n\t\t\tstate.screen.onTransformationFrame((options) => {\n\t\t\t\tthis.onScrollChange(options.scrollX, options.scrollY);\n\t\t\t}),\n\t\t\tstate.screen.onZoomFrame((options) => {this.onZoomFrame(options)}),\n\t\t\tstate.onDestroy(() => this.onDestroy()),\n\t\t\tstate.onResize(() => this.onResize())\n\t\t);\n\t}\n\n\tprivate onDestroy() {\n\t\tthis.isDestroyed = true;\n\t\tthis.unbindEvents();\n\t}\n\n\tprivate onScrollChange(x: number, y: number) {\n\n\t\tif (y != void 0) {\n\t\t\tthis.axisYObject.position.y = y;\n\t\t\tthis.axisXObject.position.y = y;\n\t\t}\n\n\t\tif (x != void 0) {\n\t\t\tthis.axisYObject.position.x = x;\n\t\t\tthis.updateAxisXRequest();\n\t\t}\n\n\t}\n\n\tprivate onResize() {\n\t\tthis.setupAxis(AXIS_TYPE.X);\n\t\tthis.setupAxis(AXIS_TYPE.Y);\n\t}\n\n\tprivate setupAxis(orientation: AXIS_TYPE) {\n\n\t\tlet isXAxis = orientation == AXIS_TYPE.X;\n\t\tlet {width: visibleWidth, height: visibleHeight} = this.chart.data;\n\t\tlet canvasWidth = 0, canvasHeight = 0;\n\n\t\t// clean meshes\n\t\tif (isXAxis) {\n\t\t\tthis.axisXObject.traverse(obj => this.axisXObject.remove(obj));\n\t\t\tcanvasWidth = visibleWidth * 3;\n\t\t\tcanvasHeight = 50;\n\t\t} else {\n\t\t\tthis.axisYObject.traverse(obj => this.axisYObject.remove(obj));\n\t\t\tcanvasWidth = 50;\n\t\t\tcanvasHeight = visibleHeight * 3;\n\t\t}\n\n\t\tvar texture = Utils.createPixelPerfectTexture(canvasWidth, canvasHeight, (ctx) => {\n\t\t\tctx.beginPath();\n\t\t\tctx.font = \"10px Arial\";\n\t\t\tctx.fillStyle = \"rgba(255,255,255,0.5)\";\n\t\t\tctx.strokeStyle = \"rgba(255,255,255,0.1)\";\n\t\t});\n\n\n\t\tvar material = new THREE.MeshBasicMaterial( {map: texture, side: THREE.FrontSide} );\n\t\tmaterial.transparent = true;\n\n\t\tvar axisMesh = new Mesh(\n\t\t\tnew THREE.PlaneGeometry(canvasWidth, canvasHeight),\n\t\t\tmaterial\n\t\t);\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh.position.set(canvasWidth / 2, canvasHeight / 2, 0);\n\t\t\tthis.axisXObject.add(axisMesh);\n\t\t} else {\n\t\t\taxisMesh.position.set(visibleWidth - canvasWidth / 2, canvasHeight / 2, 0);\n\t\t\tthis.axisYObject.add(axisMesh);\n\t\t}\n\n\t\tthis.updateAxis(orientation);\n\n\t}\n\t\n\tgetObject3D(): Object3D {\n\t\treturn this.object3D;\n\t}\n\n\tprivate updateAxis(orientation: AXIS_TYPE) {\n\t\tif (this.isDestroyed) return;\n\t\tvar isXAxis = orientation == AXIS_TYPE.X;\n\t\tvar {width: visibleWidth, height: visibleHeight} = this.chart.data;\n\t\tvar {scrollX, scrollY, zoomX, zoomY} = this.chart.screen.options;\n\t\tvar axisOptions: IAxisOptions;\n\t\tvar axisMesh: Mesh;\n\t\tvar axisGridParams: IGridParamsForAxis;\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh = this.axisXObject.children[0] as Mesh;\n\t\t\taxisOptions = this.chart.data.xAxis;\n\t\t\taxisGridParams = GridWidget.getGridParamsForAxis(axisOptions, visibleWidth, zoomX);\n\t\t} else {\n\t\t\taxisMesh = this.axisYObject.children[0] as Mesh;\n\t\t\taxisOptions = this.chart.data.yAxis;\n\t\t\taxisGridParams = GridWidget.getGridParamsForAxis(axisOptions, visibleHeight, zoomY);\n\t\t}\n\n\t\tvar geometry = axisMesh.geometry as PlaneGeometry;\n\t\tvar canvasWidth = geometry.parameters.width;\n\t\tvar canvasHeight = geometry.parameters.height;\n\t\tvar texture = (axisMesh.material as MeshBasicMaterial).map;\n\t\tvar ctx = texture.image.getContext('2d');\n\t\tctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh.position.x = canvasWidth / 2 - visibleWidth + scrollX;\n\t\t}\n\n\n\t\t// TODO: draw text and lines in different loops\n\t\tvar edgeOffset = axisGridParams.segmentsCount * axisGridParams.step;\n\t\tvar startVal = axisGridParams.start  - edgeOffset;\n\t\tvar endVal = axisGridParams.end + edgeOffset;\n\n\t\tctx.beginPath();\n\t\tfor (let val = startVal; val <= endVal; val += axisGridParams.step) {\n\t\t\tlet displayedValue = '';\n\t\t\tif (isXAxis) {\n\t\t\t\tlet pxVal = this.chart.screen.getPointOnXAxis(val) - scrollX + visibleWidth;\n\t\t\t\tctx.textAlign = \"center\";\n\t\t\t\t// uncomment for dots\n\t\t\t\t// ctx.moveTo(pxVal + 0.5, canvasHeight);\n\t\t\t\t// ctx.lineTo(pxVal + 0.5, canvasHeight - 5);\n\t\t\t\tif (axisOptions.dataType == AXIS_DATA_TYPE.DATE) {\n\t\t\t\t\tdisplayedValue = AxisWidget.getDateStr(val, axisGridParams);\n\t\t\t\t} else {\n\t\t\t\t\tdisplayedValue = Number(val.toFixed(14)).toString();\n\t\t\t\t}\n\n\t\t\t\tctx.fillText(displayedValue, pxVal, canvasHeight - 10);\n\t\t\t} else {\n\t\t\t\tlet pxVal = canvasHeight - this.chart.screen.getPointOnYAxis(val) + scrollY;\n\t\t\t\tctx.textAlign = \"right\";\n\t\t\t\t// uncomment for dots\n\t\t\t\t// ctx.moveTo(canvasWidth, pxVal + 0.5);\n\t\t\t\t// ctx.lineTo(canvasWidth - 5, pxVal + 0.5);\n\n\t\t\t\tdisplayedValue = Number(val.toFixed(14)).toString();\n\t\t\t\tctx.fillText(displayedValue, canvasWidth - 15 , pxVal + 3);\n\n\t\t\t\t// uncomment for left-side axis\n\t\t\t\t// ctx.moveTo(0, pxVal + 0.5);\n\t\t\t\t// ctx.lineTo(5, pxVal + 0.5);\n\t\t\t\t// ctx.fillText(Number(val.toFixed(14)).toString(), 15 , pxVal + 3);\n\t\t\t}\n\t\t\tctx.stroke();\n\t\t}\n\t\t// uncomment to preview canvas borders\n\t\t// ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\t\tctx.stroke();\n\t\tctx.closePath();\n\t\ttexture.needsUpdate = true;\n\t}\n\n\tprivate onZoomFrame(options: IScreenTransformOptions) {\n\t\tif (options.zoomX) {\n\t\t\tthis.updateAxis(AXIS_TYPE.X);\n\t\t\t//this.temporaryHideAxis(AXIS_ORIENTATION.H)\n\t\t}\n\t\tif (options.zoomY) {\n\t\t\tthis.updateAxis(AXIS_TYPE.Y);\n\t\t\t//this.temporaryHideAxis(AXIS_ORIENTATION.V)\n\t\t}\n\t}\n\n\t// private temporaryHideAxis(orientation: AXIS_TYPE) {\n\t// \tvar isXAxis = orientation == AXIS_TYPE.X;\n\t// \tvar timeoutId = setTimeout(() => {\n\t// \t\t\tthis.showAxis(orientation);\n\t// \t}, 200);\n\t//\n\t// \tif (isXAxis) {\n\t// \t\t(this.axisXObject.children[0] as Mesh).material.opacity = 0;\n\t// \t\tclearTimeout(this.showAxisXTimeout);\n\t// \t\tthis.showAxisXTimeout =\ttimeoutId;\n\t// \t} else {\n\t// \t\tclearTimeout(this.showAxisYTimeout);\n\t// \t\t(this.axisYObject.children[0] as Mesh).material.opacity = 0;\n\t// \t\tthis.showAxisYTimeout = timeoutId;\n\t// \t}\n\t// }\n\n\t// private showAxis(orientation: AXIS_TYPE) {\n\t// \tvar isXAxis = orientation == AXIS_TYPE.X;\n\t// \tvar material: MeshBasicMaterial;\n\t// \tif (isXAxis) {\n\t// \t\tmaterial = (this.axisXObject.children[0] as Mesh).material as MeshBasicMaterial;\n\t// \t} else {\n\t// \t\tmaterial = (this.axisYObject.children[0] as Mesh).material as MeshBasicMaterial;\n\t// \t}\n\t// \tthis.updateAxis(orientation);\n\t// \tTweenLite.to(material, 0.3, {opacity: 1});\n\t// }\n\n\tstatic getDateStr(timestamp: number, gridParams: IGridParamsForAxis): string {\n\t\tvar sec = 1000;\n\t\tvar min = sec * 60;\n\t\tvar hour = min * 60;\n\t\tvar day = hour * 60;\n\t\tvar step = gridParams.step;\n\t\tvar d = new Date(timestamp);\n\t\tvar tf = (num: number) => Utils.toFixed(num, 2);\n\t\treturn tf(d.getHours()) + ':' + tf(d.getMinutes()) + ':' + tf(d.getSeconds());\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/AxisWidget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport {ChartWidget} from \"../Widget\";\nimport LineSegments = THREE.LineSegments;\nimport {Utils} from \"../Utils\";\nimport {IScreenTransformOptions} from \"../Screen\";\nimport {IAxisOptions} from \"../interfaces\";\n\nexport interface IGridParamsForAxis {\n\tstart: number,\n\tend: number,\n\tstep: number,\n\tstepInPx: number,\n\tlength: number,\n\tsegmentsCount: number\n}\n\n/**\n * widget for drawing chart grid\n */\nexport class GridWidget extends ChartWidget{\n\tstatic widgetName = 'Grid';\n\tprivate lineSegments: LineSegments;\n\tprivate gridSizeH: number;\n\tprivate gridSizeV: number;\n\tprivate isDestroyed = false;\n\n\tonReadyHandler() {\n\t\tvar {width, height, xAxis, yAxis} = this.chart.data;\n\t\tthis.gridSizeH = Math.floor(width / xAxis.grid.minSizePx) * 3;\n\t\tthis.gridSizeV = Math.floor(height / yAxis.grid.minSizePx) * 3;\n\t\tthis.initGrid();\n\t\tthis.updateGrid();\n\t\tthis.bindEvents();\n\t}\n\n\tbindEvents() {\n\t\t// grid is bigger then screen, so it's no need to update it on each scroll event\n\t\tlet updateGridThrottled = Utils.throttle(() => this.updateGrid(), 1000);\n\t\tthis.bindEvent(this.chart.onScroll(() => updateGridThrottled()),\n\t\t\tthis.chart.screen.onZoomFrame((options) => {\n\t\t\t\tupdateGridThrottled();\n\t\t\t\tthis.onZoomFrame(options);\n\t\t\t}),\n\t\t\tthis.chart.onDestroy(() => {\n\t\t\t\tthis.isDestroyed = true;\n\t\t\t\tthis.unbindEvents();\n\t\t\t}),\n\t\t\tthis.chart.onResize(() => {\n\t\t\t\tthis.updateGrid();\n\t\t\t})\n\t\t);\n\n\t}\n\n\tprivate initGrid() {\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.LineBasicMaterial( { linewidth: 1, opacity: 0.1, transparent: true});\n\t\tvar xLinesCount = this.gridSizeH;\n\t\tvar yLinesCount = this.gridSizeV;\n\t\twhile (xLinesCount--) geometry.vertices.push(new Vector3(), new Vector3());\n\t\twhile (yLinesCount--) geometry.vertices.push(new Vector3(), new Vector3());\n\t\tthis.lineSegments = new LineSegments(geometry, material);\n\t\tthis.lineSegments.position.setZ(-1);\n\t\tthis.lineSegments.frustumCulled = false;\n\t}\n\n\tprivate updateGrid() {\n\t\tif (this.isDestroyed) return;\n\t\tvar {yAxis, xAxis, width, height} = this.chart.data;\n\t\tvar axisXGrid = GridWidget.getGridParamsForAxis(xAxis, width, xAxis.range.zoom);\n\t\tvar axisYGrid = GridWidget.getGridParamsForAxis(yAxis, height, yAxis.range.zoom);\n\t\tvar scrollXInSegments = Math.ceil(xAxis.range.scroll / axisXGrid.step);\n\t\tvar scrollYInSegments = Math.ceil(yAxis.range.scroll / axisYGrid.step);\n\t\tvar gridScrollXVal = scrollXInSegments * axisXGrid.step;\n\t\tvar gridScrollYVal = scrollYInSegments * axisYGrid.step;\n\t\tvar startXVal = axisXGrid.start + gridScrollXVal;\n\t\tvar startYVal = axisYGrid.start + gridScrollYVal;\n\t\tvar geometry = this.lineSegments.geometry as Geometry;\n\t\tvar vertices = geometry.vertices;\n\t\tvar lineInd = 0;\n\n\t\tfor (let i =  -this.gridSizeH / 3; i < this.gridSizeH * 2/3; i++) {\n\t\t\tlet value = startXVal + i * axisXGrid.step;\n\t\t\tlet lineSegment = this.getVerticalLineSegment(value, gridScrollXVal, gridScrollYVal);\n\t\t\tvertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\n\t\t\tvertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\n\t\t\tlineInd++;\n\t\t}\n\n\t\tfor (let i =  -this.gridSizeV / 3; i < this.gridSizeV * 2/3; i++) {\n\t\t\tlet value = startYVal + i * axisYGrid.step;\n\t\t\tlet lineSegment = this.getHorizontalLineSegment(value, gridScrollXVal, gridScrollYVal);\n\t\t\tvertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\n\t\t\tvertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\n\t\t\tlineInd++;\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tthis.lineSegments.scale.set(\n\t\t\txAxis.range.scaleFactor * xAxis.range.zoom,\n\t\t\tyAxis.range.scaleFactor * yAxis.range.zoom,\n\t\t\t1\n\t\t)\n\t}\n\n\tprivate getHorizontalLineSegment(yVal: number, scrollXVal: number, scrollYVal: number): Vector3[] {\n\t\tvar chartState = this.chart;\n\t\tvar localYVal = yVal - chartState.data.yAxis.range.zeroVal - scrollYVal;\n\t\tvar widthVal = chartState.pxToValueByXAxis(chartState.data.width);\n\t\treturn [\n\t\t\tnew THREE.Vector3(widthVal * 2 + scrollXVal, localYVal, 0 ),\n\t\t\tnew THREE.Vector3( -widthVal + scrollXVal, localYVal, 0 )\n\t\t];\n\t}\n\n\tprivate getVerticalLineSegment(xVal: number, scrollXVal: number, scrollYVal: number): Vector3[] {\n\t\tvar chartState = this.chart;\n\t\tvar localXVal = xVal - chartState.data.xAxis.range.zeroVal - scrollXVal;\n\t\tvar heightVal = chartState.pxToValueByYAxis(chartState.data.height);\n\t\treturn [\n\t\t\tnew THREE.Vector3(localXVal, heightVal * 2 + scrollYVal, 0 ),\n\t\t\tnew THREE.Vector3(localXVal, -heightVal + scrollYVal, 0 )\n\t\t];\n\t}\n\n\tprivate onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar {xAxis, yAxis} = this.chart.data;\n\t\tif (options.zoomX) this.lineSegments.scale.setX(xAxis.range.scaleFactor * options.zoomX);\n\t\tif (options.zoomY) this.lineSegments.scale.setY(yAxis.range.scaleFactor * options.zoomY);\n\t}\n\n\n\t// TODO: move this code to core\n\tstatic getGridParamsForAxis(axisOptions: IAxisOptions, axisWidth: number, zoom: number): IGridParamsForAxis {\n\t\tlet axisRange = axisOptions.range;\n\t\tlet from = axisRange.from;\n\t\tlet to = axisRange.to;\n\t\tlet axisLength = to - from;\n\t\tlet gridStep = 0;\n\t\tlet gridStepInPixels = 0;\n\t\tlet minGridStepInPixels = axisOptions.grid.minSizePx;\n\t\tlet axisLengthStr = String(axisLength);\n\t\tlet axisLengthPointPosition = axisLengthStr.indexOf('.');\n\t\tlet intPartLength = axisLengthPointPosition !== -1 ? axisLengthPointPosition : axisLengthStr.length;\n\n\t\tlet gridStepFound = false;\n\t\tlet digitPos = 0;\n\t\twhile (!gridStepFound) {\n\n\t\t\tlet power = intPartLength - digitPos - 1;\n\t\t\tlet multiplier = (Math.pow(10, power) || 1);\n\t\t\tlet dividers = [1, 2, 5];\n\t\t\tfor (let dividerInd = 0; dividerInd < dividers.length; dividerInd++) {\n\t\t\t\tlet nextGridStep = multiplier / dividers[dividerInd];\n\t\t\t\tlet nextGridStepInPixels = nextGridStep / axisLength * axisWidth;\n\t\t\t\tif (nextGridStepInPixels >= minGridStepInPixels) {\n\t\t\t\t\tgridStep = nextGridStep;\n\t\t\t\t\tgridStepInPixels = nextGridStepInPixels;\n\t\t\t\t} else {\n\t\t\t\t\tgridStepFound = true;\n\t\t\t\t\tif (gridStep === 0) {\n\t\t\t\t\t\tgridStep = nextGridStep;\n\t\t\t\t\t\tgridStepInPixels = nextGridStepInPixels;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!gridStepFound) digitPos++\n\n\t\t}\n\n\t\tvar gridStart = Math.floor(from / gridStep) * gridStep;\n\t\tvar gridEnd = Math.floor(to / gridStep) * gridStep;\n\n\t\treturn {\n\t\t\tstart: gridStart,\n\t\t\tend: gridEnd,\n\t\t\tstep: gridStep,\n\t\t\tstepInPx: gridStepInPixels,\n\t\t\tlength: gridEnd - gridStart,\n\t\t\tsegmentsCount: Math.round((gridEnd - gridStart) / gridStep)\n\t\t}\n\t}\n\t\n\tgetObject3D() {\n\t\treturn this.lineSegments;\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/GridWidget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport {Chart} from \"../Chart\";\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport {ITrendOptions} from \"../Trend\";\nimport {Utils} from \"../Utils\";\nimport {TrendsWidget, TrendWidget} from \"./TrendsWidget\";\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport { IScreenTransformOptions } from '../Screen';\nimport { TrendSegmentsManager, ITrendSegmentState } from '../TrendSegmentsManager';\nimport { ChartColor } from '../Color';\n\nexport class TrendsGradientWidget extends TrendsWidget<TrendGradient> {\n\tstatic widgetName = \"TrendsGradient\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendGradient;\n\t}\n}\n\n\nexport class TrendGradient extends TrendWidget {\n\tprivate gradient: Mesh;\n\tprivate visibleSegmentsCnt = 0;\n\tprivate segmentsIds: Uint16Array;\n\t\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.hasBackground;\n\t}\n\n\tconstructor (chartState: Chart, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tthis.trend = chartState.trendsManager.getTrend(trendName);\n\t\tthis.segmentsIds = new Uint16Array(chartState.data.maxVisibleSegments)\n\t\tthis.initGradient();\n\t\tthis.updateSegments();\n\t}\n\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.updateSegments();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\t// TODO: optimize updateSegments for onDisplayedRangeChanged\n\t\t\tthis.updateSegments();\n\t\t}));\n\t\tthis.bindEvent(this.chart.onZoom(() => {\n\t\t\tthis.updateSegments();\n\t\t}));\n\t}\n\n\n\tgetObject3D(): Object3D {\n\t\treturn this.gradient;\n\t}\n\n\n\tinitGradient() {\n\t\tlet geometry = new Geometry();\n\n\n\t\tfor (let i = 0; i < this.segmentsIds.length; i++) {\n\t\t\tgeometry.vertices.push(\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3()\n\t\t\t);\n\t\t\tlet ind = i * 4;\n\n\t\t\t// gradient segment scheme\n\t\t\t//\n\t\t\t// vert0 +---+ vert3\n\t\t\t//       |\\  |\n\t\t\t// face1 | \\ | face2\n\t\t\t// \t     |  \\|\n\t\t\t// vert1 +---+ vert2\n\n\t\t\tgeometry.faces.push(\n\t\t\t\tnew THREE.Face3( ind, ind + 1, ind + 2 ),\n\t\t\t\tnew THREE.Face3( ind + 3, ind, ind + 2 )\n\t\t\t);\n\t\t}\n\n\t\tlet color = new ChartColor(this.trend.getOptions().backgroundColor);\n\t\tthis.gradient = new THREE.Mesh(\n\t\t\tgeometry,\n\t\t\tnew THREE.MeshBasicMaterial( {color: color.value, transparent: true, opacity: color.a} )\n\t\t);\n\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = this.chart.data.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = this.chart.data.yAxis.range;\n\t\tthis.gradient.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.gradient.frustumCulled = false;\n\t}\n\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tlet state = this.chart.data;\n\t\tlet scaleXFactor = state.xAxis.range.scaleFactor;\n\t\tlet scaleYFactor = state.yAxis.range.scaleFactor;\n\t\tvar currentScale = this.gradient.scale;\n\t\tif (options.zoomX) currentScale.setX(scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(scaleYFactor * options.zoomY);\n\t}\n\n\n\tprotected onSegmentsAnimate(trendSegmentsManager: TrendSegmentsManager) {\n\t\tlet animatedSegmentsIds = trendSegmentsManager.animatedSegmentsIds;\n\t\tfor (let i = 0; i < this.visibleSegmentsCnt; i++) {\n\t\t\tlet segmentId = this.segmentsIds[i];\n\t\t\tif (!animatedSegmentsIds.includes(segmentId)) continue;\n\t\t\tthis.setupSegmentVertices(i, trendSegmentsManager.getSegment(segmentId).currentAnimationState);\n\t\t}\n\t\t(this.gradient.geometry as PlaneGeometry).verticesNeedUpdate = true;\n\t}\n\n\n\tprivate updateSegments() {\n\t\tlet geometry = this.gradient.geometry as PlaneGeometry;\n\t\tlet {\n\t\t\tsegments: trendSegments,\n\t\t\tfirstDisplayedSegmentInd: segmentInd,\n\t\t\tlastDisplayedSegmentInd\n\t\t} = this.trend.segmentsManager;\n\t\tlet prevVisibleSegmentsCnt = this.visibleSegmentsCnt;\n\t\tthis.visibleSegmentsCnt = lastDisplayedSegmentInd - segmentInd + 1;\n\t\tlet segmentsToProcessCnt = Math.max(prevVisibleSegmentsCnt, this.visibleSegmentsCnt);\n\n\t\tif (segmentsToProcessCnt > this.segmentsIds.length) {\n\t\t\tUtils.error(TrendsGradientWidget.widgetName + ': MAX_SEGMENTS reached');\n\t\t}\n\n\t\t// setup visible segments and collapse invisible\n\t\tfor (let i = 0; i <= segmentsToProcessCnt; i++) {\n\t\t\tif (segmentInd <= lastDisplayedSegmentInd) {\n\t\t\t\tlet segment = trendSegments[segmentInd];\n\t\t\t\tthis.setupSegmentVertices(i, segment.currentAnimationState);\n\t\t\t\tthis.segmentsIds[i] = segment.id;\n\t\t\t\tsegmentInd++;\n\t\t\t} else {\n\t\t\t\tthis.setupSegmentVertices(i);\n\t\t\t}\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\t}\n\n\n\t/**\n\t * setup gradient segment by segmentState\n\t * if segmentState is undefined, then collapse vertices to 0,0,0\n\t */\n\tprivate setupSegmentVertices(segmentInd: number, segmentState?: ITrendSegmentState) {\n\t\tlet gradientSegmentInd = segmentInd * 4;\n\t\tlet vertices = (this.gradient.geometry as PlaneGeometry).vertices;\n\t\tlet\ttopLeft = vertices[gradientSegmentInd];\n\t\tlet\tbottomLeft = vertices[gradientSegmentInd + 1];\n\t\tlet\tbottomRight = vertices[gradientSegmentInd + 2];\n\t\tlet\ttopRight = vertices[gradientSegmentInd + 3];\n\t\tlet screenHeightVal = Math.max(\n\t\t\tthis.chart.pxToValueByYAxis(this.chart.data.height),\n\t\t\tthis.chart.screen.pxToValueByYAxis(this.chart.data.height)\n\t\t);\n\n\t\tif (segmentState) {\n\t\t\tlet startX = this.toLocalX(segmentState.startXVal);\n\t\t\tlet startY = this.toLocalY(segmentState.startYVal);\n\t\t\tlet endX = this.toLocalX(segmentState.endXVal);\n\t\t\tlet endY = this.toLocalY(segmentState.endYVal);\n\t\t\ttopLeft.set(startX, startY, 0);\n\t\t\ttopRight.set(endX, endY, 0);\n\t\t\tbottomLeft.set(topLeft.x, topLeft.y - screenHeightVal, 0);\n\t\t\tbottomRight.set(topRight.x, topRight.y - screenHeightVal, 0);\n\t\t} else {\n\t\t\ttopLeft.set(0, 0, 0);\n\t\t\ttopRight.set(0, 0, 0);\n\t\t\tbottomLeft.set(0, 0, 0);\n\t\t\tbottomRight.set(0, 0, 0);\n\t\t}\n\n\t}\n\n\tprivate toLocalX(xVal: number): number {\n\t\treturn xVal - this.chart.data.xAxis.range.zeroVal;\n\t}\n\n\n\tprivate toLocalY(yVal: number): number {\n\t\treturn yVal - this.chart.data.yAxis.range.zeroVal;\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsGradientWidget.ts\n **/","\nimport {ChartWidget} from \"../Widget\";\nimport Object3D = THREE.Object3D;\nimport {Chart} from \"../Chart\";\nimport {ITrendOptions, ITrendData, Trend} from \"../Trend\";\nimport Vector2 = THREE.Vector2;\nimport Vector3 = THREE.Vector3;\nimport {TrendSegmentsManager} from \"../TrendSegmentsManager\";\nimport {IScreenTransformOptions} from \"../Screen\";\n\n\nexport interface ITrendWidgetClass<TrendWidgetType> {\n\tnew (chart: Chart, trendName: string): TrendWidgetType;\n\twidgetIsEnabled(trendOptions: ITrendOptions, chart: Chart): boolean;\n}\n\n/**\n * abstract manager class for all trends widgets\n */\nexport abstract class TrendsWidget<TrendWidgetType extends TrendWidget> extends ChartWidget {\n\tprotected abstract getTrendWidgetClass(): ITrendWidgetClass<TrendWidgetType>;\n\tprotected object3D: Object3D;\n\tprotected widgets: {[trendName: string]: TrendWidgetType} = {};\n\n\tonReadyHandler() {\n\t\tthis.object3D = new Object3D();\n\t\tthis.onTrendsChange();\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tvar state = this.chart;\n\t\tstate.onTrendsChange(() => this.onTrendsChange());\n\t\tstate.onTrendChange((trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tthis.onTrendChange(trendName, changedOptions, newData)\n\t\t});\n\t}\n\n\tprotected onTrendsChange() {\n\t\tvar trendsOptions = this.chart.data.trends;\n\t\tvar TrendWidgetClass = this.getTrendWidgetClass();\n\t\tfor (let trendName in trendsOptions) {\n\t\t\tlet trendOptions = trendsOptions[trendName];\n\t\t\tlet widgetCanBeEnabled = TrendWidgetClass.widgetIsEnabled(trendOptions, this.chart);\n\t\t\tif (widgetCanBeEnabled && !this.widgets[trendName]) {\n\t\t\t\tthis.createTrendWidget(trendName);\n\t\t\t} else if (!widgetCanBeEnabled && this.widgets[trendName]){\n\t\t\t\tthis.destroyTrendWidget(trendName);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onTrendChange(trendName: string, changedOptions: ITrendOptions, newData: ITrendData) {\n\t\tvar widget = this.widgets[trendName];\n\t\tif (!widget) return;\n\t\twidget.onTrendChange(changedOptions);\n\t\tif (newData) {\n\t\t\tvar data = this.chart.getTrend(trendName).getData();\n\t\t\tvar isAppend = (!data.length || data[0].xVal < newData[0].xVal);\n\t\t\tisAppend ? widget.appendData(newData) : widget.prependData(newData);\n\t\t}\n\t}\n\n\tgetObject3D(): Object3D {\n\t\treturn this.object3D;\n\t}\n\n\tprivate createTrendWidget(trendName: string) {\n\t\tvar WidgetConstructor = this.getTrendWidgetClass();\n\t\tvar widget = new WidgetConstructor(this.chart, trendName);\n\t\tthis.widgets[trendName] = widget;\n\t\tvar widgetObject = widget.getObject3D();\n\t\twidgetObject.name = trendName;\n\t\tthis.object3D.add(widget.getObject3D());\n\t}\n\n\tprivate destroyTrendWidget(trendName: string) {\n\t\tthis.widgets[trendName].onDestroy();\n\t\tdelete this.widgets[trendName];\n\t\tvar widgetObject = this.object3D.getObjectByName(trendName);\n\t\tthis.object3D.remove(widgetObject);\n\t}\n}\n\n/**\n * based class for all trends widgets\n */\nexport abstract class TrendWidget {\n\tprotected trend: Trend;\n\tprotected unbindList: Function[] = [];\n\n\tconstructor (protected chart: Chart, protected trendName: string) {\n\t\tthis.trend = chart.trendsManager.getTrend(trendName);\n\t\tthis.chart = chart;\n\t\tthis.bindEvents();\n\t}\n\tabstract getObject3D(): Object3D;\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions, chart: Chart) {\n\t\treturn trendOptions.enabled;\n\t}\n\tappendData(newData: ITrendData) {};\n\tprependData(newData: ITrendData) {};\n\tonTrendChange(changedOptions?: ITrendOptions) {}\n\tonDestroy() {\n\t\tfor (let unsubscriber of this.unbindList) {\n\t\t\tunsubscriber();\n\t\t}\n\t}\n\tprotected onSegmentsAnimate(segments: TrendSegmentsManager) {\n\t}\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t}\n\tprotected onTransformationFrame(options: IScreenTransformOptions) {\n\t}\n\tprotected onZoom() {\n\t}\n\n\n\tprotected bindEvents() {\n\n\t\tthis.bindEvent(this.trend.segmentsManager.onAnimationFrame(\n\t\t\t(trendPoints: TrendSegmentsManager) => this.onSegmentsAnimate(trendPoints)\n\t\t));\n\n\t\tthis.bindEvent(this.chart.screen.onTransformationFrame(\n\t\t\t(options) => this.onTransformationFrame(options)\n\t\t));\n\t\t\n\t\tthis.bindEvent(this.chart.screen.onZoomFrame(\n\t\t\t(options) => this.onZoomFrame(options)\n\t\t));\n\n\t\tthis.bindEvent(this.chart.onZoom(() => this.onZoom()));\n\t};\n\n\tprotected bindEvent(unbind: Function) {\n\t\tthis.unbindList.push(unbind);\n\t}\n\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsWidget.ts\n **/","export declare type TChartColor = string | number;\n\n\nexport class ChartColor {\n\n\t/**!\n\t * @preserve $.parseColor\n\t * Copyright 2011 THEtheChad Elliott\n\t * Released under the MIT and GPL licenses.\n\t */\n\t/**\n\t * Parse hex/rgb{a} color syntax.\n\t * @input string\n\t * @returns array [r,g,b{,o}]\n\t */\n\tstatic parseColor(color: string): number[] {\n\n\t\tvar cache: any\n\t\t\t, p = parseInt // Use p as a byte saving reference to parseInt\n\t\t\t, color = color.replace(/\\s\\s*/g, '') // Remove all spaces\n\t\t\t;//var\n\n\t\t// Checks for 6 digit hex and converts string to integer\n\t\tif (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\n\n\t\t// Checks for 3 digit hex and converts string to integer\n\t\telse if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\n\t\t\tcache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\n\n\n\t\t// Checks for 6 digit hex with alpha and converts string to integer\n\t\telse if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\n\n\t\t// Checks for rgba and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3], +cache[4]];\n\n\t\t// Checks for rgb and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3]];\n\n\t\t// Otherwise throw an exception to make debugging easier\n\t\telse throw Error(color + ' is not supported by parseColor');\n\n\t\t// Performs RGBA conversion by default\n\t\tisNaN(cache[3]) && (cache[3] = 1);\n\t\treturn cache;\n\t\t// Adds or removes 4th value based on rgba support\n\t\t// Support is flipped twice to prevent erros if\n\t\t// it's not defined\n\t\t//return cache.slice(0,3 + !!$.support.rgba);\n\t}\n\n\tr: number;\n\tg: number;\n\tb: number;\n\ta: number;\n\tvalue: number;\n\thexStr: string;\n\trgbaStr: string;\n\n\tconstructor (color: TChartColor) {\n\t\tthis.set(color);\n\t}\n\n\tset(color: TChartColor) {\n\t\tif (typeof color == 'number') color = '#' + (color as number).toString(16);\n\t\tlet colorStr = color as string;\n\t\tlet rgba = ChartColor.parseColor(colorStr);\n\t\tthis.r = rgba[0];\n\t\tthis.g = rgba[1];\n\t\tthis.b = rgba[2];\n\t\tthis.a = rgba[3];\n\t\tthis.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\n\t\tthis.hexStr = '#' + this.value.toString(16);\n\t\tthis.rgbaStr = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Color.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport {Chart} from \"../Chart\";\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport {TrendsWidget, TrendWidget} from \"./TrendsWidget\";\nimport { TrendSegmentsManager, ITrendSegmentState } from \"../TrendSegmentsManager\";\nimport LineSegments = THREE.LineSegments;\nimport {IScreenTransformOptions} from \"../Screen\";\nimport { ITrendOptions, TREND_TYPE } from '../Trend';\nimport { Utils } from '../Utils';\n\n\n/**\n * widget for drawing trends lines\n */\nexport class TrendsLineWidget extends TrendsWidget<TrendLine> {\n\tstatic widgetName = \"TrendsLine\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendLine;\n\t}\n}\n\ninterface ILineSegment {\n\tind: number,\n\tsegmentId: number\n}\n\nexport class TrendLine extends TrendWidget {\n\tprivate material: LineBasicMaterial;\n\tprivate lineSegments: LineSegments;\n\tprivate vertices: Vector3[];\n\n\t// contains indexes of free segments\n\tprivate freeSegmentsInds: number[] = [];\n\n\t// contains segments to display\n\tprivate displayedSegments: {[segmentId: number]: ILineSegment} = {};\n\t\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.type == TREND_TYPE.LINE;\n\t}\n\t\n\tconstructor (chartState: Chart, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tvar options = this.trend.getOptions();\n\t\tthis.material = new LineBasicMaterial( { color: options.lineColor, linewidth: options.lineWidth } );\n\t\tthis.initLine();\n\t}\n\n\tgetObject3D() {\n\t\treturn this.lineSegments;\n\t}\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.destroySegments();\n\t\t\tthis.setupSegments();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\tthis.setupSegments();\n\t\t}));\n\t}\n\t\n\tprivate initLine() {\n\t\tlet geometry = new Geometry();\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = this.chart.data.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = this.chart.data.yAxis.range;\n\t\tthis.lineSegments = new LineSegments(geometry, this.material);\n\t\tthis.lineSegments.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.lineSegments.frustumCulled = false;\n\t\tfor (let i = 0; i < this.chart.data.maxVisibleSegments; i++) {\n\t\t\tgeometry.vertices.push(new  Vector3(), new Vector3());\n\t\t\tthis.freeSegmentsInds.push(i);\n\t\t}\n\t\tthis.vertices = geometry.vertices;\n\t\tthis.setupSegments();\n\t}\n\n\tprivate setupSegments() {\n\t\tlet geometry = this.lineSegments.geometry as Geometry;\n\n\t\tlet {firstDisplayedSegment, lastDisplayedSegment} = this.trend.segmentsManager;\n\n\t\tfor (let segmentId in this.displayedSegments) {\n\t\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\t\tlet segment = this.trend.segmentsManager.segments[lineSegment.segmentId];\n\t\t\tlet segmentIsNotDisplayed = (\n\t\t\t\tsegment.startXVal < firstDisplayedSegment.startXVal ||\n\t\t\t\tsegment.endXVal > lastDisplayedSegment.endXVal\n\t\t\t);\n\t\t\tif (segmentIsNotDisplayed) this.destroySegment(Number(segmentId));\n\t\t}\n\n\t\tlet segment = firstDisplayedSegment;\n\t\twhile (segment && segment.xVal <= lastDisplayedSegment.xVal) {\n\t\t\tthis.setupSegment(segment.id, segment.currentAnimationState);\n\t\t\tsegment = segment.getNext();\n\t\t}\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t}\n\n\tprivate setupSegment(segmentId: number, segmentState: ITrendSegmentState) {\n\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\tif (!lineSegment) {\n\t\t\tif (this.freeSegmentsInds.length == 0) Utils.error('Max allocated segments reached');\n\t\t\tlet ind = this.freeSegmentsInds.pop();\n\t\t\tlineSegment = this.displayedSegments[segmentId] = {segmentId, ind};\n\t\t}\n\t\tlet segmentInd = lineSegment.ind;\n\t\tlet lineStartVertex = this.vertices[segmentInd * 2];\n\t\tlet lineEndVertex = this.vertices[segmentInd * 2 + 1];\n\t\tlineStartVertex.set(this.toLocalX(segmentState.startXVal), this.toLocalY(segmentState.startYVal), 0);\n\t\tlineEndVertex.set(this.toLocalX(segmentState.endXVal), this.toLocalY(segmentState.endYVal), 0);\n\t}\n\n\tprivate destroySegments() {\n\t\tfor (let segmentId in this.displayedSegments) this.destroySegment(Number(segmentId));\n\t}\n\n\tprivate destroySegment(segmentId: number) {\n\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\tlet lineStartVertex = this.vertices[lineSegment.ind * 2];\n\t\tlet lineEndVertex = this.vertices[lineSegment.ind * 2 + 1];\n\t\tlineStartVertex.set(0, 0, 0);\n\t\tlineEndVertex.set(0, 0, 0);\n\t\tdelete this.displayedSegments[segmentId];\n\t\tthis.freeSegmentsInds.push(lineSegment.ind);\n\t}\n\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar currentScale = this.lineSegments.scale;\n\t\tlet state = this.chart.data;\n\t\tlet scaleXFactor = state.xAxis.range.scaleFactor;\n\t\tlet scaleYFactor = state.yAxis.range.scaleFactor;\n\t\tif (options.zoomX) currentScale.setX(scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(scaleYFactor * options.zoomY);\n\t}\n\n\n\tprotected onSegmentsAnimate(trendSegments: TrendSegmentsManager) {\n\t\tvar geometry = this.lineSegments.geometry as Geometry;\n\t\tfor (let segmentId of trendSegments.animatedSegmentsIds) {\n\t\t\tif (!this.displayedSegments[segmentId]) continue;\n\t\t\tthis.setupSegment(segmentId, trendSegments.segmentsById[segmentId].currentAnimationState);\n\t\t}\n\t\tgeometry.verticesNeedUpdate = true;\n\t}\n\n\n\tprivate toLocalX(xVal: number): number {\n\t\treturn xVal - this.chart.data.xAxis.range.zeroVal;\n\t}\n\n\tprivate toLocalY(yVal: number): number {\n\t\treturn yVal - this.chart.data.yAxis.range.zeroVal;\n\t}\n\n\tprivate toLocalVec(vec: Vector3): Vector3 {\n\t\treturn new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsLineWidget.ts\n **/","\n\nimport { TrendsWidget, TrendWidget } from './TrendsWidget';\nimport { Chart } from '../Chart';\nimport Object3D = THREE.Object3D;\nimport Geometry = THREE.Geometry;\nimport { IScreenTransformOptions } from '../Screen';\nimport { TrendSegmentsManager, ITrendSegmentState } from '../TrendSegmentsManager';\nimport Vector3 = THREE.Vector3;\nimport Mesh = THREE.Mesh;\nimport Line = THREE.Line;\nimport BoxGeometry = THREE.BoxGeometry;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport { TREND_TYPE, ITrendOptions } from '../Trend';\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport remove = THREE.Cache.remove;\nimport { Utils } from '../Utils';\n\n\nconst RISE_COLOR = 0x2CAC40;\nconst FALL_COLOR = 0xEE5533;\nconst MARGIN_PERCENT = 0.3;\nconst MAX_CANDLES = 100;\n\n/**\n * widget for drawing trends candles\n */\nexport class TrendsCandlesWidget extends TrendsWidget<TrendCandlesWidget> {\n\tstatic widgetName = \"TrendsCandles\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendCandlesWidget;\n\t}\n}\n\n\nexport class TrendCandlesWidget extends TrendWidget {\n\tprivate scaleXFactor: number;\n\tprivate scaleYFactor: number;\n\tprivate object3D: Object3D;\n\t\n\t// contains indexes of free candles\n\tprivate freeCandlesInds: number[] = [];\n\tprivate candlesPool: CandleWidget[] = [];\n\tprivate candles: {[segmentId: number]: CandleWidget} = {};\n\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.type == TREND_TYPE.CANDLE;\n\t}\n\n\tconstructor (chartState: Chart, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tthis.initObject();\n\t}\n\n\n\tgetObject3D() {\n\t\treturn this.object3D;\n\t}\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.destroyCandles();\n\t\t\tthis.setupCandles();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\tthis.setupCandles();\n\t\t}));\n\t}\n\t\n\tprivate initObject() {\n\t\tlet stateData = this.chart.data;\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = stateData.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = stateData.yAxis.range;\n\t\tthis.scaleXFactor = scaleXFactor;\n\t\tthis.scaleYFactor = scaleYFactor;\n\t\tthis.object3D = new Object3D();\n\t\tthis.object3D.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.object3D.frustumCulled = false;\n\t\tfor (let i = 0; i < MAX_CANDLES; i++) this.freeCandlesInds.push(i);\n\t\tthis.setupCandles();\n\t}\n\n\tprivate setupCandles() {\n\n\t\t// remove invisible\n\t\tlet {firstDisplayedSegment, lastDisplayedSegment} = this.trend.segmentsManager;\n\n\t\tfor (let segmentId in this.candles) {\n\t\t\tlet segment = this.candles[segmentId].segment;\n\t\t\tlet segmentIsNotDisplayed = (\n\t\t\t\tsegment.startXVal < firstDisplayedSegment.startXVal ||\n\t\t\t\tsegment.endXVal > lastDisplayedSegment.endXVal\n\t\t\t);\n\t\t\tif (segmentIsNotDisplayed) this.destroyCandle(Number(segmentId));\n\t\t}\n\n\t\tlet segment = firstDisplayedSegment;\n\t\twhile (segment && segment.xVal <= lastDisplayedSegment.xVal) {\n\t\t\tthis.setupCandle(segment.id, segment.currentAnimationState);\n\t\t\tsegment = segment.getNext();\n\t\t}\n\t}\n\n\tprivate destroyCandles() {\n\t\tfor (let segmentId in this.candles) this.destroyCandle(Number(segmentId));\n\t}\n\n\tprivate destroyCandle(segmentId: number) {\n\t\tlet candle = this.candles[segmentId];\n\t\tthis.object3D.remove(candle.getObject3D());\n\t\tdelete this.candles[segmentId];\n\t}\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar currentScale = this.object3D.scale;\n\t\tif (options.zoomX) currentScale.setX(this.scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(this.scaleYFactor * options.zoomY);\n\t}\n\n\tprotected onSegmentsAnimate(trendSegments: TrendSegmentsManager) {\n\t\tfor (let segmentId of trendSegments.animatedSegmentsIds) {\n\t\t\tif (!this.candles[segmentId]) continue;\n\t\t\tlet segmentState = trendSegments.segmentsById[segmentId].currentAnimationState;\n\t\t\tthis.setupCandle(segmentId, segmentState);\n\t\t}\n\t}\n\n\t/**\n\t * create or modify candle\n\t */\n\tprivate setupCandle(candleId: number, segmentState: ITrendSegmentState) {\n\t\tlet candleInd = candleId % MAX_CANDLES;\n\n\t\t// get candle from candlesPool to avoid creating new Objects by performance reasons\n\t\tlet candle = this.candlesPool[candleInd];\n\t\tif (!candle) {\n\t\t\tcandle = this.candlesPool[candleInd] = new CandleWidget();\n\t\t}\n\n\t\tif (!this.candles[candleId]) {\n\t\t\tthis.candles[candleId] = candle;\n\t\t\tthis.object3D.add(candle.getObject3D());\n\t\t}\n\t\tcandle.getObject3D().position.set(this.toLocalX(segmentState.xVal), this.toLocalY(segmentState.yVal), 0);\n\t\tcandle.setSegment(segmentState);\n\t}\n\n\ttoLocalX(xVal: number): number {\n\t\treturn xVal - this.chart.data.xAxis.range.zeroVal;\n\t}\n\n\ttoLocalY(yVal: number): number {\n\t\treturn yVal - this.chart.data.yAxis.range.zeroVal;\n\t}\n\n\ttoLocalVec(vec: Vector3): Vector3 {\n\t\treturn new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\n\t}\n}\n\nclass CandleWidget {\n\tsegment: ITrendSegmentState;\n\tprivate rect: Mesh;\n\tprivate vLine: Line;\n\tprivate hLine: Line;\n\tconstructor () {\n\t\tthis.initObject();\n\t}\n\n\tgetObject3D(): Object3D {\n\t\treturn this.rect;\n\t}\n\n\tsetSegment(segment: ITrendSegmentState) {\n\t\tthis.segment = segment;\n\t\tlet color = segment.endYVal < segment.startYVal ? FALL_COLOR : RISE_COLOR;\n\n\t\t// update rect\n\t\tlet geometry = this.rect.geometry as PlaneGeometry;\n\t\tlet material = this.rect.material as MeshBasicMaterial;\n\t\tlet width = segment.endXVal - segment.startXVal;\n\t\twidth -= width * MARGIN_PERCENT;\n\t\tlet height = Math.max(segment.startYVal, segment.endYVal) - Math.min(segment.startYVal, segment.endYVal);\n\t\tlet [leftTop, rightTop, leftBottom, rightBottom] = geometry.vertices;\n\t\tleftTop.set(-width / 2, height / 2, 0);\n\t\trightTop.set(width / 2, height / 2, 0);\n\t\tleftBottom.set(-width / 2, -height / 2, 0);\n\t\trightBottom.set(width / 2, -height / 2, 0);\n\n\t\t// prevent to draw bars with height < 1px\n\t\tif (Utils.getDistance(leftTop.y, leftBottom.y) < 1) {\n\t\t\tleftBottom.setY(leftBottom.y + 1);\n\t\t\trightBottom.setY(rightBottom.y + 1);\n\t\t}\n\n\t\tmaterial.color.set(color);\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t// update lines\n\t\tlet vLineGeometry = this.vLine.geometry as Geometry;\n\t\tlet vLineMaterial = this.vLine.material as LineBasicMaterial;\n\t\tlet lineTop = segment.maxYVal - segment.yVal;\n\t\tlet lineBottom = segment.minYVal - segment.yVal;\n\t\tvLineGeometry.vertices[0].set(0, lineTop, 0);\n\t\tvLineGeometry.vertices[1].set(0, lineBottom, 0);\n\t\tvLineMaterial.color.set(color);\n\t\tvLineGeometry.verticesNeedUpdate = true;\n\n\t\tlet hLineGeometry = this.hLine.geometry as Geometry;\n\t\tlet hLineMaterial = this.hLine.material as LineBasicMaterial;\n\t\tlet lineLeft = (-width) / 2;\n\t\tlet lineRight = width / 2;\n\t\thLineGeometry.vertices[0].set(lineLeft, 0, 0);\n\t\thLineGeometry.vertices[1].set(lineRight, 0, 0);\n\t\thLineMaterial.color.set(color);\n\t\thLineGeometry.verticesNeedUpdate = true;\n\n\t}\n\n\tprivate initObject() {\n\t\tthis.rect = new Mesh(\n\t\t\tnew PlaneGeometry(1, 1),\n\t\t\tnew MeshBasicMaterial()\n\t\t);\n\t\tlet vLineGeometry = new Geometry();\n\t\tlet hLineGeometry = new Geometry();\n\t\tvLineGeometry.vertices.push(new Vector3(), new Vector3);\n\t\thLineGeometry.vertices.push(new Vector3(), new Vector3);\n\t\tthis.vLine = new Line(vLineGeometry, new LineBasicMaterial({linewidth: 1}));\n\t\tthis.hLine = new Line(hLineGeometry, new LineBasicMaterial({linewidth: 1}));\n\t\tthis.rect.add(this.vLine);\n\t\tthis.rect.add(this.hLine);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsCandleWidget.ts\n **/","export * from './deps'\n\n\n/** WEBPACK FOOTER **\n ** ./src/deps/index.ts\n **/"],"sourceRoot":""}