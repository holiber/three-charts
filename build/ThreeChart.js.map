{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ThreeChart.js","webpack:///webpack/bootstrap 4ca07fd65cd4b0cc2ace","webpack:///./index.ts","webpack:///./src/index.ts","webpack:///./src/deps/deps.ts","webpack:///./~/three/examples/js/libs/stats.min.js","webpack:///./~/is-plain-object/index.js","webpack:///./~/isobject/index.js","webpack:///./~/eventemitter2/lib/eventemitter2.js","webpack:///./src/polyfills/es6-promise.js","webpack:///./~/css-element-queries/src/ResizeSensor.js","webpack:///./src/ChartView.ts","webpack:///./src/Plugin.ts","webpack:///./src/Utils.ts","webpack:///./src/EventEmmiter.ts","webpack:///./src/deps/index.ts","webpack:///./src/Chart.ts","webpack:///./src/Trend.ts","webpack:///./src/TrendSegmentsManager.ts","webpack:///./src/TrendsManager.ts","webpack:///./src/Screen.ts","webpack:///./src/interfaces.ts","webpack:///./src/AnimationManager.ts","webpack:///./src/Easing.ts","webpack:///./src/Widget.ts","webpack:///./src/widgets/AxisWidget.ts","webpack:///./src/widgets/GridWidget.ts","webpack:///./src/Color.ts","webpack:///./src/widgets/TrendsGradientWidget.ts","webpack:///./src/widgets/TrendsWidget.ts","webpack:///./src/widgets/TrendsLineWidget.ts","webpack:///./src/widgets/TrendsCandleWidget.ts","webpack:///./src/UniqCollection.ts","webpack:///./src/widgets/index.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","__export","hasOwnProperty","window","TweenLite","TweenMax","Stats","isPlainObject","EE2","es6_promise_1","Promise","ResizeSensor","h","a","appendChild","dom","k","d","children","length","style","display","l","document","createElement","cssText","addEventListener","preventDefault","g","performance","Date","now","e","r","Panel","f","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","Infinity","Math","round","devicePixelRatio","u","n","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","v","min","max","drawImage","isObject","isObjectObject","o","Object","prototype","toString","ctor","prot","constructor","val","Array","isArray","__WEBPACK_AMD_DEFINE_RESULT__","undefined","_isArray","obj","defaultMaxListeners","init","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","EventEmitter","searchListenerTree","handlers","type","tree","i","listeners","leaf","len","branch","xTree","xxTree","isolatedBranch","endReached","typeLength","currentType","nextType","_listeners","push","concat","**","growListenerTree","listener","split","slice","name","shift","warned","console","error","trace","setMaxListeners","event","once","fn","many","ttl","Error","off","apply","arguments","_origin","on","emit","_all","args","handler","ns","onAny","addListener","leafs","iLeaf","position","splice","offAny","fns","removeListener","removeAllListeners","listenersAny","EventEmitter2","element","callback","EventQueue","add","ev","j","getComputedStyle","prop","currentStyle","getPropertyValue","attachResizeEvent","resized","resizedAttached","resizeSensor","className","styleChild","innerHTML","fixed","absolute","expand","childNodes","expandChild","shrink","shrinkChild","lastWidth","lastHeight","reset","offsetWidth","offsetHeight","scrollLeft","scrollWidth","scrollTop","scrollHeight","changed","addEvent","el","cb","attachEvent","onScroll","elementType","isCollectionTyped","jQuery","Elements","detach","removeChild","__extends","__","create","Plugin_1","PerspectiveCamera","THREE","Chart_1","Widget_1","Utils_1","AxisWidget_1","GridWidget_1","TrendsGradientWidget_1","TrendsLineWidget_1","TrendsCandleWidget_1","deps_1","Color_1","ChartBlankView","state","$container","pluginsAndWidgets","_this","widgets","Utils","parseInt","plugins","filter","pluginOrWidget","ChartPlugin","chart","Chart","zoomThrottled","throttle","zoomValue","origin","zoom","_a","w","showStats","autoRender","scene","Scene","isStopped","enabled","renderer","ChartView","renderers","antialias","alpha","backgroundColor","Color","setSize","setPixelRatio","setClearColor","value","$el","stats","setupCamera","initWidgets","bindEvents","renderLoop","preinstalledWidgetsClasses","preinstalledWidgets","customWidgets","forEach","ChartWidget","pluginWidgetClasses","providedWidgets","map","WidgetClass","widget","setupChart","onReadyHandler","getObject3D","isDestroyed","render","fpsLimit","fps","delay_1","setTimeout","requestAnimationFrame","camera","stop","run","destroy","unbindEvents","forceContextLoss","wtf","context","getState","getTrend","trendName","setState","controls","onMouseWheel","onMouseMove","onMouseDown","onMouseUp","onTouchMove","onTouchEnd","autoResize","onChartContainerResizeHandler","clientWidth","clientHeight","unsubscribers","screen","onTransformationFrame","options","onScreenTransformHandler","onResize","onChartResize","remove","unsubscribe","camSettings","getCameraSettings","FOV","aspect","near","far","fov","updateProjectionMatrix","set","x","y","z","cameraInitialPosition","clone","scrollX","scrollX_1","setX","scrollY","scrollY_1","setY","cursor","dragMode","clientX","clientY","stopPropagation","zoomOrigin","layerX","wheelDeltaY","touches","MAX_ZOOM_VALUE","MIN_ZOOM_VALUE","CanvasRenderer","WebGLRenderer","_super","TrendsLineWidget","TrendsCandlesWidget","AxisWidget","GridWidget","TrendsGradientWidget","EventEmmiter_1","DEFAULT_CONFIG","installPluginWidgets","config","initialState","deepMerge","NAME","ee","bindEvent","onInitialStateApplied","onInitialStateAppliedHandler","onReady","onDestroy","onDestroyHandler","onPluginsStateChange","changedPluginsStates","onStateChangedHandler","getOptions","pluginsState","changedState","_i","unsubscriber","deepmerge","target","src","mergeArrays","array","dst","indexOf","keys","key","obj1","obj2","deepCopy","JSON","parse","stringify","patch","objectToPatch","idKey","_loop_1","patchItem","subObject","find","item","this_1","travers","object","allowTraverseDeeper","canTraverseDeeper","setIdsToArrayItems","sourceObject","arr","arr_1","getUid","toFixed","num","digitsCount","maxDigits","result","intVal","floor","intStr","lengthDiff","repeat","afterPointDigitsCount","afterPointStr","substr","createTexture","canvas","ctx","texture","Texture","needsUpdate","createNearestTexture","minFilter","NearestFilter","createPixelPerfectTexture","magFilter","msg","warn","currentId","getDistance","num1","num2","binarySearchClosestInd","mid","lo","hi","binarySearchClosest","ind","binarySearchInd","binarySearch","rectsIntersect","r1","r2","left1","top1","width1","height1","left2","top2","width2","height2","right1","right2","bottom1","bottom2","func","ms","isThrottled","savedArgs","savedThis","wrapper","msToTimeString","timestamp","s","getRandomItem","random","copyProps","srcObject","dstObject","props","excludeProps","eventName","subscribe","listenersCount","Vector3","Trend_1","TrendsManager_1","Screen_1","interfaces_1","AnimationManager_1","Easing_1","CHART_STATE_EVENTS","INITIAL_STATE_APPLIED","READY","DESTROY","CHANGE","TREND_CHANGE","TRENDS_CHANGE","ZOOM","RESIZE","SCROLL","DRAG_STATE_CHAGED","PLUGINS_STATE_CHANGED","LIGHT_BLUE","prevState","xAxis","range","AXIS_RANGE_TYPE","ALL","from","to","scroll","padding","start","margin","dataType","AXIS_DATA_TYPE","NUMBER","grid","minSizePx","color","yAxis","RELATIVE_END","animations","trendChangeSpeed","trendChangeEase","zoomSpeed","scrollSpeed","scrollEase","EASING","Quadratic","Out","zoomEase","autoScrollSpeed","autoScrollEase","Linear","None","autoScroll","trendDefaultState","TREND_TYPE","LINE","data","maxSegmentLength","lineWidth","lineColor","hasBackground","hasBeacon","settingsForTypes","CANDLE","minSegmentLengthInPx","maxSegmentLengthInPx","eventEmitterMaxListeners","maxVisibleSegments","inertialScroll","isReady","trendsManager","TrendsManager","trends","calculatedOptions","installPlugins","computedData","getComputedData","savePrevState","animationManager","AnimationManager","setAimationsEnabled","Screen","onChange","onTrendChange","onTrendsChange","onDragStateChanged","onZoom","tick","newState","eventData","silent","stateData","newStateObj","changedProps","trendsData","trendOptions","newStateContainsData","recalculateResult","recalculateState","emitChangedStateEvents","actualData","cursorOptions","isMouseDrag","oldX","currentX","currentScroll","deltaXVal","pxToValueByXAxis","chartWasResized","scrollXChanged","needToRecalculateXAxis","zeroVal","xAxisPatch","recalculateXAxis","needToRecalculateYAxis","AUTO","isMirrorMode","yAxisPatch","recalculateYAxis","allChangedProps","computeAll","maxXVal","getEndXVal","minXVal","getStartXVal","dragEventNeeded","scrollChangeEventsNeeded","zoomEventsNeeded","resizeEventNeeded","pluginStateChangedEventNeeded","plugin","PluginClass","pluginName","getPlugin","changedTrends","newData","handleTrendsChange","dragState","onDragStateChangedHandler","animationOptions","isAnimationsEnabled","oldTrendsMaxX","trendsMaxXDelta","maxVisibleXVal","getScreenRightVal","paddingRightVal","getValueByScreenX","marginRightVal","scrollDelta","isDragMode","axisRange","isInitialize","scaleFactor","currentScaleFactor","rangeLength","needToRecalculateZoom","rangeMoreThenMaxValue","maxLength","rangeLessThenMinValue","minLength","fixScale","yAxisRange","trendsEndXVal","trendsStartXVal","xRange","xFrom","xTo","xRangeLength","needToZoom","maxY","getMaxYVal","minY","getMinYVal","trendLastY","distanceFromZeroValForMaxY","abs","distanceFromZeroValForMinY","maxDistanceFromZeroVal","paddingTopInPercents","paddingBottomInPercents","rangeLengthInPercents","visibleRangeLength","fromVal","toVal","maxScreenY","getScreenYByValue","minScreenY","currentAxisRange","newZoom","currentRange","nextRange","newScroll","resolve","animationTime","zoomToRange","scrollToEnd","endXVal","getPointOnXAxis","xVal","getPointOnYAxis","yVal","getValueOnXAxis","valueToPxByXAxis","valueToPxByYAxis","pxToValueByYAxis","getValueByScreenY","getScreenXByValue","getScreenXByPoint","getPointByScreenX","screenX","getPointOnChart","getScreenLeftVal","TrendSegmentsManager_1","EVENTS","PREPEND_REQUEST","Trend","chartState","minYVal","maxYVal","dataset","prepareData","segmentsManager","TrendSegmentsManager","checkForPrependRequest","changedOptions","getCalculatedOptions","appendData","rawData","getData","updatedTrendData","changeData","prependData","allData","newData_1","statePatch","fromX","toX","filteredData","data_1","getFirstItem","getLastItem","setOptions","onPrependRequest","onDataChange","onChangeCb","prependRequest","minScreenX","needToRequest","requestedDataLength","reject","then","currentData","isPrepend","initialItem","MAX_ANIMATED_SEGMENTS","REBUILD","DISLPAYED_RANGE_CHANGED","ANIMATION_FRAME","trend","segmentsById","segments","animatedSegmentsIds","segmentsLength","animatedSegmentsForAppend","animatedSegmentsForPrepend","nextEmptyId","startSegmentId","endSegmentId","unbindList","onTrendChangeHandler","onZoomHandler","recalculateDisplayedRange","unbind","tryToRebuildSegments","appendAnimation","kill","prependAnimation","segmentsRebuilded","needToRebuildSegments","isAppend","getSegment","getEndSegment","getStartSegment","force","trendTypeName","trendTypesSettings","trendTypeSettings","needToRebuild","segmentLength","currentSegmentLengthInPx","Number","currentMaxSegmentLengthInPx","ceil","stopAllAnimations","segmentsAreRebuilded","_b","firstDisplayedSegment","lastDisplayedSegment","displayedRange","firstDisplayedSegmentInd","lastDisplayedSegmentInd","displayedRangeChanged","getSegmentsForXValues","values","valueInd","lastValueInd","results","segment","hasValue","startXVal","getNext","valueInPoint","onAnimationFrame","onRebuild","onDisplayedRangeChanged","allocateNextSegment","TrendSegment","prevSegment","nextId","prevId","allocatePrevSegment","nextSegment","unshift","needRebuildSegments","trendData","startItemInd","initialSegment","initialAnimationState","createAnimationState","itemInd","itemIsInserted","appendItem","isLastItem","isCompleted","complete","recalculateItems","segmentIsReadyForAnimate","startYVal","endYVal","currentAnimationState","targetAnimationState","prevItem","animationsOptions","time","segmentId","segment_1","animate","prependItem","nextItem","animation","isActive","onAnimationFrameHandler","ease","objectToAnimate","animationValue","eventCallback","coefficient","animatedSegmentsIds_1","targetValue","initialValue","currentValue","trendPoints","items","trendSegments","itemsLength","endItem","startItem","minX","maxX","middleXVal","middleYVal","yVals","nextPoint","getPrev","prevPoint","getFrameVal","getFramePoint","frameVal","SEGMENTS_REBUILDED","trendsCalculatedOptions","createTrend","getEnabledTrends","enabledTrends","allTrends","firstTrendData","getExtremumYVal","extremumIsMax","compareFn","trends_1","trendYValues","dataItem","NaN","onSegmentsRebuilded","TRANSFORMATION_EVENT","SCREEN_EVENTS","ZOOM_FRAME","SCROLL_FRAME","TRANSFORMATION_FRAME","scrollXVal","scrollYVal","zoomX","zoomY","transformationInProgress","transform","vFOV","PI","tan","onZoomFrame","onScrollFrame","onTransformationEvent","cameraIsMoving","scrollXAnimation","isFinished","zoomXAnimation","hasActiveAnimations","scrollYAnimation","zoomYAnimation","transformationStarted","transformationFinished","STARTED","scrollEventNeeded","zoomEventNeeded","FINISHED","onScrollXHandler","onZoomXHandler","onScrollYHandler","onZoomYHandler","zoomXChanged","isAutoscroll","targetX","onTick","targetY","targetZoom","getPointByScreenY","screenY","getTop","getBottom","getLeft","getTopVal","getBottomVal","getCenterYVal","AXIS_TYPE","lastTickTime","timingFunction","Animation","animateObj","source","isEnabled","i_1","completeAndStop","createdTime","easing","progress","delay","startTime","setProgress","sourceObj","initialObj","sourceIteralable","targetObj","targetObject","initialIteralable","targetIteralable","onTickCb","onFinishCb","withDelay","initialVal","targetVal","In","InOut","Cubic","Quartic","Quintic","Sinusoidal","cos","sin","Exponential","pow","Circular","sqrt","Elastic","Back","Bounce","unbindEvent","widgetName","Mesh","Object3D","object3D","axisXObject","axisYObject","setupAxis","X","Y","updateAxisXRequest","updateAxis","onScrollChange","orientation","isXAxis","visibleWidth","visibleHeight","canvasWidth","canvasHeight","axisOptions","traverse","beginPath","rgbaStr","strokeStyle","material","MeshBasicMaterial","side","FrontSide","transparent","axisMesh","PlaneGeometry","axisGridParams","getGridParamsForAxis","geometry","parameters","image","clearRect","edgeOffset","segmentsCount","step","startVal","endVal","displayedValue","pxVal","textAlign","DATE","getDateStr","stroke","closePath","gridParams","sec","hour","day","tf","getHours","getMinutes","getSeconds","LineSegments","gridSizeH","gridSizeV","initGrid","updateGrid","updateGridThrottled","Geometry","LineBasicMaterial","linewidth","opacity","xLinesCount","yLinesCount","vertices","lineSegments","setZ","frustumCulled","axisXGrid","axisYGrid","scrollXInSegments","scrollYInSegments","gridScrollXVal","gridScrollYVal","lineInd","lineSegment","getVerticalLineSegment","getHorizontalLineSegment","verticesNeedUpdate","scale","localYVal","widthVal","localXVal","heightVal","axisWidth","axisLength","gridStep","gridStepInPixels","minGridStepInPixels","axisLengthStr","String","axisLengthPointPosition","intPartLength","gridStepFound","digitPos","power","multiplier","dividers","dividerInd","nextGridStep","nextGridStepInPixels","gridStart","gridEnd","stepInPx","parseColor","cache","replace","exec","isNaN","numberToHexStr","colorStr","rgba","hexStr","getTransparent","TrendsWidget_1","getTrendWidgetClass","TrendGradient","TrendsWidget","visibleSegmentsCnt","segmentsIds","Uint16Array","initGradient","updateSegments","widgetIsEnabled","gradient","faces","Face3","scaleXFactor","scaleYFactor","currentScale","onSegmentsAnimate","trendSegmentsManager","includes","setupSegmentVertices","segmentInd","prevVisibleSegmentsCnt","segmentsToProcessCnt","segmentState","gradientSegmentInd","topLeft","bottomLeft","bottomRight","topRight","screenHeightVal","startX","toLocalX","startY","toLocalY","endX","endY","TrendWidget","trendsOptions","TrendWidgetClass","widgetCanBeEnabled","createTrendWidget","destroyTrendWidget","WidgetConstructor","widgetObject","getObjectByName","TrendLine","freeSegmentsInds","displayedSegments","initLine","destroySegments","setupSegments","segmentIsNotDisplayed","destroySegment","setupSegment","pop","lineStartVertex","lineEndVertex","toLocalVec","vec","Line","RISE_COLOR","FALL_COLOR","MARGIN_PERCENT","MAX_CANDLES","TrendCandlesWidget","freeCandlesInds","candlesPool","candles","initObject","destroyCandles","setupCandles","destroyCandle","setupCandle","candle","candleId","candleInd","CandleWidget","setSegment","rect","leftTop","rightTop","leftBottom","rightBottom","vLineGeometry","vLine","vLineMaterial","lineTop","lineBottom","hLineGeometry","hLine","hLineMaterial","lineLeft","lineRight","UniqCollectionItem","getId","_id","ID_KEY","CREATE","UPDATE","REMOVE","UniqCollection","models","models_1","model","getItemInd","justCreated","createInstance","prevProps","getItem","getLast","onCreate","onUpdate","onRemove"],"mappings":"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","file":"ThreeChart.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory();\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory();\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(1));\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__webpack_require__(2);\r\n\t__export(__webpack_require__(9));\r\n\t__export(__webpack_require__(19));\r\n\t__export(__webpack_require__(18));\r\n\t__export(__webpack_require__(14));\r\n\t__export(__webpack_require__(15));\r\n\t__export(__webpack_require__(16));\r\n\t__export(__webpack_require__(17));\r\n\t__export(__webpack_require__(11));\r\n\t__export(__webpack_require__(30));\r\n\t__export(__webpack_require__(22));\r\n\t__export(__webpack_require__(31));\r\n\t__export(__webpack_require__(10));\r\n\t__export(__webpack_require__(25));\r\n\t__export(__webpack_require__(20));\r\n\t__export(__webpack_require__(12));\r\n\t__export(__webpack_require__(21));\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"./ResizeSensor.ts\" />\r\n\t\"use strict\";\r\n\twindow.TweenLite = TweenMax;\r\n\twindow.Stats = __webpack_require__(3);\r\n\t// require('gsap/src/uncompressed/easing/EasePack.js');\r\n\t// require('three/examples/js/renderers/CanvasRenderer.js');\r\n\t// require('three/examples/js/renderers/Projector.js');\r\n\texports.isPlainObject = __webpack_require__(4);\r\n\texports.EE2 = __webpack_require__(6);\r\n\tvar es6_promise_1 = __webpack_require__(7);\r\n\texports.Promise = es6_promise_1.Promise;\r\n\texports.ResizeSensor = __webpack_require__(8);\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t// stats.js - http://github.com/mrdoob/stats.js\n\tvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\n\tif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\n\tStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\n\tv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n\t *\n\t * Copyright (c) 2014-2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\tvar isObject = __webpack_require__(5);\n\t\n\tfunction isObjectObject(o) {\n\t  return isObject(o) === true\n\t    && Object.prototype.toString.call(o) === '[object Object]';\n\t}\n\t\n\tmodule.exports = function isPlainObject(o) {\n\t  var ctor,prot;\n\t  \n\t  if (isObjectObject(o) === false) return false;\n\t  \n\t  // If has modified constructor\n\t  ctor = o.constructor;\n\t  if (typeof ctor !== 'function') return false;\n\t  \n\t  // If has modified prototype\n\t  prot = ctor.prototype;\n\t  if (isObjectObject(prot) === false) return false;\n\t  \n\t  // If constructor does not have an Object-specific method\n\t  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n\t    return false;\n\t  }\n\t  \n\t  // Most likely a plain Object\n\t  return true;\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * isobject <https://github.com/jonschlinkert/isobject>\n\t *\n\t * Copyright (c) 2014-2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\tmodule.exports = function isObject(val) {\n\t  return val != null && typeof val === 'object'\n\t    && !Array.isArray(val);\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * EventEmitter2\n\t * https://github.com/hij1nx/EventEmitter2\n\t *\n\t * Copyright (c) 2013 hij1nx\n\t * Licensed under the MIT license.\n\t */\n\t;!function(undefined) {\n\t\n\t  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n\t    return Object.prototype.toString.call(obj) === \"[object Array]\";\n\t  };\n\t  var defaultMaxListeners = 10;\n\t\n\t  function init() {\n\t    this._events = {};\n\t    if (this._conf) {\n\t      configure.call(this, this._conf);\n\t    }\n\t  }\n\t\n\t  function configure(conf) {\n\t    if (conf) {\n\t\n\t      this._conf = conf;\n\t\n\t      conf.delimiter && (this.delimiter = conf.delimiter);\n\t      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n\t      conf.wildcard && (this.wildcard = conf.wildcard);\n\t      conf.newListener && (this.newListener = conf.newListener);\n\t\n\t      if (this.wildcard) {\n\t        this.listenerTree = {};\n\t      }\n\t    }\n\t  }\n\t\n\t  function EventEmitter(conf) {\n\t    this._events = {};\n\t    this.newListener = false;\n\t    configure.call(this, conf);\n\t  }\n\t\n\t  //\n\t  // Attention, function return type now is array, always !\n\t  // It has zero elements if no any matches found and one or more\n\t  // elements (leafs) if there are matches\n\t  //\n\t  function searchListenerTree(handlers, type, tree, i) {\n\t    if (!tree) {\n\t      return [];\n\t    }\n\t    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n\t        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n\t    if (i === typeLength && tree._listeners) {\n\t      //\n\t      // If at the end of the event(s) list and the tree has listeners\n\t      // invoke those listeners.\n\t      //\n\t      if (typeof tree._listeners === 'function') {\n\t        handlers && handlers.push(tree._listeners);\n\t        return [tree];\n\t      } else {\n\t        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n\t          handlers && handlers.push(tree._listeners[leaf]);\n\t        }\n\t        return [tree];\n\t      }\n\t    }\n\t\n\t    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n\t      //\n\t      // If the event emitted is '*' at this part\n\t      // or there is a concrete match at this patch\n\t      //\n\t      if (currentType === '*') {\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n\t          }\n\t        }\n\t        return listeners;\n\t      } else if(currentType === '**') {\n\t        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n\t        if(endReached && tree._listeners) {\n\t          // The next element has a _listeners, add it to the handlers.\n\t          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n\t        }\n\t\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            if(branch === '*' || branch === '**') {\n\t              if(tree[branch]._listeners && !endReached) {\n\t                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n\t              }\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            } else if(branch === nextType) {\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n\t            } else {\n\t              // No match on this one, shift into the tree but not in the type array.\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            }\n\t          }\n\t        }\n\t        return listeners;\n\t      }\n\t\n\t      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n\t    }\n\t\n\t    xTree = tree['*'];\n\t    if (xTree) {\n\t      //\n\t      // If the listener tree will allow any match for this part,\n\t      // then recursively explore all branches of the tree\n\t      //\n\t      searchListenerTree(handlers, type, xTree, i+1);\n\t    }\n\t\n\t    xxTree = tree['**'];\n\t    if(xxTree) {\n\t      if(i < typeLength) {\n\t        if(xxTree._listeners) {\n\t          // If we have a listener on a '**', it will catch all, so add its handler.\n\t          searchListenerTree(handlers, type, xxTree, typeLength);\n\t        }\n\t\n\t        // Build arrays of matching next branches and others.\n\t        for(branch in xxTree) {\n\t          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n\t            if(branch === nextType) {\n\t              // We know the next element will match, so jump twice.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+2);\n\t            } else if(branch === currentType) {\n\t              // Current node matches, move into the tree.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+1);\n\t            } else {\n\t              isolatedBranch = {};\n\t              isolatedBranch[branch] = xxTree[branch];\n\t              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n\t            }\n\t          }\n\t        }\n\t      } else if(xxTree._listeners) {\n\t        // We have reached the end and still on a '**'\n\t        searchListenerTree(handlers, type, xxTree, typeLength);\n\t      } else if(xxTree['*'] && xxTree['*']._listeners) {\n\t        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n\t      }\n\t    }\n\t\n\t    return listeners;\n\t  }\n\t\n\t  function growListenerTree(type, listener) {\n\t\n\t    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t\n\t    //\n\t    // Looks for two consecutive '**', if so, don't add the event at all.\n\t    //\n\t    for(var i = 0, len = type.length; i+1 < len; i++) {\n\t      if(type[i] === '**' && type[i+1] === '**') {\n\t        return;\n\t      }\n\t    }\n\t\n\t    var tree = this.listenerTree;\n\t    var name = type.shift();\n\t\n\t    while (name) {\n\t\n\t      if (!tree[name]) {\n\t        tree[name] = {};\n\t      }\n\t\n\t      tree = tree[name];\n\t\n\t      if (type.length === 0) {\n\t\n\t        if (!tree._listeners) {\n\t          tree._listeners = listener;\n\t        }\n\t        else if(typeof tree._listeners === 'function') {\n\t          tree._listeners = [tree._listeners, listener];\n\t        }\n\t        else if (isArray(tree._listeners)) {\n\t\n\t          tree._listeners.push(listener);\n\t\n\t          if (!tree._listeners.warned) {\n\t\n\t            var m = defaultMaxListeners;\n\t\n\t            if (typeof this._events.maxListeners !== 'undefined') {\n\t              m = this._events.maxListeners;\n\t            }\n\t\n\t            if (m > 0 && tree._listeners.length > m) {\n\t\n\t              tree._listeners.warned = true;\n\t              console.error('(node) warning: possible EventEmitter memory ' +\n\t                            'leak detected. %d listeners added. ' +\n\t                            'Use emitter.setMaxListeners() to increase limit.',\n\t                            tree._listeners.length);\n\t              console.trace();\n\t            }\n\t          }\n\t        }\n\t        return true;\n\t      }\n\t      name = type.shift();\n\t    }\n\t    return true;\n\t  }\n\t\n\t  // By default EventEmitters will print a warning if more than\n\t  // 10 listeners are added to it. This is a useful default which\n\t  // helps finding memory leaks.\n\t  //\n\t  // Obviously not all Emitters should be limited to 10. This function allows\n\t  // that to be increased. Set to zero for unlimited.\n\t\n\t  EventEmitter.prototype.delimiter = '.';\n\t\n\t  EventEmitter.prototype.setMaxListeners = function(n) {\n\t    this._events || init.call(this);\n\t    this._events.maxListeners = n;\n\t    if (!this._conf) this._conf = {};\n\t    this._conf.maxListeners = n;\n\t  };\n\t\n\t  EventEmitter.prototype.event = '';\n\t\n\t  EventEmitter.prototype.once = function(event, fn) {\n\t    this.many(event, 1, fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.many = function(event, ttl, fn) {\n\t    var self = this;\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('many only accepts instances of Function');\n\t    }\n\t\n\t    function listener() {\n\t      if (--ttl === 0) {\n\t        self.off(event, listener);\n\t      }\n\t      fn.apply(this, arguments);\n\t    }\n\t\n\t    listener._origin = fn;\n\t\n\t    this.on(event, listener);\n\t\n\t    return self;\n\t  };\n\t\n\t  EventEmitter.prototype.emit = function() {\n\t\n\t    this._events || init.call(this);\n\t\n\t    var type = arguments[0];\n\t\n\t    if (type === 'newListener' && !this.newListener) {\n\t      if (!this._events.newListener) { return false; }\n\t    }\n\t\n\t    // Loop through the *_all* functions and invoke them.\n\t    if (this._all) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t      for (i = 0, l = this._all.length; i < l; i++) {\n\t        this.event = type;\n\t        this._all[i].apply(this, args);\n\t      }\n\t    }\n\t\n\t    // If there is no 'error' event listener then throw.\n\t    if (type === 'error') {\n\t\n\t      if (!this._all &&\n\t        !this._events.error &&\n\t        !(this.wildcard && this.listenerTree.error)) {\n\t\n\t        if (arguments[1] instanceof Error) {\n\t          throw arguments[1]; // Unhandled 'error' event\n\t        } else {\n\t          throw new Error(\"Uncaught, unspecified 'error' event.\");\n\t        }\n\t        return false;\n\t      }\n\t    }\n\t\n\t    var handler;\n\t\n\t    if(this.wildcard) {\n\t      handler = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      handler = this._events[type];\n\t    }\n\t\n\t    if (typeof handler === 'function') {\n\t      this.event = type;\n\t      if (arguments.length === 1) {\n\t        handler.call(this);\n\t      }\n\t      else if (arguments.length > 1)\n\t        switch (arguments.length) {\n\t          case 2:\n\t            handler.call(this, arguments[1]);\n\t            break;\n\t          case 3:\n\t            handler.call(this, arguments[1], arguments[2]);\n\t            break;\n\t          // slower\n\t          default:\n\t            var l = arguments.length;\n\t            var args = new Array(l - 1);\n\t            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t            handler.apply(this, args);\n\t        }\n\t      return true;\n\t    }\n\t    else if (handler) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t\n\t      var listeners = handler.slice();\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\n\t        this.event = type;\n\t        listeners[i].apply(this, args);\n\t      }\n\t      return (listeners.length > 0) || !!this._all;\n\t    }\n\t    else {\n\t      return !!this._all;\n\t    }\n\t\n\t  };\n\t\n\t  EventEmitter.prototype.on = function(type, listener) {\n\t\n\t    if (typeof type === 'function') {\n\t      this.onAny(type);\n\t      return this;\n\t    }\n\t\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('on only accepts instances of Function');\n\t    }\n\t    this._events || init.call(this);\n\t\n\t    // To avoid recursion in the case that type == \"newListeners\"! Before\n\t    // adding it to the listeners, first emit \"newListeners\".\n\t    this.emit('newListener', type, listener);\n\t\n\t    if(this.wildcard) {\n\t      growListenerTree.call(this, type, listener);\n\t      return this;\n\t    }\n\t\n\t    if (!this._events[type]) {\n\t      // Optimize the case of one listener. Don't need the extra array object.\n\t      this._events[type] = listener;\n\t    }\n\t    else if(typeof this._events[type] === 'function') {\n\t      // Adding the second element, need to change to array.\n\t      this._events[type] = [this._events[type], listener];\n\t    }\n\t    else if (isArray(this._events[type])) {\n\t      // If we've already got an array, just append.\n\t      this._events[type].push(listener);\n\t\n\t      // Check for listener leak\n\t      if (!this._events[type].warned) {\n\t\n\t        var m = defaultMaxListeners;\n\t\n\t        if (typeof this._events.maxListeners !== 'undefined') {\n\t          m = this._events.maxListeners;\n\t        }\n\t\n\t        if (m > 0 && this._events[type].length > m) {\n\t\n\t          this._events[type].warned = true;\n\t          console.error('(node) warning: possible EventEmitter memory ' +\n\t                        'leak detected. %d listeners added. ' +\n\t                        'Use emitter.setMaxListeners() to increase limit.',\n\t                        this._events[type].length);\n\t          console.trace();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.onAny = function(fn) {\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('onAny only accepts instances of Function');\n\t    }\n\t\n\t    if(!this._all) {\n\t      this._all = [];\n\t    }\n\t\n\t    // Add the function to the event listener collection.\n\t    this._all.push(fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t  EventEmitter.prototype.off = function(type, listener) {\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('removeListener only takes instances of Function');\n\t    }\n\t\n\t    var handlers,leafs=[];\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      // does not use listeners(), so no side effect of creating _events[type]\n\t      if (!this._events[type]) return this;\n\t      handlers = this._events[type];\n\t      leafs.push({_listeners:handlers});\n\t    }\n\t\n\t    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t      var leaf = leafs[iLeaf];\n\t      handlers = leaf._listeners;\n\t      if (isArray(handlers)) {\n\t\n\t        var position = -1;\n\t\n\t        for (var i = 0, length = handlers.length; i < length; i++) {\n\t          if (handlers[i] === listener ||\n\t            (handlers[i].listener && handlers[i].listener === listener) ||\n\t            (handlers[i]._origin && handlers[i]._origin === listener)) {\n\t            position = i;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (position < 0) {\n\t          continue;\n\t        }\n\t\n\t        if(this.wildcard) {\n\t          leaf._listeners.splice(position, 1);\n\t        }\n\t        else {\n\t          this._events[type].splice(position, 1);\n\t        }\n\t\n\t        if (handlers.length === 0) {\n\t          if(this.wildcard) {\n\t            delete leaf._listeners;\n\t          }\n\t          else {\n\t            delete this._events[type];\n\t          }\n\t        }\n\t        return this;\n\t      }\n\t      else if (handlers === listener ||\n\t        (handlers.listener && handlers.listener === listener) ||\n\t        (handlers._origin && handlers._origin === listener)) {\n\t        if(this.wildcard) {\n\t          delete leaf._listeners;\n\t        }\n\t        else {\n\t          delete this._events[type];\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.offAny = function(fn) {\n\t    var i = 0, l = 0, fns;\n\t    if (fn && this._all && this._all.length > 0) {\n\t      fns = this._all;\n\t      for(i = 0, l = fns.length; i < l; i++) {\n\t        if(fn === fns[i]) {\n\t          fns.splice(i, 1);\n\t          return this;\n\t        }\n\t      }\n\t    } else {\n\t      this._all = [];\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\t\n\t  EventEmitter.prototype.removeAllListeners = function(type) {\n\t    if (arguments.length === 0) {\n\t      !this._events || init.call(this);\n\t      return this;\n\t    }\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t\n\t      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t        var leaf = leafs[iLeaf];\n\t        leaf._listeners = null;\n\t      }\n\t    }\n\t    else {\n\t      if (!this._events[type]) return this;\n\t      this._events[type] = null;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.listeners = function(type) {\n\t    if(this.wildcard) {\n\t      var handlers = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n\t      return handlers;\n\t    }\n\t\n\t    this._events || init.call(this);\n\t\n\t    if (!this._events[type]) this._events[type] = [];\n\t    if (!isArray(this._events[type])) {\n\t      this._events[type] = [this._events[type]];\n\t    }\n\t    return this._events[type];\n\t  };\n\t\n\t  EventEmitter.prototype.listenersAny = function() {\n\t\n\t    if(this._all) {\n\t      return this._all;\n\t    }\n\t    else {\n\t      return [];\n\t    }\n\t\n\t  };\n\t\n\t  if (true) {\n\t     // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return EventEmitter;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    // CommonJS\n\t    exports.EventEmitter2 = EventEmitter;\n\t  }\n\t  else {\n\t    // Browser global.\n\t    window.EventEmitter2 = EventEmitter;\n\t  }\n\t}();\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {Promise: window['Promise']}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n\t * directory of this distribution and at\n\t * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n\t */\n\t;\n\t(function() {\n\t\n\t    /**\n\t     * Class for dimension change detection.\n\t     *\n\t     * @param {Element|Element[]|Elements|jQuery} element\n\t     * @param {Function} callback\n\t     *\n\t     * @constructor\n\t     */\n\t    var ResizeSensor = function(element, callback) {\n\t        /**\n\t         *\n\t         * @constructor\n\t         */\n\t        function EventQueue() {\n\t            this.q = [];\n\t            this.add = function(ev) {\n\t                this.q.push(ev);\n\t            };\n\t\n\t            var i, j;\n\t            this.call = function() {\n\t                for (i = 0, j = this.q.length; i < j; i++) {\n\t                    this.q[i].call();\n\t                }\n\t            };\n\t        }\n\t\n\t        /**\n\t         * @param {HTMLElement} element\n\t         * @param {String}      prop\n\t         * @returns {String|Number}\n\t         */\n\t        function getComputedStyle(element, prop) {\n\t            if (element.currentStyle) {\n\t                return element.currentStyle[prop];\n\t            } else if (window.getComputedStyle) {\n\t                return window.getComputedStyle(element, null).getPropertyValue(prop);\n\t            } else {\n\t                return element.style[prop];\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param {HTMLElement} element\n\t         * @param {Function}    resized\n\t         */\n\t        function attachResizeEvent(element, resized) {\n\t            if (!element.resizedAttached) {\n\t                element.resizedAttached = new EventQueue();\n\t                element.resizedAttached.add(resized);\n\t            } else if (element.resizedAttached) {\n\t                element.resizedAttached.add(resized);\n\t                return;\n\t            }\n\t\n\t            element.resizeSensor = document.createElement('div');\n\t            element.resizeSensor.className = 'resize-sensor';\n\t            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n\t            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\t\n\t            element.resizeSensor.style.cssText = style;\n\t            element.resizeSensor.innerHTML =\n\t                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n\t                    '<div style=\"' + styleChild + '\"></div>' +\n\t                '</div>' +\n\t                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n\t                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n\t                '</div>';\n\t            element.appendChild(element.resizeSensor);\n\t\n\t            if (!{fixed: 1, absolute: 1}[getComputedStyle(element, 'position')]) {\n\t                element.style.position = 'relative';\n\t            }\n\t\n\t            var expand = element.resizeSensor.childNodes[0];\n\t            var expandChild = expand.childNodes[0];\n\t            var shrink = element.resizeSensor.childNodes[1];\n\t            var shrinkChild = shrink.childNodes[0];\n\t\n\t            var lastWidth, lastHeight;\n\t\n\t            var reset = function() {\n\t                expandChild.style.width = expand.offsetWidth + 10 + 'px';\n\t                expandChild.style.height = expand.offsetHeight + 10 + 'px';\n\t                expand.scrollLeft = expand.scrollWidth;\n\t                expand.scrollTop = expand.scrollHeight;\n\t                shrink.scrollLeft = shrink.scrollWidth;\n\t                shrink.scrollTop = shrink.scrollHeight;\n\t                lastWidth = element.offsetWidth;\n\t                lastHeight = element.offsetHeight;\n\t            };\n\t\n\t            reset();\n\t\n\t            var changed = function() {\n\t                if (element.resizedAttached) {\n\t                    element.resizedAttached.call();\n\t                }\n\t            };\n\t\n\t            var addEvent = function(el, name, cb) {\n\t                if (el.attachEvent) {\n\t                    el.attachEvent('on' + name, cb);\n\t                } else {\n\t                    el.addEventListener(name, cb);\n\t                }\n\t            };\n\t\n\t            var onScroll = function() {\n\t              if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {\n\t                  changed();\n\t              }\n\t              reset();\n\t            };\n\t\n\t            addEvent(expand, 'scroll', onScroll);\n\t            addEvent(shrink, 'scroll', onScroll);\n\t        }\n\t\n\t        var elementType = Object.prototype.toString.call(element);\n\t        var isCollectionTyped = ('[object Array]' === elementType\n\t            || ('[object NodeList]' === elementType)\n\t            || ('[object HTMLCollection]' === elementType)\n\t            || ('undefined' !== typeof jQuery && element instanceof jQuery) //jquery\n\t            || ('undefined' !== typeof Elements && element instanceof Elements) //mootools\n\t        );\n\t\n\t        if (isCollectionTyped) {\n\t            var i = 0, j = element.length;\n\t            for (; i < j; i++) {\n\t                attachResizeEvent(element[i], callback);\n\t            }\n\t        } else {\n\t            attachResizeEvent(element, callback);\n\t        }\n\t\n\t        this.detach = function() {\n\t            if (isCollectionTyped) {\n\t                var i = 0, j = element.length;\n\t                for (; i < j; i++) {\n\t                    ResizeSensor.detach(element[i]);\n\t                }\n\t            } else {\n\t                ResizeSensor.detach(element);\n\t            }\n\t        };\n\t    };\n\t\n\t    ResizeSensor.detach = function(element) {\n\t        if (element.resizeSensor) {\n\t            element.removeChild(element.resizeSensor);\n\t            delete element.resizeSensor;\n\t            delete element.resizedAttached;\n\t        }\n\t    };\n\t\n\t    // make available to common module loader\n\t    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t        module.exports = ResizeSensor;\n\t    }\n\t    else {\n\t        window.ResizeSensor = ResizeSensor;\n\t    }\n\t\n\t})();\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Plugin_1 = __webpack_require__(10);\r\n\tvar PerspectiveCamera = THREE.PerspectiveCamera;\r\n\tvar Chart_1 = __webpack_require__(14);\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar AxisWidget_1 = __webpack_require__(23);\r\n\tvar GridWidget_1 = __webpack_require__(24);\r\n\tvar TrendsGradientWidget_1 = __webpack_require__(26);\r\n\tvar TrendsLineWidget_1 = __webpack_require__(28);\r\n\tvar TrendsCandleWidget_1 = __webpack_require__(29);\r\n\tvar deps_1 = __webpack_require__(13);\r\n\tvar Color_1 = __webpack_require__(25);\r\n\tvar ChartBlankView = (function () {\r\n\t    function ChartBlankView(state, $container, pluginsAndWidgets) {\r\n\t        var _this = this;\r\n\t        if (pluginsAndWidgets === void 0) { pluginsAndWidgets = []; }\r\n\t        this.widgets = [];\r\n\t        if (!THREE || !THREE.REVISION)\r\n\t            Utils_1.Utils.error('three.js not found');\r\n\t        if (!$container) {\r\n\t            Utils_1.Utils.error('$el must be set');\r\n\t        }\r\n\t        // calculate state size\r\n\t        var style = getComputedStyle($container);\r\n\t        state.width = parseInt(style.width);\r\n\t        state.height = parseInt(style.height);\r\n\t        var plugins = pluginsAndWidgets.filter(function (pluginOrWidget) { return pluginOrWidget instanceof Plugin_1.ChartPlugin; });\r\n\t        this.chart = new Chart_1.Chart(state, plugins);\r\n\t        this.pluginsAndWidgets = pluginsAndWidgets;\r\n\t        this.zoomThrottled = Utils_1.Utils.throttle(function (zoomValue, origin) { return _this.zoom(zoomValue, origin); }, 200);\r\n\t        this.$container = $container;\r\n\t        this.init($container);\r\n\t    }\r\n\t    ;\r\n\t    ChartBlankView.prototype.init = function ($container) {\r\n\t        var chart = this.chart;\r\n\t        var _a = chart.state, w = _a.width, h = _a.height, showStats = _a.showStats, autoRender = _a.autoRender;\r\n\t        this.scene = new THREE.Scene();\r\n\t        this.isStopped = !autoRender.enabled;\r\n\t        var renderer = this.renderer = new ChartView.renderers[this.chart.state.renderer]({\r\n\t            antialias: true,\r\n\t            alpha: true\r\n\t        });\r\n\t        var backgroundColor = new Color_1.Color(chart.state.backgroundColor);\r\n\t        renderer.setSize(w, h);\r\n\t        renderer.setPixelRatio(ChartView.devicePixelRatio);\r\n\t        renderer.setClearColor(backgroundColor.value, backgroundColor.a);\r\n\t        $container.appendChild(renderer.domElement);\r\n\t        this.$el = renderer.domElement;\r\n\t        this.$el.style.display = 'block';\r\n\t        if (showStats) {\r\n\t            this.stats = new Stats();\r\n\t            $container.appendChild(this.stats.domElement);\r\n\t        }\r\n\t        this.setupCamera();\r\n\t        this.initWidgets();\r\n\t        this.bindEvents();\r\n\t        this.renderLoop();\r\n\t    };\r\n\t    /**\r\n\t     * collect and init widgets from preinstalled widgets, plugins widgets and custom widgets\r\n\t     */\r\n\t    ChartBlankView.prototype.initWidgets = function () {\r\n\t        var _this = this;\r\n\t        var preinstalledWidgetsClasses = this.constructor.preinstalledWidgets.slice();\r\n\t        var customWidgets = [];\r\n\t        this.pluginsAndWidgets.forEach(function (pluginOrWidget) {\r\n\t            if (pluginOrWidget instanceof Widget_1.ChartWidget) {\r\n\t                customWidgets.push(pluginOrWidget);\r\n\t                return;\r\n\t            }\r\n\t            if (!(pluginOrWidget instanceof Plugin_1.ChartPlugin))\r\n\t                return;\r\n\t            var pluginWidgetClasses = pluginOrWidget.constructor.providedWidgets;\r\n\t            preinstalledWidgetsClasses.push.apply(preinstalledWidgetsClasses, pluginWidgetClasses);\r\n\t        });\r\n\t        this.widgets = customWidgets.concat(preinstalledWidgetsClasses.map(function (WidgetClass) { return new WidgetClass(); }));\r\n\t        this.widgets.forEach(function (widget) {\r\n\t            widget.setupChart(_this.chart);\r\n\t            widget.onReadyHandler();\r\n\t            _this.scene.add(widget.getObject3D());\r\n\t        });\r\n\t    };\r\n\t    ChartBlankView.prototype.renderLoop = function () {\r\n\t        var _this = this;\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        this.stats && this.stats.begin();\r\n\t        this.render();\r\n\t        if (this.isStopped)\r\n\t            return;\r\n\t        var fpsLimit = this.chart.state.autoRender.fps;\r\n\t        if (fpsLimit) {\r\n\t            var delay_1 = 1000 / fpsLimit;\r\n\t            setTimeout(function () { return requestAnimationFrame(function () { return _this.renderLoop(); }); }, delay_1);\r\n\t        }\r\n\t        else {\r\n\t            requestAnimationFrame(function () { return _this.renderLoop(); });\r\n\t        }\r\n\t        this.stats && this.stats.end();\r\n\t    };\r\n\t    ChartBlankView.prototype.render = function () {\r\n\t        this.chart.render();\r\n\t        this.renderer.render(this.scene, this.camera);\r\n\t    };\r\n\t    ChartBlankView.prototype.stop = function () {\r\n\t        this.isStopped = true;\r\n\t    };\r\n\t    ChartBlankView.prototype.run = function () {\r\n\t        this.isStopped = false;\r\n\t        this.renderLoop();\r\n\t    };\r\n\t    /**\r\n\t     * call to destroy state an init garbage collection\r\n\t     */\r\n\t    ChartBlankView.prototype.destroy = function () {\r\n\t        this.isDestroyed = true;\r\n\t        this.stop();\r\n\t        this.chart.destroy();\r\n\t        this.unbindEvents();\r\n\t        // WARNING! undocumented method for free webgl context\r\n\t        try {\r\n\t            this.renderer.forceContextLoss();\r\n\t        }\r\n\t        catch (wtf) {\r\n\t        }\r\n\t        this.renderer.context = null;\r\n\t        this.renderer.domElement = null;\r\n\t        this.renderer = null;\r\n\t    };\r\n\t    ChartBlankView.prototype.getState = function () {\r\n\t        return this.chart.state;\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for ChartView.state.getTrend\r\n\t     */\r\n\t    ChartBlankView.prototype.getTrend = function (trendName) {\r\n\t        return this.chart.getTrend(trendName);\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for ChartView.state.setState\r\n\t     */\r\n\t    ChartBlankView.prototype.setState = function (state) {\r\n\t        return this.chart.setState(state);\r\n\t    };\r\n\t    ChartBlankView.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var $el = this.$el;\r\n\t        if (this.chart.state.controls.enabled) {\r\n\t            $el.addEventListener('mousewheel', function (ev) {\r\n\t                _this.onMouseWheel(ev);\r\n\t            });\r\n\t            $el.addEventListener('mousemove', function (ev) {\r\n\t                _this.onMouseMove(ev);\r\n\t            });\r\n\t            $el.addEventListener('mousedown', function (ev) { return _this.onMouseDown(ev); });\r\n\t            $el.addEventListener('mouseup', function (ev) { return _this.onMouseUp(ev); });\r\n\t            $el.addEventListener('touchmove', function (ev) {\r\n\t                _this.onTouchMove(ev);\r\n\t            });\r\n\t            $el.addEventListener('touchend', function (ev) {\r\n\t                _this.onTouchEnd(ev);\r\n\t            });\r\n\t        }\r\n\t        if (this.chart.state.autoResize) {\r\n\t            this.resizeSensor = new deps_1.ResizeSensor(this.$container, function () {\r\n\t                _this.onChartContainerResizeHandler(_this.$container.clientWidth, _this.$container.clientHeight);\r\n\t            });\r\n\t        }\r\n\t        this.unsubscribers = [\r\n\t            this.chart.screen.onTransformationFrame(function (options) { return _this.onScreenTransformHandler(options); }),\r\n\t            this.chart.onResize(function (options) { return _this.onChartResize(); })\r\n\t        ];\r\n\t    };\r\n\t    ChartBlankView.prototype.unbindEvents = function () {\r\n\t        // TODO: unbind events correctly\r\n\t        try {\r\n\t            this.resizeSensor && this.resizeSensor.detach();\r\n\t        }\r\n\t        catch (e) {\r\n\t        }\r\n\t        this.$el.remove();\r\n\t        this.unsubscribers.forEach(function (unsubscribe) { return unsubscribe(); });\r\n\t    };\r\n\t    ChartBlankView.prototype.setupCamera = function () {\r\n\t        var camSettings = this.chart.screen.getCameraSettings();\r\n\t        if (!this.camera) {\r\n\t            this.camera = new PerspectiveCamera(camSettings.FOV, camSettings.aspect, camSettings.near, camSettings.far);\r\n\t            this.scene.add(this.camera);\r\n\t        }\r\n\t        else {\r\n\t            this.camera.fov = camSettings.FOV;\r\n\t            this.camera.aspect = camSettings.aspect;\r\n\t            this.camera.far = camSettings.far;\r\n\t            this.camera.near = camSettings.near;\r\n\t            this.camera.updateProjectionMatrix();\r\n\t        }\r\n\t        this.camera.position.set(camSettings.x, camSettings.y, camSettings.z);\r\n\t        this.cameraInitialPosition = this.camera.position.clone();\r\n\t        this.onScreenTransformHandler(this.chart.screen.options);\r\n\t    };\r\n\t    ChartBlankView.prototype.onScreenTransformHandler = function (options) {\r\n\t        if (options.scrollX != void 0) {\r\n\t            var scrollX_1 = this.cameraInitialPosition.x + options.scrollX;\r\n\t            this.camera.position.setX(scrollX_1);\r\n\t        }\r\n\t        if (options.scrollY != void 0) {\r\n\t            var scrollY_1 = this.cameraInitialPosition.y + options.scrollY;\r\n\t            this.camera.position.setY(scrollY_1);\r\n\t        }\r\n\t    };\r\n\t    ChartBlankView.prototype.onMouseDown = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: true, x: ev.clientX, y: ev.clientY } });\r\n\t    };\r\n\t    ChartBlankView.prototype.onMouseUp = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: false } });\r\n\t    };\r\n\t    ChartBlankView.prototype.onMouseMove = function (ev) {\r\n\t        if (this.chart.state.cursor.dragMode) {\r\n\t            this.setState({ cursor: { dragMode: true, x: ev.clientX, y: ev.clientY } });\r\n\t        }\r\n\t    };\r\n\t    ChartBlankView.prototype.onMouseWheel = function (ev) {\r\n\t        ev.stopPropagation();\r\n\t        ev.preventDefault();\r\n\t        var zoomOrigin = ev.layerX / this.chart.state.width;\r\n\t        var zoomValue = 1 + ev.wheelDeltaY * 0.001;\r\n\t        this.zoom(zoomValue, zoomOrigin);\r\n\t    };\r\n\t    ChartBlankView.prototype.onTouchMove = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: true, x: ev.touches[0].clientX, y: ev.touches[0].clientY } });\r\n\t    };\r\n\t    ChartBlankView.prototype.onTouchEnd = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: false } });\r\n\t    };\r\n\t    ChartBlankView.prototype.onChartContainerResizeHandler = function (width, height) {\r\n\t        this.setState({ width: width, height: height });\r\n\t    };\r\n\t    ChartBlankView.prototype.onChartResize = function () {\r\n\t        var _a = this.chart.state, width = _a.width, height = _a.height;\r\n\t        this.renderer.setSize(width, height);\r\n\t        this.setupCamera();\r\n\t    };\r\n\t    ChartBlankView.prototype.zoom = function (zoomValue, zoomOrigin) {\r\n\t        var MAX_ZOOM_VALUE = 1.5;\r\n\t        var MIN_ZOOM_VALUE = 0.7;\r\n\t        zoomValue = Math.min(zoomValue, MAX_ZOOM_VALUE);\r\n\t        zoomValue = Math.max(zoomValue, MIN_ZOOM_VALUE);\r\n\t        this.chart.zoom(zoomValue, zoomOrigin);\r\n\t    };\r\n\t    ChartBlankView.devicePixelRatio = window.devicePixelRatio;\r\n\t    ChartBlankView.preinstalledWidgets = [];\r\n\t    ChartBlankView.renderers = {\r\n\t        CanvasRenderer: THREE.CanvasRenderer,\r\n\t        WebGLRenderer: THREE.WebGLRenderer\r\n\t    };\r\n\t    return ChartBlankView;\r\n\t}());\r\n\texports.ChartBlankView = ChartBlankView;\r\n\tvar ChartView = (function (_super) {\r\n\t    __extends(ChartView, _super);\r\n\t    function ChartView() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    ChartView.preinstalledWidgets = [\r\n\t        TrendsLineWidget_1.TrendsLineWidget,\r\n\t        TrendsCandleWidget_1.TrendsCandlesWidget,\r\n\t        AxisWidget_1.AxisWidget,\r\n\t        GridWidget_1.GridWidget,\r\n\t        TrendsGradientWidget_1.TrendsGradientWidget\r\n\t    ];\r\n\t    return ChartView;\r\n\t}(ChartBlankView));\r\n\texports.ChartView = ChartView;\r\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\texports.DEFAULT_CONFIG = {\r\n\t    installPluginWidgets: true\r\n\t};\r\n\t/**\r\n\t * base class for all plugins\r\n\t * NAME is mandatory\r\n\t */\r\n\tvar ChartPlugin = (function () {\r\n\t    function ChartPlugin(options, config) {\r\n\t        if (config === void 0) { config = {}; }\r\n\t        this.unsubscribers = [];\r\n\t        this.initialState = options;\r\n\t        this.config = Utils_1.Utils.deepMerge(exports.DEFAULT_CONFIG, config);\r\n\t        this.name = this.constructor.NAME;\r\n\t        if (!this.name)\r\n\t            Utils_1.Utils.error('Unnamed plugin detected');\r\n\t    }\r\n\t    ChartPlugin.prototype.setupChart = function (chart) {\r\n\t        var _this = this;\r\n\t        this.chart = chart;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.bindEvent(this.chart.onInitialStateApplied(function (initialState) { return _this.onInitialStateAppliedHandler(initialState); }), this.chart.onReady(function () { return _this.onReadyHandler(); }), this.chart.onDestroy(function () { return _this.onDestroyHandler(); }), this.chart.onPluginsStateChange(function (changedPluginsStates) { return changedPluginsStates[_this.name] && _this.onStateChangedHandler(changedPluginsStates[_this.name]); }));\r\n\t    };\r\n\t    ChartPlugin.prototype.getOptions = function () {\r\n\t        return this.chart.state.pluginsState[this.name];\r\n\t    };\r\n\t    ChartPlugin.prototype.onInitialStateAppliedHandler = function (initialState) {\r\n\t    };\r\n\t    ChartPlugin.prototype.onReadyHandler = function () {\r\n\t    };\r\n\t    ChartPlugin.prototype.onStateChangedHandler = function (changedState) {\r\n\t    };\r\n\t    ChartPlugin.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t    };\r\n\t    ChartPlugin.prototype.bindEvent = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var unsubscribers = [];\r\n\t        if (!Array.isArray(args[0])) {\r\n\t            unsubscribers.push(args[0]);\r\n\t        }\r\n\t        else {\r\n\t            unsubscribers.push.apply(unsubscribers, (args));\r\n\t        }\r\n\t        (_a = this.unsubscribers).push.apply(_a, unsubscribers);\r\n\t        var _a;\r\n\t    };\r\n\t    ChartPlugin.prototype.unbindEvents = function () {\r\n\t        this.unsubscribers.forEach(function (unsubscriber) { return unsubscriber(); });\r\n\t        this.unsubscribers.length = 0;\r\n\t    };\r\n\t    ChartPlugin.NAME = '';\r\n\t    ChartPlugin.providedWidgets = [];\r\n\t    return ChartPlugin;\r\n\t}());\r\n\texports.ChartPlugin = ChartPlugin;\r\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar deps_1 = __webpack_require__(2);\r\n\tfunction deepmerge(target, src, mergeArrays) {\r\n\t    if (mergeArrays === void 0) { mergeArrays = true; }\r\n\t    var array = Array.isArray(src);\r\n\t    var dst = array && [] || {};\r\n\t    if (array) {\r\n\t        target = target || [];\r\n\t        if (mergeArrays) {\r\n\t            dst = dst.concat(target);\r\n\t        }\r\n\t        src.forEach(function (e, i) {\r\n\t            if (typeof dst[i] === 'undefined') {\r\n\t                dst[i] = e;\r\n\t            }\r\n\t            else if (typeof e === 'object') {\r\n\t                dst[i] = deepmerge(target[i], e, mergeArrays);\r\n\t            }\r\n\t            else {\r\n\t                if (target.indexOf(e) === -1) {\r\n\t                    dst.push(e);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t    else {\r\n\t        if (target && typeof target === 'object') {\r\n\t            Object.keys(target).forEach(function (key) {\r\n\t                dst[key] = target[key];\r\n\t            });\r\n\t        }\r\n\t        Object.keys(src).forEach(function (key) {\r\n\t            if (typeof src[key] !== 'object' || !src[key]) {\r\n\t                dst[key] = src[key];\r\n\t            }\r\n\t            else {\r\n\t                if (!target[key]) {\r\n\t                    dst[key] = src[key];\r\n\t                }\r\n\t                else {\r\n\t                    dst[key] = deepmerge(target[key], src[key], mergeArrays);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t    return dst;\r\n\t}\r\n\t/**\r\n\t * project utils static class\r\n\t */\r\n\tvar Utils = (function () {\r\n\t    function Utils() {\r\n\t    }\r\n\t    /**\r\n\t     * deepMerge based on https://www.npmjs.com/package/deepmerge\r\n\t     */\r\n\t    Utils.deepMerge = function (obj1, obj2, mergeArrays) {\r\n\t        return deepmerge(obj1, obj2, mergeArrays);\r\n\t    };\r\n\t    /**\r\n\t     * deepCopy based on JSON.stringify function\r\n\t     * @deprecated\r\n\t     */\r\n\t    Utils.deepCopy = function (obj) {\r\n\t        // TODO: use deepMerge function to copy\r\n\t        return JSON.parse(JSON.stringify(obj));\r\n\t    };\r\n\t    Utils.patch = function (objectToPatch, patch) {\r\n\t        var idKey = '_id';\r\n\t        for (var key in patch) {\r\n\t            if (!patch.hasOwnProperty(key))\r\n\t                continue;\r\n\t            if (objectToPatch[key]) {\r\n\t                if (Array.isArray(patch[key])) {\r\n\t                    var _loop_1 = function(patchItem) {\r\n\t                        var subObject = objectToPatch[key].find(function (item) {\r\n\t                            return item[idKey] != void 0 && item[idKey] === patchItem[idKey];\r\n\t                        });\r\n\t                        if (subObject) {\r\n\t                            this_1.patch(subObject, patchItem);\r\n\t                        }\r\n\t                        else {\r\n\t                            objectToPatch[key].push(patchItem);\r\n\t                        }\r\n\t                    };\r\n\t                    var this_1 = this;\r\n\t                    for (var _i = 0, _a = patch[key]; _i < _a.length; _i++) {\r\n\t                        var patchItem = _a[_i];\r\n\t                        _loop_1(patchItem);\r\n\t                    }\r\n\t                    continue;\r\n\t                }\r\n\t                else if (typeof patch[key] === 'object' && objectToPatch[key] != void 0) {\r\n\t                    if (patch[idKey] && Object.keys(patch).length == 1) {\r\n\t                        delete objectToPatch[key];\r\n\t                    }\r\n\t                    else {\r\n\t                        this.patch(objectToPatch[key], patch[key]);\r\n\t                    }\r\n\t                    continue;\r\n\t                }\r\n\t            }\r\n\t            objectToPatch[key] = patch[key];\r\n\t        }\r\n\t        if (objectToPatch['_onUpdate'])\r\n\t            objectToPatch['_onUpdate'].call(objectToPatch, patch);\r\n\t        return objectToPatch;\r\n\t    };\r\n\t    Utils.travers = function (object, fn) {\r\n\t        for (var key in object) {\r\n\t            if (!object.hasOwnProperty(key))\r\n\t                continue;\r\n\t            var allowTraverseDeeper = fn(object[key]);\r\n\t            var canTraverseDeeper = allowTraverseDeeper && typeof object[key] == 'object';\r\n\t            if (canTraverseDeeper)\r\n\t                this.travers(object[key], fn);\r\n\t        }\r\n\t    };\r\n\t    Utils.setIdsToArrayItems = function (sourceObject) {\r\n\t        var idKey = '_id';\r\n\t        Utils.travers(sourceObject, function (item) {\r\n\t            if (!Array.isArray(item))\r\n\t                return true;\r\n\t            var arr = item;\r\n\t            for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {\r\n\t                var obj = arr_1[_i];\r\n\t                if (typeof obj !== 'object' || Array.isArray(obj))\r\n\t                    continue;\r\n\t                if (!obj[idKey])\r\n\t                    obj[idKey] = Utils.getUid();\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     *\r\n\t     * @example\r\n\t     * // returns \"000015\"\r\n\t     * Utils.toFixed(15, 6);\r\n\t     */\r\n\t    Utils.toFixed = function (num, digitsCount) {\r\n\t        var maxDigits = 15;\r\n\t        var result = '';\r\n\t        var intVal = Math.floor(num);\r\n\t        var intStr = intVal.toString();\r\n\t        var lengthDiff = digitsCount - intStr.length;\r\n\t        if (lengthDiff > 0) {\r\n\t            result = '0'.repeat(lengthDiff) + intStr;\r\n\t        }\r\n\t        else {\r\n\t            result = intStr;\r\n\t        }\r\n\t        var afterPointDigitsCount = maxDigits - intStr.length;\r\n\t        var afterPointStr = num.toString().split('.')[1];\r\n\t        if (afterPointStr) {\r\n\t            result += '.' + afterPointStr.substr(0, afterPointDigitsCount);\r\n\t        }\r\n\t        return result;\r\n\t    };\r\n\t    Utils.bindEvent = function () {\r\n\t    };\r\n\t    /**\r\n\t     * generate texture from canvas context\r\n\t     * @example\r\n\t     * \t// create texture with rect\r\n\t     *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\r\n\t     */\r\n\t    Utils.createTexture = function (width, height, fn) {\r\n\t        var canvas = document.createElement('canvas');\r\n\t        canvas.width = width;\r\n\t        canvas.height = height;\r\n\t        var ctx = canvas.getContext('2d');\r\n\t        fn && fn(ctx, width, height);\r\n\t        var texture = new THREE.Texture(canvas);\r\n\t        texture.needsUpdate = true;\r\n\t        return texture;\r\n\t    };\r\n\t    /**\r\n\t     * generate texture from canvas context with NearestFilter\r\n\t     * @example\r\n\t     * \t// create texture with rect\r\n\t     *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\r\n\t     */\r\n\t    Utils.createNearestTexture = function (width, height, fn) {\r\n\t        var texture = this.createTexture(width, height, fn);\r\n\t        texture.minFilter = THREE.NearestFilter;\r\n\t        return texture;\r\n\t    };\r\n\t    Utils.createPixelPerfectTexture = function (width, height, fn) {\r\n\t        var texture = this.createTexture(width, height, fn);\r\n\t        texture.magFilter = THREE.NearestFilter;\r\n\t        texture.minFilter = THREE.NearestFilter;\r\n\t        return texture;\r\n\t    };\r\n\t    /**\r\n\t     * throw error\r\n\t     */\r\n\t    Utils.error = function (msg) {\r\n\t        console.error('Chart error: ' + msg);\r\n\t        throw 'Chart: ' + msg;\r\n\t    };\r\n\t    /**\r\n\t     * throw error\r\n\t     */\r\n\t    Utils.warn = function (msg) {\r\n\t        console.warn('Chart warning: ' + msg);\r\n\t    };\r\n\t    /**\r\n\t     * @returns new unique id\r\n\t     */\r\n\t    Utils.getUid = function () {\r\n\t        return this.currentId++;\r\n\t    };\r\n\t    /**\r\n\t     * @returns distance between numbers\r\n\t     */\r\n\t    Utils.getDistance = function (num1, num2) {\r\n\t        return Math.max(num1, num2) - Math.min(num1, num2);\r\n\t    };\r\n\t    // TODO: refactor binary search functions\r\n\t    Utils.binarySearchClosestInd = function (arr, num, key) {\r\n\t        var mid;\r\n\t        var lo = 0;\r\n\t        var hi = arr.length - 1;\r\n\t        while (hi - lo > 1) {\r\n\t            mid = Math.floor((lo + hi) / 2);\r\n\t            if (arr[mid][key] < num) {\r\n\t                lo = mid;\r\n\t            }\r\n\t            else {\r\n\t                hi = mid;\r\n\t            }\r\n\t        }\r\n\t        if (num - arr[lo][key] <= arr[hi][key] - num) {\r\n\t            return lo;\r\n\t        }\r\n\t        return hi;\r\n\t    };\r\n\t    Utils.binarySearchClosest = function (arr, num, key) {\r\n\t        var ind = this.binarySearchClosestInd(arr, num, key);\r\n\t        return arr[ind];\r\n\t    };\r\n\t    Utils.binarySearchInd = function (arr, num, key) {\r\n\t        var mid;\r\n\t        var lo = 0;\r\n\t        var hi = arr.length - 1;\r\n\t        while (hi - lo > 1) {\r\n\t            mid = Math.floor((hi - lo) / 2);\r\n\t            if (arr[mid][key] < num) {\r\n\t                lo = mid;\r\n\t            }\r\n\t            else {\r\n\t                hi = mid;\r\n\t            }\r\n\t            if (arr[lo][key] == num) {\r\n\t                return lo;\r\n\t            }\r\n\t            else if (arr[hi][key] == num) {\r\n\t                return hi;\r\n\t            }\r\n\t        }\r\n\t        return -1;\r\n\t    };\r\n\t    Utils.binarySearch = function (arr, num, key) {\r\n\t        var ind = this.binarySearchInd(arr, num, key);\r\n\t        return arr[ind];\r\n\t    };\r\n\t    Utils.rectsIntersect = function (r1, r2) {\r\n\t        var left1 = r1[0], top1 = r1[1], width1 = r1[2], height1 = r1[3];\r\n\t        var left2 = r2[0], top2 = r2[1], width2 = r2[2], height2 = r2[3];\r\n\t        var _a = [left1 + width1, left2 + width2, top1 + height1, top2 + height2], right1 = _a[0], right2 = _a[1], bottom1 = _a[2], bottom2 = _a[3];\r\n\t        return !(left2 > right1 ||\r\n\t            right2 < left1 ||\r\n\t            top2 > bottom1 ||\r\n\t            bottom2 < top1);\r\n\t    };\r\n\t    Utils.throttle = function (func, ms) {\r\n\t        var isThrottled = false, savedArgs, savedThis;\r\n\t        function wrapper() {\r\n\t            if (isThrottled) {\r\n\t                savedArgs = arguments;\r\n\t                savedThis = this;\r\n\t                return;\r\n\t            }\r\n\t            func.apply(this, arguments); // (1)\r\n\t            isThrottled = true;\r\n\t            setTimeout(function () {\r\n\t                isThrottled = false; // (3)\r\n\t                if (savedArgs) {\r\n\t                    wrapper.apply(savedThis, savedArgs);\r\n\t                    savedArgs = savedThis = null;\r\n\t                }\r\n\t            }, ms);\r\n\t        }\r\n\t        return wrapper;\r\n\t    };\r\n\t    Utils.msToTimeString = function (timestamp) {\r\n\t        var h = Math.floor(timestamp / 360000);\r\n\t        var m = Math.floor(timestamp / 60000);\r\n\t        var s = Math.floor(timestamp / 1000);\r\n\t        return h + ':' + m + ':' + s;\r\n\t    };\r\n\t    Utils.getRandomItem = function (arr) {\r\n\t        var ind = Math.floor(Math.random() * arr.length);\r\n\t        return arr[ind];\r\n\t    };\r\n\t    Utils.copyProps = function (srcObject, dstObject, props, excludeProps) {\r\n\t        if (excludeProps === void 0) { excludeProps = []; }\r\n\t        for (var key in props) {\r\n\t            if (excludeProps.indexOf(key) !== -1)\r\n\t                continue;\r\n\t            if (srcObject[key] == void 0)\r\n\t                continue;\r\n\t            if (deps_1.isPlainObject(props[key]) && dstObject[key] !== void 0) {\r\n\t                this.copyProps(srcObject[key], dstObject[key], props[key]);\r\n\t            }\r\n\t            else if (typeof srcObject[key] == 'function') {\r\n\t                dstObject[key] = srcObject[key];\r\n\t            }\r\n\t            else {\r\n\t                dstObject[key] = this.deepCopy(srcObject[key]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    Utils.currentId = 1;\r\n\t    return Utils;\r\n\t}());\r\n\texports.Utils = Utils;\r\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar deps_1 = __webpack_require__(13);\r\n\t/**\r\n\t * this class uses as proxy for EventEmitter2\r\n\t */\r\n\tvar EventEmitter = (function () {\r\n\t    // TODO: allow to create EE instances only in Chart class\r\n\t    function EventEmitter() {\r\n\t        this.ee = new deps_1.EE2();\r\n\t    }\r\n\t    EventEmitter.prototype.emit = function (eventName) {\r\n\t        var args = [];\r\n\t        for (var _i = 1; _i < arguments.length; _i++) {\r\n\t            args[_i - 1] = arguments[_i];\r\n\t        }\r\n\t        (_a = this.ee).emit.apply(_a, [eventName].concat(args));\r\n\t        var _a;\r\n\t    };\r\n\t    EventEmitter.prototype.on = function (eventName, callback) {\r\n\t        return this.ee.on(eventName, callback);\r\n\t    };\r\n\t    EventEmitter.prototype.off = function (eventName, callback) {\r\n\t        return this.ee.off(eventName, callback);\r\n\t    };\r\n\t    EventEmitter.prototype.subscribe = function (eventName, callback) {\r\n\t        var _this = this;\r\n\t        this.on(eventName, callback);\r\n\t        return function () { return _this.off(eventName, callback); };\r\n\t    };\r\n\t    EventEmitter.prototype.setMaxListeners = function (listenersCount) {\r\n\t        this.ee.setMaxListeners(listenersCount);\r\n\t    };\r\n\t    EventEmitter.prototype.removeAllListeners = function (eventName) {\r\n\t        this.ee.removeAllListeners(eventName);\r\n\t    };\r\n\t    return EventEmitter;\r\n\t}());\r\n\texports.EventEmitter = EventEmitter;\r\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(2));\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Trend_1 = __webpack_require__(15);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar TrendsManager_1 = __webpack_require__(17);\r\n\tvar Screen_1 = __webpack_require__(18);\r\n\tvar interfaces_1 = __webpack_require__(19);\r\n\tvar deps_1 = __webpack_require__(2);\r\n\tvar AnimationManager_1 = __webpack_require__(20);\r\n\tvar Easing_1 = __webpack_require__(21);\r\n\tvar CHART_STATE_EVENTS = {\r\n\t    INITIAL_STATE_APPLIED: 'initialStateApplied',\r\n\t    READY: 'ready',\r\n\t    DESTROY: 'destroy',\r\n\t    CHANGE: 'change',\r\n\t    TREND_CHANGE: 'trendChange',\r\n\t    TRENDS_CHANGE: 'trendsChange',\r\n\t    ZOOM: 'zoom',\r\n\t    RESIZE: 'resize',\r\n\t    SCROLL: 'scroll',\r\n\t    DRAG_STATE_CHAGED: 'scrollStop',\r\n\t    PLUGINS_STATE_CHANGED: 'pluginsStateChanged'\r\n\t};\r\n\tvar LIGHT_BLUE = '#5273bd';\r\n\t/**\r\n\t *  all state changes caused only by Chart.setState method\r\n\t */\r\n\tvar Chart = (function () {\r\n\t    function Chart(initialState, plugins) {\r\n\t        if (plugins === void 0) { plugins = []; }\r\n\t        this.state = {\r\n\t            prevState: {},\r\n\t            zoom: 0,\r\n\t            xAxis: {\r\n\t                range: {\r\n\t                    type: interfaces_1.AXIS_RANGE_TYPE.ALL,\r\n\t                    from: 0,\r\n\t                    to: 0,\r\n\t                    scroll: 0,\r\n\t                    zoom: 1,\r\n\t                    padding: { start: 0, end: 5 },\r\n\t                    margin: { start: 0, end: 5 }\r\n\t                },\r\n\t                dataType: interfaces_1.AXIS_DATA_TYPE.NUMBER,\r\n\t                grid: { enabled: true, minSizePx: 100, color: \"rgba(\" + LIGHT_BLUE + \", 0.12)\" },\r\n\t                color: LIGHT_BLUE\r\n\t            },\r\n\t            yAxis: {\r\n\t                range: {\r\n\t                    type: interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END,\r\n\t                    from: 0,\r\n\t                    to: 0,\r\n\t                    zoom: 1,\r\n\t                    padding: { start: 5, end: 5 },\r\n\t                    margin: { start: 5, end: 5 },\r\n\t                },\r\n\t                grid: { enabled: true, minSizePx: 50, color: \"rgba(\" + LIGHT_BLUE + \", 0.12)\" },\r\n\t                dataType: interfaces_1.AXIS_DATA_TYPE.NUMBER,\r\n\t                color: LIGHT_BLUE\r\n\t            },\r\n\t            animations: {\r\n\t                enabled: true,\r\n\t                trendChangeSpeed: 0.5,\r\n\t                trendChangeEase: void 0,\r\n\t                zoomSpeed: 250,\r\n\t                scrollSpeed: 1000,\r\n\t                scrollEase: Easing_1.EASING.Quadratic.Out,\r\n\t                zoomEase: Easing_1.EASING.Quadratic.Out,\r\n\t                autoScrollSpeed: 1100,\r\n\t                autoScrollEase: Easing_1.EASING.Linear.None,\r\n\t            },\r\n\t            autoRender: { enabled: true, fps: 0 },\r\n\t            autoResize: true,\r\n\t            renderer: 'WebGLRenderer',\r\n\t            autoScroll: true,\r\n\t            controls: { enabled: true },\r\n\t            trendDefaultState: {\r\n\t                enabled: true,\r\n\t                type: Trend_1.TREND_TYPE.LINE,\r\n\t                data: [],\r\n\t                maxSegmentLength: 1000,\r\n\t                lineWidth: 2,\r\n\t                lineColor: 0xFFFFFF,\r\n\t                hasBackground: true,\r\n\t                backgroundColor: 'rgba(#FFFFFF, 0.07)',\r\n\t                hasBeacon: false,\r\n\t                settingsForTypes: {\r\n\t                    CANDLE: {\r\n\t                        minSegmentLengthInPx: 20,\r\n\t                        maxSegmentLengthInPx: 40,\r\n\t                    },\r\n\t                    LINE: {\r\n\t                        minSegmentLengthInPx: 2,\r\n\t                        maxSegmentLengthInPx: 10,\r\n\t                    }\r\n\t                }\r\n\t            },\r\n\t            cursor: {\r\n\t                dragMode: false,\r\n\t                x: 0,\r\n\t                y: 0\r\n\t            },\r\n\t            font: {\r\n\t                s: '11px Arial',\r\n\t                m: '12px Arial',\r\n\t                l: '13px Arial'\r\n\t            },\r\n\t            backgroundColor: 0x000c2a,\r\n\t            showStats: false,\r\n\t            pluginsState: {},\r\n\t            eventEmitterMaxListeners: 20,\r\n\t            maxVisibleSegments: 1280,\r\n\t            inertialScroll: true\r\n\t        };\r\n\t        this.plugins = {};\r\n\t        /**\r\n\t         * true then state was initialized and ready to use\r\n\t         */\r\n\t        this.isReady = false;\r\n\t        this.isDestroyed = false;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.ee.setMaxListeners(initialState.eventEmitterMaxListeners || this.state.eventEmitterMaxListeners);\r\n\t        this.state = Utils_1.Utils.patch(this.state, initialState); //Utils.deepMerge(this.state, initialState);\r\n\t        this.trendsManager = new TrendsManager_1.TrendsManager(this, initialState);\r\n\t        initialState.trends = this.trendsManager.calculatedOptions;\r\n\t        initialState = this.installPlugins(plugins, initialState);\r\n\t        this.setState(initialState);\r\n\t        this.setState({ computedData: this.getComputedData() });\r\n\t        this.savePrevState();\r\n\t        this.animationManager = new AnimationManager_1.AnimationManager();\r\n\t        this.animationManager.setAimationsEnabled(this.state.animations.enabled);\r\n\t        this.screen = new Screen_1.Screen(this);\r\n\t        this.bindEvents();\r\n\t        // message to other modules that Chart.state is ready for use\r\n\t        this.ee.emit(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, initialState);\r\n\t        // message to other modules that Chart is ready for use\r\n\t        this.isReady = true;\r\n\t        this.ee.emit(CHART_STATE_EVENTS.READY, initialState);\r\n\t    }\r\n\t    /**\r\n\t     * destroy chart, use ChartView.destroy to completely destroy Chart\r\n\t     */\r\n\t    Chart.prototype.destroy = function () {\r\n\t        this.ee.emit(CHART_STATE_EVENTS.DESTROY);\r\n\t        this.ee.removeAllListeners();\r\n\t        this.state = {};\r\n\t        this.isDestroyed = true;\r\n\t    };\r\n\t    Chart.prototype.onDestroy = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.DESTROY, cb);\r\n\t    };\r\n\t    Chart.prototype.onInitialStateApplied = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, cb);\r\n\t    };\r\n\t    Chart.prototype.onReady = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.READY, cb);\r\n\t    };\r\n\t    Chart.prototype.onChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.CHANGE, cb);\r\n\t    };\r\n\t    Chart.prototype.onTrendChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.TREND_CHANGE, cb);\r\n\t    };\r\n\t    Chart.prototype.onTrendsChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.TRENDS_CHANGE, cb);\r\n\t    };\r\n\t    Chart.prototype.onDragStateChanged = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.DRAG_STATE_CHAGED, cb);\r\n\t    };\r\n\t    Chart.prototype.onScroll = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.SCROLL, cb);\r\n\t    };\r\n\t    Chart.prototype.onZoom = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.ZOOM, cb);\r\n\t    };\r\n\t    Chart.prototype.onResize = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.RESIZE, cb);\r\n\t    };\r\n\t    Chart.prototype.onPluginsStateChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, cb);\r\n\t    };\r\n\t    Chart.prototype.getTrend = function (trendName) {\r\n\t        return this.trendsManager.getTrend(trendName);\r\n\t    };\r\n\t    Chart.prototype.render = function () {\r\n\t        this.animationManager.tick();\r\n\t    };\r\n\t    Chart.prototype.setState = function (newState, eventData, silent) {\r\n\t        if (silent === void 0) { silent = false; }\r\n\t        if (this.isDestroyed) {\r\n\t            Utils_1.Utils.error('You have tried to change state of destroyed Chart instance');\r\n\t        }\r\n\t        var stateData = this.state;\r\n\t        var newStateObj = newState;\r\n\t        var changedProps = {};\r\n\t        for (var key in newStateObj) {\r\n\t            if (stateData[key] !== newStateObj[key]) {\r\n\t                changedProps[key] = newStateObj[key];\r\n\t            }\r\n\t        }\r\n\t        this.savePrevState(changedProps);\r\n\t        // temporary remove trends state from newState by performance reasons\r\n\t        var trendsData = {};\r\n\t        if (newState.trends)\r\n\t            for (var trendName in newState.trends) {\r\n\t                var trendOptions = newState.trends[trendName];\r\n\t                if (trendOptions.data)\r\n\t                    trendsData[trendName] = trendOptions.data;\r\n\t                delete trendOptions.data;\r\n\t            }\r\n\t        var newStateContainsData = Object.keys(trendsData).length > 0;\r\n\t        // setup ids to array items\r\n\t        newState = Utils_1.Utils.deepMerge({}, newState);\r\n\t        Utils_1.Utils.setIdsToArrayItems(newState);\r\n\t        this.state = Utils_1.Utils.patch(this.state, newState); //Utils.deepMerge(this.state, newState, false);\r\n\t        // return state to state\r\n\t        if (newStateContainsData)\r\n\t            for (var trendName in trendsData) {\r\n\t                this.state.trends[trendName].data = trendsData[trendName];\r\n\t            }\r\n\t        if (silent)\r\n\t            return;\r\n\t        // recalculate all dynamic state props\r\n\t        var recalculateResult = this.recalculateState(changedProps);\r\n\t        changedProps = recalculateResult.changedProps;\r\n\t        this.emitChangedStateEvents(changedProps, eventData);\r\n\t    };\r\n\t    /**\r\n\t     * recalculate all computed state props\r\n\t     */\r\n\t    Chart.prototype.recalculateState = function (changedProps) {\r\n\t        var data = this.state;\r\n\t        var patch = {};\r\n\t        var actualData = Utils_1.Utils.patch({}, data); //Utils.deepMerge({}, data);\r\n\t        // recalculate scroll position by changed cursor options\r\n\t        var cursorOptions = changedProps.cursor;\r\n\t        var isMouseDrag = cursorOptions && data.cursor.dragMode && data.prevState.cursor.dragMode;\r\n\t        if (isMouseDrag) {\r\n\t            var oldX = data.prevState.cursor.x;\r\n\t            var currentX = cursorOptions.x;\r\n\t            var currentScroll = data.xAxis.range.scroll;\r\n\t            var deltaXVal = this.pxToValueByXAxis(oldX - currentX);\r\n\t            patch.xAxis = { range: { scroll: currentScroll + deltaXVal } };\r\n\t            actualData = Utils_1.Utils.patch(actualData, { xAxis: patch.xAxis }); //Utils.deepMerge(actualData, {xAxis: patch.xAxis} as IChartState)\r\n\t        }\r\n\t        var chartWasResized = changedProps.width != void 0 || changedProps.height != void 0;\r\n\t        var scrollXChanged = false;\r\n\t        var needToRecalculateXAxis = (isMouseDrag ||\r\n\t            chartWasResized ||\r\n\t            (changedProps.xAxis && (changedProps.xAxis.range)) ||\r\n\t            this.state.xAxis.range.zeroVal == void 0);\r\n\t        if (needToRecalculateXAxis) {\r\n\t            var xAxisPatch = this.recalculateXAxis(actualData, changedProps);\r\n\t            if (xAxisPatch) {\r\n\t                scrollXChanged = true;\r\n\t                //patch = Utils.deepMerge(patch, {xAxis: xAxisPatch});\r\n\t                Utils_1.Utils.patch(patch, { xAxis: xAxisPatch });\r\n\t                //actualData = Utils.deepMerge(actualData, {xAxis: xAxisPatch} as IChartState);\r\n\t                Utils_1.Utils.patch(actualData, { xAxis: xAxisPatch });\r\n\t            }\r\n\t        }\r\n\t        // recalculate axis \"from\" and \"to\" for dynamics AXIS_RANGE_TYPE\r\n\t        var needToRecalculateYAxis = (chartWasResized ||\r\n\t            (data.yAxis.range.type === interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END ||\r\n\t                data.yAxis.range.type === interfaces_1.AXIS_RANGE_TYPE.AUTO ||\r\n\t                data.yAxis.range.isMirrorMode) &&\r\n\t                (scrollXChanged || changedProps.trends || changedProps.yAxis) ||\r\n\t            this.state.yAxis.range.zeroVal == void 0);\r\n\t        if (needToRecalculateYAxis) {\r\n\t            var yAxisPatch = this.recalculateYAxis(actualData);\r\n\t            if (yAxisPatch) {\r\n\t                // patch = Utils.deepMerge(patch, {yAxis: yAxisPatch});\r\n\t                // actualData = Utils.deepMerge(actualData, {yAxis: yAxisPatch} as IChartState);\r\n\t                Utils_1.Utils.patch(patch, { yAxis: yAxisPatch });\r\n\t                Utils_1.Utils.patch(actualData, { yAxis: yAxisPatch });\r\n\t            }\r\n\t        }\r\n\t        this.savePrevState(patch);\r\n\t        var allChangedProps = Utils_1.Utils.deepMerge(changedProps, patch);\r\n\t        patch.computedData = this.getComputedData(allChangedProps);\r\n\t        this.savePrevState(patch);\r\n\t        // this.state = Utils.deepMerge(this.state, patch);\r\n\t        Utils_1.Utils.patch(this.state, patch);\r\n\t        return { changedProps: allChangedProps, patch: patch };\r\n\t    };\r\n\t    Chart.prototype.getComputedData = function (changedProps) {\r\n\t        var computeAll = !changedProps;\r\n\t        var computedData = {};\r\n\t        if (computeAll || changedProps.trends && this.trendsManager) {\r\n\t            computedData.trends = {\r\n\t                maxXVal: this.trendsManager.getEndXVal(),\r\n\t                minXVal: this.trendsManager.getStartXVal()\r\n\t            };\r\n\t        }\r\n\t        return computedData;\r\n\t    };\r\n\t    Chart.prototype.savePrevState = function (changedProps) {\r\n\t        if (!changedProps)\r\n\t            changedProps = this.state;\r\n\t        var prevState = this.state.prevState;\r\n\t        // prevent to store prev trend state by performance reasons\r\n\t        Utils_1.Utils.copyProps(this.state, prevState, changedProps, ['trends']);\r\n\t    };\r\n\t    Chart.prototype.emitChangedStateEvents = function (changedProps, eventData) {\r\n\t        var prevState = this.state.prevState;\r\n\t        // emit common change event\r\n\t        this.ee.emit(CHART_STATE_EVENTS.CHANGE, changedProps, eventData);\r\n\t        // emit event for each changed state property\r\n\t        for (var key in changedProps) {\r\n\t            this.ee.emit(key + 'Change', changedProps[key], eventData);\r\n\t        }\r\n\t        if (!this.isReady)\r\n\t            return;\r\n\t        // emit special events based on changed state\r\n\t        var dragEventNeeded = (changedProps.cursor &&\r\n\t            (changedProps.cursor.dragMode != prevState.cursor.dragMode));\r\n\t        dragEventNeeded && this.ee.emit(CHART_STATE_EVENTS.DRAG_STATE_CHAGED, changedProps.cursor.dragMode, changedProps);\r\n\t        var scrollChangeEventsNeeded = (changedProps.xAxis &&\r\n\t            changedProps.xAxis.range &&\r\n\t            changedProps.xAxis.range.scroll != void 0);\r\n\t        scrollChangeEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL, changedProps);\r\n\t        var zoomEventsNeeded = ((changedProps.xAxis && changedProps.xAxis.range && changedProps.xAxis.range.zoom) ||\r\n\t            (changedProps.yAxis && changedProps.yAxis.range && changedProps.yAxis.range.zoom));\r\n\t        zoomEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.ZOOM, changedProps);\r\n\t        var resizeEventNeeded = (changedProps.width || changedProps.height);\r\n\t        resizeEventNeeded && this.ee.emit(CHART_STATE_EVENTS.RESIZE, changedProps);\r\n\t        var pluginStateChangedEventNeeded = !!(changedProps.pluginsState);\r\n\t        pluginStateChangedEventNeeded && this.ee.emit(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, changedProps.pluginsState);\r\n\t    };\r\n\t    /**\r\n\t     * init plugins and save plugins options in initialState\r\n\t     */\r\n\t    Chart.prototype.installPlugins = function (plugins, initialState) {\r\n\t        var _this = this;\r\n\t        initialState.pluginsState = {};\r\n\t        plugins.forEach(function (plugin) {\r\n\t            var PluginClass = plugin.constructor;\r\n\t            var pluginName = PluginClass.NAME;\r\n\t            initialState.pluginsState[pluginName] = Utils_1.Utils.deepMerge({}, plugin.initialState);\r\n\t            _this.plugins[pluginName] = plugin;\r\n\t            plugin.setupChart(_this);\r\n\t        });\r\n\t        return initialState;\r\n\t    };\r\n\t    /**\r\n\t     * returns plugin instance by plugin name\r\n\t     * @example\r\n\t     */\r\n\t    Chart.prototype.getPlugin = function (pluginName) {\r\n\t        return this.plugins[pluginName];\r\n\t    };\r\n\t    Chart.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.ee.on(CHART_STATE_EVENTS.TRENDS_CHANGE, function (changedTrends, newData) {\r\n\t            _this.handleTrendsChange(changedTrends, newData);\r\n\t        });\r\n\t        this.onDragStateChanged(function (dragState) { return _this.onDragStateChangedHandler(dragState); });\r\n\t        this.ee.on('animationsChange', function (animationOptions) {\r\n\t            if (animationOptions.enabled !== _this.animationManager.isAnimationsEnabled) {\r\n\t                _this.animationManager.setAimationsEnabled(animationOptions.enabled);\r\n\t            }\r\n\t        });\r\n\t    };\r\n\t    Chart.prototype.handleTrendsChange = function (changedTrends, newData) {\r\n\t        for (var trendName in changedTrends) {\r\n\t            this.ee.emit(CHART_STATE_EVENTS.TREND_CHANGE, trendName, changedTrends[trendName], newData);\r\n\t        }\r\n\t        // process autoscroll\r\n\t        var state = this.state;\r\n\t        if (!state.autoScroll || state.cursor.dragMode)\r\n\t            return;\r\n\t        var oldTrendsMaxX = state.prevState.computedData.trends.maxXVal;\r\n\t        var trendsMaxXDelta = state.computedData.trends.maxXVal - oldTrendsMaxX;\r\n\t        if (trendsMaxXDelta > 0) {\r\n\t            var maxVisibleXVal = this.screen.getScreenRightVal();\r\n\t            var paddingRightVal = this.getValueByScreenX(this.state.width -\r\n\t                state.xAxis.range.padding.end -\r\n\t                state.xAxis.range.margin.end);\r\n\t            var marginRightVal = this.getValueByScreenX(this.state.width -\r\n\t                state.xAxis.range.margin.end);\r\n\t            var currentScroll = state.xAxis.range.scroll;\r\n\t            if (oldTrendsMaxX < marginRightVal || oldTrendsMaxX > maxVisibleXVal) {\r\n\t                return;\r\n\t            }\r\n\t            var scrollDelta = state.computedData.trends.maxXVal - paddingRightVal;\r\n\t            this.setState({ xAxis: { range: { scroll: currentScroll + scrollDelta } } });\r\n\t        }\r\n\t    };\r\n\t    Chart.prototype.onDragStateChangedHandler = function (isDragMode) {\r\n\t        // process inertial scroll\r\n\t        var state = this.state;\r\n\t        if (!state.inertialScroll || isDragMode)\r\n\t            return;\r\n\t        // TODO:\r\n\t        // let currentScroll = state.xAxis.range.scroll;\r\n\t        // let currentX = state.cursor.x;\r\n\t        // let prevX = state.prevState.cursor.x;\r\n\t        // let scrollDelta = this.pxToValueByXAxis(prevX - currentX) * 10;\r\n\t        // this.setState({xAxis: {range: {scroll: currentScroll + scrollDelta}}})\r\n\t    };\r\n\t    Chart.prototype.recalculateXAxis = function (actualData, changedProps) {\r\n\t        var axisRange = actualData.xAxis.range;\r\n\t        var patch = { range: {} };\r\n\t        var isInitialize = axisRange.zeroVal == void 0;\r\n\t        var zeroVal, scaleFactor;\r\n\t        var zoom = axisRange.zoom;\r\n\t        if (axisRange.isMirrorMode) {\r\n\t            Utils_1.Utils.error('range.isMirrorMode available only for yAxis.range');\r\n\t        }\r\n\t        if (isInitialize) {\r\n\t            zeroVal = axisRange.from;\r\n\t            scaleFactor = actualData.width / (axisRange.to - axisRange.from);\r\n\t            patch = { range: { zeroVal: zeroVal, scaleFactor: scaleFactor } };\r\n\t        }\r\n\t        else {\r\n\t            zeroVal = axisRange.zeroVal;\r\n\t            scaleFactor = axisRange.scaleFactor;\r\n\t            // recalculate range.zoom and range.scroll then range.from or range.to was changed\r\n\t            if (changedProps.xAxis &&\r\n\t                (changedProps.xAxis.range.from != void 0 || changedProps.xAxis.range.to)) {\r\n\t                if (changedProps.xAxis.range.zoom) {\r\n\t                    Utils_1.Utils.error('Impossible to change \"range.zoom\" then \"range.from\" or \"range.to\" present');\r\n\t                }\r\n\t                var currentScaleFactor = actualData.width / (axisRange.to - axisRange.from);\r\n\t                patch.range.scroll = axisRange.from - zeroVal;\r\n\t                patch.range.zoom = currentScaleFactor / scaleFactor;\r\n\t                return patch;\r\n\t            }\r\n\t        }\r\n\t        // recalculate range.from and range.to then range.zoom or range.scroll was changed\r\n\t        do {\r\n\t            var from = zeroVal + axisRange.scroll;\r\n\t            var to = from + actualData.width / (scaleFactor * zoom);\r\n\t            var rangeLength = to - from;\r\n\t            var needToRecalculateZoom = false;\r\n\t            var rangeMoreThenMaxValue = (axisRange.maxLength && rangeLength > axisRange.maxLength);\r\n\t            var rangeLessThenMinValue = (axisRange.minLength && rangeLength < axisRange.minLength);\r\n\t            needToRecalculateZoom = rangeMoreThenMaxValue || rangeLessThenMinValue;\r\n\t            if (needToRecalculateZoom) {\r\n\t                var fixScale = rangeLength > axisRange.maxLength ?\r\n\t                    rangeLength / axisRange.maxLength :\r\n\t                    rangeLength / axisRange.minLength;\r\n\t                var zoom = zoom * fixScale;\r\n\t                patch.range.zoom = zoom;\r\n\t            }\r\n\t        } while (needToRecalculateZoom);\r\n\t        patch.range.from = from;\r\n\t        patch.range.to = to;\r\n\t        return patch;\r\n\t    };\r\n\t    Chart.prototype.recalculateYAxis = function (actualData) {\r\n\t        var patch = { range: {} };\r\n\t        var yAxisRange = actualData.yAxis.range;\r\n\t        var isInitialize = yAxisRange.scaleFactor == void 0;\r\n\t        var trends = this.trendsManager;\r\n\t        var trendsEndXVal = trends.getEndXVal();\r\n\t        var trendsStartXVal = trends.getStartXVal();\r\n\t        var xRange = actualData.xAxis.range;\r\n\t        var xFrom = xRange.from, xTo = xRange.to;\r\n\t        var xRangeLength = xTo - xFrom;\r\n\t        var zeroVal, scaleFactor, scroll, zoom, needToZoom;\r\n\t        // check situation when state was scrolled behind trends end or before trends start\r\n\t        if (xTo > trendsEndXVal) {\r\n\t            xTo = trendsEndXVal;\r\n\t            xFrom = xTo - xRangeLength;\r\n\t        }\r\n\t        else if (xFrom < trendsStartXVal) {\r\n\t            xFrom = trendsStartXVal;\r\n\t            xTo = xFrom + xRangeLength;\r\n\t        }\r\n\t        var maxY = trends.getMaxYVal(xFrom, xTo);\r\n\t        var minY = trends.getMinYVal(xFrom, xTo);\r\n\t        var trendLastY = trends.getMaxYVal(trendsEndXVal, trendsEndXVal);\r\n\t        if (yAxisRange.type == interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END) {\r\n\t            if (trendLastY > maxY)\r\n\t                maxY = trendLastY;\r\n\t            if (trendLastY < minY)\r\n\t                minY = trendLastY;\r\n\t        }\r\n\t        if (yAxisRange.isMirrorMode) {\r\n\t            if (yAxisRange.zeroVal == void 0)\r\n\t                Utils_1.Utils.error('range.zeroVal must be set when range.isMirrorMode');\r\n\t            var distanceFromZeroValForMaxY = Math.abs(yAxisRange.zeroVal - maxY);\r\n\t            var distanceFromZeroValForMinY = Math.abs(yAxisRange.zeroVal - minY);\r\n\t            var maxDistanceFromZeroVal = Math.max(distanceFromZeroValForMaxY, distanceFromZeroValForMinY);\r\n\t            maxY = yAxisRange.zeroVal + maxDistanceFromZeroVal;\r\n\t            minY = yAxisRange.zeroVal - maxDistanceFromZeroVal;\r\n\t        }\r\n\t        var margin = yAxisRange.margin;\r\n\t        var padding = {\r\n\t            start: yAxisRange.padding.start + margin.start,\r\n\t            end: yAxisRange.padding.end + margin.end\r\n\t        };\r\n\t        if (padding.end + padding.start >= actualData.height) {\r\n\t            Utils_1.Utils.warn('Sum of padding and margins of yAxi more then available state height. Trends can be rendered incorrectly');\r\n\t        }\r\n\t        var rangeLength = maxY - minY;\r\n\t        var paddingTopInPercents = padding.end / actualData.height;\r\n\t        var paddingBottomInPercents = padding.start / actualData.height;\r\n\t        var rangeLengthInPercents = 1 - paddingTopInPercents - paddingBottomInPercents;\r\n\t        var visibleRangeLength = rangeLength / rangeLengthInPercents;\r\n\t        var fromVal = minY - visibleRangeLength * paddingBottomInPercents;\r\n\t        var toVal = maxY + visibleRangeLength * paddingTopInPercents;\r\n\t        if (isInitialize) {\r\n\t            zeroVal = yAxisRange.zeroVal != void 0 ? yAxisRange.zeroVal : fromVal;\r\n\t            scaleFactor = actualData.height / (toVal - fromVal);\r\n\t            patch = { range: { zeroVal: zeroVal, scaleFactor: scaleFactor } };\r\n\t            needToZoom = true;\r\n\t        }\r\n\t        else {\r\n\t            scaleFactor = yAxisRange.scaleFactor;\r\n\t            zeroVal = yAxisRange.zeroVal;\r\n\t            var maxScreenY = Math.round(this.getScreenYByValue(maxY));\r\n\t            var minScreenY = Math.round(this.getScreenYByValue(minY));\r\n\t            needToZoom = (maxScreenY > actualData.height - margin.end ||\r\n\t                maxScreenY < actualData.height - padding.end ||\r\n\t                minScreenY < margin.start ||\r\n\t                minScreenY > padding.start);\r\n\t        }\r\n\t        if (!needToZoom)\r\n\t            return null;\r\n\t        scroll = fromVal - zeroVal;\r\n\t        zoom = (actualData.height / (toVal - fromVal)) / scaleFactor;\r\n\t        var currentAxisRange = this.state.yAxis.range;\r\n\t        if (currentAxisRange.from !== fromVal)\r\n\t            patch.range.from = fromVal;\r\n\t        if (currentAxisRange.to !== toVal)\r\n\t            patch.range.to = toVal;\r\n\t        if (currentAxisRange.scroll !== scroll)\r\n\t            patch.range.scroll = scroll;\r\n\t        if (currentAxisRange.zoom !== zoom)\r\n\t            patch.range.zoom = zoom;\r\n\t        return patch;\r\n\t    };\r\n\t    Chart.prototype.zoom = function (zoomValue, origin) {\r\n\t        var _this = this;\r\n\t        if (origin === void 0) { origin = 0.5; }\r\n\t        var _a = this.state.xAxis.range, zoom = _a.zoom, scroll = _a.scroll, scaleFactor = _a.scaleFactor;\r\n\t        var newZoom = zoom * zoomValue;\r\n\t        var currentRange = this.state.width / (scaleFactor * zoom);\r\n\t        var nextRange = this.state.width / (scaleFactor * newZoom);\r\n\t        var newScroll = scroll + (currentRange - nextRange) * origin;\r\n\t        this.setState({ xAxis: { range: { zoom: newZoom, scroll: newScroll } } });\r\n\t        return new deps_1.Promise(function (resolve) {\r\n\t            var animationTime = _this.state.animations.enabled ? _this.state.animations.zoomSpeed : 0;\r\n\t            setTimeout(resolve, animationTime * 1000);\r\n\t        });\r\n\t    };\r\n\t    Chart.prototype.zoomToRange = function (range, origin) {\r\n\t        var _a = this.state.xAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom;\r\n\t        var currentRange = this.state.width / (scaleFactor * zoom);\r\n\t        return this.zoom(currentRange / range, origin);\r\n\t    };\r\n\t    Chart.prototype.scrollToEnd = function () {\r\n\t        var state = this.state;\r\n\t        var endXVal = this.trendsManager.getEndXVal();\r\n\t        var range = state.xAxis.range;\r\n\t        var scroll = (endXVal - this.pxToValueByXAxis(state.width) +\r\n\t            this.pxToValueByXAxis(range.padding.end + range.margin.end) -\r\n\t            range.zeroVal);\r\n\t        this.setState({ xAxis: { range: { scroll: scroll } } });\r\n\t        return new deps_1.Promise(function (resolve) {\r\n\t            var animationTime = state.animations.enabled ? state.animations.scrollSpeed : 0;\r\n\t            setTimeout(resolve, animationTime);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal to xVal\r\n\t     */\r\n\t    Chart.prototype.getPointOnXAxis = function (xVal) {\r\n\t        var _a = this.state.xAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom, zeroVal = _a.zeroVal;\r\n\t        return (xVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from yAxis.range.zeroVal to yVal\r\n\t     */\r\n\t    Chart.prototype.getPointOnYAxis = function (yVal) {\r\n\t        var _a = this.state.yAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom, zeroVal = _a.zeroVal;\r\n\t        return (yVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     * returns xVal by offset in pixels from xAxis.range.zeroVal\r\n\t     */\r\n\t    Chart.prototype.getValueOnXAxis = function (x) {\r\n\t        return this.state.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  convert xVal to pixels by using settings from xAxis.range\r\n\t     */\r\n\t    Chart.prototype.valueToPxByXAxis = function (xVal) {\r\n\t        return xVal * this.state.xAxis.range.scaleFactor * this.state.xAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert xVal to pixels by using settings from yAxis.range\r\n\t     */\r\n\t    Chart.prototype.valueToPxByYAxis = function (yVal) {\r\n\t        return yVal * this.state.yAxis.range.scaleFactor * this.state.yAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to xVal by using settings from xAxis.range\r\n\t     */\r\n\t    Chart.prototype.pxToValueByXAxis = function (xVal) {\r\n\t        return xVal / this.state.xAxis.range.scaleFactor / this.state.xAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to xVal by using settings from yAxis.range\r\n\t     */\r\n\t    Chart.prototype.pxToValueByYAxis = function (yVal) {\r\n\t        return yVal / this.state.yAxis.range.scaleFactor / this.state.yAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns x xVal by screen x coordinate\r\n\t     */\r\n\t    Chart.prototype.getValueByScreenX = function (x) {\r\n\t        var _a = this.state.xAxis.range, zeroVal = _a.zeroVal, scroll = _a.scroll;\r\n\t        return zeroVal + scroll + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  returns y xVal by screen y coordinate\r\n\t     */\r\n\t    Chart.prototype.getValueByScreenY = function (y) {\r\n\t        var _a = this.state.yAxis.range, zeroVal = _a.zeroVal, scroll = _a.scroll;\r\n\t        return zeroVal + scroll + this.pxToValueByYAxis(y);\r\n\t    };\r\n\t    /**\r\n\t     *  returns screen x xVal by screen y coordinate\r\n\t     */\r\n\t    Chart.prototype.getScreenXByValue = function (xVal) {\r\n\t        var _a = this.state.xAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByXAxis(xVal - zeroVal - scroll);\r\n\t    };\r\n\t    /**\r\n\t     *  returns screen y xVal by screen y coordinate\r\n\t     */\r\n\t    Chart.prototype.getScreenYByValue = function (yVal) {\r\n\t        var _a = this.state.yAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByYAxis(yVal - zeroVal - scroll);\r\n\t    };\r\n\t    /**\r\n\t     * returns screen x coordinate by offset in pixels from xAxis.range.zeroVal xVal\r\n\t     */\r\n\t    Chart.prototype.getScreenXByPoint = function (xVal) {\r\n\t        return this.getScreenXByValue(this.getValueOnXAxis(xVal));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from xAxis.range.zeroVal xVal by screen x coordinate\r\n\t     */\r\n\t    Chart.prototype.getPointByScreenX = function (screenX) {\r\n\t        return this.getPointOnXAxis(this.getValueByScreenX(screenX));\r\n\t    };\r\n\t    Chart.prototype.getPointOnChart = function (xVal, yVal) {\r\n\t        return new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\r\n\t    };\r\n\t    Chart.prototype.getScreenLeftVal = function () {\r\n\t        return this.getValueByScreenX(0);\r\n\t    };\r\n\t    Chart.prototype.getScreenRightVal = function () {\r\n\t        return this.getValueByScreenX(this.state.width);\r\n\t    };\r\n\t    return Chart;\r\n\t}());\r\n\texports.Chart = Chart;\r\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar TrendSegmentsManager_1 = __webpack_require__(16);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar deps_1 = __webpack_require__(2);\r\n\tvar EVENTS = {\r\n\t    CHANGE: 'Change',\r\n\t    PREPEND_REQUEST: 'prependRequest'\r\n\t};\r\n\t(function (TREND_TYPE) {\r\n\t    TREND_TYPE[TREND_TYPE[\"LINE\"] = 0] = \"LINE\";\r\n\t    TREND_TYPE[TREND_TYPE[\"CANDLE\"] = 1] = \"CANDLE\";\r\n\t})(exports.TREND_TYPE || (exports.TREND_TYPE = {}));\r\n\tvar TREND_TYPE = exports.TREND_TYPE;\r\n\tvar Trend = (function () {\r\n\t    function Trend(chartState, trendName, initialState) {\r\n\t        this.minXVal = Infinity;\r\n\t        this.minYVal = Infinity;\r\n\t        this.maxXVal = -Infinity;\r\n\t        this.maxYVal = -Infinity;\r\n\t        var options = initialState.trends[trendName];\r\n\t        this.name = trendName;\r\n\t        this.chart = chartState;\r\n\t        this.calculatedOptions = Utils_1.Utils.deepMerge(this.chart.state.trendDefaultState, options);\r\n\t        this.calculatedOptions.name = trendName;\r\n\t        if (options.dataset)\r\n\t            this.calculatedOptions.data = Trend.prepareData(options.dataset);\r\n\t        this.calculatedOptions.dataset = [];\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.segmentsManager = new TrendSegmentsManager_1.TrendSegmentsManager(this.chart, this);\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    // private onInitialStateApplied() {\r\n\t    // \tthis.segmentsManager = new TrendSegmentsManager(this.chart, this);\r\n\t    // }\r\n\t    Trend.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var chartState = this.chart;\r\n\t        // chart.onInitialStateApplied(() => this.onInitialStateApplied());\r\n\t        chartState.onDragStateChanged(function () { return _this.checkForPrependRequest(); });\r\n\t        chartState.onZoom(function () { return _this.checkForPrependRequest(); });\r\n\t        chartState.onTrendChange(function (trendName, changedOptions, newData) { return _this.ee.emit(EVENTS.CHANGE, changedOptions, newData); });\r\n\t        chartState.onDestroy(function () { return _this.ee.removeAllListeners(); });\r\n\t    };\r\n\t    Trend.prototype.getCalculatedOptions = function () {\r\n\t        return this.calculatedOptions;\r\n\t    };\r\n\t    Trend.prototype.appendData = function (rawData) {\r\n\t        var options = this.getOptions();\r\n\t        var newData = Trend.prepareData(rawData, this.getData());\r\n\t        var updatedTrendData = options.data.concat(newData);\r\n\t        this.changeData(updatedTrendData, newData);\r\n\t    };\r\n\t    Trend.prototype.prependData = function (rawData) {\r\n\t        var options = this.getOptions();\r\n\t        var newData = Trend.prepareData(rawData, this.getData(), true);\r\n\t        var updatedTrendData = newData.concat(options.data);\r\n\t        this.changeData(updatedTrendData, newData);\r\n\t    };\r\n\t    Trend.prototype.changeData = function (allData, newData) {\r\n\t        for (var _i = 0, newData_1 = newData; _i < newData_1.length; _i++) {\r\n\t            var item = newData_1[_i];\r\n\t            if (item.xVal < this.minXVal)\r\n\t                this.minXVal = item.xVal;\r\n\t            if (item.xVal > this.maxXVal)\r\n\t                this.maxXVal = item.xVal;\r\n\t            if (item.yVal < this.minYVal)\r\n\t                this.minYVal = item.yVal;\r\n\t            if (item.yVal > this.maxYVal)\r\n\t                this.maxYVal = item.yVal;\r\n\t        }\r\n\t        var options = this.getOptions();\r\n\t        var statePatch = { trends: (_a = {}, _a[options.name] = { data: allData }, _a) };\r\n\t        this.chart.setState(statePatch, newData);\r\n\t        var _a;\r\n\t    };\r\n\t    Trend.prototype.getData = function (fromX, toX) {\r\n\t        var data = this.getOptions().data;\r\n\t        if (fromX == void 0 && toX == void 0)\r\n\t            return data;\r\n\t        fromX = fromX !== void 0 ? fromX : data[0].xVal;\r\n\t        toX = toX !== void 0 ? toX : data[data.length].xVal;\r\n\t        var filteredData = [];\r\n\t        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\r\n\t            var item = data_1[_i];\r\n\t            if (item.xVal < fromX)\r\n\t                continue;\r\n\t            if (item.xVal > toX)\r\n\t                break;\r\n\t            filteredData.push(item);\r\n\t        }\r\n\t        return filteredData;\r\n\t    };\r\n\t    Trend.prototype.getFirstItem = function () {\r\n\t        return this.getOptions().data[0];\r\n\t    };\r\n\t    Trend.prototype.getLastItem = function () {\r\n\t        var data = this.getOptions().data;\r\n\t        return data[data.length - 1];\r\n\t    };\r\n\t    Trend.prototype.getOptions = function () {\r\n\t        return this.chart.state.trends[this.name];\r\n\t    };\r\n\t    Trend.prototype.setOptions = function (options) {\r\n\t        this.chart.setState({ trends: (_a = {}, _a[this.name] = options, _a) });\r\n\t        var _a;\r\n\t    };\r\n\t    Trend.prototype.onPrependRequest = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on(EVENTS.PREPEND_REQUEST, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(EVENTS.PREPEND_REQUEST, cb);\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for Chart.onTrendChange\r\n\t     */\r\n\t    Trend.prototype.onChange = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on(EVENTS.CHANGE, cb);\r\n\t        return function () { _this.ee.off(EVENTS.CHANGE, cb); };\r\n\t    };\r\n\t    Trend.prototype.onDataChange = function (cb) {\r\n\t        var _this = this;\r\n\t        var onChangeCb = function (changedOptions, newData) {\r\n\t            if (newData)\r\n\t                cb(newData);\r\n\t        };\r\n\t        this.ee.on(EVENTS.CHANGE, onChangeCb);\r\n\t        return function () {\r\n\t            _this.ee.off(EVENTS.CHANGE, onChangeCb);\r\n\t        };\r\n\t    };\r\n\t    Trend.prototype.checkForPrependRequest = function () {\r\n\t        var _this = this;\r\n\t        if (this.prependRequest)\r\n\t            return;\r\n\t        var chartState = this.chart;\r\n\t        var minXVal = chartState.state.computedData.trends.minXVal;\r\n\t        var minScreenX = chartState.getScreenXByValue(minXVal);\r\n\t        var needToRequest = minScreenX > 0;\r\n\t        var _a = chartState.state.xAxis.range, from = _a.from, to = _a.to;\r\n\t        var requestedDataLength = to - from;\r\n\t        if (!needToRequest)\r\n\t            return;\r\n\t        this.prependRequest = new deps_1.Promise(function (resolve, reject) {\r\n\t            _this.ee.emit(EVENTS.PREPEND_REQUEST, requestedDataLength, resolve, reject);\r\n\t        });\r\n\t        this.prependRequest.then(function (newData) {\r\n\t            _this.prependData(newData);\r\n\t            _this.prependRequest = null;\r\n\t        }, function () {\r\n\t            _this.prependRequest = null;\r\n\t        });\r\n\t    };\r\n\t    Trend.prepareData = function (newData, currentData, isPrepend) {\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var data = [];\r\n\t        if (typeof newData[0] == 'number') {\r\n\t            currentData = currentData || [];\r\n\t            var initialItem = void 0;\r\n\t            var xVal = void 0;\r\n\t            if (isPrepend) {\r\n\t                initialItem = currentData[0];\r\n\t                xVal = initialItem.xVal - newData.length;\r\n\t            }\r\n\t            else {\r\n\t                initialItem = currentData[currentData.length - 1];\r\n\t                xVal = initialItem ? initialItem.xVal + 1 : 0;\r\n\t            }\r\n\t            for (var _i = 0, _a = newData; _i < _a.length; _i++) {\r\n\t                var yVal = _a[_i];\r\n\t                data.push({ xVal: xVal, yVal: yVal, id: Utils_1.Utils.getUid() });\r\n\t                xVal++;\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            data = newData;\r\n\t        }\r\n\t        return data;\r\n\t    };\r\n\t    return Trend;\r\n\t}());\r\n\texports.Trend = Trend;\r\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Trend_1 = __webpack_require__(15);\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar MAX_ANIMATED_SEGMENTS = 100;\r\n\tvar EVENTS = {\r\n\t    REBUILD: 'rebuild',\r\n\t    DISLPAYED_RANGE_CHANGED: 'displayedRangeChanged',\r\n\t    ANIMATION_FRAME: 'animationFrame'\r\n\t};\r\n\t/**\r\n\t *  Class helps to display and animate trends segments\r\n\t */\r\n\tvar TrendSegmentsManager = (function () {\r\n\t    function TrendSegmentsManager(chart, trend) {\r\n\t        this.segmentsById = {};\r\n\t        this.segments = [];\r\n\t        this.animatedSegmentsIds = [];\r\n\t        this.segmentsLength = 0;\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        this.animatedSegmentsForPrepend = [];\r\n\t        this.nextEmptyId = 0;\r\n\t        this.startSegmentId = 0;\r\n\t        this.endSegmentId = 0;\r\n\t        // TODO: make subscriptions array\r\n\t        this.unbindList = [];\r\n\t        this.chart = chart;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.trend = trend;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendSegmentsManager.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.trend.onChange(function (changedOptions, newData) { return _this.onTrendChangeHandler(changedOptions, newData); });\r\n\t        this.unbindList = [\r\n\t            this.chart.onInitialStateApplied(function () { return _this.onInitialStateAppliedHandler(); }),\r\n\t            this.chart.onZoom(function () { return _this.onZoomHandler(); }),\r\n\t            this.chart.onScroll(function () { return _this.recalculateDisplayedRange(); }),\r\n\t            this.chart.onDestroy(function () { return _this.onDestroyHandler(); })\r\n\t        ];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.unbindEvents = function () {\r\n\t        this.unbindList.forEach(function (unbind) { return unbind(); });\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onInitialStateAppliedHandler = function () {\r\n\t        this.maxSegmentLength = this.trend.getOptions().maxSegmentLength;\r\n\t        this.tryToRebuildSegments();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t        this.unbindEvents();\r\n\t        this.appendAnimation && this.appendAnimation.kill();\r\n\t        this.prependAnimation && this.prependAnimation.kill();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onZoomHandler = function () {\r\n\t        var segmentsRebuilded = this.tryToRebuildSegments();\r\n\t        if (!segmentsRebuilded) {\r\n\t            this.recalculateDisplayedRange();\r\n\t        }\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onTrendChangeHandler = function (changedOptions, newData) {\r\n\t        var needToRebuildSegments = (changedOptions.type != void 0 ||\r\n\t            changedOptions.maxSegmentLength != void 0);\r\n\t        if (needToRebuildSegments) {\r\n\t            this.tryToRebuildSegments(true);\r\n\t            return;\r\n\t        }\r\n\t        if (!newData)\r\n\t            return;\r\n\t        var data = this.trend.getData();\r\n\t        var isAppend = (!data.length || data[0].xVal < newData[0].xVal);\r\n\t        isAppend ? this.appendData(newData) : this.prependData(newData);\r\n\t        this.recalculateDisplayedRange();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getSegment = function (id) {\r\n\t        return this.segmentsById[id];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getEndSegment = function () {\r\n\t        return this.segmentsById[this.endSegmentId];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getStartSegment = function () {\r\n\t        return this.segmentsById[this.startSegmentId];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.tryToRebuildSegments = function (force) {\r\n\t        if (force === void 0) { force = false; }\r\n\t        var options = this.trend.getOptions();\r\n\t        var trendTypeName = Trend_1.TREND_TYPE[options.type];\r\n\t        var trendTypesSettings = options.settingsForTypes;\r\n\t        var trendTypeSettings = trendTypesSettings[trendTypeName];\r\n\t        var minSegmentLengthInPx = trendTypeSettings.minSegmentLengthInPx, maxSegmentLengthInPx = trendTypeSettings.maxSegmentLengthInPx;\r\n\t        var needToRebuild = this.segments.length === 0 || force;\r\n\t        var segmentLength = this.maxSegmentLength;\r\n\t        // call toFixed(2) to prevent floating segment error compare\r\n\t        var currentSegmentLengthInPx = Number(this.chart.valueToPxByXAxis(segmentLength).toFixed(2));\r\n\t        var currentMaxSegmentLengthInPx = Number(this.chart.valueToPxByXAxis(this.maxSegmentLength).toFixed(2));\r\n\t        if (currentSegmentLengthInPx < minSegmentLengthInPx) {\r\n\t            needToRebuild = true;\r\n\t            segmentLength = Math.ceil(this.chart.pxToValueByXAxis(maxSegmentLengthInPx));\r\n\t        }\r\n\t        else if (currentMaxSegmentLengthInPx > maxSegmentLengthInPx) {\r\n\t            needToRebuild = true;\r\n\t            segmentLength = this.chart.pxToValueByXAxis(minSegmentLengthInPx);\r\n\t        }\r\n\t        if (!needToRebuild)\r\n\t            return false;\r\n\t        this.maxSegmentLength = segmentLength;\r\n\t        this.segmentsById = {};\r\n\t        this.segments = [];\r\n\t        this.nextEmptyId = 0;\r\n\t        this.startSegmentId = 0;\r\n\t        this.endSegmentId = 0;\r\n\t        this.segmentsLength = 0;\r\n\t        this.stopAllAnimations();\r\n\t        this.appendData(null, true);\r\n\t        this.recalculateDisplayedRange(true);\r\n\t        this.ee.emit(EVENTS.REBUILD);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.stopAllAnimations = function () {\r\n\t        this.animatedSegmentsIds = [];\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        if (this.prependAnimation)\r\n\t            this.prependAnimation.kill();\r\n\t        if (this.appendAnimation)\r\n\t            this.appendAnimation.kill();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.recalculateDisplayedRange = function (segmentsAreRebuilded) {\r\n\t        if (segmentsAreRebuilded === void 0) { segmentsAreRebuilded = false; }\r\n\t        var _a = this.chart.state.xAxis.range, from = _a.from, to = _a.to;\r\n\t        var _b = this, firstDisplayedSegment = _b.firstDisplayedSegment, lastDisplayedSegment = _b.lastDisplayedSegment;\r\n\t        var displayedRange = to - from;\r\n\t        this.firstDisplayedSegmentInd = Utils_1.Utils.binarySearchClosestInd(this.segments, from - displayedRange, 'startXVal');\r\n\t        this.firstDisplayedSegment = this.segments[this.firstDisplayedSegmentInd];\r\n\t        this.lastDisplayedSegmentInd = Utils_1.Utils.binarySearchClosestInd(this.segments, to + displayedRange, 'endXVal');\r\n\t        this.lastDisplayedSegment = this.segments[this.lastDisplayedSegmentInd];\r\n\t        if (segmentsAreRebuilded)\r\n\t            return;\r\n\t        var displayedRangeChanged = (firstDisplayedSegment.id !== this.firstDisplayedSegment.id ||\r\n\t            lastDisplayedSegment.id !== this.lastDisplayedSegment.id);\r\n\t        if (displayedRangeChanged)\r\n\t            this.ee.emit(EVENTS.DISLPAYED_RANGE_CHANGED);\r\n\t    };\r\n\t    // getSegments(fromX?: number, toX?: number): TrendSegment[] {\r\n\t    // \tvar segments = this.segments;\r\n\t    // \tif (fromX == void 0 && toX == void 0) return segments;\r\n\t    // \tfromX = fromX !== void 0 ? fromX : segments[0].startXVal;\r\n\t    // \ttoX = toX !== void 0 ? toX : segments[this.segmentsLength].endXVal;\r\n\t    // \tvar startSegmentInd = Utils.closestBinarySearch(segments, fromX, 'xVal');\r\n\t    // \tvar endSegmentInd = Utils.closestBinarySearch(segments, toX, 'xVal');\r\n\t    // \treturn segments.slice(startSegmentInd, endSegmentInd);\r\n\t    // }\r\n\t    /**\r\n\t     * returns array of segments for values array\r\n\t     * values must be sorted!\r\n\t     */\r\n\t    TrendSegmentsManager.prototype.getSegmentsForXValues = function (values) {\r\n\t        var valueInd = 0;\r\n\t        var value = values[valueInd];\r\n\t        var lastValueInd = values.length - 1;\r\n\t        var results = [];\r\n\t        var segment = this.getStartSegment();\r\n\t        if (!segment.hasValue)\r\n\t            return [];\r\n\t        while (segment) {\r\n\t            while (value < segment.startXVal) {\r\n\t                results.push(void 0);\r\n\t                value = values[++valueInd];\r\n\t            }\r\n\t            while (value > segment.endXVal) {\r\n\t                segment = segment.getNext();\r\n\t                if (!segment)\r\n\t                    break;\r\n\t            }\r\n\t            var valueInPoint = (segment.startXVal == value || segment.endXVal == value ||\r\n\t                (segment.startXVal < value && segment.endXVal > value));\r\n\t            if (valueInPoint) {\r\n\t                results.push(segment);\r\n\t                value = values[++valueInd];\r\n\t            }\r\n\t            if (valueInd > lastValueInd)\r\n\t                break;\r\n\t        }\r\n\t        return results;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onAnimationFrame = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.ANIMATION_FRAME, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onRebuild = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.REBUILD, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onDisplayedRangeChanged = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.DISLPAYED_RANGE_CHANGED, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.allocateNextSegment = function () {\r\n\t        var id = this.nextEmptyId++;\r\n\t        var segment = new TrendSegment(this, id);\r\n\t        var prevSegment = this.segmentsById[this.endSegmentId];\r\n\t        if (prevSegment && prevSegment.hasValue) {\r\n\t            prevSegment.nextId = id;\r\n\t            segment.prevId = prevSegment.id;\r\n\t        }\r\n\t        this.endSegmentId = id;\r\n\t        this.segmentsLength++;\r\n\t        this.segmentsById[id] = segment;\r\n\t        this.segments.push(segment);\r\n\t        return segment;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.allocatePrevSegment = function () {\r\n\t        var id = this.nextEmptyId++;\r\n\t        var segment = new TrendSegment(this, id);\r\n\t        var nextSegment = this.segmentsById[this.startSegmentId];\r\n\t        if (nextSegment && nextSegment.hasValue) {\r\n\t            nextSegment.prevId = id;\r\n\t            segment.nextId = nextSegment.id;\r\n\t        }\r\n\t        this.startSegmentId = id;\r\n\t        this.segmentsLength++;\r\n\t        this.segmentsById[id] = segment;\r\n\t        this.segments.unshift(segment);\r\n\t        return segment;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.appendData = function (newData, needRebuildSegments) {\r\n\t        // WARNING: bottleneck method!\r\n\t        if (needRebuildSegments === void 0) { needRebuildSegments = false; }\r\n\t        // var t1 = performance.now();\r\n\t        var trendData = this.trend.getData();\r\n\t        if (needRebuildSegments) {\r\n\t            newData = trendData;\r\n\t            this.animatedSegmentsForAppend = [];\r\n\t        }\r\n\t        var startItemInd = trendData.length - newData.length;\r\n\t        var segment = this.getEndSegment() || this.allocateNextSegment();\r\n\t        var initialSegment = segment.hasValue ? segment : null;\r\n\t        var initialAnimationState = segment.createAnimationState();\r\n\t        var itemInd = 0;\r\n\t        while (itemInd < newData.length) {\r\n\t            var item = newData[itemInd];\r\n\t            var itemIsInserted = segment.appendItem(item);\r\n\t            var isLastItem = itemInd == newData.length - 1;\r\n\t            if (itemIsInserted) {\r\n\t                if (!isLastItem)\r\n\t                    itemInd++;\r\n\t            }\r\n\t            else {\r\n\t                if (!segment.isCompleted)\r\n\t                    segment.complete();\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted) {\r\n\t                segment.recalculateItems();\r\n\t            }\r\n\t            var segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\r\n\t            if (segmentIsReadyForAnimate) {\r\n\t                var id = segment.id;\r\n\t                if (!initialSegment)\r\n\t                    initialSegment = segment;\r\n\t                if (!initialAnimationState) {\r\n\t                    initialAnimationState = initialSegment.createAnimationState();\r\n\t                }\r\n\t                segment.initialAnimationState = Utils_1.Utils.deepMerge({}, initialAnimationState);\r\n\t                if (this.animatedSegmentsForAppend.length > 0) {\r\n\t                    segment.initialAnimationState.startXVal = initialAnimationState.endXVal;\r\n\t                    segment.initialAnimationState.startYVal = initialAnimationState.endYVal;\r\n\t                }\r\n\t                segment.currentAnimationState = Utils_1.Utils.deepMerge({}, initialAnimationState);\r\n\t                segment.targetAnimationState = segment.createAnimationState();\r\n\t                this.animatedSegmentsForAppend.push(id);\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted)\r\n\t                break;\r\n\t            if (!segment.isCompleted)\r\n\t                continue;\r\n\t            segment = this.allocateNextSegment();\r\n\t            var prevItem = trendData[startItemInd + itemInd - 1];\r\n\t            segment.appendItem(prevItem);\r\n\t        }\r\n\t        var animationsOptions = this.chart.state.animations;\r\n\t        var time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\r\n\t        // var t2 = performance.now();\r\n\t        // console.log(t2 - t1);\r\n\t        // do not create animation if segments was rebuilded\r\n\t        if (needRebuildSegments) {\r\n\t            for (var _i = 0, _a = this.animatedSegmentsForAppend; _i < _a.length; _i++) {\r\n\t                var segmentId = _a[_i];\r\n\t                var segment_1 = this.segmentsById[segmentId];\r\n\t                segment_1.currentAnimationState = segment_1.createAnimationState();\r\n\t            }\r\n\t            this.animatedSegmentsForAppend = [];\r\n\t            return;\r\n\t        }\r\n\t        if (this.animatedSegmentsForAppend.length > MAX_ANIMATED_SEGMENTS)\r\n\t            time = 0;\r\n\t        this.animate(time);\r\n\t    };\r\n\t    // TODO: refactor duplicated code from appendData\r\n\t    TrendSegmentsManager.prototype.prependData = function (newData) {\r\n\t        var trendData = this.trend.getData();\r\n\t        var segment = this.getStartSegment() || this.segmentsById[0];\r\n\t        var initialSegment = segment.hasValue ? segment : null;\r\n\t        var itemInd = newData.length - 1;\r\n\t        var initialAnimationState = segment.createAnimationState();\r\n\t        while (itemInd >= 0) {\r\n\t            var item = newData[itemInd];\r\n\t            var itemIsInserted = segment.prependItem(item);\r\n\t            var isLastItem = itemInd == 0;\r\n\t            if (itemIsInserted) {\r\n\t                if (!isLastItem)\r\n\t                    itemInd--;\r\n\t            }\r\n\t            else {\r\n\t                if (!segment.isCompleted)\r\n\t                    segment.complete();\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted) {\r\n\t                segment.recalculateItems();\r\n\t            }\r\n\t            var segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\r\n\t            if (segmentIsReadyForAnimate) {\r\n\t                var id = segment.id;\r\n\t                if (!initialSegment)\r\n\t                    initialSegment = segment;\r\n\t                if (!initialAnimationState)\r\n\t                    initialAnimationState = initialSegment.createAnimationState();\r\n\t                segment.initialAnimationState = Utils_1.Utils.deepMerge({}, initialAnimationState);\r\n\t                if (this.animatedSegmentsForPrepend.length > 0) {\r\n\t                    segment.initialAnimationState.endXVal = initialAnimationState.startXVal;\r\n\t                    segment.initialAnimationState.endYVal = initialAnimationState.startYVal;\r\n\t                }\r\n\t                segment.targetAnimationState = segment.createAnimationState();\r\n\t                this.animatedSegmentsForPrepend.push(id);\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted)\r\n\t                break;\r\n\t            if (!segment.isCompleted)\r\n\t                continue;\r\n\t            segment = this.allocatePrevSegment();\r\n\t            var nextItem = trendData[itemInd + 1];\r\n\t            segment.prependItem(nextItem);\r\n\t        }\r\n\t        var animationsOptions = this.chart.state.animations;\r\n\t        var time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\r\n\t        if (this.animatedSegmentsForPrepend.length > MAX_ANIMATED_SEGMENTS)\r\n\t            time = 0;\r\n\t        this.animate(time, true);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.animate = function (time, isPrepend) {\r\n\t        var _this = this;\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\r\n\t        var animation = isPrepend ? this.prependAnimation : this.appendAnimation;\r\n\t        if ((animation && animation.isActive()) || time == 0) {\r\n\t            if (animation)\r\n\t                animation.kill();\r\n\t            this.onAnimationFrameHandler(1, isPrepend);\r\n\t            animatedSegmentsIds.length = 0;\r\n\t            return;\r\n\t        }\r\n\t        var animationsOptions = this.chart.state.animations;\r\n\t        var ease = animationsOptions.trendChangeEase;\r\n\t        var objectToAnimate = { animationValue: 0 };\r\n\t        animation = TweenLite.to(objectToAnimate, time, { animationValue: 1, ease: ease });\r\n\t        animation.eventCallback('onUpdate', function () { return _this.onAnimationFrameHandler(objectToAnimate.animationValue, isPrepend); });\r\n\t        animation.eventCallback('onComplete', function () {\r\n\t            animatedSegmentsIds.length = 0;\r\n\t            _this.appendAnimation = null;\r\n\t        });\r\n\t        if (isPrepend) {\r\n\t            this.prependAnimation = animation;\r\n\t        }\r\n\t        else {\r\n\t            this.appendAnimation = animation;\r\n\t        }\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onAnimationFrameHandler = function (coefficient, isPrepend) {\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\r\n\t        for (var _i = 0, animatedSegmentsIds_1 = animatedSegmentsIds; _i < animatedSegmentsIds_1.length; _i++) {\r\n\t            var segmentId = animatedSegmentsIds_1[_i];\r\n\t            var segment = this.segmentsById[segmentId];\r\n\t            for (var key in segment.targetAnimationState) {\r\n\t                var targetValue = segment.targetAnimationState[key];\r\n\t                var initialValue = segment.initialAnimationState[key];\r\n\t                var currentValue = initialValue + (targetValue - initialValue) * coefficient;\r\n\t                segment.currentAnimationState[key] = currentValue;\r\n\t            }\r\n\t        }\r\n\t        this.animatedSegmentsIds = this.animatedSegmentsForAppend.concat(this.animatedSegmentsForPrepend);\r\n\t        this.ee.emit(EVENTS.ANIMATION_FRAME, this);\r\n\t    };\r\n\t    return TrendSegmentsManager;\r\n\t}());\r\n\texports.TrendSegmentsManager = TrendSegmentsManager;\r\n\tvar TrendSegment = (function () {\r\n\t    function TrendSegment(trendPoints, id) {\r\n\t        this.isCompleted = false;\r\n\t        this.items = [];\r\n\t        this.initialAnimationState = {};\r\n\t        this.targetAnimationState = {};\r\n\t        this.currentAnimationState = {};\r\n\t        this.trendSegments = trendPoints;\r\n\t        this.id = id;\r\n\t        this.maxLength = trendPoints.maxSegmentLength;\r\n\t    }\r\n\t    TrendSegment.prototype.createAnimationState = function () {\r\n\t        var _a = this, xVal = _a.xVal, yVal = _a.yVal, startXVal = _a.startXVal, startYVal = _a.startYVal, endXVal = _a.endXVal, endYVal = _a.endYVal, maxYVal = _a.maxYVal, minYVal = _a.minYVal, maxLength = _a.maxLength;\r\n\t        return {\r\n\t            xVal: xVal,\r\n\t            yVal: yVal,\r\n\t            startXVal: startXVal,\r\n\t            startYVal: startYVal,\r\n\t            endXVal: endXVal,\r\n\t            endYVal: endYVal,\r\n\t            maxYVal: maxYVal,\r\n\t            minYVal: minYVal,\r\n\t            maxLength: maxLength\r\n\t        };\r\n\t    };\r\n\t    ;\r\n\t    TrendSegment.prototype.appendItem = function (item) {\r\n\t        if (this.isCompleted)\r\n\t            return false;\r\n\t        var items = this.items;\r\n\t        if (items.length < 2) {\r\n\t            this.items.push(item);\r\n\t            this.hasValue = true;\r\n\t            return true;\r\n\t        }\r\n\t        var startXVal = items[0].xVal;\r\n\t        if (item.xVal - startXVal > this.maxLength)\r\n\t            return false;\r\n\t        items.push(item);\r\n\t        return true;\r\n\t    };\r\n\t    TrendSegment.prototype.prependItem = function (item) {\r\n\t        if (this.isCompleted)\r\n\t            return false;\r\n\t        var items = this.items;\r\n\t        if (items.length < 2) {\r\n\t            this.items.unshift(item);\r\n\t            this.hasValue = true;\r\n\t            return true;\r\n\t        }\r\n\t        var endXVal = items[items.length - 1].xVal;\r\n\t        if (endXVal - item.xVal > this.maxLength)\r\n\t            return false;\r\n\t        items.unshift(item);\r\n\t        return true;\r\n\t    };\r\n\t    TrendSegment.prototype.complete = function () {\r\n\t        this.isCompleted = true;\r\n\t        this.recalculateItems();\r\n\t        this.items = []; // free memory for completed ranges\r\n\t    };\r\n\t    TrendSegment.prototype.recalculateItems = function () {\r\n\t        var items = this.items;\r\n\t        var itemsLength = items.length;\r\n\t        if (itemsLength === 0)\r\n\t            Utils_1.Utils.error('Unable to create TrendSegment without TrendItems');\r\n\t        var endItem = items[itemsLength - 1];\r\n\t        var endXVal = endItem.xVal, endYVal = endItem.yVal;\r\n\t        var startXVal, startYVal;\r\n\t        var startItem = items[0];\r\n\t        startXVal = startItem.xVal;\r\n\t        startYVal = startItem.yVal;\r\n\t        var minX = Math.min(startXVal, endXVal);\r\n\t        var maxX = Math.max(startXVal, endXVal);\r\n\t        var middleXVal = minX + (maxX - minX) / 2;\r\n\t        var minY = Math.min(startYVal, endYVal);\r\n\t        var maxY = Math.max(startYVal, endYVal);\r\n\t        var middleYVal = minY + (maxY - minY) / 2;\r\n\t        var yVals = items.map(function (item) { return item.yVal; });\r\n\t        this.startXVal = startXVal;\r\n\t        this.startYVal = startYVal;\r\n\t        this.endXVal = endXVal;\r\n\t        this.endYVal = endYVal;\r\n\t        this.xVal = middleXVal;\r\n\t        this.yVal = middleYVal;\r\n\t        this.maxYVal = Math.max.apply(Math, yVals);\r\n\t        this.minYVal = Math.min.apply(Math, yVals);\r\n\t        this.currentAnimationState = this.createAnimationState();\r\n\t    };\r\n\t    TrendSegment.prototype.getNext = function () {\r\n\t        var nextPoint = this.trendSegments.segmentsById[this.nextId];\r\n\t        return nextPoint && nextPoint.hasValue ? nextPoint : null;\r\n\t    };\r\n\t    TrendSegment.prototype.getPrev = function () {\r\n\t        var prevPoint = this.trendSegments.segmentsById[this.prevId];\r\n\t        return prevPoint && prevPoint.hasValue ? prevPoint : null;\r\n\t    };\r\n\t    TrendSegment.prototype.getFrameVal = function () {\r\n\t        var _a = this.createAnimationState(), xVal = _a.xVal, yVal = _a.yVal;\r\n\t        return new Vector3(xVal, yVal, 0);\r\n\t    };\r\n\t    TrendSegment.prototype.getFramePoint = function () {\r\n\t        var frameVal = this.getFrameVal();\r\n\t        return this.trendSegments.chart.screen.getPointOnChart(frameVal.x, frameVal.y);\r\n\t    };\r\n\t    return TrendSegment;\r\n\t}());\r\n\texports.TrendSegment = TrendSegment;\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Trend_1 = __webpack_require__(15);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar EVENTS = {\r\n\t    SEGMENTS_REBUILDED: 'segmentsRebuilded'\r\n\t};\r\n\t/**\r\n\t * Trends manager\r\n\t */\r\n\tvar TrendsManager = (function () {\r\n\t    function TrendsManager(state, initialState) {\r\n\t        this.trends = {};\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.chartState = state;\r\n\t        var trendsCalculatedOptions = {};\r\n\t        for (var trendName in initialState.trends) {\r\n\t            var trend = this.createTrend(state, trendName, initialState);\r\n\t            trendsCalculatedOptions[trendName] = trend.getCalculatedOptions();\r\n\t        }\r\n\t        this.calculatedOptions = trendsCalculatedOptions;\r\n\t    }\r\n\t    TrendsManager.prototype.getTrend = function (trendName) {\r\n\t        return this.trends[trendName];\r\n\t    };\r\n\t    TrendsManager.prototype.getEnabledTrends = function () {\r\n\t        var enabledTrends = [];\r\n\t        var allTrends = this.trends;\r\n\t        for (var trendName in allTrends) {\r\n\t            var trend = allTrends[trendName];\r\n\t            trend.getOptions().enabled && enabledTrends.push(trend);\r\n\t        }\r\n\t        return enabledTrends;\r\n\t    };\r\n\t    TrendsManager.prototype.getStartXVal = function () {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        return trends[0].getData()[0].xVal;\r\n\t    };\r\n\t    TrendsManager.prototype.getEndXVal = function () {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        var firstTrendData = trends[0].getData();\r\n\t        return firstTrendData[firstTrendData.length - 1].xVal;\r\n\t    };\r\n\t    TrendsManager.prototype.getExtremumYVal = function (extremumIsMax, fromX, toX) {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        var compareFn;\r\n\t        var result;\r\n\t        if (extremumIsMax) {\r\n\t            result = -Infinity;\r\n\t            compareFn = Math.max;\r\n\t        }\r\n\t        else {\r\n\t            result = Infinity;\r\n\t            compareFn = Math.min;\r\n\t        }\r\n\t        for (var _i = 0, trends_1 = trends; _i < trends_1.length; _i++) {\r\n\t            var trend = trends_1[_i];\r\n\t            var trendData = trend.getData(fromX, toX);\r\n\t            var trendYValues = trendData.map(function (dataItem) { return dataItem.yVal; });\r\n\t            result = compareFn.apply(void 0, [result].concat(trendYValues));\r\n\t        }\r\n\t        if (result == Infinity || result == -Infinity)\r\n\t            result = NaN;\r\n\t        return result;\r\n\t    };\r\n\t    TrendsManager.prototype.getMaxYVal = function (fromX, toX) { return this.getExtremumYVal(true, fromX, toX); };\r\n\t    TrendsManager.prototype.getMinYVal = function (fromX, toX) { return this.getExtremumYVal(false, fromX, toX); };\r\n\t    TrendsManager.prototype.onSegmentsRebuilded = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.SEGMENTS_REBUILDED, cb);\r\n\t    };\r\n\t    TrendsManager.prototype.createTrend = function (state, trendName, initialState) {\r\n\t        var _this = this;\r\n\t        var trend = new Trend_1.Trend(state, trendName, initialState);\r\n\t        this.trends[trendName] = trend;\r\n\t        trend.segmentsManager.onRebuild(function () { return _this.ee.emit(EVENTS.SEGMENTS_REBUILDED, trendName); });\r\n\t        return trend;\r\n\t    };\r\n\t    return TrendsManager;\r\n\t}());\r\n\texports.TrendsManager = TrendsManager;\r\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\t(function (TRANSFORMATION_EVENT) {\r\n\t    TRANSFORMATION_EVENT[TRANSFORMATION_EVENT[\"STARTED\"] = 0] = \"STARTED\";\r\n\t    TRANSFORMATION_EVENT[TRANSFORMATION_EVENT[\"FINISHED\"] = 1] = \"FINISHED\";\r\n\t})(exports.TRANSFORMATION_EVENT || (exports.TRANSFORMATION_EVENT = {}));\r\n\tvar TRANSFORMATION_EVENT = exports.TRANSFORMATION_EVENT;\r\n\tvar SCREEN_EVENTS = {\r\n\t    ZOOM_FRAME: 'zoomFrame',\r\n\t    SCROLL_FRAME: 'scrollFrame',\r\n\t    TRANSFORMATION_FRAME: 'transformationFrame',\r\n\t    TRANSFORMATION_EVENT: 'transformationStateChanged',\r\n\t};\r\n\t/**\r\n\t * manage camera, and contains methods for transforming pixels to values\r\n\t */\r\n\tvar Screen = (function () {\r\n\t    function Screen(chartState) {\r\n\t        // TODO: !!! rename point coordinates to world coordinates\r\n\t        // TODO: move all Chart metrics functions here\r\n\t        this.options = { scrollXVal: 0, scrollX: 0, scrollYVal: 0, scrollY: 0, zoomX: 1, zoomY: 1 };\r\n\t        this.transformationInProgress = false;\r\n\t        this.chart = chartState;\r\n\t        var _a = chartState.state, w = _a.width, h = _a.height;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.transform({\r\n\t            scrollY: this.valueToPxByYAxis(this.chart.state.yAxis.range.scroll),\r\n\t            zoomY: 1\r\n\t        });\r\n\t        this.bindEvents();\r\n\t        //camera.position.z = 1500;\r\n\t    }\r\n\t    Screen.prototype.getCameraSettings = function () {\r\n\t        var _a = this.chart.state, w = _a.width, h = _a.height;\r\n\t        // settings for pixel-perfect camera\r\n\t        var FOV = 75;\r\n\t        var vFOV = FOV * (Math.PI / 180);\r\n\t        return {\r\n\t            FOV: FOV,\r\n\t            aspect: w / h,\r\n\t            near: 0.1,\r\n\t            far: 5000,\r\n\t            z: h / (2 * Math.tan(vFOV / 2)),\r\n\t            // move 0,0 to left-bottom corner\r\n\t            x: w / 2,\r\n\t            y: h / 2\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.onZoomFrame = function (cb) {\r\n\t        return this.ee.subscribe(SCREEN_EVENTS.ZOOM_FRAME, cb);\r\n\t    };\r\n\t    Screen.prototype.onScrollFrame = function (cb) {\r\n\t        return this.ee.subscribe(SCREEN_EVENTS.SCROLL_FRAME, cb);\r\n\t    };\r\n\t    Screen.prototype.onTransformationFrame = function (cb) {\r\n\t        return this.ee.subscribe(SCREEN_EVENTS.TRANSFORMATION_FRAME, cb);\r\n\t    };\r\n\t    Screen.prototype.onTransformationEvent = function (cb) {\r\n\t        return this.ee.subscribe(SCREEN_EVENTS.TRANSFORMATION_EVENT, cb);\r\n\t    };\r\n\t    Screen.prototype.cameraIsMoving = function () {\r\n\t        return !!(this.scrollXAnimation && !this.scrollXAnimation.isFinished ||\r\n\t            this.zoomXAnimation && !this.zoomXAnimation.isFinished);\r\n\t    };\r\n\t    /**\r\n\t     * setup zoom and scroll\r\n\t     */\r\n\t    Screen.prototype.transform = function (options, silent) {\r\n\t        if (silent === void 0) { silent = false; }\r\n\t        var scrollX = options.scrollX, scrollY = options.scrollY, zoomX = options.zoomX, zoomY = options.zoomY;\r\n\t        if (scrollX != void 0)\r\n\t            this.options.scrollX = scrollX;\r\n\t        if (scrollY != void 0)\r\n\t            this.options.scrollY = scrollY;\r\n\t        if (zoomX != void 0)\r\n\t            this.options.zoomX = zoomX;\r\n\t        if (zoomY != void 0)\r\n\t            this.options.zoomY = zoomY;\r\n\t        if (scrollX != void 0 || zoomX) {\r\n\t            options.scrollXVal = this.pxToValueByXAxis(scrollX != void 0 ? scrollX : this.options.scrollX);\r\n\t            this.options.scrollXVal = options.scrollXVal;\r\n\t        }\r\n\t        if (scrollY != void 0 || zoomY) {\r\n\t            options.scrollYVal = this.pxToValueByYAxis(scrollY != void 0 ? scrollY : this.options.scrollY);\r\n\t            this.options.scrollYVal = options.scrollYVal;\r\n\t        }\r\n\t        if (silent)\r\n\t            return;\r\n\t        var hasActiveAnimations = ((this.scrollXAnimation && !this.scrollXAnimation.isStopped) ||\r\n\t            (this.scrollYAnimation && !this.scrollYAnimation.isStopped) ||\r\n\t            (this.zoomXAnimation && !this.zoomXAnimation.isStopped) ||\r\n\t            (this.zoomYAnimation && !this.zoomYAnimation.isStopped));\r\n\t        var transformationStarted = hasActiveAnimations && !this.transformationInProgress;\r\n\t        var transformationFinished = !hasActiveAnimations && this.transformationInProgress;\r\n\t        if (transformationStarted) {\r\n\t            this.transformationInProgress = true;\r\n\t            this.ee.emit(SCREEN_EVENTS.TRANSFORMATION_EVENT, TRANSFORMATION_EVENT.STARTED);\r\n\t        }\r\n\t        if (transformationFinished) {\r\n\t            this.transformationInProgress = false;\r\n\t        }\r\n\t        if (!this.transformationInProgress) {\r\n\t            // prevent to set camera between pixels\r\n\t            this.options.scrollX = options.scrollX = Math.round(this.options.scrollX);\r\n\t            this.options.scrollY = options.scrollY = Math.round(this.options.scrollY);\r\n\t        }\r\n\t        this.ee.emit(SCREEN_EVENTS.TRANSFORMATION_FRAME, options);\r\n\t        var scrollEventNeeded = options.scrollXVal != void 0 || options.scrollYVal != void 0;\r\n\t        if (scrollEventNeeded)\r\n\t            this.ee.emit(SCREEN_EVENTS.SCROLL_FRAME, options);\r\n\t        var zoomEventNeeded = options.zoomX != void 0 || options.zoomY != void 0;\r\n\t        if (zoomEventNeeded)\r\n\t            this.ee.emit(SCREEN_EVENTS.ZOOM_FRAME, options);\r\n\t        if (transformationFinished) {\r\n\t            this.ee.emit(SCREEN_EVENTS.TRANSFORMATION_EVENT, TRANSFORMATION_EVENT.FINISHED);\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chart;\r\n\t        // handle scroll and zoom\r\n\t        state.onChange(function (changedProps) {\r\n\t            if (changedProps.xAxis && changedProps.xAxis.range) {\r\n\t                if (changedProps.xAxis.range.scroll != void 0)\r\n\t                    _this.onScrollXHandler(changedProps);\r\n\t                if (changedProps.xAxis.range.zoom)\r\n\t                    _this.onZoomXHandler();\r\n\t            }\r\n\t            if (changedProps.yAxis && changedProps.yAxis.range) {\r\n\t                if (changedProps.yAxis.range.scroll != void 0)\r\n\t                    _this.onScrollYHandler();\r\n\t                if (changedProps.yAxis.range.zoom)\r\n\t                    _this.onZoomYHandler();\r\n\t            }\r\n\t        });\r\n\t        state.onDestroy(function () { return _this.onDestroyHandler(); });\r\n\t    };\r\n\t    Screen.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t    };\r\n\t    Screen.prototype.onScrollXHandler = function (changedProps) {\r\n\t        var _this = this;\r\n\t        var chart = this.chart;\r\n\t        var isDragMode = chart.state.cursor.dragMode;\r\n\t        var animations = chart.state.animations;\r\n\t        var zoomXChanged = changedProps.xAxis.range.zoom;\r\n\t        var isAutoscroll = chart.state.autoScroll && !isDragMode && !zoomXChanged;\r\n\t        var time = isAutoscroll ? animations.autoScrollSpeed : animations.zoomSpeed;\r\n\t        var ease = isAutoscroll ? animations.autoScrollEase : animations.zoomEase;\r\n\t        var range = chart.state.xAxis.range;\r\n\t        var targetX = range.scroll * range.scaleFactor * range.zoom;\r\n\t        if (isDragMode && !chart.state.inertialScroll)\r\n\t            time = 0;\r\n\t        if (this.scrollXAnimation)\r\n\t            this.scrollXAnimation.stop();\r\n\t        this.scrollXAnimation = chart.animationManager.animate(time, ease)\r\n\t            .from(this.options.scrollX)\r\n\t            .to(targetX)\r\n\t            .onTick(function (value) {\r\n\t            _this.transform({ scrollX: value });\r\n\t        });\r\n\t    };\r\n\t    Screen.prototype.onScrollYHandler = function () {\r\n\t        var _this = this;\r\n\t        var chart = this.chart;\r\n\t        var animations = chart.state.animations;\r\n\t        var range = chart.state.yAxis.range;\r\n\t        var targetY = range.scroll * range.scaleFactor * range.zoom;\r\n\t        if (this.scrollYAnimation)\r\n\t            this.scrollYAnimation.stop();\r\n\t        this.scrollYAnimation = chart.animationManager.animate(animations.zoomSpeed, animations.zoomEase)\r\n\t            .from(this.options.scrollY)\r\n\t            .to(targetY)\r\n\t            .onTick(function (value) {\r\n\t            _this.transform({ scrollY: value });\r\n\t        });\r\n\t    };\r\n\t    Screen.prototype.onZoomXHandler = function () {\r\n\t        var _this = this;\r\n\t        var chart = this.chart;\r\n\t        var animations = chart.state.animations;\r\n\t        var targetZoom = chart.state.xAxis.range.zoom;\r\n\t        if (this.zoomXAnimation)\r\n\t            this.zoomXAnimation.stop();\r\n\t        this.zoomXAnimation = chart.animationManager\r\n\t            .animate(animations.zoomSpeed, animations.zoomEase)\r\n\t            .from(this.options.zoomX)\r\n\t            .to(targetZoom)\r\n\t            .onTick(function (value) {\r\n\t            _this.transform({ zoomX: value });\r\n\t        });\r\n\t    };\r\n\t    Screen.prototype.onZoomYHandler = function () {\r\n\t        var _this = this;\r\n\t        var chart = this.chart;\r\n\t        var targetZoom = chart.state.yAxis.range.zoom;\r\n\t        var animations = chart.state.animations;\r\n\t        if (this.zoomYAnimation)\r\n\t            this.zoomYAnimation.stop();\r\n\t        this.zoomYAnimation = chart.animationManager\r\n\t            .animate(animations.zoomSpeed, animations.zoomEase)\r\n\t            .from(this.options.zoomY)\r\n\t            .to(targetZoom)\r\n\t            .onTick(function (value) {\r\n\t            _this.transform({ zoomY: value });\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal to scrollXVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnXAxis = function (xVal) {\r\n\t        var _a = this.chart.state.xAxis.range, scaleFactor = _a.scaleFactor, zeroVal = _a.zeroVal;\r\n\t        var zoom = this.options.zoomX;\r\n\t        return (xVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from yAxis.range.zeroVal to scrollYVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnYAxis = function (yVal) {\r\n\t        var _a = this.chart.state.yAxis.range, scaleFactor = _a.scaleFactor, zeroVal = _a.zeroVal;\r\n\t        var zoom = this.options.zoomY;\r\n\t        return (yVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal and from yAxis.range.zeroVal to scrollXVal and scrollYVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnChart = function (xVal, yVal) {\r\n\t        return new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\r\n\t    };\r\n\t    /**\r\n\t     * returns xVal by offset in pixels from xAxis.range.zeroVal\r\n\t     */\r\n\t    Screen.prototype.getValueOnXAxis = function (x) {\r\n\t        return this.chart.state.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  convert xVal to pixels by using settings from xAxis.range\r\n\t     */\r\n\t    Screen.prototype.valueToPxByXAxis = function (xVal) {\r\n\t        return xVal * this.chart.state.xAxis.range.scaleFactor * this.options.zoomX;\r\n\t    };\r\n\t    /**\r\n\t     *  convert xVal to pixels by using settings from yAxis.range\r\n\t     */\r\n\t    Screen.prototype.valueToPxByYAxis = function (yVal) {\r\n\t        return yVal * this.chart.state.yAxis.range.scaleFactor * this.options.zoomY;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to xVal by using settings from xAxis.range\r\n\t     */\r\n\t    Screen.prototype.pxToValueByXAxis = function (xVal) {\r\n\t        return xVal / this.chart.state.xAxis.range.scaleFactor / this.options.zoomX;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to xVal by using settings from yAxis.range\r\n\t     */\r\n\t    Screen.prototype.pxToValueByYAxis = function (yVal) {\r\n\t        return yVal / this.chart.state.yAxis.range.scaleFactor / this.options.zoomY;\r\n\t    };\r\n\t    /**\r\n\t     *  returns scrollX xVal by screen scrollX coordinate\r\n\t     */\r\n\t    Screen.prototype.getValueByScreenX = function (x) {\r\n\t        return this.chart.state.xAxis.range.zeroVal + this.options.scrollXVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    Screen.prototype.getValueByScreenY = function (y) {\r\n\t        return this.chart.state.yAxis.range.zeroVal + this.options.scrollYVal + this.pxToValueByYAxis(y);\r\n\t    };\r\n\t    Screen.prototype.getScreenXByValue = function (xVal) {\r\n\t        var _a = this.chart.state.xAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByXAxis(xVal - zeroVal - scroll);\r\n\t    };\r\n\t    Screen.prototype.getScreenYByValue = function (yVal) {\r\n\t        var _a = this.chart.state.yAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByYAxis(yVal - zeroVal - scroll);\r\n\t    };\r\n\t    Screen.prototype.getScreenXByPoint = function (xVal) {\r\n\t        return this.getScreenXByValue(this.getValueOnXAxis(xVal));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from xAxis.range.zeroVal xVal by screen scrollX coordinate\r\n\t     */\r\n\t    Screen.prototype.getPointByScreenX = function (screenX) {\r\n\t        return this.getPointOnXAxis(this.getValueByScreenX(screenX));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from yAxis.range.zeroVal xVal by screen scrollY coordinate\r\n\t     */\r\n\t    Screen.prototype.getPointByScreenY = function (screenY) {\r\n\t        return this.getPointOnYAxis(this.getValueByScreenY(screenY));\r\n\t    };\r\n\t    Screen.prototype.getTop = function () {\r\n\t        return this.getPointByScreenY(this.chart.state.height);\r\n\t    };\r\n\t    Screen.prototype.getBottom = function () {\r\n\t        return this.getPointByScreenY(0);\r\n\t    };\r\n\t    Screen.prototype.getLeft = function () {\r\n\t        return this.getPointByScreenX(0);\r\n\t    };\r\n\t    Screen.prototype.getScreenRightVal = function () {\r\n\t        return this.getValueByScreenX(this.chart.state.width);\r\n\t    };\r\n\t    Screen.prototype.getTopVal = function () {\r\n\t        return this.getValueByScreenY(this.chart.state.height);\r\n\t    };\r\n\t    Screen.prototype.getBottomVal = function () {\r\n\t        return this.getValueByScreenY(0);\r\n\t    };\r\n\t    Screen.prototype.getCenterYVal = function () {\r\n\t        return this.getValueByScreenY(this.chart.state.height / 2);\r\n\t    };\r\n\t    return Screen;\r\n\t}());\r\n\texports.Screen = Screen;\r\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t(function (AXIS_RANGE_TYPE) {\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"FIXED\"] = 0] = \"FIXED\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"RELATIVE_END\"] = 1] = \"RELATIVE_END\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"AUTO\"] = 2] = \"AUTO\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"ALL\"] = 3] = \"ALL\"; // TODO: AXIS_RANGE_TYPE.ALL\r\n\t})(exports.AXIS_RANGE_TYPE || (exports.AXIS_RANGE_TYPE = {}));\r\n\tvar AXIS_RANGE_TYPE = exports.AXIS_RANGE_TYPE;\r\n\t;\r\n\t(function (AXIS_TYPE) {\r\n\t    AXIS_TYPE[AXIS_TYPE[\"X\"] = 0] = \"X\";\r\n\t    AXIS_TYPE[AXIS_TYPE[\"Y\"] = 1] = \"Y\";\r\n\t})(exports.AXIS_TYPE || (exports.AXIS_TYPE = {}));\r\n\tvar AXIS_TYPE = exports.AXIS_TYPE;\r\n\t(function (AXIS_DATA_TYPE) {\r\n\t    AXIS_DATA_TYPE[AXIS_DATA_TYPE[\"NUMBER\"] = 0] = \"NUMBER\";\r\n\t    AXIS_DATA_TYPE[AXIS_DATA_TYPE[\"DATE\"] = 1] = \"DATE\";\r\n\t})(exports.AXIS_DATA_TYPE || (exports.AXIS_DATA_TYPE = {}));\r\n\tvar AXIS_DATA_TYPE = exports.AXIS_DATA_TYPE;\r\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Easing_1 = __webpack_require__(21);\r\n\t// TODO: transfer AnimationManager to own repo\r\n\tvar AnimationManager = (function () {\r\n\t    function AnimationManager() {\r\n\t        this.isAnimationsEnabled = true;\r\n\t        this.animations = [];\r\n\t        this.lastTickTime = Date.now();\r\n\t    }\r\n\t    AnimationManager.prototype.animate = function (time, timingFunction) {\r\n\t        var animation = new Animation(this, time, this.lastTickTime, timingFunction);\r\n\t        this.animations.push(animation);\r\n\t        return animation;\r\n\t    };\r\n\t    AnimationManager.prototype.animateObj = function (source, target) {\r\n\t    };\r\n\t    AnimationManager.prototype.setAimationsEnabled = function (isEnabled) {\r\n\t        this.isAnimationsEnabled = isEnabled;\r\n\t    };\r\n\t    AnimationManager.prototype.tick = function () {\r\n\t        var now = Date.now();\r\n\t        var animations = this.animations;\r\n\t        // call tick for each animation\r\n\t        for (var i_1 = 0; i_1 < animations.length; i_1++) {\r\n\t            var animation = animations[i_1];\r\n\t            if (this.isAnimationsEnabled) {\r\n\t                animation.tick(now);\r\n\t            }\r\n\t            else {\r\n\t                animation.completeAndStop();\r\n\t            }\r\n\t        }\r\n\t        // cleanup completed animations\r\n\t        var i = animations.length;\r\n\t        while (i--)\r\n\t            if (animations[i].isStopped)\r\n\t                animations.splice(i, 1);\r\n\t        this.lastTickTime = now;\r\n\t    };\r\n\t    AnimationManager.prototype.hasActiveAnimations = function () {\r\n\t        return this.animations.length > 0;\r\n\t    };\r\n\t    return AnimationManager;\r\n\t}());\r\n\texports.AnimationManager = AnimationManager;\r\n\tvar Animation = (function () {\r\n\t    function Animation(animationManager, time, createdTime, easing) {\r\n\t        if (easing === void 0) { easing = Easing_1.EASING.Quadratic.Out; }\r\n\t        this.animationManager = animationManager;\r\n\t        this.time = time;\r\n\t        this.createdTime = createdTime;\r\n\t        this.easing = easing;\r\n\t        this.progress = 0;\r\n\t        this.delay = 0;\r\n\t        this.isFinished = false;\r\n\t        this.isStopped = false;\r\n\t        this.startTime = createdTime;\r\n\t    }\r\n\t    Animation.prototype.tick = function (now) {\r\n\t        if (!this.isStopped) {\r\n\t            var progress = this.time > 0 ? ((now - this.startTime) / this.time) : 1;\r\n\t            this.setProgress(progress);\r\n\t        }\r\n\t    };\r\n\t    Animation.prototype.from = function (sourceObj) {\r\n\t        if (typeof sourceObj == 'object') {\r\n\t            this.sourceObj = sourceObj;\r\n\t            this.initialObj = {};\r\n\t            var sourceIteralable = sourceObj;\r\n\t            for (var key in sourceIteralable)\r\n\t                if (typeof sourceIteralable[key] == 'number') {\r\n\t                    this.initialObj[key] = sourceIteralable[key];\r\n\t                }\r\n\t        }\r\n\t        else if (typeof sourceObj == 'number') {\r\n\t            this.sourceObj = sourceObj;\r\n\t            this.initialObj = sourceObj;\r\n\t        }\r\n\t        return this;\r\n\t    };\r\n\t    Animation.prototype.to = function (targetObj) {\r\n\t        this.targetObject = targetObj;\r\n\t        // clear unused fields\r\n\t        if (typeof this.initialObj == 'object') {\r\n\t            var initialIteralable = this.initialObj;\r\n\t            for (var key in this.targetObject) {\r\n\t                if (initialIteralable[key] == void 0)\r\n\t                    delete initialIteralable[key];\r\n\t            }\r\n\t            var targetIteralable = this.targetObject;\r\n\t            for (var key in initialIteralable) {\r\n\t                if (targetIteralable[key] == void 0)\r\n\t                    delete initialIteralable[key];\r\n\t            }\r\n\t        }\r\n\t        return this;\r\n\t    };\r\n\t    Animation.prototype.onTick = function (onTickCb) {\r\n\t        this.onTickCb = onTickCb;\r\n\t        return this;\r\n\t    };\r\n\t    Animation.prototype.then = function (onFinishCb) {\r\n\t        this.onFinishCb = onFinishCb;\r\n\t        return this;\r\n\t    };\r\n\t    Animation.prototype.stop = function () {\r\n\t        this.isStopped = true;\r\n\t    };\r\n\t    Animation.prototype.completeAndStop = function () {\r\n\t        this.setProgress(1);\r\n\t    };\r\n\t    Animation.prototype.withDelay = function (delay) {\r\n\t        this.delay = delay;\r\n\t        this.startTime = this.createdTime + delay;\r\n\t        return this;\r\n\t    };\r\n\t    Animation.prototype.setProgress = function (progress) {\r\n\t        if (progress < 0)\r\n\t            return;\r\n\t        progress = Math.min(progress, 1);\r\n\t        this.progress = progress;\r\n\t        var k = this.easing(progress);\r\n\t        if (typeof this.sourceObj == 'number') {\r\n\t            var initialVal = this.initialObj;\r\n\t            var targetVal = this.targetObject;\r\n\t            this.sourceObj = (initialVal + (targetVal - initialVal) * k);\r\n\t        }\r\n\t        else if (this.sourceObj && this.targetObject) {\r\n\t            for (var key in this.initialObj) {\r\n\t                var initialVal = this.initialObj[key];\r\n\t                var targetVal = this.targetObject[key];\r\n\t                this.sourceObj[key] = initialVal + (targetVal - initialVal) * k;\r\n\t            }\r\n\t        }\r\n\t        if (progress == 1) {\r\n\t            this.isStopped = true;\r\n\t            this.isFinished = true;\r\n\t        }\r\n\t        if (this.onTickCb)\r\n\t            this.onTickCb(this.sourceObj, progress, k, this);\r\n\t        if (progress == 1 && this.onFinishCb)\r\n\t            this.onFinishCb(this.sourceObj, this);\r\n\t    };\r\n\t    return Animation;\r\n\t}());\r\n\texports.Animation = Animation;\r\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t/**\r\n\t * Easing from tween.js lib https://github.com/tweenjs/tween.js\r\n\t **/\r\n\texports.EASING = {\r\n\t    Linear: {\r\n\t        None: function (k) {\r\n\t            return k;\r\n\t        }\r\n\t    },\r\n\t    Quadratic: {\r\n\t        In: function (k) {\r\n\t            return k * k;\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            return k * (2 - k);\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if ((k *= 2) < 1) {\r\n\t                return 0.5 * k * k;\r\n\t            }\r\n\t            return -0.5 * (--k * (k - 2) - 1);\r\n\t        }\r\n\t    },\r\n\t    Cubic: {\r\n\t        In: function (k) {\r\n\t            return k * k * k;\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            return --k * k * k + 1;\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if ((k *= 2) < 1) {\r\n\t                return 0.5 * k * k * k;\r\n\t            }\r\n\t            return 0.5 * ((k -= 2) * k * k + 2);\r\n\t        }\r\n\t    },\r\n\t    Quartic: {\r\n\t        In: function (k) {\r\n\t            return k * k * k * k;\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            return 1 - (--k * k * k * k);\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if ((k *= 2) < 1) {\r\n\t                return 0.5 * k * k * k * k;\r\n\t            }\r\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\r\n\t        }\r\n\t    },\r\n\t    Quintic: {\r\n\t        In: function (k) {\r\n\t            return k * k * k * k * k;\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            return --k * k * k * k * k + 1;\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if ((k *= 2) < 1) {\r\n\t                return 0.5 * k * k * k * k * k;\r\n\t            }\r\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\r\n\t        }\r\n\t    },\r\n\t    Sinusoidal: {\r\n\t        In: function (k) {\r\n\t            return 1 - Math.cos(k * Math.PI / 2);\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            return Math.sin(k * Math.PI / 2);\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\r\n\t        }\r\n\t    },\r\n\t    Exponential: {\r\n\t        In: function (k) {\r\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if (k === 0) {\r\n\t                return 0;\r\n\t            }\r\n\t            if (k === 1) {\r\n\t                return 1;\r\n\t            }\r\n\t            if ((k *= 2) < 1) {\r\n\t                return 0.5 * Math.pow(1024, k - 1);\r\n\t            }\r\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\r\n\t        }\r\n\t    },\r\n\t    Circular: {\r\n\t        In: function (k) {\r\n\t            return 1 - Math.sqrt(1 - k * k);\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            return Math.sqrt(1 - (--k * k));\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if ((k *= 2) < 1) {\r\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\r\n\t            }\r\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\r\n\t        }\r\n\t    },\r\n\t    Elastic: {\r\n\t        In: function (k) {\r\n\t            if (k === 0) {\r\n\t                return 0;\r\n\t            }\r\n\t            if (k === 1) {\r\n\t                return 1;\r\n\t            }\r\n\t            return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            if (k === 0) {\r\n\t                return 0;\r\n\t            }\r\n\t            if (k === 1) {\r\n\t                return 1;\r\n\t            }\r\n\t            return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if (k === 0) {\r\n\t                return 0;\r\n\t            }\r\n\t            if (k === 1) {\r\n\t                return 1;\r\n\t            }\r\n\t            k *= 2;\r\n\t            if (k < 1) {\r\n\t                return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\r\n\t            }\r\n\t            return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\r\n\t        }\r\n\t    },\r\n\t    Back: {\r\n\t        In: function (k) {\r\n\t            var s = 1.70158;\r\n\t            return k * k * ((s + 1) * k - s);\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            var s = 1.70158;\r\n\t            return --k * k * ((s + 1) * k + s) + 1;\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            var s = 1.70158 * 1.525;\r\n\t            if ((k *= 2) < 1) {\r\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\r\n\t            }\r\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\r\n\t        }\r\n\t    },\r\n\t    Bounce: {\r\n\t        In: function (k) {\r\n\t            return 1 - exports.EASING.Bounce.Out(1 - k);\r\n\t        },\r\n\t        Out: function (k) {\r\n\t            if (k < (1 / 2.75)) {\r\n\t                return 7.5625 * k * k;\r\n\t            }\r\n\t            else if (k < (2 / 2.75)) {\r\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\r\n\t            }\r\n\t            else if (k < (2.5 / 2.75)) {\r\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\r\n\t            }\r\n\t            else {\r\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\r\n\t            }\r\n\t        },\r\n\t        InOut: function (k) {\r\n\t            if (k < 0.5) {\r\n\t                return exports.EASING.Bounce.In(k * 2) * 0.5;\r\n\t            }\r\n\t            return exports.EASING.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\r\n\t        }\r\n\t    }\r\n\t};\r\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t/**\r\n\t * base class for all widgets\r\n\t * each widget must have widgetName static property\r\n\t */\r\n\tvar ChartWidget = (function () {\r\n\t    function ChartWidget() {\r\n\t        this.unbindList = [];\r\n\t    }\r\n\t    ChartWidget.prototype.setupChart = function (chart) {\r\n\t        this.chart = chart;\r\n\t    };\r\n\t    ChartWidget.prototype.bindEvent = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var unbindList = [];\r\n\t        if (!Array.isArray(args[0])) {\r\n\t            unbindList.push(args[0]);\r\n\t        }\r\n\t        else {\r\n\t            unbindList.push.apply(unbindList, (args));\r\n\t        }\r\n\t        (_a = this.unbindList).push.apply(_a, unbindList);\r\n\t        var _a;\r\n\t    };\r\n\t    ChartWidget.prototype.unbindEvents = function () {\r\n\t        this.unbindList.forEach(function (unbindEvent) { return unbindEvent(); });\r\n\t        this.unbindList.length = 0;\r\n\t    };\r\n\t    ChartWidget.widgetName = '';\r\n\t    return ChartWidget;\r\n\t}());\r\n\texports.ChartWidget = ChartWidget;\r\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar GridWidget_1 = __webpack_require__(24);\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar interfaces_1 = __webpack_require__(19);\r\n\tvar Color_1 = __webpack_require__(25);\r\n\t/**\r\n\t * widget for drawing axis\r\n\t */\r\n\tvar AxisWidget = (function (_super) {\r\n\t    __extends(AxisWidget, _super);\r\n\t    function AxisWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.isDestroyed = false;\r\n\t    }\r\n\t    AxisWidget.prototype.onReadyHandler = function () {\r\n\t        var _this = this;\r\n\t        this.object3D = new Object3D();\r\n\t        this.axisXObject = new Object3D();\r\n\t        this.axisYObject = new Object3D();\r\n\t        this.object3D.add(this.axisXObject);\r\n\t        this.object3D.add(this.axisYObject);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t        // canvas drawing is expensive operation, so when we scroll, redraw must be called only once per second\r\n\t        this.updateAxisXRequest = Utils_1.Utils.throttle(function () { return _this.updateAxis(interfaces_1.AXIS_TYPE.X); }, 1000);\r\n\t        this.onScrollChange(this.chart.screen.options.scrollX, this.chart.screen.options.scrollY);\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    AxisWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chart;\r\n\t        this.bindEvent(state.screen.onTransformationFrame(function (options) {\r\n\t            _this.onScrollChange(options.scrollX, options.scrollY);\r\n\t        }), state.screen.onZoomFrame(function (options) { _this.onZoomFrame(options); }), state.onDestroy(function () { return _this.onDestroy(); }), state.onResize(function () { return _this.onResize(); }));\r\n\t    };\r\n\t    AxisWidget.prototype.onDestroy = function () {\r\n\t        this.isDestroyed = true;\r\n\t        this.unbindEvents();\r\n\t    };\r\n\t    AxisWidget.prototype.onScrollChange = function (x, y) {\r\n\t        if (y != void 0) {\r\n\t            this.axisYObject.position.y = y;\r\n\t            this.axisXObject.position.y = y;\r\n\t        }\r\n\t        if (x != void 0) {\r\n\t            this.axisYObject.position.x = x;\r\n\t            this.updateAxisXRequest();\r\n\t        }\r\n\t    };\r\n\t    AxisWidget.prototype.onResize = function () {\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t    };\r\n\t    AxisWidget.prototype.setupAxis = function (orientation) {\r\n\t        var _this = this;\r\n\t        var isXAxis = orientation == interfaces_1.AXIS_TYPE.X;\r\n\t        var _a = this.chart.state, visibleWidth = _a.width, visibleHeight = _a.height;\r\n\t        var canvasWidth = 0, canvasHeight = 0;\r\n\t        var axisOptions;\r\n\t        // clean meshes\r\n\t        if (isXAxis) {\r\n\t            this.axisXObject.traverse(function (obj) { return _this.axisXObject.remove(obj); });\r\n\t            canvasWidth = visibleWidth * 3;\r\n\t            canvasHeight = 50;\r\n\t            axisOptions = this.chart.state.xAxis;\r\n\t        }\r\n\t        else {\r\n\t            this.axisYObject.traverse(function (obj) { return _this.axisYObject.remove(obj); });\r\n\t            canvasWidth = 50;\r\n\t            canvasHeight = visibleHeight * 3;\r\n\t            axisOptions = this.chart.state.yAxis;\r\n\t        }\r\n\t        var texture = Utils_1.Utils.createNearestTexture(canvasWidth, canvasHeight, function (ctx) {\r\n\t            var color = new Color_1.Color(axisOptions.color);\r\n\t            ctx.beginPath();\r\n\t            ctx.font = _this.chart.state.font.m;\r\n\t            ctx.fillStyle = color.rgbaStr;\r\n\t            ctx.strokeStyle = color.rgbaStr;\r\n\t        });\r\n\t        var material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });\r\n\t        material.transparent = true;\r\n\t        var axisMesh = new Mesh(new THREE.PlaneGeometry(canvasWidth, canvasHeight), material);\r\n\t        if (isXAxis) {\r\n\t            axisMesh.position.set(canvasWidth / 2, canvasHeight / 2, 0);\r\n\t            this.axisXObject.add(axisMesh);\r\n\t        }\r\n\t        else {\r\n\t            axisMesh.position.set(visibleWidth - canvasWidth / 2, canvasHeight / 2, 0);\r\n\t            this.axisYObject.add(axisMesh);\r\n\t        }\r\n\t        this.updateAxis(orientation);\r\n\t    };\r\n\t    AxisWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    AxisWidget.prototype.updateAxis = function (orientation) {\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        var isXAxis = orientation == interfaces_1.AXIS_TYPE.X;\r\n\t        var _a = this.chart.state, visibleWidth = _a.width, visibleHeight = _a.height;\r\n\t        var _b = this.chart.screen.options, scrollX = _b.scrollX, scrollY = _b.scrollY, zoomX = _b.zoomX, zoomY = _b.zoomY;\r\n\t        var axisOptions;\r\n\t        var axisMesh;\r\n\t        var axisGridParams;\r\n\t        if (isXAxis) {\r\n\t            axisMesh = this.axisXObject.children[0];\r\n\t            axisOptions = this.chart.state.xAxis;\r\n\t            axisGridParams = GridWidget_1.GridWidget.getGridParamsForAxis(axisOptions, visibleWidth, zoomX);\r\n\t        }\r\n\t        else {\r\n\t            axisMesh = this.axisYObject.children[0];\r\n\t            axisOptions = this.chart.state.yAxis;\r\n\t            axisGridParams = GridWidget_1.GridWidget.getGridParamsForAxis(axisOptions, visibleHeight, zoomY);\r\n\t        }\r\n\t        var geometry = axisMesh.geometry;\r\n\t        var canvasWidth = geometry.parameters.width;\r\n\t        var canvasHeight = geometry.parameters.height;\r\n\t        var texture = axisMesh.material.map;\r\n\t        var ctx = texture.image.getContext('2d');\r\n\t        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\t        if (isXAxis) {\r\n\t            axisMesh.position.x = canvasWidth / 2 - visibleWidth + scrollX;\r\n\t        }\r\n\t        // TODO: draw text and lines in different loops\r\n\t        var edgeOffset = axisGridParams.segmentsCount * axisGridParams.step;\r\n\t        var startVal = axisGridParams.start - edgeOffset;\r\n\t        var endVal = axisGridParams.end + edgeOffset;\r\n\t        ctx.beginPath();\r\n\t        for (var val = startVal; val <= endVal; val += axisGridParams.step) {\r\n\t            var displayedValue = '';\r\n\t            if (isXAxis) {\r\n\t                var pxVal = this.chart.screen.getPointOnXAxis(val) - scrollX + visibleWidth;\r\n\t                ctx.textAlign = \"center\";\r\n\t                // uncomment for dots\r\n\t                // ctx.moveTo(pxVal + 0.5, canvasHeight);\r\n\t                // ctx.lineTo(pxVal + 0.5, canvasHeight - 5);\r\n\t                if (axisOptions.dataType == interfaces_1.AXIS_DATA_TYPE.DATE) {\r\n\t                    displayedValue = AxisWidget.getDateStr(val, axisGridParams);\r\n\t                }\r\n\t                else {\r\n\t                    displayedValue = Number(val.toFixed(14)).toString();\r\n\t                }\r\n\t                ctx.fillText(displayedValue, pxVal, canvasHeight - 10);\r\n\t            }\r\n\t            else {\r\n\t                var pxVal = canvasHeight - this.chart.screen.getPointOnYAxis(val) + scrollY;\r\n\t                ctx.textAlign = \"right\";\r\n\t                // uncomment for dots\r\n\t                // ctx.moveTo(canvasWidth, pxVal + 0.5);\r\n\t                // ctx.lineTo(canvasWidth - 5, pxVal + 0.5);\r\n\t                displayedValue = Number(val.toFixed(14)).toString();\r\n\t                ctx.fillText(displayedValue, canvasWidth - 15, pxVal + 3);\r\n\t            }\r\n\t            ctx.stroke();\r\n\t        }\r\n\t        // uncomment to preview canvas borders\r\n\t        // ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\t        ctx.stroke();\r\n\t        ctx.closePath();\r\n\t        texture.needsUpdate = true;\r\n\t    };\r\n\t    AxisWidget.prototype.onZoomFrame = function (options) {\r\n\t        if (options.zoomX) {\r\n\t            this.updateAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        }\r\n\t        if (options.zoomY) {\r\n\t            this.updateAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t        }\r\n\t    };\r\n\t    // private temporaryHideAxis(orientation: AXIS_TYPE) {\r\n\t    // \tvar isXAxis = orientation == AXIS_TYPE.X;\r\n\t    // \tvar timeoutId = setTimeout(() => {\r\n\t    // \t\t\tthis.showAxis(orientation);\r\n\t    // \t}, 200);\r\n\t    //\r\n\t    // \tif (isXAxis) {\r\n\t    // \t\t(this.axisXObject.children[0] as Mesh).material.opacity = 0;\r\n\t    // \t\tclearTimeout(this.showAxisXTimeout);\r\n\t    // \t\tthis.showAxisXTimeout =\ttimeoutId;\r\n\t    // \t} else {\r\n\t    // \t\tclearTimeout(this.showAxisYTimeout);\r\n\t    // \t\t(this.axisYObject.children[0] as Mesh).material.opacity = 0;\r\n\t    // \t\tthis.showAxisYTimeout = timeoutId;\r\n\t    // \t}\r\n\t    // }\r\n\t    // private showAxis(orientation: AXIS_TYPE) {\r\n\t    // \tvar isXAxis = orientation == AXIS_TYPE.X;\r\n\t    // \tvar material: MeshBasicMaterial;\r\n\t    // \tif (isXAxis) {\r\n\t    // \t\tmaterial = (this.axisXObject.children[0] as Mesh).material as MeshBasicMaterial;\r\n\t    // \t} else {\r\n\t    // \t\tmaterial = (this.axisYObject.children[0] as Mesh).material as MeshBasicMaterial;\r\n\t    // \t}\r\n\t    // \tthis.updateAxis(orientation);\r\n\t    // \tTweenLite.to(material, 0.3, {opacity: 1});\r\n\t    // }\r\n\t    AxisWidget.getDateStr = function (timestamp, gridParams) {\r\n\t        var sec = 1000;\r\n\t        var min = sec * 60;\r\n\t        var hour = min * 60;\r\n\t        var day = hour * 60;\r\n\t        var step = gridParams.step;\r\n\t        var d = new Date(timestamp);\r\n\t        var tf = function (num) { return Utils_1.Utils.toFixed(num, 2); };\r\n\t        return tf(d.getHours()) + ':' + tf(d.getMinutes()) + ':' + tf(d.getSeconds());\r\n\t    };\r\n\t    AxisWidget.widgetName = 'Axis';\r\n\t    return AxisWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.AxisWidget = AxisWidget;\r\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar LineSegments = THREE.LineSegments;\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar Color_1 = __webpack_require__(25);\r\n\t/**\r\n\t * widget for drawing state grid\r\n\t */\r\n\tvar GridWidget = (function (_super) {\r\n\t    __extends(GridWidget, _super);\r\n\t    function GridWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.isDestroyed = false;\r\n\t    }\r\n\t    GridWidget.prototype.onReadyHandler = function () {\r\n\t        var _a = this.chart.state, width = _a.width, height = _a.height, xAxis = _a.xAxis, yAxis = _a.yAxis;\r\n\t        this.gridSizeH = Math.floor(width / xAxis.grid.minSizePx) * 3;\r\n\t        this.gridSizeV = Math.floor(height / yAxis.grid.minSizePx) * 3;\r\n\t        this.initGrid();\r\n\t        this.updateGrid();\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    GridWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        // grid is bigger then screen, so it's no need to update it on each scroll event\r\n\t        var updateGridThrottled = Utils_1.Utils.throttle(function () { return _this.updateGrid(); }, 1000);\r\n\t        this.bindEvent(this.chart.onScroll(function () { return updateGridThrottled(); }), this.chart.screen.onZoomFrame(function (options) {\r\n\t            updateGridThrottled();\r\n\t            _this.onZoomFrame(options);\r\n\t        }), this.chart.onDestroy(function () {\r\n\t            _this.isDestroyed = true;\r\n\t            _this.unbindEvents();\r\n\t        }), this.chart.onResize(function () {\r\n\t            _this.updateGrid();\r\n\t        }));\r\n\t    };\r\n\t    GridWidget.prototype.initGrid = function () {\r\n\t        var color = new Color_1.Color(this.chart.state.xAxis.grid.color);\r\n\t        var geometry = new THREE.Geometry();\r\n\t        var material = new THREE.LineBasicMaterial({ linewidth: 1, color: color.value, opacity: color.a, transparent: true });\r\n\t        var xLinesCount = this.gridSizeH;\r\n\t        var yLinesCount = this.gridSizeV;\r\n\t        while (xLinesCount--)\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t        while (yLinesCount--)\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t        this.lineSegments = new LineSegments(geometry, material);\r\n\t        this.lineSegments.position.setZ(-1);\r\n\t        this.lineSegments.frustumCulled = false;\r\n\t    };\r\n\t    GridWidget.prototype.updateGrid = function () {\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        var _a = this.chart.state, yAxis = _a.yAxis, xAxis = _a.xAxis, width = _a.width, height = _a.height;\r\n\t        var axisXGrid = GridWidget.getGridParamsForAxis(xAxis, width, xAxis.range.zoom);\r\n\t        var axisYGrid = GridWidget.getGridParamsForAxis(yAxis, height, yAxis.range.zoom);\r\n\t        var scrollXInSegments = Math.ceil(xAxis.range.scroll / axisXGrid.step);\r\n\t        var scrollYInSegments = Math.ceil(yAxis.range.scroll / axisYGrid.step);\r\n\t        var gridScrollXVal = scrollXInSegments * axisXGrid.step;\r\n\t        var gridScrollYVal = scrollYInSegments * axisYGrid.step;\r\n\t        var startXVal = axisXGrid.start + gridScrollXVal;\r\n\t        var startYVal = axisYGrid.start + gridScrollYVal;\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        var vertices = geometry.vertices;\r\n\t        var lineInd = 0;\r\n\t        for (var i = -this.gridSizeH / 3; i < this.gridSizeH * 2 / 3; i++) {\r\n\t            var value = startXVal + i * axisXGrid.step;\r\n\t            var lineSegment = this.getVerticalLineSegment(value, gridScrollXVal, gridScrollYVal);\r\n\t            vertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\r\n\t            vertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\r\n\t            lineInd++;\r\n\t        }\r\n\t        for (var i = -this.gridSizeV / 3; i < this.gridSizeV * 2 / 3; i++) {\r\n\t            var value = startYVal + i * axisYGrid.step;\r\n\t            var lineSegment = this.getHorizontalLineSegment(value, gridScrollXVal, gridScrollYVal);\r\n\t            vertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\r\n\t            vertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\r\n\t            lineInd++;\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t        this.lineSegments.scale.set(xAxis.range.scaleFactor * xAxis.range.zoom, yAxis.range.scaleFactor * yAxis.range.zoom, 1);\r\n\t    };\r\n\t    GridWidget.prototype.getHorizontalLineSegment = function (yVal, scrollXVal, scrollYVal) {\r\n\t        var chartState = this.chart;\r\n\t        var localYVal = yVal - chartState.state.yAxis.range.zeroVal - scrollYVal;\r\n\t        var widthVal = chartState.pxToValueByXAxis(chartState.state.width);\r\n\t        return [\r\n\t            new THREE.Vector3(widthVal * 2 + scrollXVal, localYVal, 0),\r\n\t            new THREE.Vector3(-widthVal + scrollXVal, localYVal, 0)\r\n\t        ];\r\n\t    };\r\n\t    GridWidget.prototype.getVerticalLineSegment = function (xVal, scrollXVal, scrollYVal) {\r\n\t        var chartState = this.chart;\r\n\t        var localXVal = xVal - chartState.state.xAxis.range.zeroVal - scrollXVal;\r\n\t        var heightVal = chartState.pxToValueByYAxis(chartState.state.height);\r\n\t        return [\r\n\t            new THREE.Vector3(localXVal, heightVal * 2 + scrollYVal, 0),\r\n\t            new THREE.Vector3(localXVal, -heightVal + scrollYVal, 0)\r\n\t        ];\r\n\t    };\r\n\t    GridWidget.prototype.onZoomFrame = function (options) {\r\n\t        var _a = this.chart.state, xAxis = _a.xAxis, yAxis = _a.yAxis;\r\n\t        if (options.zoomX)\r\n\t            this.lineSegments.scale.setX(xAxis.range.scaleFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            this.lineSegments.scale.setY(yAxis.range.scaleFactor * options.zoomY);\r\n\t    };\r\n\t    // TODO: move this code to core\r\n\t    GridWidget.getGridParamsForAxis = function (axisOptions, axisWidth, zoom) {\r\n\t        var axisRange = axisOptions.range;\r\n\t        var from = axisRange.from;\r\n\t        var to = axisRange.to;\r\n\t        var axisLength = to - from;\r\n\t        var gridStep = 0;\r\n\t        var gridStepInPixels = 0;\r\n\t        var minGridStepInPixels = axisOptions.grid.minSizePx;\r\n\t        var axisLengthStr = String(axisLength);\r\n\t        var axisLengthPointPosition = axisLengthStr.indexOf('.');\r\n\t        var intPartLength = axisLengthPointPosition !== -1 ? axisLengthPointPosition : axisLengthStr.length;\r\n\t        var gridStepFound = false;\r\n\t        var digitPos = 0;\r\n\t        while (!gridStepFound) {\r\n\t            var power = intPartLength - digitPos - 1;\r\n\t            var multiplier = (Math.pow(10, power) || 1);\r\n\t            var dividers = [1, 2, 5];\r\n\t            for (var dividerInd = 0; dividerInd < dividers.length; dividerInd++) {\r\n\t                var nextGridStep = multiplier / dividers[dividerInd];\r\n\t                var nextGridStepInPixels = nextGridStep / axisLength * axisWidth;\r\n\t                if (nextGridStepInPixels >= minGridStepInPixels) {\r\n\t                    gridStep = nextGridStep;\r\n\t                    gridStepInPixels = nextGridStepInPixels;\r\n\t                }\r\n\t                else {\r\n\t                    gridStepFound = true;\r\n\t                    if (gridStep === 0) {\r\n\t                        gridStep = nextGridStep;\r\n\t                        gridStepInPixels = nextGridStepInPixels;\r\n\t                    }\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (!gridStepFound)\r\n\t                digitPos++;\r\n\t        }\r\n\t        var gridStart = Math.floor(from / gridStep) * gridStep;\r\n\t        var gridEnd = Math.floor(to / gridStep) * gridStep;\r\n\t        return {\r\n\t            start: gridStart,\r\n\t            end: gridEnd,\r\n\t            step: gridStep,\r\n\t            stepInPx: gridStepInPixels,\r\n\t            length: gridEnd - gridStart,\r\n\t            segmentsCount: Math.round((gridEnd - gridStart) / gridStep)\r\n\t        };\r\n\t    };\r\n\t    GridWidget.prototype.getObject3D = function () {\r\n\t        return this.lineSegments;\r\n\t    };\r\n\t    GridWidget.widgetName = 'Grid';\r\n\t    return GridWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.GridWidget = GridWidget;\r\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar Color = (function () {\r\n\t    function Color(color) {\r\n\t        this.set(color);\r\n\t    }\r\n\t    /**!\r\n\t     * @preserve $.parseColor\r\n\t     * Copyright 2011 THEtheChad Elliott\r\n\t     * Released under the MIT and GPL licenses.\r\n\t     */\r\n\t    /**\r\n\t     * Parse hex/rgb{a} color syntax.\r\n\t     * @input string\r\n\t     * @returns array [r,g,b{,o}]\r\n\t     */\r\n\t    Color.parseColor = function (color) {\r\n\t        var cache, p = parseInt // Use p as a byte saving reference to parseInt\r\n\t        , color = color.replace(/\\s\\s*/g, ''); //var\r\n\t        // Checks for 6 digit hex and converts string to integer\r\n\t        if (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\r\n\t        else if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\r\n\t            cache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\r\n\t        else if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\r\n\t        else if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3], +cache[4]];\r\n\t        else if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3]];\r\n\t        else\r\n\t            throw Error(color + ' is not supported by parseColor');\r\n\t        // Performs RGBA conversion by default\r\n\t        isNaN(cache[3]) && (cache[3] = 1);\r\n\t        return cache;\r\n\t        // Adds or removes 4th xVal based on rgba support\r\n\t        // Support is flipped twice to prevent erros if\r\n\t        // it's not defined\r\n\t        //return cache.slice(0,3 + !!$.support.rgba);\r\n\t    };\r\n\t    Color.numberToHexStr = function (value) {\r\n\t        var result = value.toString(16);\r\n\t        return '#' + '0'.repeat(6 - result.length) + result;\r\n\t    };\r\n\t    Color.prototype.set = function (color) {\r\n\t        if (typeof color == 'number')\r\n\t            color = Color.numberToHexStr(color);\r\n\t        var colorStr = color;\r\n\t        var rgba = Color.parseColor(colorStr);\r\n\t        this.r = rgba[0];\r\n\t        this.g = rgba[1];\r\n\t        this.b = rgba[2];\r\n\t        this.a = rgba[3];\r\n\t        this.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\r\n\t        this.hexStr = Color.numberToHexStr(this.value);\r\n\t        this.rgbaStr = \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.a + \")\";\r\n\t    };\r\n\t    Color.prototype.getTransparent = function (opacity) {\r\n\t        return new Color(\"rgba(\" + this.hexStr + \", \" + opacity + \")\");\r\n\t    };\r\n\t    return Color;\r\n\t}());\r\n\texports.Color = Color;\r\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar TrendsWidget_1 = __webpack_require__(27);\r\n\tvar Color_1 = __webpack_require__(25);\r\n\tvar TrendsGradientWidget = (function (_super) {\r\n\t    __extends(TrendsGradientWidget, _super);\r\n\t    function TrendsGradientWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsGradientWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendGradient;\r\n\t    };\r\n\t    TrendsGradientWidget.widgetName = \"TrendsGradient\";\r\n\t    return TrendsGradientWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsGradientWidget = TrendsGradientWidget;\r\n\tvar TrendGradient = (function (_super) {\r\n\t    __extends(TrendGradient, _super);\r\n\t    function TrendGradient(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        this.visibleSegmentsCnt = 0;\r\n\t        this.trend = chartState.trendsManager.getTrend(trendName);\r\n\t        this.segmentsIds = new Uint16Array(chartState.state.maxVisibleSegments);\r\n\t        this.initGradient();\r\n\t        this.updateSegments();\r\n\t    }\r\n\t    TrendGradient.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.hasBackground;\r\n\t    };\r\n\t    TrendGradient.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            // TODO: optimize updateSegments for onDisplayedRangeChanged\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.chart.onZoom(function () {\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t    };\r\n\t    TrendGradient.prototype.getObject3D = function () {\r\n\t        return this.gradient;\r\n\t    };\r\n\t    TrendGradient.prototype.initGradient = function () {\r\n\t        var geometry = new Geometry();\r\n\t        for (var i = 0; i < this.segmentsIds.length; i++) {\r\n\t            geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3());\r\n\t            var ind = i * 4;\r\n\t            // gradient segment scheme\r\n\t            //\r\n\t            // vert0 +---+ vert3\r\n\t            //       |\\  |\r\n\t            // face1 | \\ | face2\r\n\t            // \t     |  \\|\r\n\t            // vert1 +---+ vert2\r\n\t            geometry.faces.push(new THREE.Face3(ind, ind + 1, ind + 2), new THREE.Face3(ind + 3, ind, ind + 2));\r\n\t        }\r\n\t        var color = new Color_1.Color(this.trend.getOptions().backgroundColor);\r\n\t        this.gradient = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: color.value, transparent: true, opacity: color.a }));\r\n\t        var _a = this.chart.state.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = this.chart.state.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.gradient.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.gradient.frustumCulled = false;\r\n\t    };\r\n\t    TrendGradient.prototype.onZoomFrame = function (options) {\r\n\t        var state = this.chart.state;\r\n\t        var scaleXFactor = state.xAxis.range.scaleFactor;\r\n\t        var scaleYFactor = state.yAxis.range.scaleFactor;\r\n\t        var currentScale = this.gradient.scale;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendGradient.prototype.onSegmentsAnimate = function (trendSegmentsManager) {\r\n\t        var animatedSegmentsIds = trendSegmentsManager.animatedSegmentsIds;\r\n\t        for (var i = 0; i < this.visibleSegmentsCnt; i++) {\r\n\t            var segmentId = this.segmentsIds[i];\r\n\t            if (!animatedSegmentsIds.includes(segmentId))\r\n\t                continue;\r\n\t            this.setupSegmentVertices(i, trendSegmentsManager.getSegment(segmentId).currentAnimationState);\r\n\t        }\r\n\t        this.gradient.geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendGradient.prototype.updateSegments = function () {\r\n\t        var geometry = this.gradient.geometry;\r\n\t        var _a = this.trend.segmentsManager, trendSegments = _a.segments, segmentInd = _a.firstDisplayedSegmentInd, lastDisplayedSegmentInd = _a.lastDisplayedSegmentInd;\r\n\t        var prevVisibleSegmentsCnt = this.visibleSegmentsCnt;\r\n\t        this.visibleSegmentsCnt = lastDisplayedSegmentInd - segmentInd + 1;\r\n\t        var segmentsToProcessCnt = Math.max(prevVisibleSegmentsCnt, this.visibleSegmentsCnt);\r\n\t        if (segmentsToProcessCnt > this.segmentsIds.length) {\r\n\t            Utils_1.Utils.error(TrendsGradientWidget.widgetName + ': MAX_SEGMENTS reached');\r\n\t        }\r\n\t        // setup visible segments and collapse invisible\r\n\t        for (var i = 0; i < segmentsToProcessCnt; i++) {\r\n\t            if (segmentInd <= lastDisplayedSegmentInd) {\r\n\t                var segment = trendSegments[segmentInd];\r\n\t                this.setupSegmentVertices(i, segment.currentAnimationState);\r\n\t                this.segmentsIds[i] = segment.id;\r\n\t                segmentInd++;\r\n\t            }\r\n\t            else {\r\n\t                this.setupSegmentVertices(i);\r\n\t            }\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    /**\r\n\t     * setup gradient segment by segmentState\r\n\t     * if segmentState is undefined, then collapse vertices to 0,0,0\r\n\t     */\r\n\t    TrendGradient.prototype.setupSegmentVertices = function (segmentInd, segmentState) {\r\n\t        var gradientSegmentInd = segmentInd * 4;\r\n\t        var vertices = this.gradient.geometry.vertices;\r\n\t        var topLeft = vertices[gradientSegmentInd];\r\n\t        var bottomLeft = vertices[gradientSegmentInd + 1];\r\n\t        var bottomRight = vertices[gradientSegmentInd + 2];\r\n\t        var topRight = vertices[gradientSegmentInd + 3];\r\n\t        var screenHeightVal = Math.max(this.chart.pxToValueByYAxis(this.chart.state.height), this.chart.screen.pxToValueByYAxis(this.chart.state.height));\r\n\t        if (segmentState) {\r\n\t            var startX = this.toLocalX(segmentState.startXVal);\r\n\t            var startY = this.toLocalY(segmentState.startYVal);\r\n\t            var endX = this.toLocalX(segmentState.endXVal);\r\n\t            var endY = this.toLocalY(segmentState.endYVal);\r\n\t            topLeft.set(startX, startY, 0);\r\n\t            topRight.set(endX, endY, 0);\r\n\t            bottomLeft.set(topLeft.x, topLeft.y - screenHeightVal, 0);\r\n\t            bottomRight.set(topRight.x, topRight.y - screenHeightVal, 0);\r\n\t        }\r\n\t        else {\r\n\t            topLeft.set(0, 0, 0);\r\n\t            topRight.set(0, 0, 0);\r\n\t            bottomLeft.set(0, 0, 0);\r\n\t            bottomRight.set(0, 0, 0);\r\n\t        }\r\n\t    };\r\n\t    TrendGradient.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chart.state.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendGradient.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chart.state.yAxis.range.zeroVal;\r\n\t    };\r\n\t    return TrendGradient;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendGradient = TrendGradient;\r\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar Object3D = THREE.Object3D;\r\n\t/**\r\n\t * abstract manager class for all trends widgets\r\n\t */\r\n\tvar TrendsWidget = (function (_super) {\r\n\t    __extends(TrendsWidget, _super);\r\n\t    function TrendsWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.widgets = {};\r\n\t    }\r\n\t    TrendsWidget.prototype.onReadyHandler = function () {\r\n\t        this.object3D = new Object3D();\r\n\t        this.onTrendsChange();\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    TrendsWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chart;\r\n\t        state.onTrendsChange(function () { return _this.onTrendsChange(); });\r\n\t        state.onTrendChange(function (trendName, changedOptions, newData) {\r\n\t            _this.onTrendChange(trendName, changedOptions, newData);\r\n\t        });\r\n\t    };\r\n\t    TrendsWidget.prototype.onTrendsChange = function () {\r\n\t        var trendsOptions = this.chart.state.trends;\r\n\t        var TrendWidgetClass = this.getTrendWidgetClass();\r\n\t        for (var trendName in trendsOptions) {\r\n\t            var trendOptions = trendsOptions[trendName];\r\n\t            var widgetCanBeEnabled = TrendWidgetClass.widgetIsEnabled(trendOptions, this.chart);\r\n\t            if (widgetCanBeEnabled && !this.widgets[trendName]) {\r\n\t                this.createTrendWidget(trendName);\r\n\t            }\r\n\t            else if (!widgetCanBeEnabled && this.widgets[trendName]) {\r\n\t                this.destroyTrendWidget(trendName);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    TrendsWidget.prototype.onTrendChange = function (trendName, changedOptions, newData) {\r\n\t        var widget = this.widgets[trendName];\r\n\t        if (!widget)\r\n\t            return;\r\n\t        widget.onTrendChange(changedOptions);\r\n\t        if (newData) {\r\n\t            var data = this.chart.getTrend(trendName).getData();\r\n\t            var isAppend = (!data.length || data[0].xVal < newData[0].xVal);\r\n\t            isAppend ? widget.appendData(newData) : widget.prependData(newData);\r\n\t        }\r\n\t    };\r\n\t    TrendsWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendsWidget.prototype.createTrendWidget = function (trendName) {\r\n\t        var WidgetConstructor = this.getTrendWidgetClass();\r\n\t        var widget = new WidgetConstructor(this.chart, trendName);\r\n\t        this.widgets[trendName] = widget;\r\n\t        var widgetObject = widget.getObject3D();\r\n\t        widgetObject.name = trendName;\r\n\t        this.object3D.add(widget.getObject3D());\r\n\t    };\r\n\t    TrendsWidget.prototype.destroyTrendWidget = function (trendName) {\r\n\t        this.widgets[trendName].onDestroy();\r\n\t        delete this.widgets[trendName];\r\n\t        var widgetObject = this.object3D.getObjectByName(trendName);\r\n\t        this.object3D.remove(widgetObject);\r\n\t    };\r\n\t    return TrendsWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.TrendsWidget = TrendsWidget;\r\n\t/**\r\n\t * based class for all trends widgets\r\n\t */\r\n\tvar TrendWidget = (function () {\r\n\t    function TrendWidget(chart, trendName) {\r\n\t        this.chart = chart;\r\n\t        this.trendName = trendName;\r\n\t        this.unbindList = [];\r\n\t        this.trend = chart.trendsManager.getTrend(trendName);\r\n\t        this.chart = chart;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendWidget.widgetIsEnabled = function (trendOptions, chart) {\r\n\t        return trendOptions.enabled;\r\n\t    };\r\n\t    TrendWidget.prototype.appendData = function (newData) { };\r\n\t    ;\r\n\t    TrendWidget.prototype.prependData = function (newData) { };\r\n\t    ;\r\n\t    TrendWidget.prototype.onTrendChange = function (changedOptions) { };\r\n\t    TrendWidget.prototype.onDestroy = function () {\r\n\t        for (var _i = 0, _a = this.unbindList; _i < _a.length; _i++) {\r\n\t            var unsubscriber = _a[_i];\r\n\t            unsubscriber();\r\n\t        }\r\n\t    };\r\n\t    TrendWidget.prototype.onSegmentsAnimate = function (segments) {\r\n\t    };\r\n\t    TrendWidget.prototype.onZoomFrame = function (options) {\r\n\t    };\r\n\t    TrendWidget.prototype.onTransformationFrame = function (options) {\r\n\t    };\r\n\t    TrendWidget.prototype.onZoom = function () {\r\n\t    };\r\n\t    TrendWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.bindEvent(this.trend.segmentsManager.onAnimationFrame(function (trendPoints) { return _this.onSegmentsAnimate(trendPoints); }));\r\n\t        this.bindEvent(this.chart.screen.onTransformationFrame(function (options) { return _this.onTransformationFrame(options); }));\r\n\t        this.bindEvent(this.chart.screen.onZoomFrame(function (options) { return _this.onZoomFrame(options); }));\r\n\t        this.bindEvent(this.chart.onZoom(function () { return _this.onZoom(); }));\r\n\t    };\r\n\t    ;\r\n\t    TrendWidget.prototype.bindEvent = function (unbind) {\r\n\t        this.unbindList.push(unbind);\r\n\t    };\r\n\t    return TrendWidget;\r\n\t}());\r\n\texports.TrendWidget = TrendWidget;\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar LineBasicMaterial = THREE.LineBasicMaterial;\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar TrendsWidget_1 = __webpack_require__(27);\r\n\tvar LineSegments = THREE.LineSegments;\r\n\tvar Trend_1 = __webpack_require__(15);\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\t/**\r\n\t * widget for drawing trends lines\r\n\t */\r\n\tvar TrendsLineWidget = (function (_super) {\r\n\t    __extends(TrendsLineWidget, _super);\r\n\t    function TrendsLineWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsLineWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendLine;\r\n\t    };\r\n\t    TrendsLineWidget.widgetName = \"TrendsLine\";\r\n\t    return TrendsLineWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsLineWidget = TrendsLineWidget;\r\n\tvar TrendLine = (function (_super) {\r\n\t    __extends(TrendLine, _super);\r\n\t    function TrendLine(chart, trendName) {\r\n\t        _super.call(this, chart, trendName);\r\n\t        // contains indexes of free segments\r\n\t        this.freeSegmentsInds = [];\r\n\t        // contains segments to display\r\n\t        this.displayedSegments = {};\r\n\t        var options = this.trend.getOptions();\r\n\t        this.material = new LineBasicMaterial({ color: options.lineColor, linewidth: options.lineWidth });\r\n\t        this.initLine();\r\n\t    }\r\n\t    TrendLine.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.type == Trend_1.TREND_TYPE.LINE;\r\n\t    };\r\n\t    TrendLine.prototype.getObject3D = function () {\r\n\t        return this.lineSegments;\r\n\t    };\r\n\t    TrendLine.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.destroySegments();\r\n\t            _this.setupSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            _this.setupSegments();\r\n\t        }));\r\n\t    };\r\n\t    TrendLine.prototype.initLine = function () {\r\n\t        var geometry = new Geometry();\r\n\t        var _a = this.chart.state.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = this.chart.state.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.lineSegments = new LineSegments(geometry, this.material);\r\n\t        this.lineSegments.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.lineSegments.frustumCulled = false;\r\n\t        for (var i = 0; i < this.chart.state.maxVisibleSegments; i++) {\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t            this.freeSegmentsInds.push(i);\r\n\t        }\r\n\t        this.vertices = geometry.vertices;\r\n\t        this.setupSegments();\r\n\t    };\r\n\t    TrendLine.prototype.setupSegments = function () {\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        var _a = this.trend.segmentsManager, firstDisplayedSegment = _a.firstDisplayedSegment, lastDisplayedSegment = _a.lastDisplayedSegment;\r\n\t        for (var segmentId in this.displayedSegments) {\r\n\t            var lineSegment = this.displayedSegments[segmentId];\r\n\t            var segment_1 = this.trend.segmentsManager.segments[lineSegment.segmentId];\r\n\t            var segmentIsNotDisplayed = (segment_1.startXVal < firstDisplayedSegment.startXVal ||\r\n\t                segment_1.endXVal > lastDisplayedSegment.endXVal);\r\n\t            if (segmentIsNotDisplayed)\r\n\t                this.destroySegment(Number(segmentId));\r\n\t        }\r\n\t        var segment = firstDisplayedSegment;\r\n\t        while (segment && segment.xVal <= lastDisplayedSegment.xVal) {\r\n\t            this.setupSegment(segment.id, segment.currentAnimationState);\r\n\t            segment = segment.getNext();\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendLine.prototype.setupSegment = function (segmentId, segmentState) {\r\n\t        var lineSegment = this.displayedSegments[segmentId];\r\n\t        if (!lineSegment) {\r\n\t            if (this.freeSegmentsInds.length == 0)\r\n\t                Utils_1.Utils.error('Max allocated segments reached');\r\n\t            var ind = this.freeSegmentsInds.pop();\r\n\t            lineSegment = this.displayedSegments[segmentId] = { segmentId: segmentId, ind: ind };\r\n\t        }\r\n\t        var segmentInd = lineSegment.ind;\r\n\t        var lineStartVertex = this.vertices[segmentInd * 2];\r\n\t        var lineEndVertex = this.vertices[segmentInd * 2 + 1];\r\n\t        lineStartVertex.set(this.toLocalX(segmentState.startXVal), this.toLocalY(segmentState.startYVal), 0);\r\n\t        lineEndVertex.set(this.toLocalX(segmentState.endXVal), this.toLocalY(segmentState.endYVal), 0);\r\n\t    };\r\n\t    TrendLine.prototype.destroySegments = function () {\r\n\t        for (var segmentId in this.displayedSegments)\r\n\t            this.destroySegment(Number(segmentId));\r\n\t    };\r\n\t    TrendLine.prototype.destroySegment = function (segmentId) {\r\n\t        var lineSegment = this.displayedSegments[segmentId];\r\n\t        var lineStartVertex = this.vertices[lineSegment.ind * 2];\r\n\t        var lineEndVertex = this.vertices[lineSegment.ind * 2 + 1];\r\n\t        lineStartVertex.set(0, 0, 0);\r\n\t        lineEndVertex.set(0, 0, 0);\r\n\t        delete this.displayedSegments[segmentId];\r\n\t        this.freeSegmentsInds.push(lineSegment.ind);\r\n\t    };\r\n\t    TrendLine.prototype.onZoomFrame = function (options) {\r\n\t        var currentScale = this.lineSegments.scale;\r\n\t        var state = this.chart.state;\r\n\t        var scaleXFactor = state.xAxis.range.scaleFactor;\r\n\t        var scaleYFactor = state.yAxis.range.scaleFactor;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendLine.prototype.onSegmentsAnimate = function (trendSegments) {\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        for (var _i = 0, _a = trendSegments.animatedSegmentsIds; _i < _a.length; _i++) {\r\n\t            var segmentId = _a[_i];\r\n\t            if (!this.displayedSegments[segmentId])\r\n\t                continue;\r\n\t            this.setupSegment(segmentId, trendSegments.segmentsById[segmentId].currentAnimationState);\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chart.state.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chart.state.yAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalVec = function (vec) {\r\n\t        return new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\r\n\t    };\r\n\t    return TrendLine;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendLine = TrendLine;\r\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar TrendsWidget_1 = __webpack_require__(27);\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Line = THREE.Line;\r\n\tvar MeshBasicMaterial = THREE.MeshBasicMaterial;\r\n\tvar PlaneGeometry = THREE.PlaneGeometry;\r\n\tvar Trend_1 = __webpack_require__(15);\r\n\tvar LineBasicMaterial = THREE.LineBasicMaterial;\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar RISE_COLOR = 0x2CAC40;\r\n\tvar FALL_COLOR = 0xEE5533;\r\n\tvar MARGIN_PERCENT = 0.3;\r\n\tvar MAX_CANDLES = 100;\r\n\t/**\r\n\t * widget for drawing trends candles\r\n\t */\r\n\tvar TrendsCandlesWidget = (function (_super) {\r\n\t    __extends(TrendsCandlesWidget, _super);\r\n\t    function TrendsCandlesWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsCandlesWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendCandlesWidget;\r\n\t    };\r\n\t    TrendsCandlesWidget.widgetName = \"TrendsCandles\";\r\n\t    return TrendsCandlesWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsCandlesWidget = TrendsCandlesWidget;\r\n\tvar TrendCandlesWidget = (function (_super) {\r\n\t    __extends(TrendCandlesWidget, _super);\r\n\t    function TrendCandlesWidget(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        // contains indexes of free candles\r\n\t        this.freeCandlesInds = [];\r\n\t        this.candlesPool = [];\r\n\t        this.candles = {};\r\n\t        this.initObject();\r\n\t    }\r\n\t    TrendCandlesWidget.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.type == Trend_1.TREND_TYPE.CANDLE;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.destroyCandles();\r\n\t            _this.setupCandles();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            _this.setupCandles();\r\n\t        }));\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.initObject = function () {\r\n\t        var stateData = this.chart.state;\r\n\t        var _a = stateData.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = stateData.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.scaleXFactor = scaleXFactor;\r\n\t        this.scaleYFactor = scaleYFactor;\r\n\t        this.object3D = new Object3D();\r\n\t        this.object3D.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.object3D.frustumCulled = false;\r\n\t        for (var i = 0; i < MAX_CANDLES; i++)\r\n\t            this.freeCandlesInds.push(i);\r\n\t        this.setupCandles();\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.setupCandles = function () {\r\n\t        // remove invisible\r\n\t        var _a = this.trend.segmentsManager, firstDisplayedSegment = _a.firstDisplayedSegment, lastDisplayedSegment = _a.lastDisplayedSegment;\r\n\t        for (var segmentId in this.candles) {\r\n\t            var segment_1 = this.candles[segmentId].segment;\r\n\t            var segmentIsNotDisplayed = (segment_1.startXVal < firstDisplayedSegment.startXVal ||\r\n\t                segment_1.endXVal > lastDisplayedSegment.endXVal);\r\n\t            if (segmentIsNotDisplayed)\r\n\t                this.destroyCandle(Number(segmentId));\r\n\t        }\r\n\t        var segment = firstDisplayedSegment;\r\n\t        while (segment && segment.xVal <= lastDisplayedSegment.xVal) {\r\n\t            this.setupCandle(segment.id, segment.currentAnimationState);\r\n\t            segment = segment.getNext();\r\n\t        }\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.destroyCandles = function () {\r\n\t        for (var segmentId in this.candles)\r\n\t            this.destroyCandle(Number(segmentId));\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.destroyCandle = function (segmentId) {\r\n\t        var candle = this.candles[segmentId];\r\n\t        this.object3D.remove(candle.getObject3D());\r\n\t        delete this.candles[segmentId];\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.onZoomFrame = function (options) {\r\n\t        var currentScale = this.object3D.scale;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(this.scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(this.scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.onSegmentsAnimate = function (trendSegments) {\r\n\t        for (var _i = 0, _a = trendSegments.animatedSegmentsIds; _i < _a.length; _i++) {\r\n\t            var segmentId = _a[_i];\r\n\t            if (!this.candles[segmentId])\r\n\t                continue;\r\n\t            var segmentState = trendSegments.segmentsById[segmentId].currentAnimationState;\r\n\t            this.setupCandle(segmentId, segmentState);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * create or modify candle\r\n\t     */\r\n\t    TrendCandlesWidget.prototype.setupCandle = function (candleId, segmentState) {\r\n\t        var candleInd = candleId % MAX_CANDLES;\r\n\t        // get candle from candlesPool to avoid creating new Objects by performance reasons\r\n\t        var candle = this.candlesPool[candleInd];\r\n\t        if (!candle) {\r\n\t            candle = this.candlesPool[candleInd] = new CandleWidget();\r\n\t        }\r\n\t        if (!this.candles[candleId]) {\r\n\t            this.candles[candleId] = candle;\r\n\t            this.object3D.add(candle.getObject3D());\r\n\t        }\r\n\t        candle.getObject3D().position.set(this.toLocalX(segmentState.xVal), this.toLocalY(segmentState.yVal), 0);\r\n\t        candle.setSegment(segmentState);\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chart.state.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chart.state.yAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalVec = function (vec) {\r\n\t        return new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\r\n\t    };\r\n\t    return TrendCandlesWidget;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendCandlesWidget = TrendCandlesWidget;\r\n\tvar CandleWidget = (function () {\r\n\t    function CandleWidget() {\r\n\t        this.initObject();\r\n\t    }\r\n\t    CandleWidget.prototype.getObject3D = function () {\r\n\t        return this.rect;\r\n\t    };\r\n\t    CandleWidget.prototype.setSegment = function (segment) {\r\n\t        this.segment = segment;\r\n\t        var color = segment.endYVal < segment.startYVal ? FALL_COLOR : RISE_COLOR;\r\n\t        // update rect\r\n\t        var geometry = this.rect.geometry;\r\n\t        var material = this.rect.material;\r\n\t        var width = segment.endXVal - segment.startXVal;\r\n\t        width -= width * MARGIN_PERCENT;\r\n\t        var height = Math.max(segment.startYVal, segment.endYVal) - Math.min(segment.startYVal, segment.endYVal);\r\n\t        var _a = geometry.vertices, leftTop = _a[0], rightTop = _a[1], leftBottom = _a[2], rightBottom = _a[3];\r\n\t        leftTop.set(-width / 2, height / 2, 0);\r\n\t        rightTop.set(width / 2, height / 2, 0);\r\n\t        leftBottom.set(-width / 2, -height / 2, 0);\r\n\t        rightBottom.set(width / 2, -height / 2, 0);\r\n\t        // prevent to draw bars with height < 1px\r\n\t        if (Utils_1.Utils.getDistance(leftTop.y, leftBottom.y) < 1) {\r\n\t            leftBottom.setY(leftBottom.y + 1);\r\n\t            rightBottom.setY(rightBottom.y + 1);\r\n\t        }\r\n\t        material.color.set(color);\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t        // update lines\r\n\t        var vLineGeometry = this.vLine.geometry;\r\n\t        var vLineMaterial = this.vLine.material;\r\n\t        var lineTop = segment.maxYVal - segment.yVal;\r\n\t        var lineBottom = segment.minYVal - segment.yVal;\r\n\t        vLineGeometry.vertices[0].set(0, lineTop, 0);\r\n\t        vLineGeometry.vertices[1].set(0, lineBottom, 0);\r\n\t        vLineMaterial.color.set(color);\r\n\t        vLineGeometry.verticesNeedUpdate = true;\r\n\t        var hLineGeometry = this.hLine.geometry;\r\n\t        var hLineMaterial = this.hLine.material;\r\n\t        var lineLeft = (-width) / 2;\r\n\t        var lineRight = width / 2;\r\n\t        hLineGeometry.vertices[0].set(lineLeft, 0, 0);\r\n\t        hLineGeometry.vertices[1].set(lineRight, 0, 0);\r\n\t        hLineMaterial.color.set(color);\r\n\t        hLineGeometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    CandleWidget.prototype.initObject = function () {\r\n\t        this.rect = new Mesh(new PlaneGeometry(1, 1), new MeshBasicMaterial());\r\n\t        var vLineGeometry = new Geometry();\r\n\t        var hLineGeometry = new Geometry();\r\n\t        vLineGeometry.vertices.push(new Vector3(), new Vector3);\r\n\t        hLineGeometry.vertices.push(new Vector3(), new Vector3);\r\n\t        this.vLine = new Line(vLineGeometry, new LineBasicMaterial({ linewidth: 1 }));\r\n\t        this.hLine = new Line(hLineGeometry, new LineBasicMaterial({ linewidth: 1 }));\r\n\t        this.rect.add(this.vLine);\r\n\t        this.rect.add(this.hLine);\r\n\t    };\r\n\t    return CandleWidget;\r\n\t}());\r\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Utils_1 = __webpack_require__(11);\r\n\tvar EventEmmiter_1 = __webpack_require__(12);\r\n\tvar UniqCollectionItem = (function () {\r\n\t    function UniqCollectionItem() {\r\n\t    }\r\n\t    UniqCollectionItem.prototype.getId = function () {\r\n\t        return this._id;\r\n\t    };\r\n\t    return UniqCollectionItem;\r\n\t}());\r\n\texports.UniqCollectionItem = UniqCollectionItem;\r\n\tvar ID_KEY = '_id';\r\n\tvar EVENTS = {\r\n\t    CREATE: 'create',\r\n\t    UPDATE: 'update',\r\n\t    REMOVE: 'remove'\r\n\t};\r\n\t/**\r\n\t * useful for patching collections with id key\r\n\t */\r\n\tvar UniqCollection = (function () {\r\n\t    function UniqCollection(options) {\r\n\t        this.items = [];\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.options = options;\r\n\t    }\r\n\t    UniqCollection.prototype.patch = function (models) {\r\n\t        var options = this.options;\r\n\t        for (var _i = 0, models_1 = models; _i < models_1.length; _i++) {\r\n\t            var model = models_1[_i];\r\n\t            var id = model[ID_KEY];\r\n\t            if (!id)\r\n\t                Utils_1.Utils.error('Collection item without id detected');\r\n\t            var ind = this.getItemInd(id);\r\n\t            var item = this.items[ind];\r\n\t            var justCreated = false;\r\n\t            // create\r\n\t            if (!item) {\r\n\t                justCreated = true;\r\n\t                item = options.createInstance(model);\r\n\t                this.items.push(item);\r\n\t            }\r\n\t            // update\r\n\t            if (Object.keys(model).length > 1) {\r\n\t                var prevProps = {};\r\n\t                Utils_1.Utils.copyProps(item, prevProps, model);\r\n\t                Utils_1.Utils.patch(item, model);\r\n\t                justCreated && this.ee.emit(EVENTS.CREATE, item);\r\n\t                this.ee.emit(EVENTS.UPDATE, item, model, prevProps);\r\n\t            }\r\n\t            else {\r\n\t                this.items.splice(ind, 1);\r\n\t                this.ee.emit(EVENTS.REMOVE, item);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    UniqCollection.prototype.getItem = function (id) {\r\n\t        return this.items[this.getItemInd(id)];\r\n\t    };\r\n\t    UniqCollection.prototype.getLast = function () {\r\n\t        return this.items[this.items.length - 1];\r\n\t    };\r\n\t    UniqCollection.prototype.forEach = function (cb) {\r\n\t        for (var key in this.items)\r\n\t            cb(this.items[key]);\r\n\t    };\r\n\t    UniqCollection.prototype.filter = function (cb) {\r\n\t        var result = [];\r\n\t        this.forEach(function (item) { return cb(item) && result.push(item); });\r\n\t        return result;\r\n\t    };\r\n\t    UniqCollection.prototype.onCreate = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.CREATE, cb);\r\n\t    };\r\n\t    UniqCollection.prototype.onUpdate = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.UPDATE, cb);\r\n\t    };\r\n\t    UniqCollection.prototype.onRemove = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.REMOVE, cb);\r\n\t    };\r\n\t    UniqCollection.prototype.getItemInd = function (id) {\r\n\t        return Utils_1.Utils.binarySearchInd(this.items, id, ID_KEY);\r\n\t    };\r\n\t    return UniqCollection;\r\n\t}());\r\n\texports.UniqCollection = UniqCollection;\r\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(23));\r\n\t__export(__webpack_require__(24));\r\n\t__export(__webpack_require__(27));\r\n\t__export(__webpack_require__(28));\r\n\t__export(__webpack_require__(26));\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ThreeChart.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4ca07fd65cd4b0cc2ace\n **/","export * from './src/index';\n\n\n/** WEBPACK FOOTER **\n ** ./index.ts\n **/","require('./deps/deps');\nexport * from './ChartView';\nexport * from './interfaces';\nexport * from './Screen';\nexport * from './Chart';\nexport * from './Trend';\nexport * from './TrendSegmentsManager';\nexport * from './TrendsManager';\nexport * from './Utils';\nexport * from './UniqCollection'\nexport * from './Widget';\nexport * from './widgets';\nexport * from './Plugin';\nexport * from './Color';\nexport * from './AnimationManager';\nexport * from './EventEmmiter';\nexport * from './Easing';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.ts\n **/","/// <reference path=\"./ResizeSensor.ts\" />\n\n// TODO: think about different bundles\n\nimport { ResizeSensorType } from './ResizeSensor';\n(<any>window).TweenLite = TweenMax;\n(<any>window).Stats = require('three/examples/js/libs/stats.min');\n\n// require('gsap/src/uncompressed/easing/EasePack.js');\n// require('three/examples/js/renderers/CanvasRenderer.js');\n// require('three/examples/js/renderers/Projector.js');\nexport const isPlainObject = require('is-plain-object') as Function;\nexport const EE2 = require('eventemitter2') as typeof EventEmitter2;\n\n\nexport { Promise } from '../polyfills/es6-promise';\n\nexport * from './ResizeSensor';\nexport const ResizeSensor = require('css-element-queries/src/ResizeSensor') as ResizeSensorType;\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/deps/deps.ts\n **/","// stats.js - http://github.com/mrdoob/stats.js\nvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\nif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\nStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\nv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/examples/js/libs/stats.min.js\n ** module id = 3\n ** module chunks = 0\n **/","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n  \n  if (isObjectObject(o) === false) return false;\n  \n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n  \n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n  \n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n  \n  // Most likely a plain Object\n  return true;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-plain-object/index.js\n ** module id = 4\n ** module chunks = 0\n **/","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object'\n    && !Array.isArray(val);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isobject/index.js\n ** module id = 5\n ** module chunks = 0\n **/","/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || !!this._all;\n    }\n    else {\n      return !!this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  }\n  else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventemitter2/lib/eventemitter2.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = {Promise: window['Promise']}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/polyfills/es6-promise.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n;\n(function() {\n\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n    var ResizeSensor = function(element, callback) {\n        /**\n         *\n         * @constructor\n         */\n        function EventQueue() {\n            this.q = [];\n            this.add = function(ev) {\n                this.q.push(ev);\n            };\n\n            var i, j;\n            this.call = function() {\n                for (i = 0, j = this.q.length; i < j; i++) {\n                    this.q[i].call();\n                }\n            };\n        }\n\n        /**\n         * @param {HTMLElement} element\n         * @param {String}      prop\n         * @returns {String|Number}\n         */\n        function getComputedStyle(element, prop) {\n            if (element.currentStyle) {\n                return element.currentStyle[prop];\n            } else if (window.getComputedStyle) {\n                return window.getComputedStyle(element, null).getPropertyValue(prop);\n            } else {\n                return element.style[prop];\n            }\n        }\n\n        /**\n         *\n         * @param {HTMLElement} element\n         * @param {Function}    resized\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element.resizedAttached) {\n                element.resizedAttached = new EventQueue();\n                element.resizedAttached.add(resized);\n            } else if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.className = 'resize-sensor';\n            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n            element.resizeSensor.style.cssText = style;\n            element.resizeSensor.innerHTML =\n                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + '\"></div>' +\n                '</div>' +\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n                '</div>';\n            element.appendChild(element.resizeSensor);\n\n            if (!{fixed: 1, absolute: 1}[getComputedStyle(element, 'position')]) {\n                element.style.position = 'relative';\n            }\n\n            var expand = element.resizeSensor.childNodes[0];\n            var expandChild = expand.childNodes[0];\n            var shrink = element.resizeSensor.childNodes[1];\n            var shrinkChild = shrink.childNodes[0];\n\n            var lastWidth, lastHeight;\n\n            var reset = function() {\n                expandChild.style.width = expand.offsetWidth + 10 + 'px';\n                expandChild.style.height = expand.offsetHeight + 10 + 'px';\n                expand.scrollLeft = expand.scrollWidth;\n                expand.scrollTop = expand.scrollHeight;\n                shrink.scrollLeft = shrink.scrollWidth;\n                shrink.scrollTop = shrink.scrollHeight;\n                lastWidth = element.offsetWidth;\n                lastHeight = element.offsetHeight;\n            };\n\n            reset();\n\n            var changed = function() {\n                if (element.resizedAttached) {\n                    element.resizedAttached.call();\n                }\n            };\n\n            var addEvent = function(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent('on' + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            var onScroll = function() {\n              if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {\n                  changed();\n              }\n              reset();\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n        }\n\n        var elementType = Object.prototype.toString.call(element);\n        var isCollectionTyped = ('[object Array]' === elementType\n            || ('[object NodeList]' === elementType)\n            || ('[object HTMLCollection]' === elementType)\n            || ('undefined' !== typeof jQuery && element instanceof jQuery) //jquery\n            || ('undefined' !== typeof Elements && element instanceof Elements) //mootools\n        );\n\n        if (isCollectionTyped) {\n            var i = 0, j = element.length;\n            for (; i < j; i++) {\n                attachResizeEvent(element[i], callback);\n            }\n        } else {\n            attachResizeEvent(element, callback);\n        }\n\n        this.detach = function() {\n            if (isCollectionTyped) {\n                var i = 0, j = element.length;\n                for (; i < j; i++) {\n                    ResizeSensor.detach(element[i]);\n                }\n            } else {\n                ResizeSensor.detach(element);\n            }\n        };\n    };\n\n    ResizeSensor.detach = function(element) {\n        if (element.resizeSensor) {\n            element.removeChild(element.resizeSensor);\n            delete element.resizeSensor;\n            delete element.resizedAttached;\n        }\n    };\n\n    // make available to common module loader\n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n        module.exports = ResizeSensor;\n    }\n    else {\n        window.ResizeSensor = ResizeSensor;\n    }\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-element-queries/src/ResizeSensor.js\n ** module id = 8\n ** module chunks = 0\n **/","\nimport { ChartPlugin } from './Plugin';\nimport { Trend } from \"./Trend\";\nimport Vector3 = THREE.Vector3;\nimport PerspectiveCamera = THREE.PerspectiveCamera;\nimport Scene = THREE.Scene;\nimport Renderer = THREE.Renderer;\nimport WebGLRenderer = THREE.WebGLRenderer;\nimport Object3D = THREE.Object3D;\nimport { Chart, IChartState } from \"./Chart\";\nimport { ChartWidget, IChartWidgetConstructor } from \"./Widget\";\nimport { Utils } from \"./Utils\";\nimport { IScreenTransformOptions } from \"./Screen\";\nimport { AxisWidget } from \"./widgets/AxisWidget\";\nimport { GridWidget } from \"./widgets/GridWidget\";\nimport { TrendsGradientWidget } from \"./widgets/TrendsGradientWidget\";\nimport { TrendsLineWidget } from \"./widgets/TrendsLineWidget\";\nimport { TrendsCandlesWidget } from './widgets/TrendsCandleWidget';\nimport { ResizeSensor, ResizeSensorType } from './deps';\nimport OrthographicCamera = THREE.OrthographicCamera;\nimport {Color} from \"./Color\";\n\n\nexport class ChartBlankView {\n\n\tstatic devicePixelRatio = window.devicePixelRatio;\n\tstatic preinstalledWidgets: typeof ChartWidget[] = [];\n\tstatic renderers: {[rendererName: string]: any} = {\n\t\tCanvasRenderer: (THREE as any).CanvasRenderer,\n\t\tWebGLRenderer: THREE.WebGLRenderer\n\t};\n\n\tchart: Chart;\n\tisStopped: boolean;\n\tisDestroyed: boolean;\n\tprivate $container: Element;\n\tprivate $el: HTMLElement;\n\tprivate renderer: Renderer;\n\tprivate scene: Scene;\n\tprivate camera: PerspectiveCamera;\n\tprivate cameraInitialPosition: Vector3;\n\tprivate widgets: Array<ChartWidget> = [];\n\tprivate stats: Stats;\n\tprivate zoomThrottled: Function;\n\tprivate unsubscribers: Function[];\n\tprivate resizeSensor: ResizeSensorType;\n\tprivate pluginsAndWidgets: Array<ChartPlugin<any> | ChartWidget>;\n\n\tconstructor(state: IChartState, $container: Element, pluginsAndWidgets: Array<ChartPlugin<any> | ChartWidget> = []) {\n\n\t\tif (!THREE || !THREE.REVISION) Utils.error('three.js not found');\n\n\t\tif (!$container) {\n\t\t\tUtils.error('$el must be set');\n\t\t}\n\t\t// calculate state size\n\t\tlet style = getComputedStyle($container);\n\t\tstate.width = parseInt(style.width);\n\t\tstate.height = parseInt(style.height);\n\n\t\tlet plugins = pluginsAndWidgets.filter(pluginOrWidget => pluginOrWidget instanceof ChartPlugin) as ChartPlugin<any>[];\n\n\t\tthis.chart = new Chart(state, plugins);\n\t\tthis.pluginsAndWidgets = pluginsAndWidgets;\n\t\tthis.zoomThrottled = Utils.throttle((zoomValue: number, origin: number) => this.zoom(zoomValue, origin), 200);\n\t\tthis.$container = $container;\n\t\tthis.init($container);\n\t};\n\n\tprivate init($container: Element) {\n\t\tvar chart = this.chart;\n\t\tvar {width: w, height: h, showStats, autoRender} = chart.state;\n\t\tthis.scene = new THREE.Scene();\n\t\tthis.isStopped = !autoRender.enabled;\n\n\t\tvar renderer = this.renderer = new (ChartView.renderers[this.chart.state.renderer] as any)({\n\t\t\tantialias: true,\n\t\t\talpha: true\n\t\t});\n\t\tlet backgroundColor = new Color(chart.state.backgroundColor);\n\t\trenderer.setSize(w, h);\n\t\trenderer.setPixelRatio(ChartView.devicePixelRatio);\n\t\trenderer.setClearColor(backgroundColor.value, backgroundColor.a);\n\t\t$container.appendChild(renderer.domElement);\n\t\tthis.$el = renderer.domElement;\n\t\tthis.$el.style.display = 'block';\n\n\t\tif (showStats) {\n\t\t\tthis.stats = new Stats();\n\t\t\t$container.appendChild(this.stats.domElement);\n\t\t}\n\n\t\tthis.setupCamera();\n\t\tthis.initWidgets();\n\t\tthis.bindEvents();\n\t\tthis.renderLoop();\n\t}\n\n\t/**\n\t * collect and init widgets from preinstalled widgets, plugins widgets and custom widgets\n\t */\n\tprivate initWidgets() {\n\t\tlet preinstalledWidgetsClasses = (this.constructor as typeof ChartView).preinstalledWidgets.slice();\n\t\tlet customWidgets: ChartWidget[] = [];\n\n\t\tthis.pluginsAndWidgets.forEach(pluginOrWidget => {\n\t\t\tif (pluginOrWidget instanceof ChartWidget) {\n\t\t\t\tcustomWidgets.push(pluginOrWidget);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(pluginOrWidget instanceof ChartPlugin)) return;\n\t\t\tlet pluginWidgetClasses = (pluginOrWidget.constructor as typeof ChartPlugin).providedWidgets;\n\t\t\tpreinstalledWidgetsClasses.push(...pluginWidgetClasses);\n\t\t});\n\n\t\tthis.widgets = customWidgets.concat(\n\t\t\tpreinstalledWidgetsClasses.map((WidgetClass: IChartWidgetConstructor) => new WidgetClass())\n\t\t);\n\n\t\tthis.widgets.forEach(widget => {\n\t\t\twidget.setupChart(this.chart);\n\t\t\twidget.onReadyHandler();\n\t\t\tthis.scene.add(widget.getObject3D());\n\t\t});\n\t}\n\n\tprivate renderLoop() {\n\t\tif (this.isDestroyed) return;\n\t\tthis.stats && this.stats.begin();\n\t\tthis.render();\n\t\tif (this.isStopped) return;\n\t\tvar fpsLimit = this.chart.state.autoRender.fps;\n\n\t\tif (fpsLimit) {\n\t\t\tlet delay = 1000 / fpsLimit;\n\t\t\tsetTimeout(() => requestAnimationFrame(() => this.renderLoop()), delay);\n\t\t} else {\n\t\t\trequestAnimationFrame(() => this.renderLoop());\n\t\t}\n\t\tthis.stats && this.stats.end();\n\t}\n\n\trender() {\n\t\tthis.chart.render();\n\t\tthis.renderer.render(this.scene, this.camera);\n\t}\n\n\tstop() {\n\t\tthis.isStopped = true;\n\t}\n\n\trun() {\n\t\tthis.isStopped = false;\n\t\tthis.renderLoop();\n\t}\n\n\t/**\n\t * call to destroy state an init garbage collection\n\t */\n\tdestroy() {\n\t\tthis.isDestroyed = true;\n\t\tthis.stop();\n\t\tthis.chart.destroy();\n\t\tthis.unbindEvents();\n\t\t// WARNING! undocumented method for free webgl context\n\t\ttry {\n\t\t\t(this.renderer as any).forceContextLoss();\n\t\t} catch (wtf) {\n\t\t\t// sometimes with many state instances forceContextLoss not working\n\t\t}\n\t\t(this.renderer as any).context = null;\n\t\tthis.renderer.domElement = null;\n\t\tthis.renderer = null;\n\t}\n\n\tgetState(): IChartState {\n\t\treturn this.chart.state\n\t}\n\n\t/**\n\t * shortcut for ChartView.state.getTrend\n\t */\n\tgetTrend(trendName: string): Trend {\n\t\treturn this.chart.getTrend(trendName);\n\t}\n\n\t/**\n\t * shortcut for ChartView.state.setState\n\t */\n\tsetState(state: IChartState) {\n\t\treturn this.chart.setState(state);\n\t}\n\n\n\tprivate bindEvents() {\n\t\tvar $el = this.$el;\n\t\tif (this.chart.state.controls.enabled) {\n\t\t\t$el.addEventListener('mousewheel', (ev: MouseWheelEvent) => {\n\t\t\t\tthis.onMouseWheel(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('mousemove', (ev: MouseEvent) => {\n\t\t\t\tthis.onMouseMove(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('mousedown', (ev: MouseEvent) => this.onMouseDown(ev));\n\t\t\t$el.addEventListener('mouseup', (ev: MouseEvent) => this.onMouseUp(ev));\n\t\t\t$el.addEventListener('touchmove', (ev: TouchEvent) => {\n\t\t\t\tthis.onTouchMove(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('touchend', (ev: TouchEvent) => {\n\t\t\t\tthis.onTouchEnd(ev)\n\t\t\t});\n\t\t}\n\t\tif (this.chart.state.autoResize) {\n\t\t\tthis.resizeSensor = new ResizeSensor(this.$container, () => {\n\t\t\t\tthis.onChartContainerResizeHandler(this.$container.clientWidth, this.$container.clientHeight);\n\t\t\t});\n\t\t}\n\n\t\tthis.unsubscribers = [\n\t\t\tthis.chart.screen.onTransformationFrame((options) => this.onScreenTransformHandler(options)),\n\t\t\tthis.chart.onResize((options) => this.onChartResize())\n\t\t];\n\t}\n\n\tprivate unbindEvents() {\n\t\t// TODO: unbind events correctly\n\t\ttry {\n\t\t\tthis.resizeSensor && this.resizeSensor.detach();\n\t\t} catch (e) {\n\t\t\t// ups.. somebody already removed resizeSensor childNode\n\t\t\t// detected in angular2 apps\n\t\t}\n\t\tthis.$el.remove();\n\t\tthis.unsubscribers.forEach(unsubscribe => unsubscribe());\n\t}\n\n\tprivate setupCamera() {\n\t\tlet camSettings = this.chart.screen.getCameraSettings();\n\t\tif (!this.camera) {\n\t\t\tthis.camera = new PerspectiveCamera(camSettings.FOV, camSettings.aspect, camSettings.near, camSettings.far);\n\t\t\tthis.scene.add(this.camera);\n\t\t} else {\n\t\t\tthis.camera.fov = camSettings.FOV;\n\t\t\tthis.camera.aspect = camSettings.aspect;\n\t\t\tthis.camera.far = camSettings.far;\n\t\t\tthis.camera.near = camSettings.near;\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t}\n\t\tthis.camera.position.set(camSettings.x, camSettings.y, camSettings.z);\n\t\tthis.cameraInitialPosition = this.camera.position.clone();\n\t\tthis.onScreenTransformHandler(this.chart.screen.options);\n\t}\n\n\tprivate onScreenTransformHandler(options: IScreenTransformOptions) {\n\t\tif (options.scrollX != void 0) {\n\t\t\tlet scrollX = this.cameraInitialPosition.x + options.scrollX;\n\t\t\tthis.camera.position.setX(scrollX);\n\t\t}\n\t\tif (options.scrollY != void 0) {\n\t\t\tlet scrollY = this.cameraInitialPosition.y + options.scrollY;\n\t\t\tthis.camera.position.setY(scrollY);\n\t\t}\n\t}\n\n\tprivate onMouseDown(ev: MouseEvent) {\n\t\tthis.setState({cursor: {dragMode: true, x: ev.clientX, y: ev.clientY}});\n\t}\n\n\tprivate onMouseUp(ev: MouseEvent) {\n\t\tthis.setState({cursor: {dragMode: false}});\n\t}\n\n\tprivate onMouseMove(ev: MouseEvent) {\n\t\tif (this.chart.state.cursor.dragMode) {\n\t\t\tthis.setState({cursor: {dragMode: true, x: ev.clientX, y: ev.clientY}});\n\t\t}\n\t}\n\n\tprivate onMouseWheel(ev: MouseWheelEvent) {\n\t\tev.stopPropagation();\n\t\tev.preventDefault();\n\t\tlet zoomOrigin = ev.layerX / this.chart.state.width;\n\t\tlet zoomValue = 1 + ev.wheelDeltaY * 0.001;\n\t\tthis.zoom(zoomValue, zoomOrigin);\n\t}\n\n\tprivate onTouchMove(ev: TouchEvent) {\n\t\tthis.setState({cursor: {dragMode: true, x: ev.touches[0].clientX, y: ev.touches[0].clientY}});\n\t}\n\n\tprivate onTouchEnd(ev: TouchEvent) {\n\t\tthis.setState({cursor: {dragMode: false}});\n\t}\n\n\tprivate onChartContainerResizeHandler(width: number, height: number) {\n\t\tthis.setState({width, height});\n\t}\n\n\tprivate onChartResize() {\n\t\tlet {width, height} = this.chart.state;\n\t\tthis.renderer.setSize(width, height);\n\t\tthis.setupCamera();\n\t}\n\n\tprivate zoom(zoomValue: number, zoomOrigin: number) {\n\t\tconst MAX_ZOOM_VALUE = 1.5;\n\t\tconst MIN_ZOOM_VALUE = 0.7;\n\t\tzoomValue = Math.min(zoomValue, MAX_ZOOM_VALUE);\n\t\tzoomValue = Math.max(zoomValue, MIN_ZOOM_VALUE);\n\t\tthis.chart.zoom(zoomValue, zoomOrigin);\n\t}\n\n\n}\n\n\nexport class ChartView extends ChartBlankView {\n\tstatic preinstalledWidgets: typeof ChartWidget[] = [\n\t\tTrendsLineWidget,\n\t\tTrendsCandlesWidget,\n\t\tAxisWidget,\n\t\tGridWidget,\n\t\tTrendsGradientWidget\n\t]\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ChartView.ts\n **/","import { Chart, IChartState } from \"./Chart\";\nimport { Utils } from './Utils';\nimport { EventEmitter } from './EventEmmiter';\nimport { ChartWidget } from './Widget';\n\nexport interface IChartPluginState {\n}\n\nexport interface IChartPluginConfig {\n\tinstallPluginWidgets?: boolean;\n}\n\nexport const DEFAULT_CONFIG: IChartPluginConfig = {\n\tinstallPluginWidgets: true\n};\n\n/**\n * base class for all plugins\n * NAME is mandatory\n */\nexport abstract class ChartPlugin<TPluginState> {\n\tstatic NAME: string = '';\n\tstatic providedWidgets: typeof ChartWidget[] = [];\n\n\tinitialState: IChartPluginState;\n\tconfig: IChartPluginConfig;\n\tname: string;\n\tprotected chart: Chart;\n\tprotected unsubscribers: Function[] = [];\n\tprotected ee: EventEmitter;\n\n\tconstructor (options?: TPluginState, config: IChartPluginConfig = {}) {\n\t\tthis.initialState = options;\n\t\tthis.config = Utils.deepMerge(DEFAULT_CONFIG, config);\n\t\tthis.name = (this.constructor as typeof ChartPlugin).NAME;\n\t\tif (!this.name) Utils.error('Unnamed plugin detected');\n\t}\n\n\tsetupChart(chart: Chart) {\n\t\tthis.chart = chart;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.bindEvent(\n\t\t\tthis.chart.onInitialStateApplied(initialState => this.onInitialStateAppliedHandler(initialState)),\n\t\t\tthis.chart.onReady(() => this.onReadyHandler()),\n\t\t\tthis.chart.onDestroy(() => this.onDestroyHandler()),\n\t\t\tthis.chart.onPluginsStateChange(changedPluginsStates => changedPluginsStates[this.name] && this.onStateChangedHandler(changedPluginsStates[this.name] as any as TPluginState))\n\t\t)\n\t}\n\n\tgetOptions(): TPluginState {\n\t\treturn this.chart.state.pluginsState[this.name];\n\t}\n\n\tprotected onInitialStateAppliedHandler(initialState: IChartState) {\n\t}\n\n\tprotected onReadyHandler() {\n\t}\n\n\tprotected onStateChangedHandler(changedState: TPluginState) {\n\t}\n\n\tprotected onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t}\n\n\tprotected bindEvent(...args: Array<Function | Function[]>): void {\n\t\tlet unsubscribers: Function[] = [];\n\t\tif (!Array.isArray(args[0])) {\n\t\t\tunsubscribers.push(args[0] as Function);\n\t\t} else {\n\t\t\tunsubscribers.push(...args as Function[]);\n\t\t}\n\t\tthis.unsubscribers.push(...unsubscribers);\n\t}\n\n\n\tprotected unbindEvents() {\n\t\tthis.unsubscribers.forEach(unsubscriber => unsubscriber());\n\t\tthis.unsubscribers.length = 0;\n\t}\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Plugin.ts\n **/","import Texture = THREE.Texture;\nimport Color = THREE.Color;\nimport { TIteralable, IIteralable } from \"./interfaces\";\nimport { isPlainObject } from './deps/deps';\n\nfunction deepmerge(target: any, src: any, mergeArrays = true) {\n\tvar array = Array.isArray(src);\n\tvar dst: any = array && [] || {};\n\n\tif (array) {\n\t\ttarget = target || [];\n\t\tif (mergeArrays) {\n\t\t\tdst = dst.concat(target);\n\t\t}\n\t\tsrc.forEach(function(e: any, i: any) {\n\t\t\tif (typeof dst[i] === 'undefined') {\n\t\t\t\tdst[i] = e;\n\t\t\t} else if (typeof e === 'object') {\n\t\t\t\tdst[i] = deepmerge(target[i], e, mergeArrays);\n\t\t\t} else {\n\t\t\t\tif (target.indexOf(e) === -1) {\n\t\t\t\t\tdst.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} else {\n\t\tif (target && typeof target === 'object') {\n\t\t\tObject.keys(target).forEach(function (key) {\n\t\t\t\tdst[key] = target[key];\n\t\t\t})\n\t\t}\n\t\tObject.keys(src).forEach(function (key) {\n\t\t\tif (typeof src[key] !== 'object' || !src[key]) {\n\t\t\t\tdst[key] = src[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t} else {\n\t\t\t\t\tdst[key] = deepmerge(target[key], src[key], mergeArrays);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn dst;\n}\n\n\n\nexport declare type TUid = number;\n\n/**\n * project utils static class\n */\nexport class Utils {\n\n\tprivate static currentId: TUid = 1;\n\n\t/**\n\t * deepMerge based on https://www.npmjs.com/package/deepmerge\n\t */\n\tstatic deepMerge<T> (obj1: T, obj2: T, mergeArrays?: boolean) {\n\t\treturn deepmerge(obj1, obj2, mergeArrays) as T;\n\t}\n\n\t/**\n\t * deepCopy based on JSON.stringify function\n\t * @deprecated\n\t */\n\tstatic deepCopy<T> (obj: T) {\n\t\t// TODO: use deepMerge function to copy\n\t\treturn JSON.parse(JSON.stringify(obj)) as T;\n\t}\n\n\tstatic patch<T extends IIteralable>(objectToPatch: T, patch: T) {\n\t\tlet idKey = '_id';\n\t\tfor (let key in patch) {\n\n\t\t\tif (!patch.hasOwnProperty(key)) continue;\n\n\t\t\tif (objectToPatch[key]) {\n\n\t\t\t\tif (Array.isArray(patch[key])) {\n\t\t\t\t\tfor (let patchItem of patch[key]) {\n\n\t\t\t\t\t\tlet subObject = objectToPatch[key].find((item: any) => {\n\t\t\t\t\t\t\treturn item[idKey] != void 0 && item[idKey] === patchItem[idKey];\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (subObject) {\n\t\t\t\t\t\t\tthis.patch(subObject, patchItem);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobjectToPatch[key].push(patchItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else if (typeof patch[key] === 'object' && objectToPatch[key] != void 0) {\n\n\t\t\t\t\tif (patch[idKey] && Object.keys(patch).length == 1) {\n\t\t\t\t\t\tdelete objectToPatch[key];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.patch(objectToPatch[key], patch[key]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobjectToPatch[key] = patch[key];\n\t\t}\n\t\tif (objectToPatch['_onUpdate']) (objectToPatch['_onUpdate'] as Function).call(objectToPatch, patch);\n\t\treturn objectToPatch;\n\t}\n\n\tstatic travers(object: IIteralable, fn: (item: any) => boolean) {\n\t\tfor (let key in object) {\n\t\t\tif (!object.hasOwnProperty(key)) continue;\n\t\t\tlet allowTraverseDeeper = fn(object[key]);\n\t\t\tlet canTraverseDeeper = allowTraverseDeeper && typeof object[key] == 'object';\n\t\t\tif (canTraverseDeeper) this.travers(object[key], fn);\n\t\t}\n\t}\n\n\tstatic setIdsToArrayItems(sourceObject: any) {\n\t\tlet idKey = '_id';\n\t\tUtils.travers(sourceObject, (item: any) => {\n\t\t\tif (!Array.isArray(item)) return true;\n\t\t\tlet arr = item as any[];\n\t\t\tfor (let obj of arr) {\n\t\t\t\tif (typeof obj !== 'object' || Array.isArray(obj)) continue;\n\t\t\t\tif (!obj[idKey]) obj[idKey] = Utils.getUid();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *\n\t * @example\n\t * // returns \"000015\"\n\t * Utils.toFixed(15, 6);\n\t */\n\tstatic toFixed(num: number, digitsCount: number): string {\n\t\tvar maxDigits = 15;\n\t\tvar result = '';\n\t\tvar intVal = Math.floor(num);\n\t\tvar intStr = intVal.toString();\n\t\tvar lengthDiff = digitsCount - intStr.length;\n\t\tif (lengthDiff > 0 ) {\n\t\t\tresult = (<any>'0').repeat(lengthDiff) + intStr;\n\t\t} else {\n\t\t\tresult = intStr;\n\t\t}\n\t\tvar afterPointDigitsCount = maxDigits - intStr.length;\n\t\tvar afterPointStr = num.toString().split('.')[1];\n\t\tif (afterPointStr) {\n\t\t\tresult += '.' + afterPointStr.substr(0, afterPointDigitsCount);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic bindEvent() {\n\n\t}\n\n\t/**\n\t * generate texture from canvas context\n\t * @example\n\t * \t// create texture with rect\n\t *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\n\t */\n\tstatic createTexture(width: number, height: number, fn?: (ctx: CanvasRenderingContext2D, width: number, height: number) => void ): Texture {\n\t\tvar canvas: HTMLCanvasElement = document.createElement('canvas');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\tvar ctx = canvas.getContext('2d');\n\t\tfn && fn(ctx, width, height);\n\t\tvar texture = new THREE.Texture(canvas);\n\t\ttexture.needsUpdate = true;\n\t\treturn texture;\n\t}\n\n\t/**\n\t * generate texture from canvas context with NearestFilter\n\t * @example\n\t * \t// create texture with rect\n\t *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\n\t */\n\tstatic createNearestTexture(width: number, height: number, fn?: (ctx: CanvasRenderingContext2D) => void ): Texture{\n\t\tvar texture = this.createTexture(width, height, fn);\n\t\ttexture.minFilter = THREE.NearestFilter;\n\t\treturn texture;\n\t}\n\n\tstatic createPixelPerfectTexture(width: number, height: number, fn?: (ctx: CanvasRenderingContext2D) => void ): Texture{\n\t\tvar texture = this.createTexture(width, height, fn);\n\t\ttexture.magFilter = THREE.NearestFilter;\n\t\ttexture.minFilter = THREE.NearestFilter;\n\t\treturn texture;\n\t}\n\n\t/**\n\t * throw error\n\t */\n\tstatic error(msg: string) {\n\t\tconsole.error('Chart error: ' + msg);\n\t\tthrow 'Chart: ' + msg;\n\t}\n\n\t/**\n\t * throw error\n\t */\n\tstatic warn(msg: string) {\n\t\tconsole.warn('Chart warning: ' + msg);\n\t}\n\n\t/**\n\t * @returns new unique id\n\t */\n\tstatic getUid(): TUid {\n\t\treturn this.currentId++;\n\t}\n\n\t/**\n\t * @returns distance between numbers\n\t */\n\tstatic getDistance(num1: number, num2: number) {\n\t\treturn Math.max(num1, num2) - Math.min(num1, num2);\n\t}\n\n\t// TODO: refactor binary search functions\n\tstatic binarySearchClosestInd(arr: IIteralable[], num: number, key: string): number {\n\t\tvar mid: number;\n\t\tvar lo = 0;\n\t\tvar hi = arr.length - 1;\n\t\twhile (hi - lo > 1) {\n\t\t\tmid = Math.floor ((lo + hi) / 2);\n\t\t\tif (arr[mid][key] < num) {\n\t\t\t\tlo = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\tif (num - arr[lo][key] <= arr[hi][key] - num) {\n\t\t\treturn lo;\n\t\t}\n\t\treturn hi;\n\t}\n\n\tstatic binarySearchClosest<ArrayItem>(arr: ArrayItem[], num: number, key: string): ArrayItem {\n\t\tlet ind = this.binarySearchClosestInd(arr, num, key);\n\t\treturn arr[ind];\n\t}\n\n\tstatic binarySearchInd<ArrayItem>(arr: IIteralable[], num: number, key: string): number {\n\t\tlet mid: number;\n\t\tlet lo = 0;\n\t\tlet hi = arr.length - 1;\n\t\twhile (hi - lo > 1) {\n\t\t\tmid = Math.floor (( hi - lo) / 2);\n\t\t\tif (arr[mid][key] < num) {\n\t\t\t\tlo = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t\tif (arr[lo][key] == num) {\n\t\t\t\treturn lo;\n\t\t\t} else if (arr[hi][key] == num) {\n\t\t\t\treturn hi;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic binarySearch<ArrayItem>(arr: ArrayItem[], num: number, key: string): ArrayItem {\n\t\tlet ind = this.binarySearchInd(arr, num, key);\n\t\treturn arr[ind];\n\t}\n\n\n\tstatic rectsIntersect(r1: number[], r2: number[]) {\n\t\tlet [left1, top1, width1, height1] = r1;\n\t\tlet [left2, top2, width2, height2] = r2;\n\t\tlet [right1, right2, bottom1, bottom2] = [left1 + width1, left2 + width2, top1 + height1, top2 + height2];\n\t\treturn !(left2 > right1 ||\n\t\t\tright2 < left1 ||\n\t\t\ttop2 > bottom1 ||\n\t\t\tbottom2 < top1\n\t\t);\n\t}\n\n\n\tstatic throttle(func: Function, ms: number) {\n\n\t\tvar isThrottled = false,\n\t\t\tsavedArgs: any,\n\t\t\tsavedThis: any;\n\n\t\tfunction wrapper() {\n\n\t\t\tif (isThrottled) { // (2)\n\t\t\t\tsavedArgs = arguments;\n\t\t\t\tsavedThis = this;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfunc.apply(this, arguments); // (1)\n\n\t\t\tisThrottled = true;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tisThrottled = false; // (3)\n\t\t\t\tif (savedArgs) {\n\t\t\t\t\twrapper.apply(savedThis, savedArgs);\n\t\t\t\t\tsavedArgs = savedThis = null;\n\t\t\t\t}\n\t\t\t}, ms);\n\t\t}\n\n\t\treturn wrapper;\n\t}\n\n\tstatic msToTimeString(timestamp: number) {\n\t\tvar h = Math.floor(timestamp / 360000);\n\t\tvar m =  Math.floor(timestamp / 60000);\n\t\tvar s =  Math.floor(timestamp / 1000);\n\t\treturn h + ':' + m + ':' + s;\n\t}\n\t\n\tstatic getRandomItem<T>(arr: Array<T>): T {\n\t\tvar ind = Math.floor(Math.random() * arr.length);\n\t\treturn arr[ind];\n\t}\n\n\tstatic copyProps(srcObject: TIteralable, dstObject: TIteralable, props: TIteralable, excludeProps: string[] = []) {\n\t\tfor (var key in props) {\n\t\t\tif (excludeProps.indexOf(key) !== -1) continue;\n\t\t\tif (srcObject[key] == void 0) continue;\n\t\t\tif (isPlainObject(props[key]) && dstObject[key] !== void 0) {\n\t\t\t\tthis.copyProps(srcObject[key], dstObject[key], props[key])\n\t\t\t} else if (typeof srcObject[key] == 'function') {\n\t\t\t\tdstObject[key] = srcObject[key];\n\t\t\t} else {\n\t\t\t\tdstObject[key] = this.deepCopy(srcObject[key]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Utils.ts\n **/","import {EE2} from './deps';\n\n/**\n * this class uses as proxy for EventEmitter2\n */\nexport class EventEmitter {\n\tprivate ee: EventEmitter2;\n\n\t// TODO: allow to create EE instances only in Chart class\n\tconstructor() {\n\t\tthis.ee = new EE2();\n\t}\n\temit(eventName: string, ...args: any[]) {\n\t\tthis.ee.emit(eventName, ...args)\n\t}\n\ton(eventName: string, callback: Function) {\n\t\treturn this.ee.on(eventName, callback)\n\t}\n\toff(eventName: string, callback: Function) {\n\t\treturn this.ee.off(eventName, callback);\n\t}\n\tsubscribe(eventName: string, callback: Function): Function {\n\t\tthis.on(eventName, callback);\n\t\treturn () => this.off(eventName, callback);\n\t}\n\tsetMaxListeners(listenersCount: number) {\n\t\tthis.ee.setMaxListeners(listenersCount);\n\t}\n\tremoveAllListeners(eventName?: string) {\n\t\tthis.ee.removeAllListeners(eventName);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/EventEmmiter.ts\n **/","export * from './deps'\n\n\n/** WEBPACK FOOTER **\n ** ./src/deps/index.ts\n **/","import Vector3 = THREE.Vector3;\nimport { ITrendOptions, Trend, ITrendData, TREND_TYPE } from \"./Trend\";\nimport {EventEmitter} from './EventEmmiter';\nimport {Utils} from './Utils';\nimport {TrendsManager, ITrendsOptions} from \"./TrendsManager\";\nimport {Screen} from \"./Screen\";\nimport {\n\tAXIS_TYPE, AXIS_DATA_TYPE, IAxisOptions, IAnimationsOptions, AXIS_RANGE_TYPE\n} from \"./interfaces\";\nimport { Promise } from './deps/deps';\nimport { ChartPlugin } from './Plugin';\nimport {TColor} from \"./Color\";\nimport { AnimationManager } from \"./AnimationManager\";\nimport { EASING } from './Easing';\n\ninterface IRecalculatedStateResult {\n\tchangedProps: IChartState,\n\tpatch: IChartState\n}\n\nconst CHART_STATE_EVENTS = {\n\tINITIAL_STATE_APPLIED: 'initialStateApplied',\n\tREADY: 'ready',\n\tDESTROY: 'destroy',\n\tCHANGE: 'change',\n\tTREND_CHANGE: 'trendChange',\n\tTRENDS_CHANGE: 'trendsChange',\n\tZOOM: 'zoom',\n\tRESIZE: 'resize',\n\tSCROLL: 'scroll',\n\tDRAG_STATE_CHAGED: 'scrollStop',\n\tPLUGINS_STATE_CHANGED: 'pluginsStateChanged'\n};\n\n/**\n * readonly computed state state\n * calculated after recalculateState() call\n * contains cached values\n */\nexport interface IChartStateComputedData {\n\ttrends?: {\n\t\tmaxXVal: number,\n\t\tminXVal: number\n\t}\n}\n\nexport interface IChartState {\n\tprevState?: IChartState,\n\twidth?: number;\n\theight?: number;\n\tzoom?: number;\n\txAxis?: IAxisOptions,\n\tyAxis?: IAxisOptions,\n\tanimations?: IAnimationsOptions,\n\ttrends?: ITrendsOptions,\n\ttrendDefaultState?: ITrendOptions;\n\tcursor?: {\n\t\tdragMode?: boolean,\n\t\tx?: number,\n\t\ty?: number\n\t},\n\n\t/**\n\t * use fps = 0 for no limits\n\t */\n\tautoRender?: {enabled?: boolean, fps?: number};\n\n\t/**\n\t * by default 'WebGLRenderer'\n\t * also available 'CanvasRenderer'\n\t */\n\trenderer?: 'WebGLRenderer' | 'CanvasRenderer';\n\tfont?: {s?: string, m?: string, l?:string}\n\n\t/**\n\t * set to false for smooth animations\n\t */\n\tenablePixelPerfectRender?: boolean,\n\n\t/**\n\t * buffer size for displayed segments\n\t * used by widgets\n\t */\n\tmaxVisibleSegments?: number;\n\tautoResize?: boolean;\n\tcontrols?: {enabled: boolean};\n\tautoScroll?: boolean;\n\tinertialScroll?: boolean\n\n\t//TODO: exclude stats in plugin\n\tshowStats?: boolean;\n\tbackgroundColor?: TColor;\n\tcomputedData?: IChartStateComputedData,\n\tpluginsState?: {[pluginName: string]: any};\n\teventEmitterMaxListeners?: number;\n}\n\nconst LIGHT_BLUE = '#5273bd';\n\n/**\n *  all state changes caused only by Chart.setState method\n */\nexport class Chart {\n\n\tstate: IChartState = {\n\t\tprevState: {},\n\t\tzoom: 0,\n\t\txAxis: {\n\t\t\trange: {\n\t\t\t\ttype: AXIS_RANGE_TYPE.ALL,\n\t\t\t\tfrom: 0,\n\t\t\t\tto: 0,\n\t\t\t\tscroll: 0,\n\t\t\t\tzoom: 1,\n\t\t\t\tpadding: {start: 0, end: 5},\n\t\t\t\tmargin: {start: 0, end: 5}\n\t\t\t},\n\t\t\tdataType: AXIS_DATA_TYPE.NUMBER,\n\t\t\tgrid: {enabled: true, minSizePx:  100, color: `rgba(${LIGHT_BLUE}, 0.12)`},\n\t\t\tcolor: LIGHT_BLUE\n\t\t},\n\t\tyAxis: {\n\t\t\trange: {\n\t\t\t\ttype: AXIS_RANGE_TYPE.RELATIVE_END,\n\t\t\t\tfrom: 0,\n\t\t\t\tto: 0,\n\t\t\t\tzoom: 1,\n\t\t\t\tpadding: {start: 5, end: 5},\n\t\t\t\tmargin: {start: 5, end: 5},\n\t\t\t},\n\t\t\tgrid: {enabled: true, minSizePx:  50, color: `rgba(${LIGHT_BLUE}, 0.12)`},\n\t\t\tdataType: AXIS_DATA_TYPE.NUMBER,\n\t\t\tcolor: LIGHT_BLUE\n\t\t},\n\t\tanimations: {\n\t\t\tenabled: true,\n\t\t\ttrendChangeSpeed: 0.5,\n\t\t\ttrendChangeEase: void 0,\n\t\t\tzoomSpeed: 250,\n\t\t\tscrollSpeed: 1000,\n\t\t\tscrollEase: EASING.Quadratic.Out,\n\t\t\tzoomEase: EASING.Quadratic.Out,\n\t\t\tautoScrollSpeed: 1100,\n\t\t\tautoScrollEase: EASING.Linear.None,\n\t\t},\n\t\tautoRender: {enabled: true, fps: 0},\n\t\tautoResize: true,\n\t\trenderer: 'WebGLRenderer',\n\t\tautoScroll: true,\n\t\tcontrols: {enabled: true},\n\t\ttrendDefaultState: {\n\t\t\tenabled: true,\n\t\t\ttype: TREND_TYPE.LINE,\n\t\t\tdata: [],\n\t\t\tmaxSegmentLength: 1000,\n\t\t\tlineWidth: 2,\n\t\t\tlineColor: 0xFFFFFF,\n\t\t\thasBackground: true,\n\t\t\tbackgroundColor: 'rgba(#FFFFFF, 0.07)',\n\t\t\thasBeacon: false,\n\t\t\tsettingsForTypes: {\n\t\t\t\tCANDLE: {\n\t\t\t\t\tminSegmentLengthInPx: 20,\n\t\t\t\t\tmaxSegmentLengthInPx: 40,\n\t\t\t\t},\n\t\t\t\tLINE: {\n\t\t\t\t\tminSegmentLengthInPx: 2,\n\t\t\t\t\tmaxSegmentLengthInPx: 10,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcursor: {\n\t\t\tdragMode: false,\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t},\n\t\tfont: {\n\t\t\ts: '11px Arial',\n\t\t\tm: '12px Arial',\n\t\t\tl: '13px Arial'\n\t\t},\n\t\tbackgroundColor: 0x000c2a,\n\t\tshowStats: false,\n\t\tpluginsState: {},\n\t\teventEmitterMaxListeners: 20,\n\t\tmaxVisibleSegments: 1280,\n\t\tinertialScroll: true\n\t};\n\tplugins: {[pluginName: string]: ChartPlugin<any>} = {};\n\ttrendsManager: TrendsManager;\n\tanimationManager: AnimationManager;\n\tscreen: Screen;\n\n\t/**\n\t * true then state was initialized and ready to use\n\t */\n\tisReady = false;\n\tisDestroyed = false;\n\n\n\tprivate ee: EventEmitter;\n\n\tconstructor(\n\t\tinitialState: IChartState,\n\t\tplugins: ChartPlugin<any>[] = []\n\t) {\n\t\tthis.ee = new EventEmitter();\n\t\tthis.ee.setMaxListeners(initialState.eventEmitterMaxListeners || this.state.eventEmitterMaxListeners);\n\n\t\tthis.state = Utils.patch(this.state, initialState); //Utils.deepMerge(this.state, initialState);\n\t\tthis.trendsManager = new TrendsManager(this, initialState);\n\t\tinitialState.trends = this.trendsManager.calculatedOptions;\n\t\tinitialState = this.installPlugins(plugins, initialState);\n\t\tthis.setState(initialState);\n\t\tthis.setState({computedData: this.getComputedData()});\n\t\tthis.savePrevState();\n\n\t\tthis.animationManager = new AnimationManager();\n\t\tthis.animationManager.setAimationsEnabled(this.state.animations.enabled);\n\t\tthis.screen = new Screen(this);\n\t\tthis.bindEvents();\n\t\t\n\t\t// message to other modules that Chart.state is ready for use\n\t\tthis.ee.emit(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, initialState);\n\n\t\t// message to other modules that Chart is ready for use\n\t\tthis.isReady = true;\n\t\tthis.ee.emit(CHART_STATE_EVENTS.READY, initialState);\n\n\t}\n\n\t/**\n\t * destroy chart, use ChartView.destroy to completely destroy Chart\n\t */\n\tdestroy() {\n\t\tthis.ee.emit(CHART_STATE_EVENTS.DESTROY);\n\t\tthis.ee.removeAllListeners();\n\t\tthis.state = {};\n\t\tthis.isDestroyed = true;\n\t}\n\n\tonDestroy(cb: Function) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.DESTROY, cb);\n\t}\n\n\tonInitialStateApplied(cb: (initialState: IChartState) => void ): Function {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, cb);\n\t}\n\n\tonReady(cb: (initialState: IChartState) => void ): Function {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.READY, cb);\n\t}\n\n\tonChange(cb: (changedProps: IChartState) => void ) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.CHANGE, cb);\n\t}\n\n\tonTrendChange(cb: (trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.TREND_CHANGE, cb);\n\t}\n\n\tonTrendsChange(cb: (trendsOptions: ITrendsOptions) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.TRENDS_CHANGE, cb);\n\t}\n\n\tonDragStateChanged(cb: (isDragMode: boolean, changedProps: IChartState) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.DRAG_STATE_CHAGED, cb);\n\t}\n\n\tonScroll(cb: (scrollOptions: {deltaX: number}) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.SCROLL, cb);\n\t}\n\n\tonZoom(cb: (changedProps: IChartState) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.ZOOM, cb);\n\t}\n\n\tonResize(cb: (changedProps: IChartState) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.RESIZE, cb);\n\t}\n\n\tonPluginsStateChange(cb: (changedPluginsStates: {[pluginName: string]: Plugin}) => any) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, cb);\n\t}\n\t\n\tgetTrend(trendName: string): Trend {\n\t\treturn this.trendsManager.getTrend(trendName);\n\t}\n\n\trender() {\n\t\tthis.animationManager.tick();\n\t}\n\n\tsetState(newState: IChartState, eventData?: any, silent = false) {\n\n\t\tif (this.isDestroyed) {\n\t\t\tUtils.error('You have tried to change state of destroyed Chart instance');\n\t\t}\n\n\t\tlet stateData = this.state as {[key: string]: any};\n\t\tlet newStateObj = newState as {[key: string]: any};\n\n\t\tvar changedProps: {[key: string]: any} = {};\n\t\tfor (let key in newStateObj) {\n\t\t\tif (stateData[key] !== newStateObj[key]) {\n\t\t\t\tchangedProps[key] = newStateObj[key] as any;\n\t\t\t}\n\t\t}\n\n\t\tthis.savePrevState(changedProps as IChartState);\n\n\n\t\t// temporary remove trends state from newState by performance reasons\n\t\tlet trendsData: {[trendName: string]: ITrendData} = {};\n\t\tif (newState.trends) for (let trendName in newState.trends) {\n\t\t\tlet trendOptions = newState.trends[trendName];\n\t\t\tif (trendOptions.data) trendsData[trendName] = trendOptions.data;\n\t\t\tdelete trendOptions.data;\n\t\t}\n\t\tlet newStateContainsData = Object.keys(trendsData).length > 0;\n\n\t\t// setup ids to array items\n\t\tnewState = Utils.deepMerge({}, newState);\n\t\tUtils.setIdsToArrayItems(newState);\n\t\tthis.state = Utils.patch(this.state, newState); //Utils.deepMerge(this.state, newState, false);\n\n\t\t// return state to state\n\t\tif (newStateContainsData) for (let trendName in trendsData) {\n\t\t\tthis.state.trends[trendName].data = trendsData[trendName];\n\t\t}\n\n\t\tif (silent) return;\n\n\t\t// recalculate all dynamic state props\n\t\tvar recalculateResult = this.recalculateState(changedProps);\n\t\tchangedProps = recalculateResult.changedProps;\n\t\t\n\t\tthis.emitChangedStateEvents(changedProps, eventData);\n\n\t}\n\n\t/**\n\t * recalculate all computed state props\n\t */\n\tprivate recalculateState(changedProps?: IChartState): IRecalculatedStateResult {\n\t\tvar data = this.state;\n\t\tvar patch: IChartState = {};\n\t\tvar actualData = Utils.patch({}, data); //Utils.deepMerge({}, data);\n\n\t\t// recalculate scroll position by changed cursor options\n\t\tvar cursorOptions = changedProps.cursor;\n\t\tvar isMouseDrag = cursorOptions && data.cursor.dragMode && data.prevState.cursor.dragMode;\n\t\tif (isMouseDrag) {\n\t\t\tvar oldX = data.prevState.cursor.x;\n\t\t\tvar currentX =  cursorOptions.x;\n\t\t\tvar currentScroll = data.xAxis.range.scroll;\n\t\t\tvar deltaXVal = this.pxToValueByXAxis(oldX - currentX);\n\t\t\tpatch.xAxis = {range: {scroll: currentScroll + deltaXVal}};\n\t\t\tactualData = Utils.patch(actualData, {xAxis: patch.xAxis} as IChartState);//Utils.deepMerge(actualData, {xAxis: patch.xAxis} as IChartState)\n\t\t}\n\n\t\tlet chartWasResized = changedProps.width != void 0 || changedProps.height != void 0;\n\n\t\tlet scrollXChanged = false;\n\t\tlet needToRecalculateXAxis = (\n\t\t\tisMouseDrag ||\n\t\t\tchartWasResized ||\n\t\t\t(changedProps.xAxis && (changedProps.xAxis.range)) ||\n\t\t\tthis.state.xAxis.range.zeroVal == void 0\n\t\t);\n\t\tif (needToRecalculateXAxis) {\n\t\t\tlet xAxisPatch = this.recalculateXAxis(actualData, changedProps);\n\t\t\tif (xAxisPatch) {\n\t\t\t\tscrollXChanged = true;\n\t\t\t\t//patch = Utils.deepMerge(patch, {xAxis: xAxisPatch});\n\t\t\t\tUtils.patch(patch, {xAxis: xAxisPatch});\n\t\t\t\t//actualData = Utils.deepMerge(actualData, {xAxis: xAxisPatch} as IChartState);\n\t\t\t\tUtils.patch(actualData, {xAxis: xAxisPatch} as IChartState);\n\t\t\t}\n\t\t}\n\n\n\n\t\t// recalculate axis \"from\" and \"to\" for dynamics AXIS_RANGE_TYPE\n\t\tlet needToRecalculateYAxis = (\n\t\t\tchartWasResized ||\n\t\t\t(\n\t\t\t\tdata.yAxis.range.type === AXIS_RANGE_TYPE.RELATIVE_END ||\n\t\t\t\tdata.yAxis.range.type === AXIS_RANGE_TYPE.AUTO ||\n\t\t\t\tdata.yAxis.range.isMirrorMode\n\t\t\t) &&\n\t\t\t(scrollXChanged || changedProps.trends || changedProps.yAxis) ||\n\t\t\tthis.state.yAxis.range.zeroVal == void 0\n\t\t);\n\t\tif (needToRecalculateYAxis){\n\t\t\tlet yAxisPatch = this.recalculateYAxis(actualData);\n\t\t\tif (yAxisPatch) {\n\t\t\t\t// patch = Utils.deepMerge(patch, {yAxis: yAxisPatch});\n\t\t\t\t// actualData = Utils.deepMerge(actualData, {yAxis: yAxisPatch} as IChartState);\n\t\t\t\tUtils.patch(patch, {yAxis: yAxisPatch});\n\t\t\t\tUtils.patch(actualData, {yAxis: yAxisPatch} as IChartState);\n\t\t\t}\n\t\t}\n\n\t\tthis.savePrevState(patch);\n\t\tlet allChangedProps = Utils.deepMerge(changedProps, patch);\n\t\tpatch.computedData = this.getComputedData(allChangedProps);\n\t\tthis.savePrevState(patch);\n\t\t// this.state = Utils.deepMerge(this.state, patch);\n\t\tUtils.patch(this.state, patch);\n\t\treturn {changedProps: allChangedProps, patch: patch}\n\t}\n\n\tprivate getComputedData(changedProps?: IChartState): IChartStateComputedData {\n\t\tvar computeAll = !changedProps;\n\t\tvar computedData: IChartStateComputedData = {};\n\n\t\tif (computeAll || changedProps.trends && this.trendsManager) {\n\t\t\tcomputedData.trends = {\n\t\t\t\tmaxXVal: this.trendsManager.getEndXVal(),\n\t\t\t\tminXVal: this.trendsManager.getStartXVal()\n\t\t\t}\n\t\t}\n\t\treturn computedData;\n\t}\n\n\tprivate savePrevState(changedProps?: IChartState) {\n\t\tif (!changedProps) changedProps = this.state;\n\t\tvar prevState = this.state.prevState;\n\n\t\t// prevent to store prev trend state by performance reasons\n\t\tUtils.copyProps(this.state, prevState, changedProps, ['trends']);\n\n\t}\n\n\tprivate emitChangedStateEvents(changedProps: IChartState, eventData: any) {\n\t\tvar prevState = this.state.prevState;\n\n\t\t// emit common change event\n\t\tthis.ee.emit(CHART_STATE_EVENTS.CHANGE, changedProps, eventData);\n\n\t\t// emit event for each changed state property\n\t\tfor (let key in changedProps) {\n\t\t\tthis.ee.emit(key + 'Change', (changedProps as {[key: string]: any})[key], eventData);\n\t\t}\n\n\t\tif (!this.isReady) return;\n\n\t\t// emit special events based on changed state\n\t\tlet dragEventNeeded = (\n\t\t\tchangedProps.cursor &&\n\t\t\t(changedProps.cursor.dragMode != prevState.cursor.dragMode)\n\t\t);\n\t\tdragEventNeeded && this.ee.emit(CHART_STATE_EVENTS.DRAG_STATE_CHAGED, changedProps.cursor.dragMode, changedProps);\n\n\t\tlet scrollChangeEventsNeeded = (\n\t\t\tchangedProps.xAxis &&\n\t\t\tchangedProps.xAxis.range &&\n\t\t\tchangedProps.xAxis.range.scroll != void 0\n\t\t);\n\t\tscrollChangeEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL, changedProps);\n\n\t\tlet zoomEventsNeeded = (\n\t\t\t(changedProps.xAxis && changedProps.xAxis.range && changedProps.xAxis.range.zoom) ||\n\t\t\t(changedProps.yAxis && changedProps.yAxis.range && changedProps.yAxis.range.zoom)\n\t\t);\n\t\tzoomEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.ZOOM, changedProps);\n\n\t\tlet resizeEventNeeded = (changedProps.width || changedProps.height);\n\t\tresizeEventNeeded && this.ee.emit(CHART_STATE_EVENTS.RESIZE, changedProps);\n\n\t\tlet pluginStateChangedEventNeeded = !!(changedProps.pluginsState);\n\t\tpluginStateChangedEventNeeded && this.ee.emit(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, changedProps.pluginsState);\n\t}\n\n\n\t/**\n\t * init plugins and save plugins options in initialState\n\t */\n\tprivate installPlugins(plugins: ChartPlugin<any>[], initialState: IChartState): IChartState {\n\t\tinitialState.pluginsState = {};\n\t\tplugins.forEach(plugin => {\n\t\t\tlet PluginClass = plugin.constructor as typeof ChartPlugin;\n\t\t\tlet pluginName = PluginClass.NAME;\n\t\t\tinitialState.pluginsState[pluginName] = Utils.deepMerge({}, plugin.initialState);\n\t\t\tthis.plugins[pluginName] = plugin;\n\t\t\tplugin.setupChart(this);\n\t\t});\n\t\treturn initialState;\n\t}\n\n\n\t/**\n\t * returns plugin instance by plugin name\n\t * @example\n\t */\n\tgetPlugin(pluginName: string): ChartPlugin<any> {\n\t\treturn this.plugins[pluginName];\n\t}\n\n\n\tprivate bindEvents() {\n\t\tthis.ee.on(CHART_STATE_EVENTS.TRENDS_CHANGE, (changedTrends: ITrendsOptions, newData: ITrendData) => {\n\t\t\tthis.handleTrendsChange(changedTrends, newData)\n\t\t});\n\n\t\tthis.onDragStateChanged(dragState => this.onDragStateChangedHandler(dragState));\n\n\t\tthis.ee.on('animationsChange', (animationOptions: IAnimationsOptions) => {\n\t\t\tif (animationOptions.enabled !== this.animationManager.isAnimationsEnabled) {\n\t\t\t\tthis.animationManager.setAimationsEnabled(animationOptions.enabled);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate handleTrendsChange(changedTrends: ITrendsOptions, newData: ITrendData) {\n\t\tfor (let trendName in changedTrends) {\n\t\t\tthis.ee.emit(CHART_STATE_EVENTS.TREND_CHANGE, trendName, changedTrends[trendName], newData);\n\t\t}\n\n\t\t// process autoscroll\n\t\tlet state = this.state;\n\t\tif (!state.autoScroll || state.cursor.dragMode) return;\n\t\tlet oldTrendsMaxX = state.prevState.computedData.trends.maxXVal;\n\t\tlet trendsMaxXDelta = state.computedData.trends.maxXVal - oldTrendsMaxX;\n\n\t\tif (trendsMaxXDelta > 0) {\n\t\t\tlet maxVisibleXVal = this.screen.getScreenRightVal();\n\t\t\tlet paddingRightVal = this.getValueByScreenX(\n\t\t\t\tthis.state.width -\n\t\t\t\tstate.xAxis.range.padding.end -\n\t\t\t\tstate.xAxis.range.margin.end\n\t\t\t);\n\t\t\tlet marginRightVal = this.getValueByScreenX(\n\t\t\t\tthis.state.width -\n\t\t\t\tstate.xAxis.range.margin.end\n\t\t\t);\n\t\t\tvar currentScroll = state.xAxis.range.scroll;\n\t\t\tif (oldTrendsMaxX < marginRightVal || oldTrendsMaxX > maxVisibleXVal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet scrollDelta = state.computedData.trends.maxXVal - paddingRightVal;\n\n\t\t\tthis.setState({xAxis: {range: {scroll: currentScroll + scrollDelta}}});\n\t\t}\n\t}\n\n\tprivate onDragStateChangedHandler(isDragMode: boolean) {\n\n\t\t// process inertial scroll\n\t\tlet state = this.state;\n\t\tif (!state.inertialScroll || isDragMode) return;\n\n\t\t// TODO:\n\t\t// let currentScroll = state.xAxis.range.scroll;\n\t\t// let currentX = state.cursor.x;\n\t\t// let prevX = state.prevState.cursor.x;\n\t\t// let scrollDelta = this.pxToValueByXAxis(prevX - currentX) * 10;\n\t\t// this.setState({xAxis: {range: {scroll: currentScroll + scrollDelta}}})\n\t}\n\n\tprivate recalculateXAxis(actualData: IChartState, changedProps: IChartState): IAxisOptions {\n\t\tvar axisRange = actualData.xAxis.range;\n\t\tvar patch: IAxisOptions = {range: {}};\n\t\tvar isInitialize = axisRange.zeroVal == void 0;\n\t\tvar zeroVal: number, scaleFactor: number;\n\t\tvar zoom = axisRange.zoom;\n\n\t\tif (axisRange.isMirrorMode) {\n\t\t\tUtils.error('range.isMirrorMode available only for yAxis.range');\n\t\t}\n\n\t\tif (isInitialize) {\n\t\t\tzeroVal = axisRange.from;\n\t\t\tscaleFactor = actualData.width / (axisRange.to - axisRange.from);\n\t\t\tpatch = { range: {zeroVal: zeroVal, scaleFactor: scaleFactor}};\n\t\t} else {\n\t\t\tzeroVal = axisRange.zeroVal;\n\t\t\tscaleFactor = axisRange.scaleFactor;\n\n\t\t\t// recalculate range.zoom and range.scroll then range.from or range.to was changed\n\t\t\tif (\n\t\t\t\tchangedProps.xAxis &&\n\t\t\t\t(changedProps.xAxis.range.from != void 0 || changedProps.xAxis.range.to)\n\t\t\t) {\n\t\t\t\tif (changedProps.xAxis.range.zoom) {\n\t\t\t\t\tUtils.error('Impossible to change \"range.zoom\" then \"range.from\" or \"range.to\" present');\n\t\t\t\t}\n\t\t\t\tlet currentScaleFactor = actualData.width / (axisRange.to - axisRange.from);\n\t\t\t\tpatch.range.scroll = axisRange.from - zeroVal;\n\t\t\t\tpatch.range.zoom = currentScaleFactor / scaleFactor;\n\t\t\t\treturn patch;\n\t\t\t}\n\t\t}\n\n\n\t\t// recalculate range.from and range.to then range.zoom or range.scroll was changed\n\t\tdo {\n\t\t\tvar from = zeroVal + axisRange.scroll;\n\t\t\tvar to = from + actualData.width / (scaleFactor * zoom);\n\t\t\tvar rangeLength = to - from;\n\t\t\tvar needToRecalculateZoom = false;\n\t\t\tvar rangeMoreThenMaxValue = (axisRange.maxLength && rangeLength > axisRange.maxLength);\n\t\t\tvar rangeLessThenMinValue = (axisRange.minLength && rangeLength < axisRange.minLength);\n\t\t\tneedToRecalculateZoom = rangeMoreThenMaxValue || rangeLessThenMinValue;\n\t\t\tif (needToRecalculateZoom) {\n\t\t\t\tvar fixScale = rangeLength > axisRange.maxLength ?\n\t\t\t\t\trangeLength / axisRange.maxLength :\n\t\t\t\t\trangeLength / axisRange.minLength;\n\t\t\t\tvar zoom = zoom * fixScale;\n\t\t\t\tpatch.range.zoom = zoom;\n\t\t\t}\n\t\t} while (needToRecalculateZoom);\n\n\t\tpatch.range.from = from;\n\t\tpatch.range.to = to;\n\t\treturn patch;\n\t}\n\n\n\tprivate recalculateYAxis(actualData: IChartState): IAxisOptions {\n\t\tvar patch: IAxisOptions = {range: {}};\n\t\tvar yAxisRange = actualData.yAxis.range;\n\t\tvar isInitialize = yAxisRange.scaleFactor == void 0;\n\t\tvar trends = this.trendsManager;\n\t\tvar trendsEndXVal = trends.getEndXVal();\n\t\tvar trendsStartXVal = trends.getStartXVal();\n\t\tvar xRange = actualData.xAxis.range;\n\t\tvar {from: xFrom, to: xTo} = xRange;\n\t\tvar xRangeLength = xTo - xFrom;\n\t\tvar zeroVal: number, scaleFactor: number, scroll: number, zoom: number, needToZoom: boolean;\n\n\t\t// check situation when state was scrolled behind trends end or before trends start\n\t\tif (xTo > trendsEndXVal) {\n\t\t\txTo = trendsEndXVal;\n\t\t\txFrom = xTo - xRangeLength;\n\t\t} else if (xFrom < trendsStartXVal) {\n\t\t\txFrom = trendsStartXVal;\n\t\t\txTo = xFrom + xRangeLength;\n\t\t}\n\n\t\tvar maxY = trends.getMaxYVal(xFrom, xTo);\n\t\tvar minY = trends.getMinYVal(xFrom, xTo);\n\n\t\tvar trendLastY = trends.getMaxYVal(trendsEndXVal, trendsEndXVal);\n\t\tif (yAxisRange.type == AXIS_RANGE_TYPE.RELATIVE_END) {\n\t\t\tif (trendLastY > maxY) maxY = trendLastY;\n\t\t\tif (trendLastY < minY) minY = trendLastY;\n\t\t}\n\n\t\tif (yAxisRange.isMirrorMode) {\n\t\t\tif (yAxisRange.zeroVal == void 0) Utils.error('range.zeroVal must be set when range.isMirrorMode');\n\t\t\tlet distanceFromZeroValForMaxY = Math.abs(yAxisRange.zeroVal - maxY);\n\t\t\tlet distanceFromZeroValForMinY = Math.abs(yAxisRange.zeroVal - minY);\n\t\t\tlet maxDistanceFromZeroVal = Math.max(distanceFromZeroValForMaxY, distanceFromZeroValForMinY);\n\t\t\tmaxY = yAxisRange.zeroVal + maxDistanceFromZeroVal;\n\t\t\tminY = yAxisRange.zeroVal - maxDistanceFromZeroVal;\n\t\t}\n\t\tlet margin = yAxisRange.margin;\n\t\tlet padding = {\n\t\t\tstart: yAxisRange.padding.start + margin.start,\n\t\t\tend: yAxisRange.padding.end + margin.end\n\t\t};\n\n\t\tif (padding.end + padding.start >= actualData.height) {\n\t\t\tUtils.warn('Sum of padding and margins of yAxi more then available state height. Trends can be rendered incorrectly');\n\t\t}\n\n\t\tlet rangeLength = maxY - minY;\n\t\tlet paddingTopInPercents = padding.end / actualData.height;\n\t\tlet paddingBottomInPercents = padding.start / actualData.height;\n\t\tlet rangeLengthInPercents = 1 - paddingTopInPercents - paddingBottomInPercents;\n\t\tlet visibleRangeLength = rangeLength / rangeLengthInPercents;\n\t\tlet fromVal = minY - visibleRangeLength * paddingBottomInPercents;\n\t\tlet toVal = maxY + visibleRangeLength * paddingTopInPercents;\n\t\t\n\t\tif (isInitialize) {\n\t\t\tzeroVal = yAxisRange.zeroVal != void 0 ? yAxisRange.zeroVal : fromVal;\n\t\t\tscaleFactor = actualData.height / (toVal - fromVal);\n\t\t\tpatch = { range: {zeroVal: zeroVal, scaleFactor: scaleFactor}};\n\t\t\tneedToZoom = true;\n\t\t} else {\n\t\t\tscaleFactor = yAxisRange.scaleFactor;\n\t\t\tzeroVal = yAxisRange.zeroVal;\n\n\t\t\tlet maxScreenY = Math.round(this.getScreenYByValue(maxY));\n\t\t\tlet minScreenY = Math.round(this.getScreenYByValue(minY));\n\t\t\tneedToZoom = (\n\t\t\t\tmaxScreenY > actualData.height - margin.end ||\n\t\t\t\tmaxScreenY < actualData.height - padding.end ||\n\t\t\t\tminScreenY < margin.start ||\n\t\t\t\tminScreenY > padding.start\n\t\t\t);\n\t\t}\n\n\t\tif (!needToZoom) return null;\n\n\t\tscroll = fromVal - zeroVal;\n\t\tzoom = (actualData.height / (toVal - fromVal)) / scaleFactor ;\n\n\t\tvar currentAxisRange = this.state.yAxis.range;\n\t\tif (currentAxisRange.from !== fromVal) patch.range.from = fromVal;\n\t\tif (currentAxisRange.to !== toVal) patch.range.to = toVal;\n\t\tif (currentAxisRange.scroll !== scroll) patch.range.scroll = scroll;\n\t\tif (currentAxisRange.zoom !== zoom) patch.range.zoom = zoom;\n\t\t\n\t\treturn patch;\n\t}\n\n\tzoom(zoomValue: number, origin = 0.5): Promise<void> {\n\t\tlet {zoom, scroll, scaleFactor} = this.state.xAxis.range;\n\t\tlet newZoom = zoom * zoomValue;\n\t\tlet currentRange = this.state.width / (scaleFactor * zoom);\n\t\tlet nextRange = this.state.width / (scaleFactor * newZoom);\n\t\tlet newScroll = scroll + (currentRange - nextRange) * origin;\n\t\tthis.setState({xAxis: {range: {zoom: newZoom, scroll: newScroll}}});\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tlet animationTime = this.state.animations.enabled ? this.state.animations.zoomSpeed : 0;\n\t\t\tsetTimeout(resolve, animationTime * 1000);\n\t\t});\n\t}\n\t\n\tzoomToRange(range: number, origin?: number): Promise<void> {\n\t\tvar {scaleFactor, zoom} = this.state.xAxis.range;\n\t\tlet currentRange = this.state.width / (scaleFactor * zoom);\n\t\treturn this.zoom(currentRange / range, origin);\n\t}\n\n\tscrollToEnd(): Promise<void> {\n\t\tlet state = this.state;\n\t\tlet endXVal = this.trendsManager.getEndXVal();\n\t\tlet range = state.xAxis.range;\n\t\tlet scroll = (\n\t\t\tendXVal - this.pxToValueByXAxis(state.width) +\n\t\t\tthis.pxToValueByXAxis(range.padding.end + range.margin.end) -\n\t\t\trange.zeroVal\n\t\t);\n\t\tthis.setState({xAxis: {range: {scroll: scroll}}});\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tlet animationTime = state.animations.enabled ? state.animations.scrollSpeed : 0;\n\t\t\tsetTimeout(resolve, animationTime);\n\t\t});\n\t}\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal to xVal\n\t */\n\tgetPointOnXAxis(xVal: number): number {\n\t\tvar {scaleFactor, zoom, zeroVal} = this.state.xAxis.range;\n\t\treturn (xVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from yAxis.range.zeroVal to yVal\n\t */\n\tgetPointOnYAxis(yVal: number): number {\n\t\tvar {scaleFactor, zoom, zeroVal} = this.state.yAxis.range;\n\t\treturn (yVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t * returns xVal by offset in pixels from xAxis.range.zeroVal\n\t */\n\tgetValueOnXAxis(x: number): number {\n\t\treturn this.state.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  convert xVal to pixels by using settings from xAxis.range\n\t */\n\tvalueToPxByXAxis(xVal: number) {\n\t\treturn xVal * this.state.xAxis.range.scaleFactor * this.state.xAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  convert xVal to pixels by using settings from yAxis.range\n\t */\n\tvalueToPxByYAxis(yVal: number) {\n\t\treturn yVal * this.state.yAxis.range.scaleFactor * this.state.yAxis.range.zoom;\n\t}\n\n\t/**\n\t *  convert pixels to xVal by using settings from xAxis.range\n\t */\n\tpxToValueByXAxis(xVal: number) {\n\t\treturn xVal / this.state.xAxis.range.scaleFactor / this.state.xAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  convert pixels to xVal by using settings from yAxis.range\n\t */\n\tpxToValueByYAxis(yVal: number) {\n\t\treturn yVal / this.state.yAxis.range.scaleFactor / this.state.yAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  returns x xVal by screen x coordinate\n\t */\n\tgetValueByScreenX(x: number): number {\n\t\tvar {zeroVal, scroll} = this.state.xAxis.range;\n\t\treturn zeroVal + scroll + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  returns y xVal by screen y coordinate\n\t */\n\tgetValueByScreenY(y: number): number {\n\t\tvar {zeroVal, scroll} = this.state.yAxis.range;\n\t\treturn zeroVal + scroll + this.pxToValueByYAxis(y);\n\t}\n\n\n\t/**\n\t *  returns screen x xVal by screen y coordinate\n\t */\n\tgetScreenXByValue(xVal: number): number {\n\t\tvar {scroll, zeroVal} = this.state.xAxis.range;\n\t\treturn this.valueToPxByXAxis(xVal - zeroVal - scroll)\n\t}\n\n\t/**\n\t *  returns screen y xVal by screen y coordinate\n\t */\n\tgetScreenYByValue(yVal: number): number {\n\t\tvar {scroll, zeroVal} = this.state.yAxis.range;\n\t\treturn this.valueToPxByYAxis(yVal - zeroVal - scroll)\n\t}\n\n\n\t/**\n\t * returns screen x coordinate by offset in pixels from xAxis.range.zeroVal xVal\n\t */\n\tgetScreenXByPoint(xVal: number): number {\n\t\treturn this.getScreenXByValue(this.getValueOnXAxis(xVal));\n\t}\n\n\n\t/**\n\t * returns offset in pixels from xAxis.range.zeroVal xVal by screen x coordinate\n\t */\n\tgetPointByScreenX(screenX: number): number {\n\t\treturn this.getPointOnXAxis(this.getValueByScreenX(screenX));\n\t}\n\n\n\tgetPointOnChart(xVal: number, yVal: number): Vector3 {\n\t\treturn new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\n\t}\n\n\n\tgetScreenLeftVal() {\n\t\treturn this.getValueByScreenX(0);\n\t}\n\n\n\tgetScreenRightVal() {\n\t\treturn this.getValueByScreenX(this.state.width);\n\t}\n\n\n\t// getPaddingRight(): number {\n\t// \treturn this.getValueByScreenX(\n\t// \t\tthis.state.width - this.state.xAxis.range.padding.end);\n\t// }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Chart.ts\n **/","import {Chart, IChartState} from \"./Chart\";\nimport {Utils} from \"./Utils\";\nimport {TrendSegmentsManager} from \"./TrendSegmentsManager\";\nimport {EventEmitter} from './EventEmmiter';\nimport {Promise} from './deps/deps';\nimport { TColor } from './Color';\n\nexport interface IPrependPromiseExecutor {\n\t(requestedDataLength: number, resolve: (data: TTrendRawData) => void, reject: () => void): void;\n}\nconst EVENTS = {\n\tCHANGE: 'Change',\n\tPREPEND_REQUEST: 'prependRequest'\n};\nexport enum TREND_TYPE {LINE, CANDLE}\nexport type TTrendRawData = ITrendData | number[];\nexport interface ITrendItem {xVal: number, yVal: number, id?: number}\nexport interface ITrendData extends Array<ITrendItem>{}\nexport interface ITrendTypeSettings {\n\tminSegmentLengthInPx?: number;\n\tmaxSegmentLengthInPx?: number;\n}\nexport interface ITrendOptions {\n\tenabled?: boolean,\n\tdata?: ITrendData\n\tdataset?: ITrendData | number[];\n\tname?: string;\n\ttype?: TREND_TYPE;\n\tlineWidth?: number;\n\tlineColor?: TColor;\n\tbackgroundColor?: TColor;\n\thasIndicator?: boolean;\n\thasBackground?: boolean;\n\thasBeacon?: boolean;\n\tmaxSegmentLength?: number;\n\tsettingsForTypes?: {\n\t\tCANDLE?: ITrendTypeSettings,\n\t\tLINE?: ITrendTypeSettings\n\t}\n}\n\nexport class Trend {\n\tname: string;\n\tsegmentsManager: TrendSegmentsManager;\n\tminXVal = Infinity;\n\tminYVal = Infinity;\n\tmaxXVal = -Infinity;\n\tmaxYVal = -Infinity;\n\tprivate chart: Chart;\n\tprivate calculatedOptions: ITrendOptions;\n\tprivate prependRequest: Promise<TTrendRawData>;\n\tprivate ee: EventEmitter;\n\t\n\tconstructor(chartState: Chart, trendName: string, initialState: IChartState) {\n\t\tvar options = initialState.trends[trendName];\n\t\tthis.name = trendName;\n\t\tthis.chart = chartState;\n\t\tthis.calculatedOptions = Utils.deepMerge(this.chart.state.trendDefaultState, options);\n\t\tthis.calculatedOptions.name = trendName;\n\t\tif (options.dataset) this.calculatedOptions.data = Trend.prepareData(options.dataset);\n\t\tthis.calculatedOptions.dataset = [];\n\t\tthis.ee = new EventEmitter();\n\t\tthis.segmentsManager = new TrendSegmentsManager(this.chart, this);\n\t\tthis.bindEvents();\n\t}\n\n\t// private onInitialStateApplied() {\n\t// \tthis.segmentsManager = new TrendSegmentsManager(this.chart, this);\n\t// }\n\n\tprivate bindEvents() {\n\t\tvar chartState = this.chart;\n\t\t// chart.onInitialStateApplied(() => this.onInitialStateApplied());\n\t\tchartState.onDragStateChanged(() => this.checkForPrependRequest());\n\t\tchartState.onZoom(() => this.checkForPrependRequest());\n\t\tchartState.onTrendChange((trendName, changedOptions, newData) => this.ee.emit(EVENTS.CHANGE, changedOptions, newData));\n\t\tchartState.onDestroy(() => this.ee.removeAllListeners());\n\t}\n\n\tgetCalculatedOptions() {\n\t\treturn this.calculatedOptions;\n\t}\n\n\tappendData(rawData: TTrendRawData) {\n\t\tvar options = this.getOptions();\n\t\tvar newData = Trend.prepareData(rawData, this.getData());\n\t\tvar updatedTrendData = options.data.concat(newData);\n\t\tthis.changeData(updatedTrendData, newData);\n\t}\n\n\tprependData(rawData: TTrendRawData) {\n\t\tvar options = this.getOptions();\n\t\tvar newData = Trend.prepareData(rawData, this.getData(), true);\n\t\tvar updatedTrendData = newData.concat(options.data);\n\t\tthis.changeData(updatedTrendData, newData);\n\t}\n\n\tprivate changeData(allData: ITrendData, newData: ITrendData) {\n\t\tfor (let item of newData) {\n\t\t\tif (item.xVal < this.minXVal) this.minXVal = item.xVal;\n\t\t\tif (item.xVal > this.maxXVal) this.maxXVal = item.xVal;\n\t\t\tif (item.yVal < this.minYVal) this.minYVal = item.yVal;\n\t\t\tif (item.yVal > this.maxYVal) this.maxYVal = item.yVal;\n\t\t}\n\t\tvar options = this.getOptions();\n\t\tvar statePatch: IChartState = {trends: {[options.name]: {data: allData}}};\n\t\tthis.chart.setState(statePatch, newData);\n\t}\n\t\n\tgetData(fromX?: number, toX?: number): ITrendData {\n\t\tvar data = this.getOptions().data;\n\t\tif (fromX == void 0 && toX == void 0) return data;\n\n\t\tfromX = fromX !== void 0 ? fromX : data[0].xVal;\n\t\ttoX = toX !== void 0 ? toX : data[data.length].xVal;\n\t\tvar filteredData: ITrendData = [];\n\t\tfor (let item of data) {\n\t\t\tif (item.xVal < fromX) continue;\n\t\t\tif (item.xVal > toX) break;\n\t\t\tfilteredData.push(item)\n\t\t}\n\t\treturn filteredData;\n\t}\n\n\tgetFirstItem(): ITrendItem {\n\t\treturn this.getOptions().data[0];\n\t}\n\t\n\tgetLastItem(): ITrendItem {\n\t\tvar data = this.getOptions().data;\n\t\treturn data[data.length - 1];\n\t}\n\n\tgetOptions() {\n\t\treturn this.chart.state.trends[this.name]\n\t}\n\n\tsetOptions(options: ITrendOptions) {\n\t\tthis.chart.setState({trends: {[this.name]: options}});\n\t}\n\n\tonPrependRequest(cb: IPrependPromiseExecutor): Function {\n\t\tthis.ee.on(EVENTS.PREPEND_REQUEST, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(EVENTS.PREPEND_REQUEST, cb);\n\t\t}\n\t}\n\n\t/**\n\t * shortcut for Chart.onTrendChange\n\t */\n\tonChange(cb: (changedOptions: ITrendOptions, newData: ITrendData) => void): Function {\n\t\tthis.ee.on(EVENTS.CHANGE, cb);\n\t\treturn () => { this.ee.off(EVENTS.CHANGE, cb);}\n\t}\n\n\tonDataChange(cb: (newData: ITrendData) => void): Function {\n\t\tvar onChangeCb = (changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tif (newData) cb(newData);\n\t\t};\n\t\tthis.ee.on(EVENTS.CHANGE, onChangeCb);\n\t\treturn () => {\n\t\t\tthis.ee.off(EVENTS.CHANGE, onChangeCb);\n\t\t}\n\t}\n\n\tprivate checkForPrependRequest() {\n\t\tif (this.prependRequest) return;\n\t\tvar chartState = this.chart;\n\t\tvar minXVal = chartState.state.computedData.trends.minXVal;\n\t\tvar minScreenX = chartState.getScreenXByValue(minXVal);\n\t\tvar needToRequest = minScreenX > 0;\n\t\tvar {from, to} = chartState.state.xAxis.range;\n\t\tvar requestedDataLength = to - from;\n\t\tif (!needToRequest) return;\n\t\t\n\t\tthis.prependRequest = new Promise<TTrendRawData>((resolve: Function, reject: Function) => {\n\t\t\tthis.ee.emit(EVENTS.PREPEND_REQUEST, requestedDataLength, resolve, reject);\n\t\t});\n\n\t\tthis.prependRequest.then((newData: TTrendRawData) => {\n\t\t\tthis.prependData(newData);\n\t\t\tthis.prependRequest = null;\n\t\t}, () => {\n\t\t\tthis.prependRequest = null;\n\t\t})\n\t\n\t}\n\n\tstatic prepareData (newData: TTrendRawData, currentData?: ITrendData, isPrepend = false): ITrendData {\n\t\tvar data: ITrendData = [];\n\t\tif (typeof newData[0] == 'number') {\n\t\t\tcurrentData = currentData || [];\n\t\t\tlet initialItem: ITrendItem;\n\t\t\tlet xVal: number;\n\t\t\tif (isPrepend) {\n\t\t\t\tinitialItem = currentData[0];\n\t\t\t\txVal = initialItem.xVal - newData.length;\n\t\t\t} else {\n\t\t\t\tinitialItem = currentData[currentData.length - 1];\n\t\t\t\txVal = initialItem ? initialItem.xVal + 1 : 0;\n\t\t\t}\n\t\t\tfor (let yVal of newData as number[]) {\n\t\t\t\tdata.push({xVal: xVal, yVal: yVal, id: Utils.getUid()});\n\t\t\t\txVal++;\n\t\t\t}\n\t\t} else {\n\t\t\tdata = newData as ITrendData;\n\t\t}\n\t\treturn data;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Trend.ts\n **/","import { IIteralable } from \"./interfaces\";\nimport { EventEmitter } from './EventEmmiter';\nimport { Chart } from \"./Chart\";\nimport Vector3 = THREE.Vector3;\nimport { ITrendData, ITrendOptions, ITrendItem, Trend, TREND_TYPE, ITrendTypeSettings } from \"./Trend\";\nimport { Utils } from \"./Utils\";\n\nconst MAX_ANIMATED_SEGMENTS = 100;\nconst EVENTS = {\n\tREBUILD: 'rebuild',\n\tDISLPAYED_RANGE_CHANGED: 'displayedRangeChanged',\n\tANIMATION_FRAME: 'animationFrame'\n};\n\n/**\n *  Class helps to display and animate trends segments\n */\nexport class TrendSegmentsManager {\n\tsegmentsById: {[id: string]: TrendSegment} = {};\n\tsegments: TrendSegment[] = [];\n\tchart: Chart;\n\tanimatedSegmentsIds: number[] = [];\n\tmaxSegmentLength: number;\n\tsegmentsLength = 0;\n\tfirstDisplayedSegmentInd: number;\n\tfirstDisplayedSegment: TrendSegment;\n\tlastDisplayedSegmentInd: number;\n\tlastDisplayedSegment: TrendSegment;\n\tprivate appendAnimation: TweenLite;\n\tprivate prependAnimation: TweenLite;\n\tprivate animatedSegmentsForAppend: number[] = [];\n\tprivate animatedSegmentsForPrepend: number[] = [];\n\tprivate nextEmptyId = 0;\n\tprivate startSegmentId = 0;\n\tprivate endSegmentId = 0;\n\tprivate trend: Trend;\n\tprivate ee: EventEmitter;\n\n\t// TODO: make subscriptions array\n\tprivate unbindList: Function[] = [];\n\n\tconstructor (chart: Chart, trend: Trend) {\n\t\tthis.chart = chart;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.trend = trend;\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.trend.onChange((changedOptions, newData) => this.onTrendChangeHandler(changedOptions, newData));\n\t\tthis.unbindList = [\n\t\t\tthis.chart.onInitialStateApplied(() => this.onInitialStateAppliedHandler()),\n\t\t\tthis.chart.onZoom(() => this.onZoomHandler()),\n\t\t\tthis.chart.onScroll(() => this.recalculateDisplayedRange()),\n\t\t\tthis.chart.onDestroy(() => this.onDestroyHandler())\n\t\t]\n\t}\n\n\tprivate unbindEvents() {\n\t\tthis.unbindList.forEach(unbind => unbind())\n\t}\n\n\tprivate onInitialStateAppliedHandler() {\n\t\tthis.maxSegmentLength = this.trend.getOptions().maxSegmentLength;\n\t\tthis.tryToRebuildSegments();\n\t}\n\n\tprivate onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t\tthis.unbindEvents();\n\t\tthis.appendAnimation && this.appendAnimation.kill();\n\t\tthis.prependAnimation && this.prependAnimation.kill();\n\t}\n\n\tprivate onZoomHandler() {\n\t\tlet segmentsRebuilded = this.tryToRebuildSegments();\n\t\tif (!segmentsRebuilded) {\n\t\t\tthis.recalculateDisplayedRange()\n\t\t}\n\t}\n\n\tprivate onTrendChangeHandler(changedOptions: ITrendOptions, newData: ITrendData) {\n\t\tvar needToRebuildSegments = (\n\t\t\tchangedOptions.type != void 0 ||\n\t\t\tchangedOptions.maxSegmentLength != void 0\n\t\t);\n\n\n\t\tif (needToRebuildSegments) {\n\t\t\tthis.tryToRebuildSegments(true);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!newData) return;\n\n\t\tvar data = this.trend.getData();\n\t\tvar isAppend = (!data.length || data[0].xVal < newData[0].xVal);\n\t\tisAppend ? this.appendData(newData) : this.prependData(newData);\n\t\tthis.recalculateDisplayedRange();\n\t}\n\n\tgetSegment(id: number) {\n\t\treturn this.segmentsById[id];\n\t}\n\n\tgetEndSegment(): TrendSegment {\n\t\treturn this.segmentsById[this.endSegmentId];\n\t}\n\n\tgetStartSegment(): TrendSegment {\n\t\treturn this.segmentsById[this.startSegmentId];\n\t}\n\t\n\tprivate tryToRebuildSegments(force = false): boolean {\n\t\tlet options = this.trend.getOptions();\n\t\tlet trendTypeName = TREND_TYPE[options.type] as string;\n\t\tlet trendTypesSettings =  options.settingsForTypes as IIteralable;\n\t\tlet trendTypeSettings = trendTypesSettings[trendTypeName] as ITrendTypeSettings;\n\t\tlet {\n\t\t\tminSegmentLengthInPx,\n\t\t\tmaxSegmentLengthInPx\n\t\t} = trendTypeSettings;\n\n\t\tlet needToRebuild = this.segments.length === 0 || force;\n\t\tlet segmentLength = this.maxSegmentLength;\n\n\t\t// call toFixed(2) to prevent floating segment error compare\n\t\tlet currentSegmentLengthInPx = Number(this.chart.valueToPxByXAxis(segmentLength).toFixed(2));\n\t\tlet currentMaxSegmentLengthInPx = Number(this.chart.valueToPxByXAxis(this.maxSegmentLength).toFixed(2));\n\n\t\tif (currentSegmentLengthInPx < minSegmentLengthInPx) {\n\t\t\tneedToRebuild = true;\n\t\t\tsegmentLength = Math.ceil(this.chart.pxToValueByXAxis(maxSegmentLengthInPx));\n\t\t} else if (currentMaxSegmentLengthInPx > maxSegmentLengthInPx) {\n\t\t\tneedToRebuild = true;\n\t\t\tsegmentLength = this.chart.pxToValueByXAxis(minSegmentLengthInPx);\n\t\t}\n\n\t\tif (!needToRebuild) return false;\n\n\t\tthis.maxSegmentLength = segmentLength;\n\t\tthis.segmentsById = {};\n\t\tthis.segments = [];\n\t\tthis.nextEmptyId = 0;\n\t\tthis.startSegmentId = 0;\n\t\tthis.endSegmentId = 0;\n\t\tthis.segmentsLength = 0;\n\t\tthis.stopAllAnimations();\n\t\tthis.appendData(null, true);\n\t\tthis.recalculateDisplayedRange(true);\n\t\tthis.ee.emit(EVENTS.REBUILD);\n\t}\n\n\tprivate stopAllAnimations() {\n\t\tthis.animatedSegmentsIds = [];\n\t\tthis.animatedSegmentsForAppend = [];\n\t\tthis.animatedSegmentsForAppend = [];\n\t\tif (this.prependAnimation) this.prependAnimation.kill();\n\t\tif (this.appendAnimation) this.appendAnimation.kill();\n\t}\n\t\n\tprivate recalculateDisplayedRange(segmentsAreRebuilded = false) {\n\t\tvar {from, to} = this.chart.state.xAxis.range;\n\t\tvar {firstDisplayedSegment, lastDisplayedSegment} = this;\n\t\tvar displayedRange = to - from;\n\n\t\tthis.firstDisplayedSegmentInd = Utils.binarySearchClosestInd(this.segments, from - displayedRange, 'startXVal');\n\t\tthis.firstDisplayedSegment = this.segments[this.firstDisplayedSegmentInd];\n\t\tthis.lastDisplayedSegmentInd = Utils.binarySearchClosestInd(this.segments, to + displayedRange, 'endXVal');\n\t\tthis.lastDisplayedSegment = this.segments[this.lastDisplayedSegmentInd];\n\t\tif (segmentsAreRebuilded) return;\n\n\t\tvar displayedRangeChanged = (\n\t\t\tfirstDisplayedSegment.id !== this.firstDisplayedSegment.id ||\n\t\t\tlastDisplayedSegment.id !== this.lastDisplayedSegment.id\n\t\t);\n\t\tif (displayedRangeChanged) this.ee.emit(EVENTS.DISLPAYED_RANGE_CHANGED);\n\t}\n\n\t// getSegments(fromX?: number, toX?: number): TrendSegment[] {\n\t// \tvar segments = this.segments;\n\t// \tif (fromX == void 0 && toX == void 0) return segments;\n\t// \tfromX = fromX !== void 0 ? fromX : segments[0].startXVal;\n\t// \ttoX = toX !== void 0 ? toX : segments[this.segmentsLength].endXVal;\n\t// \tvar startSegmentInd = Utils.closestBinarySearch(segments, fromX, 'xVal');\n\t// \tvar endSegmentInd = Utils.closestBinarySearch(segments, toX, 'xVal');\n\t// \treturn segments.slice(startSegmentInd, endSegmentInd);\n\t// }\n\n\t/**\n\t * returns array of segments for values array\n\t * values must be sorted!\n\t */\n\tgetSegmentsForXValues(values: number[]): TrendSegment[] {\n\t\tvar valueInd = 0;\n\t\tvar value = values[valueInd];\n\t\tvar lastValueInd = values.length - 1;\n\t\tvar results: TrendSegment[] = [];\n\t\tvar segment = this.getStartSegment();\n\t\tif (!segment.hasValue) return [];\n\t\twhile (segment) {\n\t\t\n\t\t\twhile (value < segment.startXVal) {\n\t\t\t\tresults.push(void 0);\n\t\t\t\tvalue = values[++valueInd];\n\t\t\t}\n\t\t\n\t\t\twhile (value > segment.endXVal) {\n\t\t\t\tsegment = segment.getNext();\n\t\t\t\tif (!segment) break;\n\t\t\t}\n\t\t\n\t\t\tvar valueInPoint = (\n\t\t\t\tsegment.startXVal == value || segment.endXVal == value ||\n\t\t\t\t(segment.startXVal < value && segment.endXVal > value)\n\t\t\t);\n\t\t\tif (valueInPoint) {\n\t\t\t\tresults.push(segment);\n\t\t\t\tvalue = values[++valueInd];\n\t\t\t}\n\t\t\tif (valueInd > lastValueInd) break;\n\t\t}\n\t\treturn results;\n\t}\n\n\tonAnimationFrame(cb: (animationState: TrendSegmentsManager) => void): Function {\n\t\treturn this.ee.subscribe(EVENTS.ANIMATION_FRAME, cb);\n\t}\n\n\tonRebuild(cb: Function) {\n\t\treturn this.ee.subscribe(EVENTS.REBUILD, cb);\n\t}\n\n\tonDisplayedRangeChanged(cb: Function) {\n\t\treturn this.ee.subscribe(EVENTS.DISLPAYED_RANGE_CHANGED, cb);\n\t}\n\t\n\tallocateNextSegment() {\n\t\tvar id = this.nextEmptyId++;\n\t\tvar segment = new TrendSegment(this, id);\n\t\tvar prevSegment = this.segmentsById[this.endSegmentId];\n\t\tif (prevSegment && prevSegment.hasValue) {\n\t\t\tprevSegment.nextId = id;\n\t\t\tsegment.prevId = prevSegment.id;\n\t\t}\n\t\tthis.endSegmentId = id;\n\t\tthis.segmentsLength++;\n\t\tthis.segmentsById[id] = segment;\n\t\tthis.segments.push(segment);\n\t\treturn segment;\n\t}\n\n\tallocatePrevSegment() {\n\t\tvar id = this.nextEmptyId++;\n\t\tvar segment = new TrendSegment(this, id);\n\t\tvar nextSegment = this.segmentsById[this.startSegmentId];\n\t\tif (nextSegment && nextSegment.hasValue) {\n\t\t\tnextSegment.prevId = id;\n\t\t\tsegment.nextId = nextSegment.id;\n\t\t}\n\t\tthis.startSegmentId = id;\n\t\tthis.segmentsLength++;\n\t\tthis.segmentsById[id] = segment;\n\t\tthis.segments.unshift(segment);\n\t\treturn segment;\n\t}\n\n\tprivate appendData(newData: ITrendData, needRebuildSegments = false) {\n\n\t\t// WARNING: bottleneck method!\n\n\t\t// var t1 = performance.now();\n\t\tvar trendData = this.trend.getData();\n\t\tif (needRebuildSegments) {\n\t\t\tnewData = trendData;\n\t\t\tthis.animatedSegmentsForAppend = [];\n\t\t}\n\n\t\tvar startItemInd = trendData.length - newData.length;\n\t\tvar segment = this.getEndSegment() || this.allocateNextSegment();\n\t\tvar initialSegment = segment.hasValue ? segment : null;\n\t\tvar initialAnimationState = segment.createAnimationState();\n\t\tvar itemInd = 0;\n\t\twhile (itemInd < newData.length) {\n\t\t\tlet item = newData[itemInd];\n\t\t\tlet itemIsInserted = segment.appendItem(item);\n\t\t\tlet isLastItem = itemInd == newData.length - 1;\n\n\t\t\tif (itemIsInserted) {\n\t\t\t\tif (!isLastItem) itemInd++;\n\t\t\t} else {\n\t\t\t\tif (!segment.isCompleted) segment.complete();\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) {\n\t\t\t\tsegment.recalculateItems();\n\t\t\t}\n\n\t\t\tlet segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\n\t\t\tif (segmentIsReadyForAnimate) {\n\t\t\t\tlet id = segment.id;\n\t\t\t\tif (!initialSegment) initialSegment = segment;\n\t\t\t\tif (!initialAnimationState) {\n\t\t\t\t\tinitialAnimationState = initialSegment.createAnimationState();\n\t\t\t\t}\n\n\t\t\t\tsegment.initialAnimationState = Utils.deepMerge({}, initialAnimationState);\n\n\t\t\t\tif (this.animatedSegmentsForAppend.length > 0) {\n\t\t\t\t\tsegment.initialAnimationState.startXVal = initialAnimationState.endXVal;\n\t\t\t\t\tsegment.initialAnimationState.startYVal = initialAnimationState.endYVal;\n\t\t\t\t}\n\n\t\t\t\tsegment.currentAnimationState =  Utils.deepMerge({}, initialAnimationState);\n\t\t\t\tsegment.targetAnimationState = segment.createAnimationState();\n\t\t\t\tthis.animatedSegmentsForAppend.push(id);\n\n\t\t\t}\n\n\n\t\t\tif (isLastItem && itemIsInserted) break;\n\t\t\tif (!segment.isCompleted) continue;\n\n\t\t\tsegment = this.allocateNextSegment();\n\t\t\tlet prevItem = trendData[startItemInd + itemInd - 1];\n\t\t\tsegment.appendItem(prevItem);\n\n\t\t}\n\n\t\tvar animationsOptions = this.chart.state.animations;\n\t\tvar time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\n\n\t\t// var t2 = performance.now();\n\t\t// console.log(t2 - t1);\n\n\t\t// do not create animation if segments was rebuilded\n\t\tif (needRebuildSegments) {\n\t\t\tfor (let segmentId of this.animatedSegmentsForAppend) {\n\t\t\t\tlet segment = this.segmentsById[segmentId];\n\t\t\t\tsegment.currentAnimationState = segment.createAnimationState();\n\t\t\t}\n\t\t\tthis.animatedSegmentsForAppend = [];\n\t\t\treturn;\n\t\t}\n\t\tif (this.animatedSegmentsForAppend.length > MAX_ANIMATED_SEGMENTS) time = 0;\n\t\tthis.animate(time);\n\t}\n\n\n\t// TODO: refactor duplicated code from appendData\n\tprivate prependData(newData: ITrendData) {\n\t\tvar trendData = this.trend.getData();\n\t\tvar segment = this.getStartSegment() || this.segmentsById[0];\n\t\tvar initialSegment = segment.hasValue ? segment : null;\n\t\tvar itemInd = newData.length - 1;\n\t\tvar initialAnimationState = segment.createAnimationState();\n\t\twhile (itemInd >= 0) {\n\t\t\tlet item = newData[itemInd];\n\t\t\tlet itemIsInserted = segment.prependItem(item);\n\t\t\tlet isLastItem = itemInd == 0;\n\n\t\t\tif (itemIsInserted) {\n\t\t\t\tif (!isLastItem) itemInd--;\n\t\t\t} else {\n\t\t\t\tif (!segment.isCompleted) segment.complete();\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) {\n\t\t\t\tsegment.recalculateItems();\n\t\t\t}\n\n\t\t\tlet segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\n\t\t\tif (segmentIsReadyForAnimate) {\n\t\t\t\tlet id = segment.id;\n\t\t\t\tif (!initialSegment) initialSegment = segment;\n\t\t\t\tif (!initialAnimationState) initialAnimationState = initialSegment.createAnimationState();\n\n\t\t\t\tsegment.initialAnimationState = Utils.deepMerge({}, initialAnimationState);\n\t\t\t\tif (this.animatedSegmentsForPrepend.length > 0) {\n\t\t\t\t\tsegment.initialAnimationState.endXVal = initialAnimationState.startXVal;\n\t\t\t\t\tsegment.initialAnimationState.endYVal =  initialAnimationState.startYVal;\n\t\t\t\t}\n\n\t\t\t\tsegment.targetAnimationState = segment.createAnimationState();\n\t\t\t\tthis.animatedSegmentsForPrepend.push(id);\n\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) break;\n\t\t\tif (!segment.isCompleted) continue;\n\n\t\t\tsegment = this.allocatePrevSegment();\n\t\t\tlet nextItem = trendData[itemInd + 1];\n\t\t\tsegment.prependItem(nextItem);\n\n\t\t}\n\n\t\tvar animationsOptions = this.chart.state.animations;\n\t\tvar time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\n\n\t\tif (this.animatedSegmentsForPrepend.length > MAX_ANIMATED_SEGMENTS) time = 0;\n\t\tthis.animate(time, true);\n\t}\n\n\tprivate animate(time: number, isPrepend = false) {\n\n\t\tvar animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\n\t\tvar animation = isPrepend ? this.prependAnimation : this.appendAnimation;\n\n\t\tif ((animation && animation.isActive()) || time == 0) {\n\t\t\tif (animation) animation.kill();\n\t\t\tthis.onAnimationFrameHandler(1, isPrepend);\n\t\t\tanimatedSegmentsIds.length = 0;\n\t\t\treturn;\n\t\t}\n\t\tvar animationsOptions = this.chart.state.animations;\n\t\tvar ease = animationsOptions.trendChangeEase;\n\t\tvar objectToAnimate = {animationValue: 0};\n\t\tanimation = TweenLite.to(objectToAnimate, time, {animationValue: 1, ease});\n\t\tanimation.eventCallback('onUpdate', () => this.onAnimationFrameHandler(objectToAnimate.animationValue, isPrepend));\n\t\tanimation.eventCallback('onComplete', () => {\n\t\t\tanimatedSegmentsIds.length = 0;\n\t\t\tthis.appendAnimation = null;\n\t\t});\n\n\t\tif (isPrepend) {\n\t\t\tthis.prependAnimation = animation;\n\t\t} else {\n\t\t\tthis.appendAnimation = animation;\n\t\t}\n\t}\n\n\tprivate onAnimationFrameHandler(coefficient: number, isPrepend = false) {\n\t\tlet animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\n\t\tfor (let segmentId of animatedSegmentsIds) {\n\t\t\tlet segment = this.segmentsById[segmentId];\n\t\t\tfor (let key in segment.targetAnimationState) {\n\t\t\t\tlet targetValue = segment.targetAnimationState[key] as number;\n\t\t\t\tlet initialValue = segment.initialAnimationState[key] as number;\n\t\t\t\tlet currentValue = initialValue + (targetValue - initialValue) * coefficient;\n\t\t\t\tsegment.currentAnimationState[key] = currentValue;\n\t\t\t}\n\t\t}\n\t\tthis.animatedSegmentsIds = this.animatedSegmentsForAppend.concat(this.animatedSegmentsForPrepend);\n\t\tthis.ee.emit(EVENTS.ANIMATION_FRAME, this);\n\t}\n\n}\n\nexport interface ITrendSegmentState extends IIteralable {\n\txVal?: number;\n\tyVal?: number;\n\tstartXVal?: number;\n\tstartYVal?: number;\n\tendXVal?: number;\n\tendYVal?: number;\n\tmaxYVal?: number;\n\tminYVal?: number;\n\tmaxLength?: number;\n}\n\nexport class TrendSegment implements ITrendSegmentState {\n\tid: number;\n\tprevId: number;\n\tnextId: number;\n\thasValue: boolean;\n\txVal: number;\n\tyVal: number;\n\tstartXVal: number;\n\tstartYVal: number;\n\tendXVal: number;\n\tendYVal: number;\n\tmaxYVal: number;\n\tminYVal: number;\n\tisCompleted = false;\n\tmaxLength: number;\n\titems: ITrendItem[] = [];\n\n\tinitialAnimationState: ITrendSegmentState = {};\n\ttargetAnimationState: ITrendSegmentState = {};\n\tcurrentAnimationState: ITrendSegmentState = {};\n\n\tprivate trendSegments: TrendSegmentsManager;\n\t\n\tconstructor(trendPoints: TrendSegmentsManager, id: number) {\n\t\tthis.trendSegments = trendPoints;\n\t\tthis.id = id;\n\t\tthis.maxLength = trendPoints.maxSegmentLength;\n\t}\n\n\tcreateAnimationState(): ITrendSegmentState {\n\t\tvar {\n\t\t\txVal,\n\t\t\tyVal,\n\t\t\tstartXVal,\n\t\t\tstartYVal,\n\t\t\tendXVal,\n\t\t\tendYVal,\n\t\t\tmaxYVal,\n\t\t\tminYVal,\n\t\t\tmaxLength\n\t\t} = this;\n\t\treturn {\n\t\t\txVal,\n\t\t\tyVal,\n\t\t\tstartXVal,\n\t\t\tstartYVal,\n\t\t\tendXVal,\n\t\t\tendYVal,\n\t\t\tmaxYVal,\n\t\t\tminYVal,\n\t\t\tmaxLength\n\t\t}\n\t};\n\t\n\tappendItem(item: ITrendItem): boolean {\n\t\tif (this.isCompleted) return false;\n\n\t\tvar items = this.items;\n\t\tif (items.length < 2) {\n\t\t\tthis.items.push(item);\n\t\t\tthis.hasValue = true;\n\t\t\treturn true;\n\t\t}\n\t\tvar startXVal = items[0].xVal;\n\t\tif (item.xVal - startXVal > this.maxLength) return false;\n\t\titems.push(item);\n\t\treturn true;\n\t}\n\n\tprependItem(item: ITrendItem): boolean {\n\t\tif (this.isCompleted) return false;\n\t\tvar items = this.items;\n\t\tif (items.length < 2) {\n\t\t\tthis.items.unshift(item);\n\t\t\tthis.hasValue = true;\n\t\t\treturn true;\n\t\t}\n\t\tvar endXVal = items[items.length - 1].xVal;\n\t\tif (endXVal - item.xVal > this.maxLength) return false;\n\t\titems.unshift(item);\n\t\treturn true;\n\t}\n\n\tcomplete() {\n\t\tthis.isCompleted = true;\n\t\tthis.recalculateItems();\n\t\tthis.items = []; // free memory for completed ranges\n\t}\n\n\trecalculateItems() {\n\t\tlet items = this.items;\n\t\tlet itemsLength = items.length;\n\t\tif (itemsLength === 0) Utils.error('Unable to create TrendSegment without TrendItems');\n\t\tlet endItem = items[itemsLength - 1];\n\t\tlet {xVal: endXVal, yVal: endYVal} = endItem;\n\t\tlet startXVal: number, startYVal: number;\n\n\n\t\tlet startItem = items[0];\n\t\tstartXVal = startItem.xVal;\n\t\tstartYVal = startItem.yVal;\n\n\t\tlet minX = Math.min(startXVal, endXVal);\n\t\tlet maxX = Math.max(startXVal, endXVal);\n\t\tlet middleXVal = minX + (maxX - minX) / 2;\n\n\t\tlet minY = Math.min(startYVal, endYVal);\n\t\tlet maxY = Math.max(startYVal, endYVal);\n\t\tlet middleYVal = minY + (maxY - minY) / 2;\n\n\t\tlet yVals = items.map(item => item.yVal);\n\n\t\tthis.startXVal = startXVal;\n\t\tthis.startYVal = startYVal;\n\t\tthis.endXVal = endXVal;\n\t\tthis.endYVal = endYVal;\n\t\tthis.xVal = middleXVal;\n\t\tthis.yVal = middleYVal;\n\t\tthis.maxYVal = Math.max(...yVals);\n\t\tthis.minYVal = Math.min(...yVals);\n\t\tthis.currentAnimationState = this.createAnimationState();\n\t}\n\n\tgetNext() {\n\t\tvar nextPoint = this.trendSegments.segmentsById[this.nextId];\n\t\treturn nextPoint && nextPoint.hasValue ? nextPoint : null;\n\t}\n\n\tgetPrev() {\n\t\tvar prevPoint = this.trendSegments.segmentsById[this.prevId];\n\t\treturn prevPoint && prevPoint.hasValue ? prevPoint : null;\n\t}\n\t\n\tgetFrameVal(): Vector3 {\n\t\tlet {xVal, yVal} = this.createAnimationState();\n\t\treturn new Vector3(xVal, yVal, 0);\n\t}\n\n\tgetFramePoint(): Vector3 {\n\t\tvar frameVal = this.getFrameVal();\n\t\treturn this.trendSegments.chart.screen.getPointOnChart(frameVal.x, frameVal.y);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/TrendSegmentsManager.ts\n **/","\nimport {Trend, ITrendOptions} from \"./Trend\";\nimport {Chart, IChartState} from \"./Chart\";\nimport { EventEmitter } from './EventEmmiter';\n\nexport interface ITrendsOptions {\n\t[trendName: string]: ITrendOptions;\n}\n\nconst EVENTS = {\n\tSEGMENTS_REBUILDED: 'segmentsRebuilded'\n};\n\n/**\n * Trends manager\n */\nexport class TrendsManager {\n\ttrends: {[name: string]: Trend} = {};\n\tcalculatedOptions: ITrendsOptions;\n\tprivate ee = new EventEmitter();\n\tprivate chartState: Chart;\n\t\n\tconstructor(state: Chart, initialState: IChartState) {\n\t\tthis.chartState = state;\n\t\tvar trendsCalculatedOptions: ITrendsOptions = {};\n\t\tfor (let trendName in initialState.trends) {\n\t\t\tlet trend = this.createTrend(state, trendName, initialState);\n\t\t\ttrendsCalculatedOptions[trendName] = trend.getCalculatedOptions();\n\t\t}\n\t\tthis.calculatedOptions = trendsCalculatedOptions;\n\t}\n\n\tgetTrend(trendName: string) {\n\t\treturn this.trends[trendName];\n\t}\n\t\n\tgetEnabledTrends(): Trend[] {\n\t\tvar enabledTrends: Trend[] = [];\n\t\tvar allTrends = this.trends;\n\t\tfor (let trendName in allTrends) {\n\t\t\tlet trend = allTrends[trendName];\n\t\t\ttrend.getOptions().enabled && enabledTrends.push(trend);\n\t\t}\n\t\treturn enabledTrends;\n\t}\n\n\n\tgetStartXVal() {\n\t\tvar trends = this.getEnabledTrends();\n\t\treturn trends[0].getData()[0].xVal;\n\t}\n\n\n\tgetEndXVal(): number {\n\t\tvar trends = this.getEnabledTrends();\n\t\tvar firstTrendData = trends[0].getData();\n\t\treturn firstTrendData[firstTrendData.length - 1].xVal;\n\t}\n\t\n\t\n\tgetExtremumYVal(extremumIsMax: boolean, fromX?: number, toX?: number) {\n\t\tvar trends = this.getEnabledTrends();\n\t\tvar compareFn: Function;\n\t\tvar result: number;\n\t\tif (extremumIsMax) {\n\t\t\tresult = -Infinity;\n\t\t\tcompareFn = Math.max;\n\t\t} else {\n\t\t\tresult = Infinity;\n\t\t\tcompareFn = Math.min;\n\t\t}\n\t\tfor (let trend of trends) {\n\t\t\tvar trendData = trend.getData(fromX, toX);\n\t\t\tvar trendYValues = trendData.map((dataItem) => dataItem.yVal);\n\t\t\tresult = compareFn(result, ...trendYValues);\n\t\t}\n\t\tif (result == Infinity || result == -Infinity) result = NaN;\n\t\treturn result;\n\t}\n\n\tgetMaxYVal(fromX?: number, toX?: number) {return this.getExtremumYVal(true, fromX, toX)}\n\tgetMinYVal(fromX?: number, toX?: number) {return this.getExtremumYVal(false, fromX, toX)}\n\n\tonSegmentsRebuilded(cb: (trendName: string) => any) {\n\t\treturn this.ee.subscribe(EVENTS.SEGMENTS_REBUILDED, cb);\n\t}\n\n\tprivate createTrend(state: Chart, trendName: string, initialState: IChartState): Trend {\n\t\tlet trend = new Trend(state, trendName, initialState);\n\t\tthis.trends[trendName] = trend;\n\t\ttrend.segmentsManager.onRebuild(() => this.ee.emit(EVENTS.SEGMENTS_REBUILDED, trendName));\n\t\treturn trend;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/TrendsManager.ts\n **/","import PerspectiveCamera = THREE.PerspectiveCamera;\nimport Vector3 = THREE.Vector3;\nimport {Chart, IChartState} from \"./Chart\";\nimport { EventEmitter } from './EventEmmiter';\nimport { Animation } from './AnimationManager';\n\nexport interface IScreenTransformOptions {\n\tscrollXVal?: number,\n\tscrollYVal?: number,\n\tscrollX?: number,\n\tscrollY?: number,\n\tzoomX?: number,\n\tzoomY?: number\n}\n\nexport enum TRANSFORMATION_EVENT {\n\tSTARTED,\n\tFINISHED\n}\n\nconst SCREEN_EVENTS = {\n\tZOOM_FRAME: 'zoomFrame',\n\tSCROLL_FRAME: 'scrollFrame',\n\tTRANSFORMATION_FRAME: 'transformationFrame',\n\tTRANSFORMATION_EVENT: 'transformationStateChanged',\n};\n\n/**\n * manage camera, and contains methods for transforming pixels to values\n */\nexport class Screen {\n\t// TODO: !!! rename point coordinates to world coordinates\n\t// TODO: move all Chart metrics functions here\n\n\toptions: IScreenTransformOptions = {scrollXVal: 0, scrollX: 0, scrollYVal: 0, scrollY: 0, zoomX: 1, zoomY: 1};\n\ttransformationInProgress = false;\n\tprivate chart: Chart;\n\tprivate scrollXAnimation: Animation<number>;\n\tprivate scrollYAnimation: Animation<number>;\n\tprivate zoomXAnimation: Animation<number>;\n\tprivate zoomYAnimation: Animation<number>;\n\tprivate ee: EventEmitter;\n\n\tconstructor(chartState: Chart) {\n\t\tthis.chart = chartState;\n\t\tvar {width: w, height: h} = chartState.state;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.transform({\n\t\t\tscrollY: this.valueToPxByYAxis(this.chart.state.yAxis.range.scroll),\n\t\t\tzoomY: 1\n\t\t});\n\t\tthis.bindEvents();\n\n\t\t//camera.position.z = 1500;\n\t}\n\t\n\tgetCameraSettings() {\n\n\t\tvar {width: w, height: h} = this.chart.state;\n\n\t\t// settings for pixel-perfect camera\n\t\tvar FOV = 75;\n\t\tvar vFOV = FOV * (Math.PI / 180);\n\t\t\n\t\treturn {\n\t\t\tFOV: FOV,\n\t\t\taspect: w / h,\n\t\t\tnear: 0.1,\n\t\t\tfar: 5000,\n\t\t\tz: h / (2 * Math.tan(vFOV / 2) ),\n\n\t\t\t// move 0,0 to left-bottom corner\n\t\t\tx: w / 2,\n\t\t\ty: h / 2\n\t\t}\n\t}\n\n\tonZoomFrame(cb: (zoomX: number, zoomY: number) => any): Function {\n\t\treturn this.ee.subscribe(SCREEN_EVENTS.ZOOM_FRAME, cb);\n\t}\n\n\tonScrollFrame(cb: (options: IScreenTransformOptions) => any): Function {\n\t\treturn this.ee.subscribe(SCREEN_EVENTS.SCROLL_FRAME, cb);\n\t}\n\n\tonTransformationFrame(cb: (options: IScreenTransformOptions) => any): Function {\n\t\treturn this.ee.subscribe(SCREEN_EVENTS.TRANSFORMATION_FRAME, cb);\n\t}\n\n\tonTransformationEvent(cb: (event: TRANSFORMATION_EVENT) => any): Function {\n\t\treturn this.ee.subscribe(SCREEN_EVENTS.TRANSFORMATION_EVENT, cb);\n\t}\n\n\tcameraIsMoving(): boolean {\n\t\treturn !!(\n\t\t\tthis.scrollXAnimation && !this.scrollXAnimation.isFinished ||\n\t\t\t\tthis.zoomXAnimation && !this.zoomXAnimation.isFinished\n\t\t);\n\t}\n\n\t/**\n\t * setup zoom and scroll\n\t */\n\tprivate transform (options: IScreenTransformOptions, silent = false) {\n\t\tvar {scrollX, scrollY, zoomX, zoomY} = options;\n\t\t\n\t\tif (scrollX != void 0) this.options.scrollX = scrollX;\n\t\tif (scrollY != void 0) this.options.scrollY = scrollY;\n\t\tif (zoomX != void 0) this.options.zoomX = zoomX;\n\t\tif (zoomY != void 0) this.options.zoomY = zoomY;\n\n\t\tif (scrollX != void 0 || zoomX) {\n\t\t\toptions.scrollXVal = this.pxToValueByXAxis(scrollX != void 0 ? scrollX : this.options.scrollX);\n\t\t\tthis.options.scrollXVal = options.scrollXVal;\n\t\t}\n\n\t\tif (scrollY != void 0 || zoomY) {\n\t\t\toptions.scrollYVal = this.pxToValueByYAxis(scrollY != void 0 ? scrollY : this.options.scrollY);\n\t\t\tthis.options.scrollYVal = options.scrollYVal;\n\t\t}\n\n\t\tif (silent) return;\n\n\t\tlet hasActiveAnimations = (\n\t\t\t(this.scrollXAnimation && !this.scrollXAnimation.isStopped) ||\n\t\t\t(this.scrollYAnimation && !this.scrollYAnimation.isStopped) ||\n\t\t\t(this.zoomXAnimation && !this.zoomXAnimation.isStopped) ||\n\t\t\t(this.zoomYAnimation && !this.zoomYAnimation.isStopped)\n\t\t);\n\t\tlet transformationStarted = hasActiveAnimations && !this.transformationInProgress;\n\t\tlet transformationFinished = !hasActiveAnimations && this.transformationInProgress;\n\n\t\tif (transformationStarted) {\n\t\t\tthis.transformationInProgress = true;\n\t\t\tthis.ee.emit(SCREEN_EVENTS.TRANSFORMATION_EVENT, TRANSFORMATION_EVENT.STARTED);\n\t\t}\n\n\t\tif (transformationFinished) {\n\t\t\tthis.transformationInProgress = false;\n\t\t}\n\n\t\tif (!this.transformationInProgress) {\n\t\t\t// prevent to set camera between pixels\n\t\t\tthis.options.scrollX = options.scrollX = Math.round(this.options.scrollX);\n\t\t\tthis.options.scrollY = options.scrollY = Math.round(this.options.scrollY);\n\t\t}\n\n\t\tthis.ee.emit(SCREEN_EVENTS.TRANSFORMATION_FRAME, options);\n\n\t\tlet scrollEventNeeded = options.scrollXVal != void 0 || options.scrollYVal != void 0;\n\t\tif (scrollEventNeeded) this.ee.emit(SCREEN_EVENTS.SCROLL_FRAME, options);\n\n\t\tlet zoomEventNeeded = options.zoomX != void 0 || options.zoomY != void 0;\n\t\tif (zoomEventNeeded) this.ee.emit(SCREEN_EVENTS.ZOOM_FRAME, options);\n\n\t\tif (transformationFinished) {\n\t\t\tthis.ee.emit(SCREEN_EVENTS.TRANSFORMATION_EVENT, TRANSFORMATION_EVENT.FINISHED);\n\t\t}\n\t}\n\n\n\tprivate bindEvents() {\n\t\tvar state = this.chart;\n\n\t\t// handle scroll and zoom\n\t\tstate.onChange((changedProps) => {\n\t\t\tif (changedProps.xAxis && changedProps.xAxis.range) {\n\t\t\t\tif (changedProps.xAxis.range.scroll != void 0) this.onScrollXHandler(changedProps);\n\t\t\t\tif (changedProps.xAxis.range.zoom) this.onZoomXHandler();\n\t\t\t}\n\t\t\tif (changedProps.yAxis && changedProps.yAxis.range){\n\t\t\t\tif (changedProps.yAxis.range.scroll != void 0) this.onScrollYHandler();\n\t\t\t\tif (changedProps.yAxis.range.zoom) this.onZoomYHandler();\n\t\t\t}\n\t\t});\n\t\tstate.onDestroy(() => this.onDestroyHandler());\n\t}\n\n\tprivate onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t}\n\n\tprivate onScrollXHandler(changedProps: IChartState) {\n\t\tlet chart = this.chart;\n\t\tlet isDragMode = chart.state.cursor.dragMode;\n\t\tlet animations =  chart.state.animations;\n\t\tlet zoomXChanged = changedProps.xAxis.range.zoom;\n\t\tlet isAutoscroll = chart.state.autoScroll && !isDragMode && !zoomXChanged;\n\t\tlet time = isAutoscroll ? animations.autoScrollSpeed : animations.zoomSpeed;\n\t\tlet ease = isAutoscroll ? animations.autoScrollEase : animations.zoomEase;\n\t\tlet range = chart.state.xAxis.range;\n\t\tlet targetX = range.scroll * range.scaleFactor * range.zoom;\n\t\tif (isDragMode && !chart.state.inertialScroll) time = 0;\n\n\t\tif (this.scrollXAnimation) this.scrollXAnimation.stop();\n\n\t\tthis.scrollXAnimation = chart.animationManager.animate(time, ease)\n\t\t\t.from(this.options.scrollX)\n\t\t\t.to(targetX)\n\t\t\t.onTick((value) => {\n\t\t\t\tthis.transform({scrollX: value});\n\t\t\t});\n\t}\n\n\tprivate onScrollYHandler() {\n\t\tlet chart = this.chart;\n\t\tlet animations =  chart.state.animations;\n\t\tlet range = chart.state.yAxis.range;\n\t\tlet targetY = range.scroll * range.scaleFactor * range.zoom;\n\n\t\tif (this.scrollYAnimation) this.scrollYAnimation.stop();\n\n\t\tthis.scrollYAnimation = chart.animationManager.animate(animations.zoomSpeed, animations.zoomEase)\n\t\t\t.from(this.options.scrollY)\n\t\t\t.to(targetY)\n\t\t\t.onTick((value) => {\n\t\t\t\tthis.transform({scrollY: value});\n\t\t\t});\n\t}\n\n\n\tprivate onZoomXHandler() {\n\t\tlet chart = this.chart;\n\t\tlet animations =  chart.state.animations;\n\t\tlet targetZoom = chart.state.xAxis.range.zoom;\n\t\tif (this.zoomXAnimation) this.zoomXAnimation.stop();\n\n\t\tthis.zoomXAnimation = chart.animationManager\n\t\t\t.animate(animations.zoomSpeed, animations.zoomEase)\n\t\t\t.from(this.options.zoomX)\n\t\t\t.to(targetZoom)\n\t\t\t.onTick((value) => {\n\t\t\t\tthis.transform({zoomX: value});\n\t\t\t});\n\t}\n\n\n\tprivate onZoomYHandler() {\n\t\tlet chart = this.chart;\n\t\tlet targetZoom = chart.state.yAxis.range.zoom;\n\t\tlet animations =  chart.state.animations;\n\t\tif (this.zoomYAnimation) this.zoomYAnimation.stop();\n\n\t\tthis.zoomYAnimation = chart.animationManager\n\t\t\t.animate(animations.zoomSpeed, animations.zoomEase)\n\t\t\t.from(this.options.zoomY)\n\t\t\t.to(targetZoom)\n\t\t\t.onTick((value) => {\n\t\t\t\tthis.transform({zoomY: value});\n\t\t\t});\n\t}\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal to scrollXVal\n\t */\n\tgetPointOnXAxis(xVal: number): number {\n\t\tvar {scaleFactor, zeroVal} = this.chart.state.xAxis.range;\n\t\tvar zoom = this.options.zoomX;\n\t\treturn (xVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from yAxis.range.zeroVal to scrollYVal\n\t */\n\tgetPointOnYAxis(yVal: number): number {\n\t\tvar {scaleFactor, zeroVal} =  this.chart.state.yAxis.range;\n\t\tvar zoom = this.options.zoomY;\n\t\treturn (yVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal and from yAxis.range.zeroVal to scrollXVal and scrollYVal\n\t */\n\tgetPointOnChart(xVal: number, yVal: number): Vector3 {\n\t\treturn new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\n\t}\n\t\n\t/**\n\t * returns xVal by offset in pixels from xAxis.range.zeroVal\n\t */\n\tgetValueOnXAxis(x: number): number {\n\t\treturn this.chart.state.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  convert xVal to pixels by using settings from xAxis.range\n\t */\n\tvalueToPxByXAxis(xVal: number) {\n\t\treturn xVal * this.chart.state.xAxis.range.scaleFactor * this.options.zoomX;\n\t}\n\n\n\t/**\n\t *  convert xVal to pixels by using settings from yAxis.range\n\t */\n\tvalueToPxByYAxis(yVal: number) {\n\t\treturn yVal * this.chart.state.yAxis.range.scaleFactor * this.options.zoomY;\n\t}\n\t\n\t/**\n\t *  convert pixels to xVal by using settings from xAxis.range\n\t */\n\tpxToValueByXAxis(xVal: number) {\n\t\treturn xVal / this.chart.state.xAxis.range.scaleFactor / this.options.zoomX;\n\t}\n\n\n\t/**\n\t *  convert pixels to xVal by using settings from yAxis.range\n\t */\n\tpxToValueByYAxis(yVal: number) {\n\t\treturn yVal / this.chart.state.yAxis.range.scaleFactor / this.options.zoomY;\n\t}\n\n\n\t/**\n\t *  returns scrollX xVal by screen scrollX coordinate\n\t */\n\tgetValueByScreenX(x: number): number {\n\t\treturn this.chart.state.xAxis.range.zeroVal + this.options.scrollXVal + this.pxToValueByXAxis(x);\n\t}\n\t\n\t\n\n\tgetValueByScreenY(y: number): number {\n\t\treturn this.chart.state.yAxis.range.zeroVal + this.options.scrollYVal + this.pxToValueByYAxis(y);\n\t}\n\t\n\n\tgetScreenXByValue(xVal: number): number {\n\t\tvar {scroll, zeroVal} = this.chart.state.xAxis.range;\n\t\treturn this.valueToPxByXAxis(xVal - zeroVal - scroll)\n\t}\n\n\tgetScreenYByValue(yVal: number): number {\n\t\tvar {scroll, zeroVal} = this.chart.state.yAxis.range;\n\t\treturn this.valueToPxByYAxis(yVal - zeroVal - scroll)\n\t}\n\n\tgetScreenXByPoint(xVal: number): number {\n\t\treturn this.getScreenXByValue(this.getValueOnXAxis(xVal));\n\t}\n\n\n\t/**\n\t * returns offset in pixels from xAxis.range.zeroVal xVal by screen scrollX coordinate\n\t */\n\tgetPointByScreenX(screenX: number): number {\n\t\treturn this.getPointOnXAxis(this.getValueByScreenX(screenX));\n\t}\n\n\t/**\n\t * returns offset in pixels from yAxis.range.zeroVal xVal by screen scrollY coordinate\n\t */\n\tgetPointByScreenY(screenY: number): number {\n\t\treturn this.getPointOnYAxis(this.getValueByScreenY(screenY));\n\t}\n\n\tgetTop(): number {\n\t\treturn this.getPointByScreenY(this.chart.state.height);\n\t}\n\t\n\tgetBottom(): number {\n\t\treturn this.getPointByScreenY(0);\n\t}\n\n\tgetLeft(): number {\n\t\treturn this.getPointByScreenX(0);\n\t}\n\n\tgetScreenRightVal() {\n\t\treturn this.getValueByScreenX(this.chart.state.width);\n\t}\n\n\tgetTopVal() {\n\t\treturn this.getValueByScreenY(this.chart.state.height);\n\t}\n\t\n\tgetBottomVal() {\n\t\treturn this.getValueByScreenY(0);\n\t}\n\n\tgetCenterYVal() {\n\t\treturn this.getValueByScreenY(this.chart.state.height / 2);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Screen.ts\n **/","\n\n/**\n * defines how axis range will be calculated\n * FIXED - directly use range.from and range.to xVal\n * AUTO - automatically sets range.from and range.to by visible part of opposite axis\n * RELATIVE_END - same as AUTO, but trend end always present in range\n * ALL - automatically sets range.from and range.to by all values of opposite axis\n *\n */\nimport {TColor} from \"./Color\";\nimport { TEase } from \"./Easing\";\nexport enum AXIS_RANGE_TYPE {\n\tFIXED,\n\tRELATIVE_END,\n\tAUTO,\n\tALL // TODO: AXIS_RANGE_TYPE.ALL\n}\n\n/**\n * Animation ease type\n */\nexport declare type TTwinEase = Ease | Linear;\n\nexport declare type TIteralable = {[key: string]: any};\nexport interface IIteralable {[key: string]: any};\n\nexport enum AXIS_TYPE {X, Y}\n\nexport interface IAxisRange {\n\ttype?: AXIS_RANGE_TYPE,\n\tfrom?: number,\n\tto?: number,\n\tzoom?: number,\n\tscroll?: number,\n\n\t/**\n\t * Mode only for Y axis. When true displayed center of Y axis never changed. To use set range.zeroVal as center value.\n\t */\n\tisMirrorMode?: boolean,\n\n\tpadding?: {\n\t\tstart?: number,\n\t\tend?: number\n\t},\n\n\tmargin?: {\n\t\tstart?: number,\n\t\tend?: number\n\t},\n\n\tmaxLength?: number;\n\tminLength?: number;\n\n\t/**\n\t * value in world center coordinate\n\t */\n\tzeroVal?: number,\n\n\t/**\n\t * ratio between 1 pixel and 1 value for zoom = 1\n\t */\n\tscaleFactor?: number,\n}\n\nexport enum AXIS_DATA_TYPE {NUMBER, DATE}\n\nexport interface IAxisOptions {\n\trange?: IAxisRange;\n\tdataType?: AXIS_DATA_TYPE;\n\tautoScroll?: boolean;\n\tgrid?: IGridOptions;\n\tcolor?: TColor;\n}\n\nexport interface IGridOptions {\n\tenabled: boolean;\n\tminSizePx?: number;\n\tcolor?: TColor;\n}\n\nexport interface IAnimationsOptions {\n\tenabled?: boolean,\n\ttrendChangeSpeed?: number,\n\ttrendChangeEase?: TTwinEase,\n\tscrollSpeed?: number,\n\tscrollEase?: TEase,\n\tautoScrollSpeed?: number,\n\tautoScrollEase?: TEase,\n\tzoomSpeed?: number,\n\tzoomEase?: TEase,\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/interfaces.ts\n **/","import { IIteralable } from './interfaces';\nimport { EASING } from  './Easing';\n\n// TODO: transfer AnimationManager to own repo\nexport class AnimationManager {\n\n\tisAnimationsEnabled = true;\n\tprivate animations: Animation<any>[] = [];\n\tprivate lastTickTime: number;\n\n\tconstructor() {\n\t\tthis.lastTickTime = Date.now();\n\t}\n\n\tanimate(time: number, timingFunction?: (progress: number) => number): Animation<IIteralable|number> {\n\t\tlet animation = new Animation(this, time, this.lastTickTime, timingFunction);\n\t\tthis.animations.push(animation);\n\t\treturn animation;\n\t}\n\n\tanimateObj(source: IIteralable, target: IIteralable, ) {\n\n\t}\n\n\tsetAimationsEnabled(isEnabled: boolean) {\n\t\tthis.isAnimationsEnabled = isEnabled;\n\t}\n\n\ttick() {\n\t\tlet now = Date.now();\n\t\tlet animations = this.animations;\n\n\t\t// call tick for each animation\n\t\tfor (let i = 0; i < animations.length; i++) {\n\t\t\tlet animation = animations[i];\n\t\t\tif (this.isAnimationsEnabled) {\n\t\t\t\tanimation.tick(now);\n\t\t\t} else {\n\t\t\t\tanimation.completeAndStop();\n\t\t\t}\n\t\t}\n\n\t\t// cleanup completed animations\n\t\tlet i = animations.length;\n\t\twhile (i--) if (animations[i].isStopped) animations.splice(i, 1);\n\n\t\tthis.lastTickTime = now;\n\t}\n\n\thasActiveAnimations(): boolean {\n\t\treturn this.animations.length > 0;\n\t}\n\n}\n\nexport class Animation<AnimatedObjectType> {\n\n\tprogress = 0;\n\tdelay = 0;\n\tisFinished = false;\n\tisStopped = false;\n\tinitialObj: AnimatedObjectType;\n\tsourceObj: AnimatedObjectType;\n\ttargetObject: AnimatedObjectType;\n\tstartTime: number;\n\tprivate onFinishCb: (source: AnimatedObjectType, animation: this) => any;\n\tprivate onTickCb: (source: AnimatedObjectType, progress: number, k: number, animation: this) => any;\n\n\tconstructor(\n\t\tprivate animationManager: AnimationManager,\n\t\tpublic time: number,\n\t\tprivate createdTime: number,\n\t\tpublic easing: (k: number) => any = EASING.Quadratic.Out)\n\t{\n\t\tthis.startTime = createdTime;\n\t}\n\n\ttick(now: number) {\n\t\tif (!this.isStopped) {\n\t\t\tlet progress = this.time > 0 ? ((now - this.startTime) / this.time) : 1;\n\t\t\tthis.setProgress(progress);\n\t\t}\n\t}\n\n\tfrom<T>(sourceObj: T): Animation<T> {\n\t\tif (typeof sourceObj == 'object') {\n\t\t\tthis.sourceObj = sourceObj as any;\n\t\t\tthis.initialObj = {} as any;\n\t\t\tlet sourceIteralable = sourceObj as IIteralable;\n\t\t\tfor (let key in sourceIteralable) if (typeof sourceIteralable[key] == 'number') {\n\t\t\t\t(this.initialObj as IIteralable)[key] = sourceIteralable[key];\n\t\t\t}\n\n\t\t} else if (typeof sourceObj == 'number') {\n\t\t\tthis.sourceObj = sourceObj;\n\t\t\tthis.initialObj = sourceObj;\n\t\t}\n\t\treturn (this as any) as Animation<T>;\n\t}\n\n\tto(targetObj: AnimatedObjectType): this {\n\t\tthis.targetObject = targetObj;\n\n\t\t// clear unused fields\n\t\tif (typeof this.initialObj == 'object') {\n\n\t\t\tlet initialIteralable = this.initialObj as IIteralable;\n\t\t\tfor (let key in this.targetObject) {\n\t\t\t\tif (initialIteralable[key] == void 0) delete initialIteralable[key];\n\t\t\t}\n\n\t\t\tlet targetIteralable = this.targetObject as IIteralable;\n\t\t\tfor (let key in initialIteralable) {\n\t\t\t\tif (targetIteralable[key] == void 0) delete initialIteralable[key];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tonTick(onTickCb: (source: AnimatedObjectType, progress: number, k: number, animation: this) => any): this {\n\t\tthis.onTickCb = onTickCb;\n\t\treturn this;\n\t}\n\n\tthen(onFinishCb: (progress: AnimatedObjectType) => any): this {\n\t\tthis.onFinishCb = onFinishCb;\n\t\treturn this;\n\t}\n\n\tstop() {\n\t\tthis.isStopped = true;\n\t}\n\n\tcompleteAndStop() {\n\t\tthis.setProgress(1);\n\t}\n\n\twithDelay(delay: number): this {\n\t\tthis.delay = delay;\n\t\tthis.startTime = this.createdTime + delay;\n\t\treturn this;\n\t}\n\n\tprivate setProgress(progress: number) {\n\n\t\tif (progress < 0) return;\n\n\t\tprogress = Math.min(progress, 1);\n\t\tthis.progress = progress;\n\t\tlet k = this.easing(progress);\n\n\t\tif (typeof this.sourceObj == 'number') {\n\t\t\tlet initialVal = this.initialObj as any as number;\n\t\t\tlet targetVal = this.targetObject as any as number;\n\t\t\tthis.sourceObj = (initialVal + (targetVal - initialVal) * k) as any as AnimatedObjectType;\n\t\t} else if (this.sourceObj && this.targetObject) {\n\t\t\tfor (let key in this.initialObj) {\n\t\t\t\tlet initialVal = (this.initialObj as IIteralable)[key] as number;\n\t\t\t\tlet targetVal = (this.targetObject as IIteralable)[key] as number;\n\t\t\t\t(this.sourceObj as IIteralable)[key] = initialVal + (targetVal - initialVal) * k;\n\t\t\t}\n\t\t}\n\n\n\t\tif (progress == 1) {\n\t\t\tthis.isStopped = true;\n\t\t\tthis.isFinished = true;\n\t\t}\n\n\t\tif (this.onTickCb) this.onTickCb(this.sourceObj, progress, k, this);\n\n\t\tif (progress == 1 && this.onFinishCb) this.onFinishCb(this.sourceObj, this);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/AnimationManager.ts\n **/","export declare type TEase = (k: number) => number;\n\n/**\n * Easing from tween.js lib https://github.com/tweenjs/tween.js\n **/\nexport const EASING = {\n\n\tLinear: {\n\n\t\tNone: function (k: number) {\n\n\t\t\treturn k;\n\n\t\t}\n\n\t},\n\n\tQuadratic: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn k * k;\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\treturn k * (2 - k);\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\n\t\t}\n\n\t},\n\n\tCubic: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn k * k * k;\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\treturn --k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tQuartic: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\treturn 1 - (--k * k * k * k);\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\n\t\t}\n\n\t},\n\n\tQuintic: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn k * k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\treturn --k * k * k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tSinusoidal: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\n\t\t}\n\n\t},\n\n\tExponential: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\n\t\t}\n\n\t},\n\n\tCircular: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\treturn Math.sqrt(1 - (--k * k));\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\n\t\t}\n\n\t},\n\n\tElastic: {\n\n\t\tIn: function (k: number) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tk *= 2;\n\n\t\t\tif (k < 1) {\n\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t}\n\n\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\n\t\t}\n\n\t},\n\n\tBack: {\n\n\t\tIn: function (k: number) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn k * k * ((s + 1) * k - s);\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tvar s = 1.70158 * 1.525;\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\n\t\t}\n\n\t},\n\n\tBounce: {\n\n\t\tIn: function (k: number) {\n\n\t\t\treturn 1 - EASING.Bounce.Out(1 - k);\n\n\t\t},\n\n\t\tOut: function (k: number) {\n\n\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t}\n\n\t\t},\n\n\t\tInOut: function (k: number) {\n\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn EASING.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\n\t\t\treturn EASING.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\n\t\t}\n\n\t}\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Easing.ts\n **/","import {Chart} from \"./Chart\";\nimport Object3D = THREE.Object3D;\n\nexport interface IChartWidgetConstructor {\n\tnew (): ChartWidget;\n\twidgetName: string;\n}\n\n/**\n * base class for all widgets\n * each widget must have widgetName static property\n */\nexport abstract class ChartWidget {\n\tstatic widgetName = '';\n\tprotected chart: Chart;\n\tprivate unbindList: Function[] = [];\n\n\n\tsetupChart(chart: Chart) {\n\t\tthis.chart = chart;\n\t}\n\n\tabstract onReadyHandler(): any;\n\tabstract getObject3D(): Object3D;\n\n\n\tprotected bindEvent(...args: Array<Function | Function[]>): void {\n\t\tlet unbindList: Function[] = [];\n\t\tif (!Array.isArray(args[0])) {\n\t\t\tunbindList.push(args[0] as Function);\n\t\t} else {\n\t\t\tunbindList.push(...args as Function[]);\n\t\t}\n\t\tthis.unbindList.push(...unbindList);\n\t}\n\tprotected unbindEvents() {\n\t\tthis.unbindList.forEach(unbindEvent => unbindEvent());\n\t\tthis.unbindList.length = 0;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Widget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport UVMapping = THREE.UVMapping;\nimport GridHelper = THREE.GridHelper;\nimport {ChartWidget} from \"../Widget\";\nimport {Chart} from \"../Chart\";\nimport {GridWidget, IGridParamsForAxis} from \"./GridWidget\";\nimport {Utils} from \"../Utils\";\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport OrthographicCamera = THREE.OrthographicCamera;\nimport {IScreenTransformOptions} from \"../Screen\";\nimport {AXIS_TYPE, AXIS_DATA_TYPE, IAxisOptions} from \"../interfaces\";\nimport { Color } from \"../Color\";\n\n/**\n * widget for drawing axis\n */\nexport class AxisWidget extends ChartWidget {\n\tstatic widgetName = 'Axis';\n\tprivate isDestroyed = false;\n\tprivate object3D: Object3D;\n\tprivate axisXObject: Object3D;\n\tprivate axisYObject: Object3D;\n\tprivate updateAxisXRequest: () => void;\n\n\tonReadyHandler() {\n\t\tthis.object3D = new Object3D();\n\t\tthis.axisXObject = new Object3D();\n\t\tthis.axisYObject = new Object3D();\n\t\tthis.object3D.add(this.axisXObject);\n\t\tthis.object3D.add(this.axisYObject);\n\t\tthis.setupAxis(AXIS_TYPE.X);\n\t\tthis.setupAxis(AXIS_TYPE.Y);\n\n\t\t// canvas drawing is expensive operation, so when we scroll, redraw must be called only once per second\n\t\tthis.updateAxisXRequest = Utils.throttle(() => this.updateAxis(AXIS_TYPE.X), 1000);\n\n\t\tthis.onScrollChange(\n\t\t\tthis.chart.screen.options.scrollX,\n\t\t\tthis.chart.screen.options.scrollY\n\t\t);\n\t\tthis.bindEvents();\n\t}\n\n\tbindEvents() {\n\t\tvar state = this.chart;\n\n\t\tthis.bindEvent(\n\t\t\tstate.screen.onTransformationFrame((options) => {\n\t\t\t\tthis.onScrollChange(options.scrollX, options.scrollY);\n\t\t\t}),\n\t\t\tstate.screen.onZoomFrame((options) => {this.onZoomFrame(options)}),\n\t\t\tstate.onDestroy(() => this.onDestroy()),\n\t\t\tstate.onResize(() => this.onResize())\n\t\t);\n\t}\n\n\tprivate onDestroy() {\n\t\tthis.isDestroyed = true;\n\t\tthis.unbindEvents();\n\t}\n\n\tprivate onScrollChange(x: number, y: number) {\n\n\t\tif (y != void 0) {\n\t\t\tthis.axisYObject.position.y = y;\n\t\t\tthis.axisXObject.position.y = y;\n\t\t}\n\n\t\tif (x != void 0) {\n\t\t\tthis.axisYObject.position.x = x;\n\t\t\tthis.updateAxisXRequest();\n\t\t}\n\n\t}\n\n\tprivate onResize() {\n\t\tthis.setupAxis(AXIS_TYPE.X);\n\t\tthis.setupAxis(AXIS_TYPE.Y);\n\t}\n\n\tprivate setupAxis(orientation: AXIS_TYPE) {\n\n\t\tlet isXAxis = orientation == AXIS_TYPE.X;\n\t\tlet {width: visibleWidth, height: visibleHeight} = this.chart.state;\n\t\tlet canvasWidth = 0, canvasHeight = 0;\n\t\tlet axisOptions: IAxisOptions;\n\n\t\t// clean meshes\n\t\tif (isXAxis) {\n\t\t\tthis.axisXObject.traverse(obj => this.axisXObject.remove(obj));\n\t\t\tcanvasWidth = visibleWidth * 3;\n\t\t\tcanvasHeight = 50;\n\t\t\taxisOptions = this.chart.state.xAxis;\n\t\t} else {\n\t\t\tthis.axisYObject.traverse(obj => this.axisYObject.remove(obj));\n\t\t\tcanvasWidth = 50;\n\t\t\tcanvasHeight = visibleHeight * 3;\n\t\t\taxisOptions = this.chart.state.yAxis;\n\t\t}\n\n\t\tvar texture = Utils.createNearestTexture(canvasWidth, canvasHeight, (ctx) => {\n\t\t\tlet color = new Color(axisOptions.color);\n\t\t\tctx.beginPath();\n\t\t\tctx.font = this.chart.state.font.m;\n\t\t\tctx.fillStyle = color.rgbaStr;\n\t\t\tctx.strokeStyle = color.rgbaStr;\n\t\t});\n\n\n\t\tvar material = new THREE.MeshBasicMaterial( {map: texture, side: THREE.FrontSide} );\n\t\tmaterial.transparent = true;\n\n\t\tvar axisMesh = new Mesh(\n\t\t\tnew THREE.PlaneGeometry(canvasWidth, canvasHeight),\n\t\t\tmaterial\n\t\t);\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh.position.set(canvasWidth / 2, canvasHeight / 2, 0);\n\t\t\tthis.axisXObject.add(axisMesh);\n\t\t} else {\n\t\t\taxisMesh.position.set(visibleWidth - canvasWidth / 2, canvasHeight / 2, 0);\n\t\t\tthis.axisYObject.add(axisMesh);\n\t\t}\n\n\t\tthis.updateAxis(orientation);\n\n\t}\n\t\n\tgetObject3D(): Object3D {\n\t\treturn this.object3D;\n\t}\n\n\tprivate updateAxis(orientation: AXIS_TYPE) {\n\t\tif (this.isDestroyed) return;\n\t\tvar isXAxis = orientation == AXIS_TYPE.X;\n\t\tvar {width: visibleWidth, height: visibleHeight} = this.chart.state;\n\t\tvar {scrollX, scrollY, zoomX, zoomY} = this.chart.screen.options;\n\t\tvar axisOptions: IAxisOptions;\n\t\tvar axisMesh: Mesh;\n\t\tvar axisGridParams: IGridParamsForAxis;\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh = this.axisXObject.children[0] as Mesh;\n\t\t\taxisOptions = this.chart.state.xAxis;\n\t\t\taxisGridParams = GridWidget.getGridParamsForAxis(axisOptions, visibleWidth, zoomX);\n\t\t} else {\n\t\t\taxisMesh = this.axisYObject.children[0] as Mesh;\n\t\t\taxisOptions = this.chart.state.yAxis;\n\t\t\taxisGridParams = GridWidget.getGridParamsForAxis(axisOptions, visibleHeight, zoomY);\n\t\t}\n\n\t\tvar geometry = axisMesh.geometry as PlaneGeometry;\n\t\tvar canvasWidth = geometry.parameters.width;\n\t\tvar canvasHeight = geometry.parameters.height;\n\t\tvar texture = (axisMesh.material as MeshBasicMaterial).map;\n\t\tvar ctx = texture.image.getContext('2d');\n\t\tctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh.position.x = canvasWidth / 2 - visibleWidth + scrollX;\n\t\t}\n\n\n\t\t// TODO: draw text and lines in different loops\n\t\tvar edgeOffset = axisGridParams.segmentsCount * axisGridParams.step;\n\t\tvar startVal = axisGridParams.start  - edgeOffset;\n\t\tvar endVal = axisGridParams.end + edgeOffset;\n\n\t\tctx.beginPath();\n\t\tfor (let val = startVal; val <= endVal; val += axisGridParams.step) {\n\t\t\tlet displayedValue = '';\n\t\t\tif (isXAxis) {\n\t\t\t\tlet pxVal = this.chart.screen.getPointOnXAxis(val) - scrollX + visibleWidth;\n\t\t\t\tctx.textAlign = \"center\";\n\t\t\t\t// uncomment for dots\n\t\t\t\t// ctx.moveTo(pxVal + 0.5, canvasHeight);\n\t\t\t\t// ctx.lineTo(pxVal + 0.5, canvasHeight - 5);\n\t\t\t\tif (axisOptions.dataType == AXIS_DATA_TYPE.DATE) {\n\t\t\t\t\tdisplayedValue = AxisWidget.getDateStr(val, axisGridParams);\n\t\t\t\t} else {\n\t\t\t\t\tdisplayedValue = Number(val.toFixed(14)).toString();\n\t\t\t\t}\n\n\t\t\t\tctx.fillText(displayedValue, pxVal, canvasHeight - 10);\n\t\t\t} else {\n\t\t\t\tlet pxVal = canvasHeight - this.chart.screen.getPointOnYAxis(val) + scrollY;\n\t\t\t\tctx.textAlign = \"right\";\n\t\t\t\t// uncomment for dots\n\t\t\t\t// ctx.moveTo(canvasWidth, pxVal + 0.5);\n\t\t\t\t// ctx.lineTo(canvasWidth - 5, pxVal + 0.5);\n\n\t\t\t\tdisplayedValue = Number(val.toFixed(14)).toString();\n\t\t\t\tctx.fillText(displayedValue, canvasWidth - 15 , pxVal + 3);\n\n\t\t\t\t// uncomment for left-side axis\n\t\t\t\t// ctx.moveTo(0, pxVal + 0.5);\n\t\t\t\t// ctx.lineTo(5, pxVal + 0.5);\n\t\t\t\t// ctx.fillText(Number(val.toFixed(14)).toString(), 15 , pxVal + 3);\n\t\t\t}\n\t\t\tctx.stroke();\n\t\t}\n\t\t// uncomment to preview canvas borders\n\t\t// ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\t\tctx.stroke();\n\t\tctx.closePath();\n\t\ttexture.needsUpdate = true;\n\t}\n\n\tprivate onZoomFrame(options: IScreenTransformOptions) {\n\t\tif (options.zoomX) {\n\t\t\tthis.updateAxis(AXIS_TYPE.X);\n\t\t\t//this.temporaryHideAxis(AXIS_ORIENTATION.H)\n\t\t}\n\t\tif (options.zoomY) {\n\t\t\tthis.updateAxis(AXIS_TYPE.Y);\n\t\t\t//this.temporaryHideAxis(AXIS_ORIENTATION.V)\n\t\t}\n\t}\n\n\t// private temporaryHideAxis(orientation: AXIS_TYPE) {\n\t// \tvar isXAxis = orientation == AXIS_TYPE.X;\n\t// \tvar timeoutId = setTimeout(() => {\n\t// \t\t\tthis.showAxis(orientation);\n\t// \t}, 200);\n\t//\n\t// \tif (isXAxis) {\n\t// \t\t(this.axisXObject.children[0] as Mesh).material.opacity = 0;\n\t// \t\tclearTimeout(this.showAxisXTimeout);\n\t// \t\tthis.showAxisXTimeout =\ttimeoutId;\n\t// \t} else {\n\t// \t\tclearTimeout(this.showAxisYTimeout);\n\t// \t\t(this.axisYObject.children[0] as Mesh).material.opacity = 0;\n\t// \t\tthis.showAxisYTimeout = timeoutId;\n\t// \t}\n\t// }\n\n\t// private showAxis(orientation: AXIS_TYPE) {\n\t// \tvar isXAxis = orientation == AXIS_TYPE.X;\n\t// \tvar material: MeshBasicMaterial;\n\t// \tif (isXAxis) {\n\t// \t\tmaterial = (this.axisXObject.children[0] as Mesh).material as MeshBasicMaterial;\n\t// \t} else {\n\t// \t\tmaterial = (this.axisYObject.children[0] as Mesh).material as MeshBasicMaterial;\n\t// \t}\n\t// \tthis.updateAxis(orientation);\n\t// \tTweenLite.to(material, 0.3, {opacity: 1});\n\t// }\n\n\tstatic getDateStr(timestamp: number, gridParams: IGridParamsForAxis): string {\n\t\tvar sec = 1000;\n\t\tvar min = sec * 60;\n\t\tvar hour = min * 60;\n\t\tvar day = hour * 60;\n\t\tvar step = gridParams.step;\n\t\tvar d = new Date(timestamp);\n\t\tvar tf = (num: number) => Utils.toFixed(num, 2);\n\t\treturn tf(d.getHours()) + ':' + tf(d.getMinutes()) + ':' + tf(d.getSeconds());\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/AxisWidget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport { ChartWidget } from \"../Widget\";\nimport LineSegments = THREE.LineSegments;\nimport { Utils } from \"../Utils\";\nimport { IScreenTransformOptions } from \"../Screen\";\nimport { IAxisOptions } from \"../interfaces\";\nimport { Color } from \"../Color\";\n\nexport interface IGridParamsForAxis {\n\tstart: number,\n\tend: number,\n\tstep: number,\n\tstepInPx: number,\n\tlength: number,\n\tsegmentsCount: number\n}\n\n/**\n * widget for drawing state grid\n */\nexport class GridWidget extends ChartWidget{\n\tstatic widgetName = 'Grid';\n\tprivate lineSegments: LineSegments;\n\tprivate gridSizeH: number;\n\tprivate gridSizeV: number;\n\tprivate isDestroyed = false;\n\n\tonReadyHandler() {\n\t\tvar {width, height, xAxis, yAxis} = this.chart.state;\n\t\tthis.gridSizeH = Math.floor(width / xAxis.grid.minSizePx) * 3;\n\t\tthis.gridSizeV = Math.floor(height / yAxis.grid.minSizePx) * 3;\n\t\tthis.initGrid();\n\t\tthis.updateGrid();\n\t\tthis.bindEvents();\n\t}\n\n\tbindEvents() {\n\t\t// grid is bigger then screen, so it's no need to update it on each scroll event\n\t\tlet updateGridThrottled = Utils.throttle(() => this.updateGrid(), 1000);\n\t\tthis.bindEvent(this.chart.onScroll(() => updateGridThrottled()),\n\t\t\tthis.chart.screen.onZoomFrame((options) => {\n\t\t\t\tupdateGridThrottled();\n\t\t\t\tthis.onZoomFrame(options);\n\t\t\t}),\n\t\t\tthis.chart.onDestroy(() => {\n\t\t\t\tthis.isDestroyed = true;\n\t\t\t\tthis.unbindEvents();\n\t\t\t}),\n\t\t\tthis.chart.onResize(() => {\n\t\t\t\tthis.updateGrid();\n\t\t\t})\n\t\t);\n\n\t}\n\n\tprivate initGrid() {\n\t\tlet color = new Color(this.chart.state.xAxis.grid.color);\n\t\tlet geometry = new THREE.Geometry();\n\t\tlet material = new THREE.LineBasicMaterial({linewidth: 1, color: color.value, opacity: color.a, transparent: true});\n\t\tlet xLinesCount = this.gridSizeH;\n\t\tlet yLinesCount = this.gridSizeV;\n\t\twhile (xLinesCount--) geometry.vertices.push(new Vector3(), new Vector3());\n\t\twhile (yLinesCount--) geometry.vertices.push(new Vector3(), new Vector3());\n\t\tthis.lineSegments = new LineSegments(geometry, material);\n\t\tthis.lineSegments.position.setZ(-1);\n\t\tthis.lineSegments.frustumCulled = false;\n\t}\n\n\tprivate updateGrid() {\n\t\tif (this.isDestroyed) return;\n\t\tvar {yAxis, xAxis, width, height} = this.chart.state;\n\t\tvar axisXGrid = GridWidget.getGridParamsForAxis(xAxis, width, xAxis.range.zoom);\n\t\tvar axisYGrid = GridWidget.getGridParamsForAxis(yAxis, height, yAxis.range.zoom);\n\t\tvar scrollXInSegments = Math.ceil(xAxis.range.scroll / axisXGrid.step);\n\t\tvar scrollYInSegments = Math.ceil(yAxis.range.scroll / axisYGrid.step);\n\t\tvar gridScrollXVal = scrollXInSegments * axisXGrid.step;\n\t\tvar gridScrollYVal = scrollYInSegments * axisYGrid.step;\n\t\tvar startXVal = axisXGrid.start + gridScrollXVal;\n\t\tvar startYVal = axisYGrid.start + gridScrollYVal;\n\t\tvar geometry = this.lineSegments.geometry as Geometry;\n\t\tvar vertices = geometry.vertices;\n\t\tvar lineInd = 0;\n\n\t\tfor (let i =  -this.gridSizeH / 3; i < this.gridSizeH * 2/3; i++) {\n\t\t\tlet value = startXVal + i * axisXGrid.step;\n\t\t\tlet lineSegment = this.getVerticalLineSegment(value, gridScrollXVal, gridScrollYVal);\n\t\t\tvertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\n\t\t\tvertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\n\t\t\tlineInd++;\n\t\t}\n\n\t\tfor (let i =  -this.gridSizeV / 3; i < this.gridSizeV * 2/3; i++) {\n\t\t\tlet value = startYVal + i * axisYGrid.step;\n\t\t\tlet lineSegment = this.getHorizontalLineSegment(value, gridScrollXVal, gridScrollYVal);\n\t\t\tvertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\n\t\t\tvertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\n\t\t\tlineInd++;\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tthis.lineSegments.scale.set(\n\t\t\txAxis.range.scaleFactor * xAxis.range.zoom,\n\t\t\tyAxis.range.scaleFactor * yAxis.range.zoom,\n\t\t\t1\n\t\t)\n\t}\n\n\tprivate getHorizontalLineSegment(yVal: number, scrollXVal: number, scrollYVal: number): Vector3[] {\n\t\tvar chartState = this.chart;\n\t\tvar localYVal = yVal - chartState.state.yAxis.range.zeroVal - scrollYVal;\n\t\tvar widthVal = chartState.pxToValueByXAxis(chartState.state.width);\n\t\treturn [\n\t\t\tnew THREE.Vector3(widthVal * 2 + scrollXVal, localYVal, 0 ),\n\t\t\tnew THREE.Vector3( -widthVal + scrollXVal, localYVal, 0 )\n\t\t];\n\t}\n\n\tprivate getVerticalLineSegment(xVal: number, scrollXVal: number, scrollYVal: number): Vector3[] {\n\t\tvar chartState = this.chart;\n\t\tvar localXVal = xVal - chartState.state.xAxis.range.zeroVal - scrollXVal;\n\t\tvar heightVal = chartState.pxToValueByYAxis(chartState.state.height);\n\t\treturn [\n\t\t\tnew THREE.Vector3(localXVal, heightVal * 2 + scrollYVal, 0 ),\n\t\t\tnew THREE.Vector3(localXVal, -heightVal + scrollYVal, 0 )\n\t\t];\n\t}\n\n\tprivate onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar {xAxis, yAxis} = this.chart.state;\n\t\tif (options.zoomX) this.lineSegments.scale.setX(xAxis.range.scaleFactor * options.zoomX);\n\t\tif (options.zoomY) this.lineSegments.scale.setY(yAxis.range.scaleFactor * options.zoomY);\n\t}\n\n\n\t// TODO: move this code to core\n\tstatic getGridParamsForAxis(axisOptions: IAxisOptions, axisWidth: number, zoom: number): IGridParamsForAxis {\n\t\tlet axisRange = axisOptions.range;\n\t\tlet from = axisRange.from;\n\t\tlet to = axisRange.to;\n\t\tlet axisLength = to - from;\n\t\tlet gridStep = 0;\n\t\tlet gridStepInPixels = 0;\n\t\tlet minGridStepInPixels = axisOptions.grid.minSizePx;\n\t\tlet axisLengthStr = String(axisLength);\n\t\tlet axisLengthPointPosition = axisLengthStr.indexOf('.');\n\t\tlet intPartLength = axisLengthPointPosition !== -1 ? axisLengthPointPosition : axisLengthStr.length;\n\n\t\tlet gridStepFound = false;\n\t\tlet digitPos = 0;\n\t\twhile (!gridStepFound) {\n\n\t\t\tlet power = intPartLength - digitPos - 1;\n\t\t\tlet multiplier = (Math.pow(10, power) || 1);\n\t\t\tlet dividers = [1, 2, 5];\n\t\t\tfor (let dividerInd = 0; dividerInd < dividers.length; dividerInd++) {\n\t\t\t\tlet nextGridStep = multiplier / dividers[dividerInd];\n\t\t\t\tlet nextGridStepInPixels = nextGridStep / axisLength * axisWidth;\n\t\t\t\tif (nextGridStepInPixels >= minGridStepInPixels) {\n\t\t\t\t\tgridStep = nextGridStep;\n\t\t\t\t\tgridStepInPixels = nextGridStepInPixels;\n\t\t\t\t} else {\n\t\t\t\t\tgridStepFound = true;\n\t\t\t\t\tif (gridStep === 0) {\n\t\t\t\t\t\tgridStep = nextGridStep;\n\t\t\t\t\t\tgridStepInPixels = nextGridStepInPixels;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!gridStepFound) digitPos++\n\n\t\t}\n\n\t\tvar gridStart = Math.floor(from / gridStep) * gridStep;\n\t\tvar gridEnd = Math.floor(to / gridStep) * gridStep;\n\n\t\treturn {\n\t\t\tstart: gridStart,\n\t\t\tend: gridEnd,\n\t\t\tstep: gridStep,\n\t\t\tstepInPx: gridStepInPixels,\n\t\t\tlength: gridEnd - gridStart,\n\t\t\tsegmentsCount: Math.round((gridEnd - gridStart) / gridStep)\n\t\t}\n\t}\n\t\n\tgetObject3D() {\n\t\treturn this.lineSegments;\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/GridWidget.ts\n **/","export declare type TColor = string | number;\n\n\nexport class Color {\n\n\t/**!\n\t * @preserve $.parseColor\n\t * Copyright 2011 THEtheChad Elliott\n\t * Released under the MIT and GPL licenses.\n\t */\n\t/**\n\t * Parse hex/rgb{a} color syntax.\n\t * @input string\n\t * @returns array [r,g,b{,o}]\n\t */\n\tstatic parseColor(color: string): number[] {\n\n\t\tvar cache: any\n\t\t\t, p = parseInt // Use p as a byte saving reference to parseInt\n\t\t\t, color = color.replace(/\\s\\s*/g, '') // Remove all spaces\n\t\t\t;//var\n\n\t\t// Checks for 6 digit hex and converts string to integer\n\t\tif (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\n\n\t\t// Checks for 3 digit hex and converts string to integer\n\t\telse if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\n\t\t\tcache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\n\n\n\t\t// Checks for 6 digit hex with alpha and converts string to integer\n\t\telse if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\n\n\t\t// Checks for rgba and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3], +cache[4]];\n\n\t\t// Checks for rgb and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3]];\n\n\t\t// Otherwise throw an exception to make debugging easier\n\t\telse throw Error(color + ' is not supported by parseColor');\n\n\t\t// Performs RGBA conversion by default\n\t\tisNaN(cache[3]) && (cache[3] = 1);\n\t\treturn cache;\n\t\t// Adds or removes 4th xVal based on rgba support\n\t\t// Support is flipped twice to prevent erros if\n\t\t// it's not defined\n\t\t//return cache.slice(0,3 + !!$.support.rgba);\n\t}\n\n\tr: number;\n\tg: number;\n\tb: number;\n\ta: number;\n\tvalue: number;\n\thexStr: string;\n\trgbaStr: string;\n\n\tconstructor (color: TColor) {\n\t\tthis.set(color);\n\t}\n\n\tstatic numberToHexStr(value: number): string {\n\t\tlet result = value.toString(16);\n\t\treturn '#' + '0'.repeat(6 - result.length) + result;\n\t}\n\n\n\tset(color: TColor) {\n\t\tif (typeof color == 'number') color = Color.numberToHexStr(color);\n\t\tlet colorStr = color as string;\n\t\tlet rgba = Color.parseColor(colorStr);\n\t\tthis.r = rgba[0];\n\t\tthis.g = rgba[1];\n\t\tthis.b = rgba[2];\n\t\tthis.a = rgba[3];\n\t\tthis.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\n\t\tthis.hexStr = Color.numberToHexStr(this.value);\n\t\tthis.rgbaStr = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;\n\t}\n\n\tgetTransparent(opacity: number) {\n\t\treturn new Color(`rgba(${this.hexStr}, ${opacity})`);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Color.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport {Chart} from \"../Chart\";\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport {ITrendOptions} from \"../Trend\";\nimport {Utils} from \"../Utils\";\nimport {TrendsWidget, TrendWidget} from \"./TrendsWidget\";\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport { IScreenTransformOptions } from '../Screen';\nimport { TrendSegmentsManager, ITrendSegmentState } from '../TrendSegmentsManager';\nimport { Color } from '../Color';\n\nexport class TrendsGradientWidget extends TrendsWidget<TrendGradient> {\n\tstatic widgetName = \"TrendsGradient\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendGradient;\n\t}\n}\n\n\nexport class TrendGradient extends TrendWidget {\n\tprivate gradient: Mesh;\n\tprivate visibleSegmentsCnt = 0;\n\tprivate segmentsIds: Uint16Array;\n\t\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.hasBackground;\n\t}\n\n\tconstructor (chartState: Chart, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tthis.trend = chartState.trendsManager.getTrend(trendName);\n\t\tthis.segmentsIds = new Uint16Array(chartState.state.maxVisibleSegments)\n\t\tthis.initGradient();\n\t\tthis.updateSegments();\n\t}\n\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.updateSegments();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\t// TODO: optimize updateSegments for onDisplayedRangeChanged\n\t\t\tthis.updateSegments();\n\t\t}));\n\t\tthis.bindEvent(this.chart.onZoom(() => {\n\t\t\tthis.updateSegments();\n\t\t}));\n\t}\n\n\n\tgetObject3D(): Object3D {\n\t\treturn this.gradient;\n\t}\n\n\n\tinitGradient() {\n\t\tlet geometry = new Geometry();\n\n\n\t\tfor (let i = 0; i < this.segmentsIds.length; i++) {\n\t\t\tgeometry.vertices.push(\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3()\n\t\t\t);\n\t\t\tlet ind = i * 4;\n\n\t\t\t// gradient segment scheme\n\t\t\t//\n\t\t\t// vert0 +---+ vert3\n\t\t\t//       |\\  |\n\t\t\t// face1 | \\ | face2\n\t\t\t// \t     |  \\|\n\t\t\t// vert1 +---+ vert2\n\n\t\t\tgeometry.faces.push(\n\t\t\t\tnew THREE.Face3( ind, ind + 1, ind + 2 ),\n\t\t\t\tnew THREE.Face3( ind + 3, ind, ind + 2 )\n\t\t\t);\n\t\t}\n\n\t\tlet color = new Color(this.trend.getOptions().backgroundColor);\n\t\tthis.gradient = new THREE.Mesh(\n\t\t\tgeometry,\n\t\t\tnew THREE.MeshBasicMaterial( {color: color.value, transparent: true, opacity: color.a} )\n\t\t);\n\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = this.chart.state.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = this.chart.state.yAxis.range;\n\t\tthis.gradient.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.gradient.frustumCulled = false;\n\t}\n\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tlet state = this.chart.state;\n\t\tlet scaleXFactor = state.xAxis.range.scaleFactor;\n\t\tlet scaleYFactor = state.yAxis.range.scaleFactor;\n\t\tvar currentScale = this.gradient.scale;\n\t\tif (options.zoomX) currentScale.setX(scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(scaleYFactor * options.zoomY);\n\t}\n\n\n\tprotected onSegmentsAnimate(trendSegmentsManager: TrendSegmentsManager) {\n\t\tlet animatedSegmentsIds = trendSegmentsManager.animatedSegmentsIds;\n\t\tfor (let i = 0; i < this.visibleSegmentsCnt; i++) {\n\t\t\tlet segmentId = this.segmentsIds[i];\n\t\t\tif (!animatedSegmentsIds.includes(segmentId)) continue;\n\t\t\tthis.setupSegmentVertices(i, trendSegmentsManager.getSegment(segmentId).currentAnimationState);\n\t\t}\n\t\t(this.gradient.geometry as PlaneGeometry).verticesNeedUpdate = true;\n\t}\n\n\n\tprivate updateSegments() {\n\t\tlet geometry = this.gradient.geometry as PlaneGeometry;\n\t\tlet {\n\t\t\tsegments: trendSegments,\n\t\t\tfirstDisplayedSegmentInd: segmentInd,\n\t\t\tlastDisplayedSegmentInd\n\t\t} = this.trend.segmentsManager;\n\t\tlet prevVisibleSegmentsCnt = this.visibleSegmentsCnt;\n\t\tthis.visibleSegmentsCnt = lastDisplayedSegmentInd - segmentInd + 1;\n\t\tlet segmentsToProcessCnt = Math.max(prevVisibleSegmentsCnt, this.visibleSegmentsCnt);\n\n\t\tif (segmentsToProcessCnt > this.segmentsIds.length) {\n\t\t\tUtils.error(TrendsGradientWidget.widgetName + ': MAX_SEGMENTS reached');\n\t\t}\n\n\t\t// setup visible segments and collapse invisible\n\t\tfor (let i = 0; i < segmentsToProcessCnt; i++) {\n\t\t\tif (segmentInd <= lastDisplayedSegmentInd) {\n\t\t\t\tlet segment = trendSegments[segmentInd];\n\t\t\t\tthis.setupSegmentVertices(i, segment.currentAnimationState);\n\t\t\t\tthis.segmentsIds[i] = segment.id;\n\t\t\t\tsegmentInd++;\n\t\t\t} else {\n\t\t\t\tthis.setupSegmentVertices(i);\n\t\t\t}\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\t}\n\n\n\t/**\n\t * setup gradient segment by segmentState\n\t * if segmentState is undefined, then collapse vertices to 0,0,0\n\t */\n\tprivate setupSegmentVertices(segmentInd: number, segmentState?: ITrendSegmentState) {\n\t\tlet gradientSegmentInd = segmentInd * 4;\n\t\tlet vertices = (this.gradient.geometry as PlaneGeometry).vertices;\n\t\tlet\ttopLeft = vertices[gradientSegmentInd];\n\t\tlet\tbottomLeft = vertices[gradientSegmentInd + 1];\n\t\tlet\tbottomRight = vertices[gradientSegmentInd + 2];\n\t\tlet\ttopRight = vertices[gradientSegmentInd + 3];\n\t\tlet screenHeightVal = Math.max(\n\t\t\tthis.chart.pxToValueByYAxis(this.chart.state.height),\n\t\t\tthis.chart.screen.pxToValueByYAxis(this.chart.state.height)\n\t\t);\n\n\t\tif (segmentState) {\n\t\t\tlet startX = this.toLocalX(segmentState.startXVal);\n\t\t\tlet startY = this.toLocalY(segmentState.startYVal);\n\t\t\tlet endX = this.toLocalX(segmentState.endXVal);\n\t\t\tlet endY = this.toLocalY(segmentState.endYVal);\n\t\t\ttopLeft.set(startX, startY, 0);\n\t\t\ttopRight.set(endX, endY, 0);\n\t\t\tbottomLeft.set(topLeft.x, topLeft.y - screenHeightVal, 0);\n\t\t\tbottomRight.set(topRight.x, topRight.y - screenHeightVal, 0);\n\t\t} else {\n\t\t\ttopLeft.set(0, 0, 0);\n\t\t\ttopRight.set(0, 0, 0);\n\t\t\tbottomLeft.set(0, 0, 0);\n\t\t\tbottomRight.set(0, 0, 0);\n\t\t}\n\n\t}\n\n\tprivate toLocalX(xVal: number): number {\n\t\treturn xVal - this.chart.state.xAxis.range.zeroVal;\n\t}\n\n\n\tprivate toLocalY(yVal: number): number {\n\t\treturn yVal - this.chart.state.yAxis.range.zeroVal;\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsGradientWidget.ts\n **/","\nimport {ChartWidget} from \"../Widget\";\nimport Object3D = THREE.Object3D;\nimport {Chart} from \"../Chart\";\nimport {ITrendOptions, ITrendData, Trend} from \"../Trend\";\nimport Vector2 = THREE.Vector2;\nimport Vector3 = THREE.Vector3;\nimport {TrendSegmentsManager} from \"../TrendSegmentsManager\";\nimport {IScreenTransformOptions} from \"../Screen\";\n\n\nexport interface ITrendWidgetClass<TrendWidgetType> {\n\tnew (chart: Chart, trendName: string): TrendWidgetType;\n\twidgetIsEnabled(trendOptions: ITrendOptions, chart: Chart): boolean;\n}\n\n/**\n * abstract manager class for all trends widgets\n */\nexport abstract class TrendsWidget<TrendWidgetType extends TrendWidget> extends ChartWidget {\n\tprotected abstract getTrendWidgetClass(): ITrendWidgetClass<TrendWidgetType>;\n\tprotected object3D: Object3D;\n\tprotected widgets: {[trendName: string]: TrendWidgetType} = {};\n\n\tonReadyHandler() {\n\t\tthis.object3D = new Object3D();\n\t\tthis.onTrendsChange();\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tvar state = this.chart;\n\t\tstate.onTrendsChange(() => this.onTrendsChange());\n\t\tstate.onTrendChange((trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tthis.onTrendChange(trendName, changedOptions, newData)\n\t\t});\n\t}\n\n\tprotected onTrendsChange() {\n\t\tvar trendsOptions = this.chart.state.trends;\n\t\tvar TrendWidgetClass = this.getTrendWidgetClass();\n\t\tfor (let trendName in trendsOptions) {\n\t\t\tlet trendOptions = trendsOptions[trendName];\n\t\t\tlet widgetCanBeEnabled = TrendWidgetClass.widgetIsEnabled(trendOptions, this.chart);\n\t\t\tif (widgetCanBeEnabled && !this.widgets[trendName]) {\n\t\t\t\tthis.createTrendWidget(trendName);\n\t\t\t} else if (!widgetCanBeEnabled && this.widgets[trendName]){\n\t\t\t\tthis.destroyTrendWidget(trendName);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onTrendChange(trendName: string, changedOptions: ITrendOptions, newData: ITrendData) {\n\t\tvar widget = this.widgets[trendName];\n\t\tif (!widget) return;\n\t\twidget.onTrendChange(changedOptions);\n\t\tif (newData) {\n\t\t\tvar data = this.chart.getTrend(trendName).getData();\n\t\t\tvar isAppend = (!data.length || data[0].xVal < newData[0].xVal);\n\t\t\tisAppend ? widget.appendData(newData) : widget.prependData(newData);\n\t\t}\n\t}\n\n\tgetObject3D(): Object3D {\n\t\treturn this.object3D;\n\t}\n\n\tprivate createTrendWidget(trendName: string) {\n\t\tvar WidgetConstructor = this.getTrendWidgetClass();\n\t\tvar widget = new WidgetConstructor(this.chart, trendName);\n\t\tthis.widgets[trendName] = widget;\n\t\tvar widgetObject = widget.getObject3D();\n\t\twidgetObject.name = trendName;\n\t\tthis.object3D.add(widget.getObject3D());\n\t}\n\n\tprivate destroyTrendWidget(trendName: string) {\n\t\tthis.widgets[trendName].onDestroy();\n\t\tdelete this.widgets[trendName];\n\t\tvar widgetObject = this.object3D.getObjectByName(trendName);\n\t\tthis.object3D.remove(widgetObject);\n\t}\n}\n\n/**\n * based class for all trends widgets\n */\nexport abstract class TrendWidget {\n\tprotected trend: Trend;\n\tprotected unbindList: Function[] = [];\n\n\tconstructor (protected chart: Chart, protected trendName: string) {\n\t\tthis.trend = chart.trendsManager.getTrend(trendName);\n\t\tthis.chart = chart;\n\t\tthis.bindEvents();\n\t}\n\tabstract getObject3D(): Object3D;\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions, chart: Chart) {\n\t\treturn trendOptions.enabled;\n\t}\n\tappendData(newData: ITrendData) {};\n\tprependData(newData: ITrendData) {};\n\tonTrendChange(changedOptions?: ITrendOptions) {}\n\tonDestroy() {\n\t\tfor (let unsubscriber of this.unbindList) {\n\t\t\tunsubscriber();\n\t\t}\n\t}\n\tprotected onSegmentsAnimate(segments: TrendSegmentsManager) {\n\t}\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t}\n\tprotected onTransformationFrame(options: IScreenTransformOptions) {\n\t}\n\tprotected onZoom() {\n\t}\n\n\n\tprotected bindEvents() {\n\n\t\tthis.bindEvent(this.trend.segmentsManager.onAnimationFrame(\n\t\t\t(trendPoints: TrendSegmentsManager) => this.onSegmentsAnimate(trendPoints)\n\t\t));\n\n\t\tthis.bindEvent(this.chart.screen.onTransformationFrame(\n\t\t\t(options) => this.onTransformationFrame(options)\n\t\t));\n\t\t\n\t\tthis.bindEvent(this.chart.screen.onZoomFrame(\n\t\t\t(options) => this.onZoomFrame(options)\n\t\t));\n\n\t\tthis.bindEvent(this.chart.onZoom(() => this.onZoom()));\n\t};\n\n\tprotected bindEvent(unbind: Function) {\n\t\tthis.unbindList.push(unbind);\n\t}\n\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsWidget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport {Chart} from \"../Chart\";\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport {TrendsWidget, TrendWidget} from \"./TrendsWidget\";\nimport { TrendSegmentsManager, ITrendSegmentState } from \"../TrendSegmentsManager\";\nimport LineSegments = THREE.LineSegments;\nimport {IScreenTransformOptions} from \"../Screen\";\nimport { ITrendOptions, TREND_TYPE } from '../Trend';\nimport { Utils } from '../Utils';\n\n\n/**\n * widget for drawing trends lines\n */\nexport class TrendsLineWidget extends TrendsWidget<TrendLine> {\n\tstatic widgetName = \"TrendsLine\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendLine;\n\t}\n}\n\ninterface ILineSegment {\n\tind: number,\n\tsegmentId: number\n}\n\nexport class TrendLine extends TrendWidget {\n\tprivate material: LineBasicMaterial;\n\tprivate lineSegments: LineSegments;\n\tprivate vertices: Vector3[];\n\n\t// contains indexes of free segments\n\tprivate freeSegmentsInds: number[] = [];\n\n\t// contains segments to display\n\tprivate displayedSegments: {[segmentId: number]: ILineSegment} = {};\n\t\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.type == TREND_TYPE.LINE;\n\t}\n\t\n\tconstructor (chart: Chart, trendName: string) {\n\t\tsuper(chart, trendName);\n\t\tvar options = this.trend.getOptions();\n\t\tthis.material = new LineBasicMaterial( { color: options.lineColor, linewidth: options.lineWidth } );\n\t\tthis.initLine();\n\t}\n\n\tgetObject3D() {\n\t\treturn this.lineSegments;\n\t}\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.destroySegments();\n\t\t\tthis.setupSegments();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\tthis.setupSegments();\n\t\t}));\n\t}\n\t\n\tprivate initLine() {\n\t\tlet geometry = new Geometry();\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = this.chart.state.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = this.chart.state.yAxis.range;\n\t\tthis.lineSegments = new LineSegments(geometry, this.material);\n\t\tthis.lineSegments.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.lineSegments.frustumCulled = false;\n\t\tfor (let i = 0; i < this.chart.state.maxVisibleSegments; i++) {\n\t\t\tgeometry.vertices.push(new  Vector3(), new Vector3());\n\t\t\tthis.freeSegmentsInds.push(i);\n\t\t}\n\t\tthis.vertices = geometry.vertices;\n\t\tthis.setupSegments();\n\t}\n\n\tprivate setupSegments() {\n\t\tlet geometry = this.lineSegments.geometry as Geometry;\n\n\t\tlet {firstDisplayedSegment, lastDisplayedSegment} = this.trend.segmentsManager;\n\n\t\tfor (let segmentId in this.displayedSegments) {\n\t\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\t\tlet segment = this.trend.segmentsManager.segments[lineSegment.segmentId];\n\t\t\tlet segmentIsNotDisplayed = (\n\t\t\t\tsegment.startXVal < firstDisplayedSegment.startXVal ||\n\t\t\t\tsegment.endXVal > lastDisplayedSegment.endXVal\n\t\t\t);\n\t\t\tif (segmentIsNotDisplayed) this.destroySegment(Number(segmentId));\n\t\t}\n\n\t\tlet segment = firstDisplayedSegment;\n\t\twhile (segment && segment.xVal <= lastDisplayedSegment.xVal) {\n\t\t\tthis.setupSegment(segment.id, segment.currentAnimationState);\n\t\t\tsegment = segment.getNext();\n\t\t}\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t}\n\n\tprivate setupSegment(segmentId: number, segmentState: ITrendSegmentState) {\n\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\tif (!lineSegment) {\n\t\t\tif (this.freeSegmentsInds.length == 0) Utils.error('Max allocated segments reached');\n\t\t\tlet ind = this.freeSegmentsInds.pop();\n\t\t\tlineSegment = this.displayedSegments[segmentId] = {segmentId, ind};\n\t\t}\n\t\tlet segmentInd = lineSegment.ind;\n\t\tlet lineStartVertex = this.vertices[segmentInd * 2];\n\t\tlet lineEndVertex = this.vertices[segmentInd * 2 + 1];\n\t\tlineStartVertex.set(this.toLocalX(segmentState.startXVal), this.toLocalY(segmentState.startYVal), 0);\n\t\tlineEndVertex.set(this.toLocalX(segmentState.endXVal), this.toLocalY(segmentState.endYVal), 0);\n\t}\n\n\tprivate destroySegments() {\n\t\tfor (let segmentId in this.displayedSegments) this.destroySegment(Number(segmentId));\n\t}\n\n\tprivate destroySegment(segmentId: number) {\n\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\tlet lineStartVertex = this.vertices[lineSegment.ind * 2];\n\t\tlet lineEndVertex = this.vertices[lineSegment.ind * 2 + 1];\n\t\tlineStartVertex.set(0, 0, 0);\n\t\tlineEndVertex.set(0, 0, 0);\n\t\tdelete this.displayedSegments[segmentId];\n\t\tthis.freeSegmentsInds.push(lineSegment.ind);\n\t}\n\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar currentScale = this.lineSegments.scale;\n\t\tlet state = this.chart.state;\n\t\tlet scaleXFactor = state.xAxis.range.scaleFactor;\n\t\tlet scaleYFactor = state.yAxis.range.scaleFactor;\n\t\tif (options.zoomX) currentScale.setX(scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(scaleYFactor * options.zoomY);\n\t}\n\n\n\tprotected onSegmentsAnimate(trendSegments: TrendSegmentsManager) {\n\t\tvar geometry = this.lineSegments.geometry as Geometry;\n\t\tfor (let segmentId of trendSegments.animatedSegmentsIds) {\n\t\t\tif (!this.displayedSegments[segmentId]) continue;\n\t\t\tthis.setupSegment(segmentId, trendSegments.segmentsById[segmentId].currentAnimationState);\n\t\t}\n\t\tgeometry.verticesNeedUpdate = true;\n\t}\n\n\n\tprivate toLocalX(xVal: number): number {\n\t\treturn xVal - this.chart.state.xAxis.range.zeroVal;\n\t}\n\n\tprivate toLocalY(yVal: number): number {\n\t\treturn yVal - this.chart.state.yAxis.range.zeroVal;\n\t}\n\n\tprivate toLocalVec(vec: Vector3): Vector3 {\n\t\treturn new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsLineWidget.ts\n **/","\n\nimport { TrendsWidget, TrendWidget } from './TrendsWidget';\nimport { Chart } from '../Chart';\nimport Object3D = THREE.Object3D;\nimport Geometry = THREE.Geometry;\nimport { IScreenTransformOptions } from '../Screen';\nimport { TrendSegmentsManager, ITrendSegmentState } from '../TrendSegmentsManager';\nimport Vector3 = THREE.Vector3;\nimport Mesh = THREE.Mesh;\nimport Line = THREE.Line;\nimport BoxGeometry = THREE.BoxGeometry;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport { TREND_TYPE, ITrendOptions } from '../Trend';\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport remove = THREE.Cache.remove;\nimport { Utils } from '../Utils';\n\n\nconst RISE_COLOR = 0x2CAC40;\nconst FALL_COLOR = 0xEE5533;\nconst MARGIN_PERCENT = 0.3;\nconst MAX_CANDLES = 100;\n\n/**\n * widget for drawing trends candles\n */\nexport class TrendsCandlesWidget extends TrendsWidget<TrendCandlesWidget> {\n\tstatic widgetName = \"TrendsCandles\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendCandlesWidget;\n\t}\n}\n\n\nexport class TrendCandlesWidget extends TrendWidget {\n\tprivate scaleXFactor: number;\n\tprivate scaleYFactor: number;\n\tprivate object3D: Object3D;\n\t\n\t// contains indexes of free candles\n\tprivate freeCandlesInds: number[] = [];\n\tprivate candlesPool: CandleWidget[] = [];\n\tprivate candles: {[segmentId: number]: CandleWidget} = {};\n\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.type == TREND_TYPE.CANDLE;\n\t}\n\n\tconstructor (chartState: Chart, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tthis.initObject();\n\t}\n\n\n\tgetObject3D() {\n\t\treturn this.object3D;\n\t}\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.destroyCandles();\n\t\t\tthis.setupCandles();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\tthis.setupCandles();\n\t\t}));\n\t}\n\t\n\tprivate initObject() {\n\t\tlet stateData = this.chart.state;\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = stateData.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = stateData.yAxis.range;\n\t\tthis.scaleXFactor = scaleXFactor;\n\t\tthis.scaleYFactor = scaleYFactor;\n\t\tthis.object3D = new Object3D();\n\t\tthis.object3D.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.object3D.frustumCulled = false;\n\t\tfor (let i = 0; i < MAX_CANDLES; i++) this.freeCandlesInds.push(i);\n\t\tthis.setupCandles();\n\t}\n\n\tprivate setupCandles() {\n\n\t\t// remove invisible\n\t\tlet {firstDisplayedSegment, lastDisplayedSegment} = this.trend.segmentsManager;\n\n\t\tfor (let segmentId in this.candles) {\n\t\t\tlet segment = this.candles[segmentId].segment;\n\t\t\tlet segmentIsNotDisplayed = (\n\t\t\t\tsegment.startXVal < firstDisplayedSegment.startXVal ||\n\t\t\t\tsegment.endXVal > lastDisplayedSegment.endXVal\n\t\t\t);\n\t\t\tif (segmentIsNotDisplayed) this.destroyCandle(Number(segmentId));\n\t\t}\n\n\t\tlet segment = firstDisplayedSegment;\n\t\twhile (segment && segment.xVal <= lastDisplayedSegment.xVal) {\n\t\t\tthis.setupCandle(segment.id, segment.currentAnimationState);\n\t\t\tsegment = segment.getNext();\n\t\t}\n\t}\n\n\tprivate destroyCandles() {\n\t\tfor (let segmentId in this.candles) this.destroyCandle(Number(segmentId));\n\t}\n\n\tprivate destroyCandle(segmentId: number) {\n\t\tlet candle = this.candles[segmentId];\n\t\tthis.object3D.remove(candle.getObject3D());\n\t\tdelete this.candles[segmentId];\n\t}\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar currentScale = this.object3D.scale;\n\t\tif (options.zoomX) currentScale.setX(this.scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(this.scaleYFactor * options.zoomY);\n\t}\n\n\tprotected onSegmentsAnimate(trendSegments: TrendSegmentsManager) {\n\t\tfor (let segmentId of trendSegments.animatedSegmentsIds) {\n\t\t\tif (!this.candles[segmentId]) continue;\n\t\t\tlet segmentState = trendSegments.segmentsById[segmentId].currentAnimationState;\n\t\t\tthis.setupCandle(segmentId, segmentState);\n\t\t}\n\t}\n\n\t/**\n\t * create or modify candle\n\t */\n\tprivate setupCandle(candleId: number, segmentState: ITrendSegmentState) {\n\t\tlet candleInd = candleId % MAX_CANDLES;\n\n\t\t// get candle from candlesPool to avoid creating new Objects by performance reasons\n\t\tlet candle = this.candlesPool[candleInd];\n\t\tif (!candle) {\n\t\t\tcandle = this.candlesPool[candleInd] = new CandleWidget();\n\t\t}\n\n\t\tif (!this.candles[candleId]) {\n\t\t\tthis.candles[candleId] = candle;\n\t\t\tthis.object3D.add(candle.getObject3D());\n\t\t}\n\t\tcandle.getObject3D().position.set(this.toLocalX(segmentState.xVal), this.toLocalY(segmentState.yVal), 0);\n\t\tcandle.setSegment(segmentState);\n\t}\n\n\ttoLocalX(xVal: number): number {\n\t\treturn xVal - this.chart.state.xAxis.range.zeroVal;\n\t}\n\n\ttoLocalY(yVal: number): number {\n\t\treturn yVal - this.chart.state.yAxis.range.zeroVal;\n\t}\n\n\ttoLocalVec(vec: Vector3): Vector3 {\n\t\treturn new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\n\t}\n}\n\nclass CandleWidget {\n\tsegment: ITrendSegmentState;\n\tprivate rect: Mesh;\n\tprivate vLine: Line;\n\tprivate hLine: Line;\n\tconstructor () {\n\t\tthis.initObject();\n\t}\n\n\tgetObject3D(): Object3D {\n\t\treturn this.rect;\n\t}\n\n\tsetSegment(segment: ITrendSegmentState) {\n\t\tthis.segment = segment;\n\t\tlet color = segment.endYVal < segment.startYVal ? FALL_COLOR : RISE_COLOR;\n\n\t\t// update rect\n\t\tlet geometry = this.rect.geometry as PlaneGeometry;\n\t\tlet material = this.rect.material as MeshBasicMaterial;\n\t\tlet width = segment.endXVal - segment.startXVal;\n\t\twidth -= width * MARGIN_PERCENT;\n\t\tlet height = Math.max(segment.startYVal, segment.endYVal) - Math.min(segment.startYVal, segment.endYVal);\n\t\tlet [leftTop, rightTop, leftBottom, rightBottom] = geometry.vertices;\n\t\tleftTop.set(-width / 2, height / 2, 0);\n\t\trightTop.set(width / 2, height / 2, 0);\n\t\tleftBottom.set(-width / 2, -height / 2, 0);\n\t\trightBottom.set(width / 2, -height / 2, 0);\n\n\t\t// prevent to draw bars with height < 1px\n\t\tif (Utils.getDistance(leftTop.y, leftBottom.y) < 1) {\n\t\t\tleftBottom.setY(leftBottom.y + 1);\n\t\t\trightBottom.setY(rightBottom.y + 1);\n\t\t}\n\n\t\tmaterial.color.set(color);\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t// update lines\n\t\tlet vLineGeometry = this.vLine.geometry as Geometry;\n\t\tlet vLineMaterial = this.vLine.material as LineBasicMaterial;\n\t\tlet lineTop = segment.maxYVal - segment.yVal;\n\t\tlet lineBottom = segment.minYVal - segment.yVal;\n\t\tvLineGeometry.vertices[0].set(0, lineTop, 0);\n\t\tvLineGeometry.vertices[1].set(0, lineBottom, 0);\n\t\tvLineMaterial.color.set(color);\n\t\tvLineGeometry.verticesNeedUpdate = true;\n\n\t\tlet hLineGeometry = this.hLine.geometry as Geometry;\n\t\tlet hLineMaterial = this.hLine.material as LineBasicMaterial;\n\t\tlet lineLeft = (-width) / 2;\n\t\tlet lineRight = width / 2;\n\t\thLineGeometry.vertices[0].set(lineLeft, 0, 0);\n\t\thLineGeometry.vertices[1].set(lineRight, 0, 0);\n\t\thLineMaterial.color.set(color);\n\t\thLineGeometry.verticesNeedUpdate = true;\n\n\t}\n\n\tprivate initObject() {\n\t\tthis.rect = new Mesh(\n\t\t\tnew PlaneGeometry(1, 1),\n\t\t\tnew MeshBasicMaterial()\n\t\t);\n\t\tlet vLineGeometry = new Geometry();\n\t\tlet hLineGeometry = new Geometry();\n\t\tvLineGeometry.vertices.push(new Vector3(), new Vector3);\n\t\thLineGeometry.vertices.push(new Vector3(), new Vector3);\n\t\tthis.vLine = new Line(vLineGeometry, new LineBasicMaterial({linewidth: 1}));\n\t\tthis.hLine = new Line(hLineGeometry, new LineBasicMaterial({linewidth: 1}));\n\t\tthis.rect.add(this.vLine);\n\t\tthis.rect.add(this.hLine);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsCandleWidget.ts\n **/","import { Utils } from './Utils';\nimport { IIteralable } from './interfaces';\nimport { EventEmitter } from './EventEmmiter'\n\nexport class UniqCollectionItem {\n\tprivate _id: number;\n\tgetId() {\n\t\treturn this._id;\n\t}\n}\n\nconst ID_KEY = '_id';\n\nconst EVENTS = {\n\tCREATE: 'create',\n\tUPDATE: 'update',\n\tREMOVE: 'remove'\n};\n\nexport interface IUniqCollectionOptions<TItem, TItemModel> {\n\tcreateInstance: (itemModel: TItemModel) => TItem;\n}\n\n/**\n * useful for patching collections with id key\n */\nexport class UniqCollection<TItem extends UniqCollectionItem, TItemModel> {\n\tprotected items: TItem[] = [];\n\tprotected options: IUniqCollectionOptions<TItem, TItemModel>;\n\tprotected ee = new EventEmitter();\n\tconstructor(options: IUniqCollectionOptions<TItem, TItemModel>) {\n\t\tthis.options = options;\n\t}\n\n\tpatch(models: TItemModel[]) {\n\t\tlet options = this.options;\n\t\tfor (let model of models) {\n\t\t\tlet id = (model as IIteralable)[ID_KEY];\n\t\t\tif (!id) Utils.error('Collection item without id detected');\n\t\t\tlet ind = this.getItemInd(id);\n\t\t\tlet item = this.items[ind];\n\t\t\tlet justCreated = false;\n\n\t\t\t// create\n\t\t\tif (!item) {\n\t\t\t\tjustCreated = true;\n\t\t\t\titem = options.createInstance(model);\n\t\t\t\tthis.items.push(item);\n\t\t\t}\n\n\t\t\t// update\n\t\t\tif (Object.keys(model).length > 1) {\n\t\t\t\tlet prevProps = {};\n\t\t\t\tUtils.copyProps(item, prevProps, model);\n\t\t\t\tUtils.patch(item as IIteralable, model);\n\t\t\t\tjustCreated && this.ee.emit(EVENTS.CREATE, item);\n\t\t\t\tthis.ee.emit(EVENTS.UPDATE, item, model, prevProps as TItemModel);\n\n\t\t\t// delete\n\t\t\t} else {\n\t\t\t\tthis.items.splice(ind, 1);\n\t\t\t\tthis.ee.emit(EVENTS.REMOVE, item);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tgetItem(id: number): TItem {\n\t\treturn this.items[this.getItemInd(id)];\n\t}\n\n\n\tgetLast(): TItem {\n\t\treturn this.items[this.items.length - 1];\n\t}\n\n\n\tforEach(cb: (item: TItem) => any) {\n\t\tfor (let key in this.items) cb(this.items[key]);\n\t}\n\n\n\tfilter(cb: (item: TItem) => boolean): TItem[] {\n\t\tlet result: TItem[] = [];\n\t\tthis.forEach(item => cb(item) && result.push(item));\n\t\treturn result;\n\t}\n\n\n\tonCreate(cb: (item: TItem) => any): Function {\n\t\treturn this.ee.subscribe(EVENTS.CREATE, cb);\n\t}\n\n\n\tonUpdate (cb: (item: TItem, itemModel: TItemModel, prevProps: TItemModel) => any): Function {\n\t\treturn this.ee.subscribe(EVENTS.UPDATE, cb);\n\t}\n\n\n\tonRemove(cb: (item: TItem) => any): Function {\n\t\treturn this.ee.subscribe(EVENTS.REMOVE, cb);\n\t}\n\n\n\tprotected getItemInd(id: number) {\n\t\treturn Utils.binarySearchInd(this.items, id, ID_KEY);\n\t}\n\n}\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/UniqCollection.ts\n **/","export * from './AxisWidget';\nexport * from './GridWidget';\nexport * from './TrendsWidget';\nexport * from './TrendsLineWidget';\nexport * from './TrendsGradientWidget';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/index.ts\n **/"],"sourceRoot":""}