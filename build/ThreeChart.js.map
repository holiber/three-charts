{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ThreeChart.js","webpack:///webpack/bootstrap aa8a96c64dad3de6cbf0","webpack:///./index.ts","webpack:///./src/index.ts","webpack:///./src/Chart.ts","webpack:///./src/Plugin.ts","webpack:///./src/Utils.ts","webpack:///./src/deps/deps.ts","webpack:///./~/three/examples/js/libs/stats.min.js","webpack:///./~/three/examples/js/renderers/CanvasRenderer.js","webpack:///./~/three/examples/js/renderers/Projector.js","webpack:///./~/is-plain-object/index.js","webpack:///./~/isobject/index.js","webpack:///./~/EventEmitter2/lib/eventemitter2.js","webpack:///./src/polyfills/es6-promise.js","webpack:///./~/css-element-queries/src/ResizeSensor.js","webpack:///./src/EventEmmiter.ts","webpack:///./src/State.ts","webpack:///./src/Trend.ts","webpack:///./src/TrendSegmentsManager.ts","webpack:///./src/TrendsManager.ts","webpack:///./src/Screen.ts","webpack:///./src/AxisMarks.ts","webpack:///./src/interfaces.ts","webpack:///./src/Widget.ts","webpack:///./src/widgets/AxisWidget.ts","webpack:///./src/widgets/GridWidget.ts","webpack:///./src/widgets/TrendsGradientWidget.ts","webpack:///./src/widgets/TrendsWidget.ts","webpack:///./src/Color.ts","webpack:///./src/widgets/TrendsLineWidget.ts","webpack:///./src/widgets/TrendsCandleWidget.ts"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","__export","hasOwnProperty","Plugin_1","PerspectiveCamera","THREE","State_1","Widget_1","Utils_1","AxisWidget_1","GridWidget_1","TrendsGradientWidget_1","TrendsLineWidget_1","TrendsCandleWidget_1","Chart","state","$container","pluginsAndWidgets","_this","widgets","REVISION","Utils","error","style","getComputedStyle","width","parseInt","height","plugins","filter","pluginOrWidget","ChartPlugin","ChartState","zoomThrottled","throttle","zoomValue","origin","zoom","init","installWidget","Widget","widgetName","preinstalledWidgets","push","prototype","_a","data","w","h","showStats","autoRender","scene","Scene","isStopped","enabled","renderer","renderers","antialias","alpha","setSize","setPixelRatio","devicePixelRatio","setClearColor","backgroundColor","backgroundOpacity","appendChild","domElement","$el","display","stats","Stats","setupCamera","initWidgets","bindEvents","renderLoop","preinstalledWidgetsClasses","constructor","customWidgets","forEach","ChartWidget","pluginWidgetClasses","providedWidgets","apply","concat","map","WidgetClass","widget","setupChartState","onReadyHandler","add","getObject3D","isDestroyed","begin","render","fpsLimit","fps","delay_1","setTimeout","requestAnimationFrame","end","camera","stop","run","destroy","unbindEvents","forceContextLoss","wtf","context","getState","getTrend","trendName","setState","controls","addEventListener","ev","onMouseWheel","onMouseMove","onMouseDown","onMouseUp","onTouchMove","onTouchEnd","autoResize","unsubscribers","onTrendsChange","autoscroll","screen","onTransformationFrame","options","onScreenTransformHandler","onResize","onChartResize","resizeSensor","detach","e","remove","unsubscribe","camSettings","getCameraSettings","FOV","aspect","near","far","fov","updateProjectionMatrix","position","set","x","y","z","cameraInitialPosition","clone","scrollX","scrollX_1","setX","scrollY","scrollY_1","setY","autoScroll","oldTrendsMaxX","prevState","computedData","trends","maxXVal","trendsMaxXDelta","maxVisibleX","getScreenRightVal","paddingRightX","getPaddingRight","currentScroll","xAxis","range","scroll","scrollDelta","onScrollStop","cursor","dragMode","clientX","clientY","stopPropagation","preventDefault","zoomOrigin","layerX","wheelDeltaY","touches","onChartContainerResizeHandler","MAX_ZOOM_VALUE","MIN_ZOOM_VALUE","Math","min","max","autoScrollIsEnabled","then","window","CanvasRenderer","WebGLRenderer","TrendsLineWidget","TrendsCandlesWidget","AxisWidget","GridWidget","TrendsGradientWidget","EventEmmiter_1","DEFAULT_CONFIG","installPluginWidgets","config","initialState","deepMerge","name","NAME","chartState","ee","EventEmitter","bindEvent","onInitialStateApplied","onInitialStateAppliedHandler","onReady","onDestroy","onDestroyHandler","onPluginsStateChange","changedPluginsStates","onStateChanged","getOptions","pluginsState","changedState","removeAllListeners","args","_i","arguments","length","Array","isArray","unsubscriber","deps_1","deepmerge","target","src","mergeArrays","array","dst","i","indexOf","Object","keys","key","obj1","obj2","deepCopy","obj","JSON","parse","stringify","toFixed","num","digitsCount","maxDigits","result","intVal","floor","intStr","toString","lengthDiff","repeat","afterPointDigitsCount","afterPointStr","split","substr","createTexture","fn","canvas","document","createElement","ctx","getContext","texture","Texture","needsUpdate","createPixelPerfectTexture","minFilter","NearestFilter","msg","console","warn","getUid","currentId","getDistance","num1","num2","binarySearchClosestInd","arr","mid","lo","hi","binarySearchClosest","ind","rectsIntersect","r1","r2","left1","top1","width1","height1","left2","top2","width2","height2","right1","right2","bottom1","bottom2","func","ms","isThrottled","savedArgs","savedThis","wrapper","msToTimeString","timestamp","s","getRandomItem","random","copyProps","srcObject","dstObject","props","excludeProps","isPlainObject","TweenLite","TweenMax","EE2","es6_promise_1","Promise","ResizeSensor","a","dom","k","d","children","l","cssText","g","performance","Date","now","r","Panel","f","self","memory","t","addPanel","showPanel","update","usedJSHeapSize","jsHeapSizeLimit","setMode","Infinity","round","u","n","q","b","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","v","drawImage","SpriteCanvasMaterial","parameters","Material","type","color","Color","program","setValues","create","material","copy","log","_renderData","_elements","_lights","_projector","Projector","_canvas","undefined","_canvasWidth","_canvasHeight","_canvasWidthHalf","_canvasHeightHalf","_viewportX","_viewportY","_viewportWidth","_viewportHeight","_pixelRatio","_context","_clearColor","_clearAlpha","_contextGlobalAlpha","_contextGlobalCompositeOperation","_contextStrokeStyle","_contextFillStyle","_contextLineWidth","_contextLineCap","_contextLineJoin","_contextLineDash","_camera","_v1","_v2","_v3","_v4","_v5","RenderableVertex","_v6","_v1x","_v1y","_v2x","_v2y","_v3x","_v3y","_v4x","_v4y","_v5x","_v5y","_v6x","_v6y","_color","_color1","_color2","_color3","_color4","_diffuseColor","_emissiveColor","_lightColor","_patterns","_image","_uvs","_uv1x","_uv1y","_uv2x","_uv2y","_uv3x","_uv3y","_clipBox","Box2","_clearBox","_elemBox","_ambientLight","_directionalLights","_pointLights","_vector3","Vector3","_centroid","_normal","_normalViewMatrix","Matrix3","setLineDash","autoClear","sortObjects","sortElements","info","vertices","faces","supportsVertexTextures","setFaceCulling","getContextAttributes","getPixelRatio","value","updateStyle","setViewport","setScissor","setScissorTest","setClearColorHex","hex","getClearColor","getClearAlpha","getMaxAnisotropy","clear","isEmpty","intersect","expandByScalar","clearRect","setBlending","NormalBlending","setOpacity","setFillStyle","makeEmpty","clearColor","clearDepth","clearStencil","Camera","setTransform","translate","projectScene","elements","lights","getNormalMatrix","matrixWorldInverse","calculateLights","el","element","opacity","RenderableSprite","renderSprite","RenderableLine","v1","v2","positionScreen","setFromPoints","intersectsBox","renderLine","RenderableFace","v3","overdraw","expand","renderFace3","union","setRGB","ll","light","lightColor","AmbientLight","DirectionalLight","PointLight","calculateLight","normal","lightPosition","setFromMatrixPosition","matrixWorld","normalize","amount","dot","intensity","multiplyScalar","subVectors","distance","distanceTo","blending","scaleX","scale","scaleY","dist","sqrt","SpriteMaterial","pattern","version","textureToPattern","bitmap","image","ox","offset","oy","sx","sy","cx","cy","save","rotation","rotate","restore","getStyle","setStrokeStyle","beginPath","moveTo","lineTo","LineBasicMaterial","setLineWidth","linewidth","setLineCap","linecap","setLineJoin","linejoin","vertexColors","VertexColors","colorStyle1","colorStyle2","grad","createLinearGradient","addColorStop","exception","stroke","LineDashedMaterial","dashSize","gapSize","uv1","uv2","uv3","drawTriangle","MeshLambertMaterial","MeshPhongMaterial","emissive","FaceColors","multiply","positionWorld","divideScalar","normalModel","wireframe","strokePath","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","fillPath","MeshBasicMaterial","mapping","UVMapping","uvs","patternPath","envMap","SphericalReflectionMapping","vertexNormalsModel","applyMatrix3","MeshNormalMaterial","addScalar","x0","y0","x1","y1","x2","y2","closePath","fill","CompressedTexture","DataTexture","complete","repeatX","wrapS","RepeatWrapping","repeatY","wrapT","createPattern","onUpdate","u0","v0","u1","u2","det","idet","offsetX","offsetY","transform","clipImage","clip","pixels","globalCompositeOperation","AdditiveBlending","SubtractiveBlending","MultiplyBlending","lineWidth","lineCap","lineJoin","strokeStyle","RenderableObject","object","renderOrder","vertexNormalsLength","Vector2","Vector4","visible","vertex","_object","_objectCount","_objectPool","_objectPoolLength","_vertex","_vertexCount","_vertexPool","_vertexPoolLength","_face","_faceCount","_facePool","_facePoolLength","_line","_lineCount","_linePool","_linePoolLength","_sprite","_spriteCount","_spritePool","_spritePoolLength","objects","_vector4","Box3","_boundingBox","_points3","_points4","_viewMatrix","Matrix4","_viewProjectionMatrix","_modelMatrix","_modelViewProjectionMatrix","_normalMatrix","_frustum","Frustum","_clippedVertex1PositionScreen","_clippedVertex2PositionScreen","projectVector","vector","project","unprojectVector","unproject","pickingRay","RenderList","normals","normalMatrix","setObject","projectVertex","applyMatrix4","invW","pushVertex","getNextVertexInPool","pushNormal","pushUv","checkTriangleVisibility","checkBackfaceCulling","pushLine","getNextLineInPool","pushTriangle","side","DoubleSide","getNextFaceInPool","fromArray","uv","renderList","autoUpdate","updateMatrixWorld","parent","getInverse","multiplyMatrices","projectionMatrix","setFromMatrix","addObject","getNextObjectInPool","applyProjection","traverseVisible","Light","Mesh","Line","frustumCulled","intersectsObject","Sprite","intersectsSprite","sort","painterSort","o","ol","geometry","BufferGeometry","attributes","groups","positions","index","indices","group","start","count","Geometry","faceVertexUvs","isFaceMaterial","MultiMaterial","objectMaterials","vl","morphTargets","morphInfluences","morphTargetInfluences","tl","influence","targetVertex","fl","face","materials","materialIndex","FrontSide","BackSide","negate","faceVertexNormals","vertexNormals","nl","vertexUvs","step","LineSegments","clipLine","colors","getNextSpriteInPool","abs","line","sprite","s1","s2","alpha1","alpha2","bc1near","bc2near","bc1far","bc2far","lerp","isObject","isObjectObject","ctor","prot","val","__WEBPACK_AMD_DEFINE_RESULT__","_isArray","defaultMaxListeners","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","searchListenerTree","handlers","tree","listeners","leaf","len","branch","xTree","xxTree","isolatedBranch","endReached","typeLength","currentType","nextType","_listeners","**","growListenerTree","listener","slice","shift","warned","trace","setMaxListeners","event","once","many","ttl","Error","off","_origin","on","emit","_all","handler","ns","onAny","addListener","leafs","iLeaf","splice","offAny","fns","removeListener","listenersAny","EventEmitter2","callback","EventQueue","j","prop","currentStyle","getPropertyValue","attachResizeEvent","resized","resizedAttached","className","styleChild","innerHTML","fixed","absolute","childNodes","expandChild","shrink","shrinkChild","lastWidth","lastHeight","reset","offsetWidth","offsetHeight","scrollLeft","scrollWidth","scrollTop","scrollHeight","changed","addEvent","cb","attachEvent","onScroll","elementType","isCollectionTyped","jQuery","Elements","removeChild","eventName","subscribe","listenersCount","Trend_1","TrendsManager_1","Screen_1","AxisMarks_1","interfaces_1","CHART_STATE_EVENTS","INITIAL_STATE_APPLIED","READY","DESTROY","CHANGE","TREND_CHANGE","TRENDS_CHANGE","ZOOM","RESIZE","SCROLL","SCROLL_STOP","PLUGINS_STATE_CHANGED","AXIS_RANGE_TYPE","ALL","from","to","padding","margin","dataType","AXIS_DATA_TYPE","NUMBER","grid","minSizePx","marks","yAxis","RELATIVE_END","animations","trendChangeSpeed","trendChangeEase","zoomSpeed","zoomEase","scrollSpeed","scrollEase","Linear","easeNone","autoScrollSpeed","autoScrollEase","trendDefaultState","TREND_TYPE","LINE","maxSegmentLength","lineColor","hasBackground","hasBeacon","settingsForTypes","CANDLE","minSegmentLengthInPx","maxSegmentLengthInPx","eventEmitterMaxListeners","maxVisibleSegments","isReady","trendsManager","TrendsManager","calculatedOptions","installPlugins","getComputedData","savePrevState","Screen","xAxisMarks","AxisMarks","AXIS_TYPE","X","yAxisMarks","Y","initListeners","onChange","onTrendChange","onZoom","newState","eventData","silent","stateData","newStateObj","changedProps","trendsData","trendOptions","newStateContainsData","recalculateResult","recalculateState","emitChangedStateEvents","patch","actualData","cursorOptions","isMouseDrag","oldX","currentX","deltaXVal","pxToValueByXAxis","chartWasResized","scrollXChanged","needToRecalculateXAxis","zeroVal","xAxisPatch","recalculateXAxis","needToRecalculateYAxis","AUTO","isMirrorMode","yAxisPatch","recalculateYAxis","allChangedProps","computeAll","getEndXVal","minXVal","getStartXVal","scrollStopEventNeeded","scrollChangeEventsNeeded","zoomEventsNeeded","resizeEventNeeded","pluginStateChangedEventNeeded","plugin","PluginClass","pluginName","getPlugin","changedTrends","newData","handleTrendsChange","axisRange","isInitialize","scaleFactor","currentScaleFactor","rangeLength","needToRecalculateZoom","rangeMoreThenMaxValue","maxLength","rangeLessThenMinValue","minLength","fixScale","yAxisRange","trendsEndXVal","trendsStartXVal","xRange","xFrom","xTo","xRangeLength","needToZoom","maxY","getMaxYVal","minY","getMinYVal","trendLastY","distanceFromZeroValForMaxY","distanceFromZeroValForMinY","maxDistanceFromZeroVal","paddingTopInPercents","paddingBottomInPercents","rangeLengthInPercents","visibleRangeLength","fromVal","toVal","maxScreenY","getScreenYByValue","minScreenY","currentAxisRange","newZoom","currentRange","nextRange","newScroll","resolve","animationTime","zoomToRange","scrollToEnd","endXVal","getPointOnXAxis","xVal","getPointOnYAxis","yVal","getValueOnXAxis","valueToPxByXAxis","valueToPxByYAxis","pxToValueByYAxis","getValueByScreenX","getValueByScreenY","getScreenXByValue","getScreenXByPoint","getPointByScreenX","screenX","getPointOnChart","getScreenLeftVal","TrendSegmentsManager_1","EVENTS","PREPEND_REQUEST","Trend","minYVal","maxYVal","dataset","prepareData","segmentsManager","TrendSegmentsManager","checkForPrependRequest","changedOptions","getCalculatedOptions","appendData","rawData","getData","updatedTrendData","changeData","prependData","allData","newData_1","item","statePatch","fromX","toX","filteredData","data_1","getFirstItem","getLastItem","setOptions","onPrependRequest","onDataChange","onChangeCb","prependRequest","minScreenX","needToRequest","requestedDataLength","reject","currentData","isPrepend","initialItem","MAX_ANIMATED_SEGMENTS","REBUILD","DISLPAYED_RANGE_CHANGED","ANIMATION_FRAME","trend","segmentsById","segments","animatedSegmentsIds","segmentsLength","animatedSegmentsForAppend","animatedSegmentsForPrepend","nextEmptyId","startSegmentId","endSegmentId","tryToRebuildSegments","onTrendChangeHandler","onZoomHandler","recalculateDisplayedRange","appendAnimation","kill","prependAnimation","segmentsRebuilded","needToRebuildSegments","isAppend","getSegment","getEndSegment","getStartSegment","force","trendTypeName","trendTypesSettings","trendTypeSettings","needToRebuild","segmentLength","currentSegmentLengthInPx","Number","currentMaxSegmentLengthInPx","ceil","stopAllAnimations","segmentsAreRebuilded","_b","firstDisplayedSegment","lastDisplayedSegment","displayedRange","firstDisplayedSegmentInd","lastDisplayedSegmentInd","displayedRangeChanged","getSegmentsForXValues","values","valueInd","lastValueInd","results","segment","hasValue","startXVal","getNext","valueInPoint","onAnimationFrame","onRebuild","onDisplayedRangeChanged","allocateNextSegment","TrendSegment","prevSegment","nextId","prevId","allocatePrevSegment","nextSegment","unshift","needRebuildSegments","trendData","startItemInd","initialSegment","initialAnimationState","createAnimationState","itemInd","itemIsInserted","appendItem","isLastItem","isCompleted","recalculateItems","segmentIsReadyForAnimate","startYVal","endYVal","targetAnimationState","prevItem","animationsOptions","time","segmentId","segment_1","currentAnimationState","animate","prependItem","nextItem","animation","isActive","onAnimationFrameHandler","ease","objectToAnimate","animationValue","eventCallback","coefficient","animatedSegmentsIds_1","targetValue","initialValue","currentValue","trendPoints","items","trendSegments","itemsLength","endItem","startItem","minX","maxX","middleXVal","middleYVal","yVals","nextPoint","getPrev","prevPoint","getFrameVal","getFramePoint","frameVal","SEGMENTS_REBUILDED","trendsCalculatedOptions","createTrend","getEnabledTrends","enabledTrends","allTrends","firstTrendData","getExtremumYVal","extremumIsMax","compareFn","trends_1","trendYValues","dataItem","NaN","onSegmentsRebuilded","_loop_1","this_1","scrollXVal","scrollYVal","zoomX","zoomY","currentScrollX","currentScrollY","currentZoomX","currentZoomY","vFOV","PI","tan","onZoomFrame","onScrollFrame","cameraIsMoving","scrollXAnimation","zoomXAnimation","onScrollXHandler","onZoomXHandler","onScrollYHandler","onZoomYHandler","scrollYAnimation","zoomYAnimation","isDragMode","canAnimate","zoomXChanged","isAutoscroll","pause","targetX","targetY","targetZoom","getPointByScreenY","screenY","getTop","getBottom","getLeft","getTopVal","getBottomVal","getCenterYVal","__extends","__","AXIS_MARK_DEFAULT_OPTIONS","showValue","stickToEdges","title","axisType","axisMarksOptions","axisMarksOptions_1","axisMark","AxisTimeleftMark","AxisMark","startVal","endVal","markName","mark","markVal","markWasCrossed","getItems","getItem","renderOnTrendsChange","newOptions","getDisplayedVal","displayedValue","String","onMarkCrossed","onValueChange","onDisplayedValueChange","typeName","_super","unbindList","unbindEvent","Object3D","object3D","axisXObject","axisYObject","setupAxis","updateAxisXRequest","updateAxis","onScrollChange","orientation","isXAxis","visibleWidth","visibleHeight","canvasWidth","canvasHeight","traverse","transparent","axisMesh","PlaneGeometry","axisOptions","axisGridParams","getGridParamsForAxis","edgeOffset","segmentsCount","pxVal","textAlign","DATE","getDateStr","gridParams","sec","hour","day","tf","getHours","getMinutes","getSeconds","gridSizeH","gridSizeV","initGrid","updateGrid","updateGridThrottled","xLinesCount","yLinesCount","lineSegments","setZ","axisXGrid","axisYGrid","scrollXInSegments","scrollYInSegments","gridScrollXVal","gridScrollYVal","lineInd","lineSegment","getVerticalLineSegment","getHorizontalLineSegment","verticesNeedUpdate","localYVal","widthVal","localXVal","heightVal","axisWidth","axisLength","gridStep","gridStepInPixels","minGridStepInPixels","axisLengthStr","axisLengthPointPosition","intPartLength","gridStepFound","digitPos","power","multiplier","pow","dividers","dividerInd","nextGridStep","nextGridStepInPixels","gridStart","gridEnd","stepInPx","TrendsWidget_1","Color_1","getTrendWidgetClass","TrendGradient","TrendsWidget","visibleSegmentsCnt","segmentsIds","Uint16Array","initGradient","updateSegments","widgetIsEnabled","gradient","Face3","ChartColor","scaleXFactor","scaleYFactor","currentScale","onSegmentsAnimate","trendSegmentsManager","includes","setupSegmentVertices","segmentInd","prevVisibleSegmentsCnt","segmentsToProcessCnt","segmentState","gradientSegmentInd","topLeft","bottomLeft","bottomRight","topRight","screenHeightVal","startX","toLocalX","startY","toLocalY","endX","endY","TrendWidget","trendsOptions","TrendWidgetClass","widgetCanBeEnabled","createTrendWidget","destroyTrendWidget","WidgetConstructor","widgetObject","getObjectByName","unbind","parseColor","cache","replace","exec","isNaN","colorStr","rgba","hexStr","rgbaStr","TrendLine","freeSegmentsInds","displayedSegments","initLine","destroySegments","setupSegments","segmentIsNotDisplayed","destroySegment","setupSegment","pop","lineStartVertex","lineEndVertex","toLocalVec","vec","RISE_COLOR","FALL_COLOR","MARGIN_PERCENT","MAX_CANDLES","TrendCandlesWidget","freeCandlesInds","candlesPool","candles","initObject","destroyCandles","setupCandles","destroyCandle","setupCandle","candle","candleId","candleInd","CandleWidget","setSegment","rect","leftTop","rightTop","leftBottom","rightBottom","vLineGeometry","vLine","vLineMaterial","lineTop","lineBottom","hLineGeometry","hLine","hLineMaterial","lineLeft","lineRight"],"mappings":"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","file":"ThreeChart.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory();\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"THREE_CHARTS\"] = factory();\n\telse\n\t\troot[\"THREE_CHARTS\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(1));\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tfunction __export(m) {\r\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n\t}\r\n\t__export(__webpack_require__(2));\r\n\t__export(__webpack_require__(21));\r\n\t__export(__webpack_require__(20));\r\n\t__export(__webpack_require__(19));\r\n\t__export(__webpack_require__(15));\r\n\t__export(__webpack_require__(16));\r\n\t__export(__webpack_require__(17));\r\n\t__export(__webpack_require__(18));\r\n\t__export(__webpack_require__(4));\r\n\t__export(__webpack_require__(22));\r\n\t__export(__webpack_require__(3));\r\n\t__export(__webpack_require__(26));\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t// deps must be always on top\r\n\tvar Plugin_1 = __webpack_require__(3);\r\n\t__webpack_require__(5);\r\n\tvar PerspectiveCamera = THREE.PerspectiveCamera;\r\n\tvar State_1 = __webpack_require__(15);\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar AxisWidget_1 = __webpack_require__(23);\r\n\tvar GridWidget_1 = __webpack_require__(24);\r\n\tvar TrendsGradientWidget_1 = __webpack_require__(25);\r\n\tvar TrendsLineWidget_1 = __webpack_require__(28);\r\n\tvar TrendsCandleWidget_1 = __webpack_require__(29);\r\n\tvar Chart = (function () {\r\n\t    function Chart(state, $container, pluginsAndWidgets) {\r\n\t        var _this = this;\r\n\t        if (pluginsAndWidgets === void 0) { pluginsAndWidgets = []; }\r\n\t        this.widgets = [];\r\n\t        if (!THREE || !THREE.REVISION)\r\n\t            Utils_1.Utils.error('three.js not found');\r\n\t        if (!$container) {\r\n\t            Utils_1.Utils.error('$el must be set');\r\n\t        }\r\n\t        // calculate chart size\r\n\t        var style = getComputedStyle($container);\r\n\t        state.width = parseInt(style.width);\r\n\t        state.height = parseInt(style.height);\r\n\t        var plugins = pluginsAndWidgets.filter(function (pluginOrWidget) { return pluginOrWidget instanceof Plugin_1.ChartPlugin; });\r\n\t        this.state = new State_1.ChartState(state, plugins);\r\n\t        this.pluginsAndWidgets = pluginsAndWidgets;\r\n\t        this.zoomThrottled = Utils_1.Utils.throttle(function (zoomValue, origin) { return _this.zoom(zoomValue, origin); }, 200);\r\n\t        this.$container = $container;\r\n\t        this.init($container);\r\n\t    }\r\n\t    ;\r\n\t    Chart.installWidget = function (Widget) {\r\n\t        if (!Widget.widgetName)\r\n\t            Utils_1.Utils.error('unnamed widget');\r\n\t        this.preinstalledWidgets.push(Widget);\r\n\t    };\r\n\t    Chart.prototype.init = function ($container) {\r\n\t        var state = this.state;\r\n\t        var _a = state.data, w = _a.width, h = _a.height, showStats = _a.showStats, autoRender = _a.autoRender;\r\n\t        this.scene = new THREE.Scene();\r\n\t        this.isStopped = !autoRender.enabled;\r\n\t        var renderer = this.renderer = new Chart.renderers[this.state.data.renderer]({\r\n\t            antialias: true,\r\n\t            alpha: true\r\n\t        });\r\n\t        renderer.setSize(w, h);\r\n\t        renderer.setPixelRatio(Chart.devicePixelRatio);\r\n\t        renderer.setClearColor(state.data.backgroundColor, state.data.backgroundOpacity);\r\n\t        $container.appendChild(renderer.domElement);\r\n\t        this.$el = renderer.domElement;\r\n\t        this.$el.style.display = 'block';\r\n\t        if (showStats) {\r\n\t            this.stats = new Stats();\r\n\t            $container.appendChild(this.stats.domElement);\r\n\t        }\r\n\t        this.setupCamera();\r\n\t        this.initWidgets();\r\n\t        this.bindEvents();\r\n\t        this.renderLoop();\r\n\t    };\r\n\t    /**\r\n\t     * collect and init widgets from preinstalled widgets, plugins widgets and custom widgets\r\n\t     */\r\n\t    Chart.prototype.initWidgets = function () {\r\n\t        var _this = this;\r\n\t        var preinstalledWidgetsClasses = this.constructor.preinstalledWidgets;\r\n\t        var customWidgets = [];\r\n\t        this.pluginsAndWidgets.forEach(function (pluginOrWidget) {\r\n\t            if (pluginOrWidget instanceof Widget_1.ChartWidget) {\r\n\t                customWidgets.push(pluginOrWidget);\r\n\t                return;\r\n\t            }\r\n\t            if (!(pluginOrWidget instanceof Plugin_1.ChartPlugin))\r\n\t                return;\r\n\t            var pluginWidgetClasses = pluginOrWidget.constructor.providedWidgets;\r\n\t            preinstalledWidgetsClasses.push.apply(preinstalledWidgetsClasses, pluginWidgetClasses);\r\n\t        });\r\n\t        this.widgets = customWidgets.concat(preinstalledWidgetsClasses.map(function (WidgetClass) { return new WidgetClass(); }));\r\n\t        this.widgets.forEach(function (widget) {\r\n\t            widget.setupChartState(_this.state);\r\n\t            widget.onReadyHandler();\r\n\t            _this.scene.add(widget.getObject3D());\r\n\t        });\r\n\t    };\r\n\t    Chart.prototype.renderLoop = function () {\r\n\t        var _this = this;\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        this.stats && this.stats.begin();\r\n\t        this.render();\r\n\t        if (this.isStopped)\r\n\t            return;\r\n\t        var fpsLimit = this.state.data.autoRender.fps;\r\n\t        if (fpsLimit) {\r\n\t            var delay_1 = 1000 / fpsLimit;\r\n\t            setTimeout(function () { return requestAnimationFrame(function () { return _this.renderLoop(); }); }, delay_1);\r\n\t        }\r\n\t        else {\r\n\t            requestAnimationFrame(function () { return _this.renderLoop(); });\r\n\t        }\r\n\t        this.stats && this.stats.end();\r\n\t    };\r\n\t    Chart.prototype.render = function () {\r\n\t        this.renderer.render(this.scene, this.camera);\r\n\t    };\r\n\t    Chart.prototype.stop = function () {\r\n\t        this.isStopped = true;\r\n\t    };\r\n\t    Chart.prototype.run = function () {\r\n\t        this.isStopped = false;\r\n\t        this.renderLoop();\r\n\t    };\r\n\t    /**\r\n\t     * call to destroy chart an init garbage collection\r\n\t     */\r\n\t    Chart.prototype.destroy = function () {\r\n\t        this.isDestroyed = true;\r\n\t        this.stop();\r\n\t        this.state.destroy();\r\n\t        this.unbindEvents();\r\n\t        // WARNING! undocumented method for free webgl context\r\n\t        try {\r\n\t            this.renderer.forceContextLoss();\r\n\t        }\r\n\t        catch (wtf) {\r\n\t        }\r\n\t        this.renderer.context = null;\r\n\t        this.renderer.domElement = null;\r\n\t        this.renderer = null;\r\n\t    };\r\n\t    Chart.prototype.getState = function () {\r\n\t        return this.state.data;\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for Chart.state.getTrend\r\n\t     */\r\n\t    Chart.prototype.getTrend = function (trendName) {\r\n\t        return this.state.getTrend(trendName);\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for Chart.state.setState\r\n\t     */\r\n\t    Chart.prototype.setState = function (state) {\r\n\t        return this.state.setState(state);\r\n\t    };\r\n\t    Chart.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var $el = this.$el;\r\n\t        if (this.state.data.controls.enabled) {\r\n\t            $el.addEventListener('mousewheel', function (ev) {\r\n\t                _this.onMouseWheel(ev);\r\n\t            });\r\n\t            $el.addEventListener('mousemove', function (ev) {\r\n\t                _this.onMouseMove(ev);\r\n\t            });\r\n\t            $el.addEventListener('mousedown', function (ev) { return _this.onMouseDown(ev); });\r\n\t            $el.addEventListener('mouseup', function (ev) { return _this.onMouseUp(ev); });\r\n\t            $el.addEventListener('touchmove', function (ev) {\r\n\t                _this.onTouchMove(ev);\r\n\t            });\r\n\t            $el.addEventListener('touchend', function (ev) {\r\n\t                _this.onTouchEnd(ev);\r\n\t            });\r\n\t        }\r\n\t        if (this.state.data.autoResize) {\r\n\t        }\r\n\t        this.unsubscribers = [\r\n\t            this.state.onTrendsChange(function () { return _this.autoscroll(); }),\r\n\t            this.state.screen.onTransformationFrame(function (options) { return _this.onScreenTransformHandler(options); }),\r\n\t            this.state.onResize(function (options) { return _this.onChartResize(); })\r\n\t        ];\r\n\t    };\r\n\t    Chart.prototype.unbindEvents = function () {\r\n\t        // TODO: unbind events correctly\r\n\t        try {\r\n\t            this.resizeSensor && this.resizeSensor.detach();\r\n\t        }\r\n\t        catch (e) {\r\n\t        }\r\n\t        this.$el.remove();\r\n\t        this.unsubscribers.forEach(function (unsubscribe) { return unsubscribe(); });\r\n\t    };\r\n\t    Chart.prototype.setupCamera = function () {\r\n\t        var camSettings = this.state.screen.getCameraSettings();\r\n\t        if (!this.camera) {\r\n\t            this.camera = new PerspectiveCamera(camSettings.FOV, camSettings.aspect, camSettings.near, camSettings.far);\r\n\t            this.scene.add(this.camera);\r\n\t        }\r\n\t        else {\r\n\t            this.camera.fov = camSettings.FOV;\r\n\t            this.camera.aspect = camSettings.aspect;\r\n\t            this.camera.far = camSettings.far;\r\n\t            this.camera.near = camSettings.near;\r\n\t            this.camera.updateProjectionMatrix();\r\n\t        }\r\n\t        this.camera.position.set(camSettings.x, camSettings.y, camSettings.z);\r\n\t        this.cameraInitialPosition = this.camera.position.clone();\r\n\t        this.onScreenTransformHandler(this.state.screen.options);\r\n\t    };\r\n\t    Chart.prototype.onScreenTransformHandler = function (options) {\r\n\t        if (options.scrollX != void 0) {\r\n\t            var scrollX_1 = this.cameraInitialPosition.x + options.scrollX;\r\n\t            // scrollX =  Math.round(scrollX); // prevent to set camera beetween pixels\r\n\t            this.camera.position.setX(scrollX_1);\r\n\t        }\r\n\t        if (options.scrollY != void 0) {\r\n\t            var scrollY_1 = this.cameraInitialPosition.y + options.scrollY;\r\n\t            // scrollY = Math.round(scrollY); // prevent to set camera beetween pixels\r\n\t            this.camera.position.setY(scrollY_1);\r\n\t        }\r\n\t    };\r\n\t    Chart.prototype.autoscroll = function () {\r\n\t        var state = this.state;\r\n\t        if (!state.data.autoScroll)\r\n\t            return;\r\n\t        var oldTrendsMaxX = state.data.prevState.computedData.trends.maxXVal;\r\n\t        var trendsMaxXDelta = state.data.computedData.trends.maxXVal - oldTrendsMaxX;\r\n\t        if (trendsMaxXDelta > 0) {\r\n\t            var maxVisibleX = this.state.screen.getScreenRightVal();\r\n\t            var paddingRightX = this.state.getPaddingRight();\r\n\t            var currentScroll = state.data.xAxis.range.scroll;\r\n\t            if (oldTrendsMaxX < paddingRightX || oldTrendsMaxX > maxVisibleX) {\r\n\t                return;\r\n\t            }\r\n\t            var scrollDelta = trendsMaxXDelta;\r\n\t            this.setState({ xAxis: { range: { scroll: currentScroll + scrollDelta } } });\r\n\t        }\r\n\t    };\r\n\t    Chart.prototype.onScrollStop = function () {\r\n\t        // var tendsXMax = this.state.data.computedData.trends.maxX;\r\n\t        // var paddingRightX = this.state.getPaddingRight();\r\n\t        // if (tendsXMax < paddingRightX) {\r\n\t        // \tthis.state.scrollToEnd();\r\n\t        // }\r\n\t    };\r\n\t    Chart.prototype.onMouseDown = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: true, x: ev.clientX, y: ev.clientY } });\r\n\t    };\r\n\t    Chart.prototype.onMouseUp = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: false } });\r\n\t    };\r\n\t    Chart.prototype.onMouseMove = function (ev) {\r\n\t        if (this.state.data.cursor.dragMode) {\r\n\t            this.setState({ cursor: { dragMode: true, x: ev.clientX, y: ev.clientY } });\r\n\t        }\r\n\t    };\r\n\t    Chart.prototype.onMouseWheel = function (ev) {\r\n\t        ev.stopPropagation();\r\n\t        ev.preventDefault();\r\n\t        var zoomOrigin = ev.layerX / this.state.data.width;\r\n\t        var zoomValue = 1 + ev.wheelDeltaY * 0.001;\r\n\t        this.zoom(zoomValue, zoomOrigin);\r\n\t    };\r\n\t    Chart.prototype.onTouchMove = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: true, x: ev.touches[0].clientX, y: ev.touches[0].clientY } });\r\n\t    };\r\n\t    Chart.prototype.onTouchEnd = function (ev) {\r\n\t        this.setState({ cursor: { dragMode: false } });\r\n\t    };\r\n\t    Chart.prototype.onChartContainerResizeHandler = function (width, height) {\r\n\t        this.setState({ width: width, height: height });\r\n\t    };\r\n\t    Chart.prototype.onChartResize = function () {\r\n\t        var _a = this.state.data, width = _a.width, height = _a.height;\r\n\t        this.renderer.setSize(width, height);\r\n\t        this.setupCamera();\r\n\t    };\r\n\t    Chart.prototype.zoom = function (zoomValue, zoomOrigin) {\r\n\t        var _this = this;\r\n\t        var MAX_ZOOM_VALUE = 1.5;\r\n\t        var MIN_ZOOM_VALUE = 0.7;\r\n\t        zoomValue = Math.min(zoomValue, MAX_ZOOM_VALUE);\r\n\t        zoomValue = Math.max(zoomValue, MIN_ZOOM_VALUE);\r\n\t        var autoScrollIsEnabled = this.state.data.autoScroll;\r\n\t        if (autoScrollIsEnabled)\r\n\t            this.state.setState({ autoScroll: false });\r\n\t        this.state.zoom(zoomValue, zoomOrigin).then(function () {\r\n\t            if (autoScrollIsEnabled)\r\n\t                _this.setState({ autoScroll: true });\r\n\t        });\r\n\t    };\r\n\t    Chart.devicePixelRatio = window.devicePixelRatio;\r\n\t    Chart.preinstalledWidgets = [];\r\n\t    Chart.renderers = {\r\n\t        CanvasRenderer: THREE.CanvasRenderer,\r\n\t        WebGLRenderer: THREE.WebGLRenderer\r\n\t    };\r\n\t    return Chart;\r\n\t}());\r\n\texports.Chart = Chart;\r\n\t// install built-in widgets\r\n\tChart.installWidget(TrendsLineWidget_1.TrendsLineWidget);\r\n\tChart.installWidget(TrendsCandleWidget_1.TrendsCandlesWidget);\r\n\tChart.installWidget(AxisWidget_1.AxisWidget);\r\n\tChart.installWidget(GridWidget_1.GridWidget);\r\n\tChart.installWidget(TrendsGradientWidget_1.TrendsGradientWidget);\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar EventEmmiter_1 = __webpack_require__(14);\r\n\texports.DEFAULT_CONFIG = {\r\n\t    installPluginWidgets: true\r\n\t};\r\n\t/**\r\n\t * base class for all plugins\r\n\t * NAME is mandatory\r\n\t */\r\n\tvar ChartPlugin = (function () {\r\n\t    function ChartPlugin(options, config) {\r\n\t        if (config === void 0) { config = {}; }\r\n\t        this.unsubscribers = [];\r\n\t        this.initialState = options;\r\n\t        this.config = Utils_1.Utils.deepMerge(exports.DEFAULT_CONFIG, config);\r\n\t        this.name = this.constructor.NAME;\r\n\t        if (!this.name)\r\n\t            Utils_1.Utils.error('Unnamed plugin detected');\r\n\t    }\r\n\t    ChartPlugin.prototype.setupChartState = function (chartState) {\r\n\t        var _this = this;\r\n\t        this.chartState = chartState;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.bindEvent(this.chartState.onInitialStateApplied(function (initialState) { return _this.onInitialStateAppliedHandler(initialState); }), this.chartState.onReady(function () { return _this.onReadyHandler(); }), this.chartState.onDestroy(function () { return _this.onDestroyHandler(); }), this.chartState.onPluginsStateChange(function (changedPluginsStates) { return changedPluginsStates[_this.name] && _this.onStateChanged(changedPluginsStates[_this.name]); }));\r\n\t    };\r\n\t    ChartPlugin.prototype.getOptions = function () {\r\n\t        return this.chartState.data.pluginsState[this.name];\r\n\t    };\r\n\t    ChartPlugin.prototype.onInitialStateAppliedHandler = function (initialState) {\r\n\t    };\r\n\t    ChartPlugin.prototype.onReadyHandler = function () {\r\n\t    };\r\n\t    ChartPlugin.prototype.onStateChanged = function (changedState) {\r\n\t    };\r\n\t    ChartPlugin.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t    };\r\n\t    ChartPlugin.prototype.bindEvent = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var unsubscribers = [];\r\n\t        if (!Array.isArray(args[0])) {\r\n\t            unsubscribers.push(args[0]);\r\n\t        }\r\n\t        else {\r\n\t            unsubscribers.push.apply(unsubscribers, (args));\r\n\t        }\r\n\t        (_a = this.unsubscribers).push.apply(_a, unsubscribers);\r\n\t        var _a;\r\n\t    };\r\n\t    ChartPlugin.prototype.unbindEvents = function () {\r\n\t        this.unsubscribers.forEach(function (unsubscriber) { return unsubscriber(); });\r\n\t        this.unsubscribers.length = 0;\r\n\t    };\r\n\t    ChartPlugin.NAME = '';\r\n\t    ChartPlugin.providedWidgets = [];\r\n\t    return ChartPlugin;\r\n\t}());\r\n\texports.ChartPlugin = ChartPlugin;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar deps_1 = __webpack_require__(5);\r\n\tfunction deepmerge(target, src, mergeArrays) {\r\n\t    if (mergeArrays === void 0) { mergeArrays = true; }\r\n\t    var array = Array.isArray(src);\r\n\t    var dst = array && [] || {};\r\n\t    if (array) {\r\n\t        target = target || [];\r\n\t        if (mergeArrays) {\r\n\t            dst = dst.concat(target);\r\n\t        }\r\n\t        src.forEach(function (e, i) {\r\n\t            if (typeof dst[i] === 'undefined') {\r\n\t                dst[i] = e;\r\n\t            }\r\n\t            else if (typeof e === 'object') {\r\n\t                dst[i] = deepmerge(target[i], e, mergeArrays);\r\n\t            }\r\n\t            else {\r\n\t                if (target.indexOf(e) === -1) {\r\n\t                    dst.push(e);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t    else {\r\n\t        if (target && typeof target === 'object') {\r\n\t            Object.keys(target).forEach(function (key) {\r\n\t                dst[key] = target[key];\r\n\t            });\r\n\t        }\r\n\t        Object.keys(src).forEach(function (key) {\r\n\t            if (typeof src[key] !== 'object' || !src[key]) {\r\n\t                dst[key] = src[key];\r\n\t            }\r\n\t            else {\r\n\t                if (!target[key]) {\r\n\t                    dst[key] = src[key];\r\n\t                }\r\n\t                else {\r\n\t                    dst[key] = deepmerge(target[key], src[key], mergeArrays);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t    return dst;\r\n\t}\r\n\t/**\r\n\t * project utils static class\r\n\t */\r\n\tvar Utils = (function () {\r\n\t    function Utils() {\r\n\t    }\r\n\t    /**\r\n\t     * deepMerge based on https://www.npmjs.com/package/deepmerge\r\n\t     */\r\n\t    Utils.deepMerge = function (obj1, obj2, mergeArrays) {\r\n\t        return deepmerge(obj1, obj2, mergeArrays);\r\n\t    };\r\n\t    /**\r\n\t     * deepCopy based on JSON.stringify function\r\n\t     * @deprecated\r\n\t     */\r\n\t    Utils.deepCopy = function (obj) {\r\n\t        // TODO: use deepMerge function to copy\r\n\t        return JSON.parse(JSON.stringify(obj));\r\n\t    };\r\n\t    /**\r\n\t     *\r\n\t     * @example\r\n\t     * // returns \"000015\"\r\n\t     * Utils.toFixed(15, 6);\r\n\t     */\r\n\t    Utils.toFixed = function (num, digitsCount) {\r\n\t        var maxDigits = 15;\r\n\t        var result = '';\r\n\t        var intVal = Math.floor(num);\r\n\t        var intStr = intVal.toString();\r\n\t        var lengthDiff = digitsCount - intStr.length;\r\n\t        if (lengthDiff > 0) {\r\n\t            result = '0'.repeat(lengthDiff) + intStr;\r\n\t        }\r\n\t        else {\r\n\t            result = intStr;\r\n\t        }\r\n\t        var afterPointDigitsCount = maxDigits - intStr.length;\r\n\t        var afterPointStr = num.toString().split('.')[1];\r\n\t        if (afterPointStr) {\r\n\t            result += '.' + afterPointStr.substr(0, afterPointDigitsCount);\r\n\t        }\r\n\t        return result;\r\n\t    };\r\n\t    Utils.bindEvent = function () {\r\n\t    };\r\n\t    /**\r\n\t     * generate texture from canvas context\r\n\t     * @example\r\n\t     * \t// create texture with rect\r\n\t     *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\r\n\t     */\r\n\t    Utils.createTexture = function (width, height, fn) {\r\n\t        var canvas = document.createElement('canvas');\r\n\t        canvas.width = width;\r\n\t        canvas.height = height;\r\n\t        var ctx = canvas.getContext('2d');\r\n\t        fn(ctx);\r\n\t        var texture = new THREE.Texture(canvas);\r\n\t        texture.needsUpdate = true;\r\n\t        return texture;\r\n\t    };\r\n\t    /**\r\n\t     * generate texture from canvas context with NearestFilter\r\n\t     * @example\r\n\t     * \t// create texture with rect\r\n\t     *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\r\n\t     */\r\n\t    Utils.createPixelPerfectTexture = function (width, height, fn) {\r\n\t        var texture = this.createTexture(width, height, fn);\r\n\t        // texture.magFilter = THREE.NearestFilter;\r\n\t        texture.minFilter = THREE.NearestFilter;\r\n\t        return texture;\r\n\t    };\r\n\t    /**\r\n\t     * throw error\r\n\t     */\r\n\t    Utils.error = function (msg) {\r\n\t        console.error('Chart error: ' + msg);\r\n\t        throw 'Chart: ' + msg;\r\n\t    };\r\n\t    /**\r\n\t     * throw error\r\n\t     */\r\n\t    Utils.warn = function (msg) {\r\n\t        console.warn('Chart warning: ' + msg);\r\n\t    };\r\n\t    /**\r\n\t     * @returns new unique id\r\n\t     */\r\n\t    Utils.getUid = function () {\r\n\t        return this.currentId++;\r\n\t    };\r\n\t    /**\r\n\t     * @returns distance between numbers\r\n\t     */\r\n\t    Utils.getDistance = function (num1, num2) {\r\n\t        return Math.max(num1, num2) - Math.min(num1, num2);\r\n\t    };\r\n\t    Utils.binarySearchClosestInd = function (arr, num, key) {\r\n\t        var mid;\r\n\t        var lo = 0;\r\n\t        var hi = arr.length - 1;\r\n\t        while (hi - lo > 1) {\r\n\t            mid = Math.floor((lo + hi) / 2);\r\n\t            if (arr[mid][key] < num) {\r\n\t                lo = mid;\r\n\t            }\r\n\t            else {\r\n\t                hi = mid;\r\n\t            }\r\n\t        }\r\n\t        if (num - arr[lo][key] <= arr[hi][key] - num) {\r\n\t            return lo;\r\n\t        }\r\n\t        return hi;\r\n\t    };\r\n\t    Utils.binarySearchClosest = function (arr, num, key) {\r\n\t        var ind = this.binarySearchClosestInd(arr, num, key);\r\n\t        return arr[ind];\r\n\t    };\r\n\t    Utils.rectsIntersect = function (r1, r2) {\r\n\t        var left1 = r1[0], top1 = r1[1], width1 = r1[2], height1 = r1[3];\r\n\t        var left2 = r2[0], top2 = r2[1], width2 = r2[2], height2 = r2[3];\r\n\t        var _a = [left1 + width1, left2 + width2, top1 + height1, top2 + height2], right1 = _a[0], right2 = _a[1], bottom1 = _a[2], bottom2 = _a[3];\r\n\t        return !(left2 > right1 ||\r\n\t            right2 < left1 ||\r\n\t            top2 > bottom1 ||\r\n\t            bottom2 < top1);\r\n\t    };\r\n\t    Utils.throttle = function (func, ms) {\r\n\t        var isThrottled = false, savedArgs, savedThis;\r\n\t        function wrapper() {\r\n\t            if (isThrottled) {\r\n\t                savedArgs = arguments;\r\n\t                savedThis = this;\r\n\t                return;\r\n\t            }\r\n\t            func.apply(this, arguments); // (1)\r\n\t            isThrottled = true;\r\n\t            setTimeout(function () {\r\n\t                isThrottled = false; // (3)\r\n\t                if (savedArgs) {\r\n\t                    wrapper.apply(savedThis, savedArgs);\r\n\t                    savedArgs = savedThis = null;\r\n\t                }\r\n\t            }, ms);\r\n\t        }\r\n\t        return wrapper;\r\n\t    };\r\n\t    Utils.msToTimeString = function (timestamp) {\r\n\t        var h = Math.floor(timestamp / 360000);\r\n\t        var m = Math.floor(timestamp / 60000);\r\n\t        var s = Math.floor(timestamp / 1000);\r\n\t        return h + ':' + m + ':' + s;\r\n\t    };\r\n\t    Utils.getRandomItem = function (arr) {\r\n\t        var ind = Math.floor(Math.random() * arr.length);\r\n\t        return arr[ind];\r\n\t    };\r\n\t    Utils.copyProps = function (srcObject, dstObject, props, excludeProps) {\r\n\t        if (excludeProps === void 0) { excludeProps = []; }\r\n\t        for (var key in props) {\r\n\t            if (excludeProps.indexOf(key) !== -1)\r\n\t                continue;\r\n\t            if (srcObject[key] == void 0)\r\n\t                continue;\r\n\t            if (deps_1.isPlainObject(props[key]) && dstObject[key] !== void 0) {\r\n\t                this.copyProps(srcObject[key], dstObject[key], props[key]);\r\n\t            }\r\n\t            else {\r\n\t                dstObject[key] = this.deepCopy(srcObject[key]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    Utils.currentId = 1;\r\n\t    return Utils;\r\n\t}());\r\n\texports.Utils = Utils;\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"./ResizeSensor.ts\" />\r\n\t\"use strict\";\r\n\twindow.TweenLite = TweenMax;\r\n\twindow.Stats = __webpack_require__(6);\r\n\t//require('gsap/src/uncompressed/easing/EasePack.js');\r\n\t__webpack_require__(7);\r\n\t__webpack_require__(8);\r\n\texports.isPlainObject = __webpack_require__(9);\r\n\texports.EE2 = __webpack_require__(11);\r\n\tvar es6_promise_1 = __webpack_require__(12);\r\n\texports.Promise = es6_promise_1.Promise;\r\n\texports.ResizeSensor = __webpack_require__(13);\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// stats.js - http://github.com/mrdoob/stats.js\n\tvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\n\tif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\n\tStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\n\tv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.SpriteCanvasMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'SpriteCanvasMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\tthis.program = function ( context, color ) {};\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.SpriteCanvasMaterial.prototype.constructor = THREE.SpriteCanvasMaterial;\n\t\n\tTHREE.SpriteCanvasMaterial.prototype.clone = function () {\n\t\n\t\tvar material = new THREE.SpriteCanvasMaterial();\n\t\n\t\tmaterial.copy( this );\n\t\tmaterial.color.copy( this.color );\n\t\tmaterial.program = this.program;\n\t\n\t\treturn material;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.CanvasRenderer = function ( parameters ) {\n\t\n\t\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\n\t\n\t\tparameters = parameters || {};\n\t\n\t\tvar _this = this,\n\t\t_renderData, _elements, _lights,\n\t\t_projector = new THREE.Projector(),\n\t\n\t\t_canvas = parameters.canvas !== undefined\n\t\t\t\t ? parameters.canvas\n\t\t\t\t : document.createElement( 'canvas' ),\n\t\n\t\t_canvasWidth = _canvas.width,\n\t\t_canvasHeight = _canvas.height,\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),\n\t\n\t\t_viewportX = 0,\n\t\t_viewportY = 0,\n\t\t_viewportWidth = _canvasWidth,\n\t\t_viewportHeight = _canvasHeight,\n\t\n\t\t_pixelRatio = 1,\n\t\n\t\t_context = _canvas.getContext( '2d', {\n\t\t\talpha: parameters.alpha === true\n\t\t} ),\n\t\n\t\t_clearColor = new THREE.Color( 0x000000 ),\n\t\t_clearAlpha = parameters.alpha === true ? 0 : 1,\n\t\n\t\t_contextGlobalAlpha = 1,\n\t\t_contextGlobalCompositeOperation = 0,\n\t\t_contextStrokeStyle = null,\n\t\t_contextFillStyle = null,\n\t\t_contextLineWidth = null,\n\t\t_contextLineCap = null,\n\t\t_contextLineJoin = null,\n\t\t_contextLineDash = [],\n\t\n\t\t_camera,\n\t\n\t\t_v1, _v2, _v3, _v4,\n\t\t_v5 = new THREE.RenderableVertex(),\n\t\t_v6 = new THREE.RenderableVertex(),\n\t\n\t\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\n\t\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\n\t\n\t\t_color = new THREE.Color(),\n\t\t_color1 = new THREE.Color(),\n\t\t_color2 = new THREE.Color(),\n\t\t_color3 = new THREE.Color(),\n\t\t_color4 = new THREE.Color(),\n\t\n\t\t_diffuseColor = new THREE.Color(),\n\t\t_emissiveColor = new THREE.Color(),\n\t\n\t\t_lightColor = new THREE.Color(),\n\t\n\t\t_patterns = {},\n\t\n\t\t_image, _uvs,\n\t\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\n\t\n\t\t_clipBox = new THREE.Box2(),\n\t\t_clearBox = new THREE.Box2(),\n\t\t_elemBox = new THREE.Box2(),\n\t\n\t\t_ambientLight = new THREE.Color(),\n\t\t_directionalLights = new THREE.Color(),\n\t\t_pointLights = new THREE.Color(),\n\t\n\t\t_vector3 = new THREE.Vector3(), // Needed for PointLight\n\t\t_centroid = new THREE.Vector3(),\n\t\t_normal = new THREE.Vector3(),\n\t\t_normalViewMatrix = new THREE.Matrix3();\n\t\n\t\t/* TODO\n\t\t_canvas.mozImageSmoothingEnabled = false;\n\t\t_canvas.webkitImageSmoothingEnabled = false;\n\t\t_canvas.msImageSmoothingEnabled = false;\n\t\t_canvas.imageSmoothingEnabled = false;\n\t\t*/\n\t\n\t\t// dash+gap fallbacks for Firefox and everything else\n\t\n\t\tif ( _context.setLineDash === undefined ) {\n\t\n\t\t\t_context.setLineDash = function () {};\n\t\n\t\t}\n\t\n\t\tthis.domElement = _canvas;\n\t\n\t\tthis.autoClear = true;\n\t\tthis.sortObjects = true;\n\t\tthis.sortElements = true;\n\t\n\t\tthis.info = {\n\t\n\t\t\trender: {\n\t\n\t\t\t\tvertices: 0,\n\t\t\t\tfaces: 0\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// WebGLRenderer compatibility\n\t\n\t\tthis.supportsVertexTextures = function () {};\n\t\tthis.setFaceCulling = function () {};\n\t\n\t\t// API\n\t\n\t\tthis.getContext = function () {\n\t\n\t\t\treturn _context;\n\t\n\t\t};\n\t\n\t\tthis.getContextAttributes = function () {\n\t\n\t\t\treturn _context.getContextAttributes();\n\t\n\t\t};\n\t\n\t\tthis.getPixelRatio = function () {\n\t\n\t\t\treturn _pixelRatio;\n\t\n\t\t};\n\t\n\t\tthis.setPixelRatio = function ( value ) {\n\t\n\t\t\tif ( value !== undefined ) _pixelRatio = value;\n\t\n\t\t};\n\t\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\t\n\t\t\t_canvasWidth = width * _pixelRatio;\n\t\t\t_canvasHeight = height * _pixelRatio;\n\t\n\t\t\t_canvas.width = _canvasWidth;\n\t\t\t_canvas.height = _canvasHeight;\n\t\n\t\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\n\t\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\n\t\n\t\t\tif ( updateStyle !== false ) {\n\t\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\t\n\t\t\t}\n\t\n\t\t\t_clipBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\n\t\t\t_clipBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\n\t\n\t\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\n\t\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\n\t\n\t\t\t_contextGlobalAlpha = 1;\n\t\t\t_contextGlobalCompositeOperation = 0;\n\t\t\t_contextStrokeStyle = null;\n\t\t\t_contextFillStyle = null;\n\t\t\t_contextLineWidth = null;\n\t\t\t_contextLineCap = null;\n\t\t\t_contextLineJoin = null;\n\t\n\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t};\n\t\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\t\n\t\t\t_viewportX = x * _pixelRatio;\n\t\t\t_viewportY = y * _pixelRatio;\n\t\n\t\t\t_viewportWidth = width * _pixelRatio;\n\t\t\t_viewportHeight = height * _pixelRatio;\n\t\n\t\t};\n\t\n\t\tthis.setScissor = function () {};\n\t\tthis.setScissorTest = function () {};\n\t\n\t\tthis.setClearColor = function ( color, alpha ) {\n\t\n\t\t\t_clearColor.set( color );\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\t\n\t\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\n\t\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\n\t\n\t\t};\n\t\n\t\tthis.setClearColorHex = function ( hex, alpha ) {\n\t\n\t\t\tconsole.warn( 'THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\t\t\tthis.setClearColor( hex, alpha );\n\t\n\t\t};\n\t\n\t\tthis.getClearColor = function () {\n\t\n\t\t\treturn _clearColor;\n\t\n\t\t};\n\t\n\t\tthis.getClearAlpha = function () {\n\t\n\t\t\treturn _clearAlpha;\n\t\n\t\t};\n\t\n\t\tthis.getMaxAnisotropy = function () {\n\t\n\t\t\treturn 0;\n\t\n\t\t};\n\t\n\t\tthis.clear = function () {\n\t\n\t\t\tif ( _clearBox.isEmpty() === false ) {\n\t\n\t\t\t\t_clearBox.intersect( _clipBox );\n\t\t\t\t_clearBox.expandByScalar( 2 );\n\t\n\t\t\t\t_clearBox.min.x = _clearBox.min.x + _canvasWidthHalf;\n\t\t\t\t_clearBox.min.y =  - _clearBox.min.y + _canvasHeightHalf;\t\t// higher y value !\n\t\t\t\t_clearBox.max.x = _clearBox.max.x + _canvasWidthHalf;\n\t\t\t\t_clearBox.max.y =  - _clearBox.max.y + _canvasHeightHalf;\t\t// lower y value !\n\t\n\t\t\t\tif ( _clearAlpha < 1 ) {\n\t\n\t\t\t\t\t_context.clearRect(\n\t\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t\t_clearBox.max.y | 0,\n\t\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t\t( _clearBox.min.y - _clearBox.max.y ) | 0\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _clearAlpha > 0 ) {\n\t\n\t\t\t\t\tsetBlending( THREE.NormalBlending );\n\t\t\t\t\tsetOpacity( 1 );\n\t\n\t\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );\n\t\n\t\t\t\t\t_context.fillRect(\n\t\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t\t_clearBox.max.y | 0,\n\t\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t\t( _clearBox.min.y - _clearBox.max.y ) | 0\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_clearBox.makeEmpty();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// compatibility\n\t\n\t\tthis.clearColor = function () {};\n\t\tthis.clearDepth = function () {};\n\t\tthis.clearStencil = function () {};\n\t\n\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.autoClear === true ) this.clear();\n\t\n\t\t\t_this.info.render.vertices = 0;\n\t\t\t_this.info.render.faces = 0;\n\t\n\t\t\t_context.setTransform( _viewportWidth / _canvasWidth, 0, 0, - _viewportHeight / _canvasHeight, _viewportX, _canvasHeight - _viewportY );\n\t\t\t_context.translate( _canvasWidthHalf, _canvasHeightHalf );\n\t\n\t\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\n\t\t\t_elements = _renderData.elements;\n\t\t\t_lights = _renderData.lights;\n\t\t\t_camera = camera;\n\t\n\t\t\t_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );\n\t\n\t\t\t/* DEBUG\n\t\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n\t\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n\t\t\t*/\n\t\n\t\t\tcalculateLights();\n\t\n\t\t\tfor ( var e = 0, el = _elements.length; e < el; e ++ ) {\n\t\n\t\t\t\tvar element = _elements[ e ];\n\t\n\t\t\t\tvar material = element.material;\n\t\n\t\t\t\tif ( material === undefined || material.opacity === 0 ) continue;\n\t\n\t\t\t\t_elemBox.makeEmpty();\n\t\n\t\t\t\tif ( element instanceof THREE.RenderableSprite ) {\n\t\n\t\t\t\t\t_v1 = element;\n\t\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\n\t\n\t\t\t\t\trenderSprite( _v1, element, material );\n\t\n\t\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\n\t\n\t\t\t\t\t_v1 = element.v1; _v2 = element.v2;\n\t\n\t\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\n\t\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t\t_v2.positionScreen\n\t\t\t\t\t] );\n\t\n\t\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\n\t\n\t\t\t\t\t\trenderLine( _v1, _v2, element, material );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( element instanceof THREE.RenderableFace ) {\n\t\n\t\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\n\t\n\t\t\t\t\tif ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) continue;\n\t\t\t\t\tif ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) continue;\n\t\t\t\t\tif ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) continue;\n\t\n\t\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\t\n\t\t\t\t\tif ( material.overdraw > 0 ) {\n\t\n\t\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen, material.overdraw );\n\t\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen, material.overdraw );\n\t\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen, material.overdraw );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t\t_v2.positionScreen,\n\t\t\t\t\t\t_v3.positionScreen\n\t\t\t\t\t] );\n\t\n\t\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\n\t\n\t\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t/* DEBUG\n\t\t\t\tsetLineWidth( 1 );\n\t\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n\t\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n\t\t\t\t*/\n\t\n\t\t\t\t_clearBox.union( _elemBox );\n\t\n\t\t\t}\n\t\n\t\t\t/* DEBUG\n\t\t\tsetLineWidth( 1 );\n\t\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n\t\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n\t\t\t*/\n\t\n\t\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction calculateLights() {\n\t\n\t\t\t_ambientLight.setRGB( 0, 0, 0 );\n\t\t\t_directionalLights.setRGB( 0, 0, 0 );\n\t\t\t_pointLights.setRGB( 0, 0, 0 );\n\t\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\t\n\t\t\t\tvar light = _lights[ l ];\n\t\t\t\tvar lightColor = light.color;\n\t\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\t\n\t\t\t\t\t_ambientLight.add( lightColor );\n\t\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\t\n\t\t\t\t\t// for sprites\n\t\n\t\t\t\t\t_directionalLights.add( lightColor );\n\t\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\t\n\t\t\t\t\t// for sprites\n\t\n\t\t\t\t\t_pointLights.add( lightColor );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction calculateLight( position, normal, color ) {\n\t\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\t\n\t\t\t\tvar light = _lights[ l ];\n\t\n\t\t\t\t_lightColor.copy( light.color );\n\t\n\t\t\t\tif ( light instanceof THREE.DirectionalLight ) {\n\t\n\t\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\n\t\n\t\t\t\t\tvar amount = normal.dot( lightPosition );\n\t\n\t\t\t\t\tif ( amount <= 0 ) continue;\n\t\n\t\t\t\t\tamount *= light.intensity;\n\t\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\t\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\t\n\t\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\n\t\n\t\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\n\t\n\t\t\t\t\tif ( amount <= 0 ) continue;\n\t\n\t\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\n\t\n\t\t\t\t\tif ( amount == 0 ) continue;\n\t\n\t\t\t\t\tamount *= light.intensity;\n\t\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction renderSprite( v1, element, material ) {\n\t\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\t\n\t\t\tvar scaleX = element.scale.x * _canvasWidthHalf;\n\t\t\tvar scaleY = element.scale.y * _canvasHeightHalf;\n\t\n\t\t\tvar dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite\n\t\t\t_elemBox.min.set( v1.x - dist, v1.y - dist );\n\t\t\t_elemBox.max.set( v1.x + dist, v1.y + dist );\n\t\n\t\t\tif ( material instanceof THREE.SpriteMaterial ) {\n\t\n\t\t\t\tvar texture = material.map;\n\t\n\t\t\t\tif ( texture !== null ) {\n\t\n\t\t\t\t\tvar pattern = _patterns[ texture.id ];\n\t\n\t\t\t\t\tif ( pattern === undefined || pattern.version !== texture.version ) {\n\t\n\t\t\t\t\t\tpattern = textureToPattern( texture );\n\t\t\t\t\t\t_patterns[ texture.id ] = pattern;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( pattern.canvas !== undefined ) {\n\t\n\t\t\t\t\t\tsetFillStyle( pattern.canvas );\n\t\n\t\t\t\t\t\tvar bitmap = texture.image;\n\t\n\t\t\t\t\t\tvar ox = bitmap.width * texture.offset.x;\n\t\t\t\t\t\tvar oy = bitmap.height * texture.offset.y;\n\t\n\t\t\t\t\t\tvar sx = bitmap.width * texture.repeat.x;\n\t\t\t\t\t\tvar sy = bitmap.height * texture.repeat.y;\n\t\n\t\t\t\t\t\tvar cx = scaleX / sx;\n\t\t\t\t\t\tvar cy = scaleY / sy;\n\t\n\t\t\t\t\t\t_context.save();\n\t\t\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t\t\t_context.translate( - scaleX / 2, - scaleY / 2 );\n\t\t\t\t\t\t_context.scale( cx, cy );\n\t\t\t\t\t\t_context.translate( - ox, - oy );\n\t\t\t\t\t\t_context.fillRect( ox, oy, sx, sy );\n\t\t\t\t\t\t_context.restore();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// no texture\n\t\n\t\t\t\t\tsetFillStyle( material.color.getStyle() );\n\t\n\t\t\t\t\t_context.save();\n\t\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t\t_context.scale( scaleX, - scaleY );\n\t\t\t\t\t_context.fillRect( - 0.5, - 0.5, 1, 1 );\n\t\t\t\t\t_context.restore();\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( material instanceof THREE.SpriteCanvasMaterial ) {\n\t\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\t\tsetFillStyle( material.color.getStyle() );\n\t\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t_context.scale( scaleX, scaleY );\n\t\n\t\t\t\tmaterial.program( _context );\n\t\n\t\t\t\t_context.restore();\n\t\n\t\t\t}\n\t\n\t\t\t/* DEBUG\n\t\t\tsetStrokeStyle( 'rgb(255,255,0)' );\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( v1.x - 10, v1.y );\n\t\t\t_context.lineTo( v1.x + 10, v1.y );\n\t\t\t_context.moveTo( v1.x, v1.y - 10 );\n\t\t\t_context.lineTo( v1.x, v1.y + 10 );\n\t\t\t_context.stroke();\n\t\t\t*/\n\t\n\t\t}\n\t\n\t\tfunction renderLine( v1, v2, element, material ) {\n\t\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\t\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\n\t\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\n\t\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\t\n\t\t\t\tsetLineWidth( material.linewidth );\n\t\t\t\tsetLineCap( material.linecap );\n\t\t\t\tsetLineJoin( material.linejoin );\n\t\n\t\t\t\tif ( material.vertexColors !== THREE.VertexColors ) {\n\t\n\t\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar colorStyle1 = element.vertexColors[ 0 ].getStyle();\n\t\t\t\t\tvar colorStyle2 = element.vertexColors[ 1 ].getStyle();\n\t\n\t\t\t\t\tif ( colorStyle1 === colorStyle2 ) {\n\t\n\t\t\t\t\t\tsetStrokeStyle( colorStyle1 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\t\tvar grad = _context.createLinearGradient(\n\t\t\t\t\t\t\t\tv1.positionScreen.x,\n\t\t\t\t\t\t\t\tv1.positionScreen.y,\n\t\t\t\t\t\t\t\tv2.positionScreen.x,\n\t\t\t\t\t\t\t\tv2.positionScreen.y\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tgrad.addColorStop( 0, colorStyle1 );\n\t\t\t\t\t\t\tgrad.addColorStop( 1, colorStyle2 );\n\t\n\t\t\t\t\t\t} catch ( exception ) {\n\t\n\t\t\t\t\t\t\tgrad = colorStyle1;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tsetStrokeStyle( grad );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_context.stroke();\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\t\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\t\n\t\t\t\tsetLineWidth( material.linewidth );\n\t\t\t\tsetLineCap( material.linecap );\n\t\t\t\tsetLineJoin( material.linejoin );\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\t\tsetLineDash( [ material.dashSize, material.gapSize ] );\n\t\n\t\t\t\t_context.stroke();\n\t\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\t\n\t\t\t\tsetLineDash( [] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\n\t\n\t\t\t_this.info.render.vertices += 3;\n\t\t\t_this.info.render.faces ++;\n\t\n\t\t\tsetOpacity( material.opacity );\n\t\t\tsetBlending( material.blending );\n\t\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\t\n\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\n\t\n\t\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\n\t\n\t\t\t\t_diffuseColor.copy( material.color );\n\t\t\t\t_emissiveColor.copy( material.emissive );\n\t\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\t\n\t\t\t\t\t_diffuseColor.multiply( element.color );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_color.copy( _ambientLight );\n\t\n\t\t\t\t_centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );\n\t\n\t\t\t\tcalculateLight( _centroid, element.normalModel, _color );\n\t\n\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\n\t\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t : fillPath( _color );\n\t\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t\t    material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t\t    material instanceof THREE.MeshPhongMaterial ) {\n\t\n\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\tvar mapping = material.map.mapping;\n\t\n\t\t\t\t\tif ( mapping === THREE.UVMapping ) {\n\t\n\t\t\t\t\t\t_uvs = element.uvs;\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( material.envMap !== null ) {\n\t\n\t\t\t\t\tif ( material.envMap.mapping === THREE.SphericalReflectionMapping ) {\n\t\n\t\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );\n\t\t\t\t\t\t_uv1x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t\t_uv1y = 0.5 * _normal.y + 0.5;\n\t\n\t\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );\n\t\t\t\t\t\t_uv2x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t\t_uv2y = 0.5 * _normal.y + 0.5;\n\t\n\t\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );\n\t\t\t\t\t\t_uv3x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t\t_uv3y = 0.5 * _normal.y + 0.5;\n\t\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_color.copy( material.color );\n\t\n\t\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\t\n\t\t\t\t\t\t_color.multiply( element.color );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t\t : fillPath( _color );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\t\n\t\t\t\t_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );\n\t\n\t\t\t\t_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\t\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t : fillPath( _color );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t_color.setRGB( 1, 1, 1 );\n\t\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t : fillPath( _color );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\n\t\n\t\t\t_context.beginPath();\n\t\t\t_context.moveTo( x0, y0 );\n\t\t\t_context.lineTo( x1, y1 );\n\t\t\t_context.lineTo( x2, y2 );\n\t\t\t_context.closePath();\n\t\n\t\t}\n\t\n\t\tfunction strokePath( color, linewidth, linecap, linejoin ) {\n\t\n\t\t\tsetLineWidth( linewidth );\n\t\t\tsetLineCap( linecap );\n\t\t\tsetLineJoin( linejoin );\n\t\t\tsetStrokeStyle( color.getStyle() );\n\t\n\t\t\t_context.stroke();\n\t\n\t\t\t_elemBox.expandByScalar( linewidth * 2 );\n\t\n\t\t}\n\t\n\t\tfunction fillPath( color ) {\n\t\n\t\t\tsetFillStyle( color.getStyle() );\n\t\t\t_context.fill();\n\t\n\t\t}\n\t\n\t\tfunction textureToPattern( texture ) {\n\t\n\t\t\tif ( texture.version === 0 ||\n\t\t\t\ttexture instanceof THREE.CompressedTexture ||\n\t\t\t\ttexture instanceof THREE.DataTexture ) {\n\t\n\t\t\t\treturn {\n\t\t\t\t\tcanvas: undefined,\n\t\t\t\t\tversion: texture.version\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar image = texture.image;\n\t\n\t\t\tif ( image.complete === false ) {\n\t\n\t\t\t\treturn {\n\t\t\t\t\tcanvas: undefined,\n\t\t\t\t\tversion: 0\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar canvas = document.createElement( 'canvas' );\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\t\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.setTransform( 1, 0, 0, - 1, 0, image.height );\n\t\t\tcontext.drawImage( image, 0, 0 );\n\t\n\t\t\tvar repeatX = texture.wrapS === THREE.RepeatWrapping;\n\t\t\tvar repeatY = texture.wrapT === THREE.RepeatWrapping;\n\t\n\t\t\tvar repeat = 'no-repeat';\n\t\n\t\t\tif ( repeatX === true && repeatY === true ) {\n\t\n\t\t\t\trepeat = 'repeat';\n\t\n\t\t\t} else if ( repeatX === true ) {\n\t\n\t\t\t\trepeat = 'repeat-x';\n\t\n\t\t\t} else if ( repeatY === true ) {\n\t\n\t\t\t\trepeat = 'repeat-y';\n\t\n\t\t\t}\n\t\n\t\t\tvar pattern = _context.createPattern( canvas, repeat );\n\t\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\treturn {\n\t\t\t\tcanvas: pattern,\n\t\t\t\tversion: texture.version\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\n\t\n\t\t\tvar pattern = _patterns[ texture.id ];\n\t\n\t\t\tif ( pattern === undefined || pattern.version !== texture.version ) {\n\t\n\t\t\t\tpattern = textureToPattern( texture );\n\t\t\t\t_patterns[ texture.id ] = pattern;\n\t\n\t\t\t}\n\t\n\t\t\tif ( pattern.canvas !== undefined ) {\n\t\n\t\t\t\tsetFillStyle( pattern.canvas );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tsetFillStyle( 'rgba( 0, 0, 0, 1)' );\n\t\t\t\t_context.fill();\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\t\n\t\t\tvar a, b, c, d, e, f, det, idet,\n\t\t\toffsetX = texture.offset.x / texture.repeat.x,\n\t\t\toffsetY = texture.offset.y / texture.repeat.y,\n\t\t\twidth = texture.image.width * texture.repeat.x,\n\t\t\theight = texture.image.height * texture.repeat.y;\n\t\n\t\t\tu0 = ( u0 + offsetX ) * width;\n\t\t\tv0 = ( v0 + offsetY ) * height;\n\t\n\t\t\tu1 = ( u1 + offsetX ) * width;\n\t\t\tv1 = ( v1 + offsetY ) * height;\n\t\n\t\t\tu2 = ( u2 + offsetX ) * width;\n\t\t\tv2 = ( v2 + offsetY ) * height;\n\t\n\t\t\tx1 -= x0; y1 -= y0;\n\t\t\tx2 -= x0; y2 -= y0;\n\t\n\t\t\tu1 -= u0; v1 -= v0;\n\t\t\tu2 -= u0; v2 -= v0;\n\t\n\t\t\tdet = u1 * v2 - u2 * v1;\n\t\n\t\t\tif ( det === 0 ) return;\n\t\n\t\t\tidet = 1 / det;\n\t\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\t\n\t\t\te = x0 - a * u0 - c * v0;\n\t\t\tf = y0 - b * u0 - d * v0;\n\t\n\t\t\t_context.save();\n\t\t\t_context.transform( a, b, c, d, e, f );\n\t\t\t_context.fill();\n\t\t\t_context.restore();\n\t\n\t\t}\n\t\n\t\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\n\t\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\t\n\t\t\tvar a, b, c, d, e, f, det, idet,\n\t\t\twidth = image.width - 1,\n\t\t\theight = image.height - 1;\n\t\n\t\t\tu0 *= width; v0 *= height;\n\t\t\tu1 *= width; v1 *= height;\n\t\t\tu2 *= width; v2 *= height;\n\t\n\t\t\tx1 -= x0; y1 -= y0;\n\t\t\tx2 -= x0; y2 -= y0;\n\t\n\t\t\tu1 -= u0; v1 -= v0;\n\t\t\tu2 -= u0; v2 -= v0;\n\t\n\t\t\tdet = u1 * v2 - u2 * v1;\n\t\n\t\t\tidet = 1 / det;\n\t\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\t\n\t\t\te = x0 - a * u0 - c * v0;\n\t\t\tf = y0 - b * u0 - d * v0;\n\t\n\t\t\t_context.save();\n\t\t\t_context.transform( a, b, c, d, e, f );\n\t\t\t_context.clip();\n\t\t\t_context.drawImage( image, 0, 0 );\n\t\t\t_context.restore();\n\t\n\t\t}\n\t\n\t\t// Hide anti-alias gaps\n\t\n\t\tfunction expand( v1, v2, pixels ) {\n\t\n\t\t\tvar x = v2.x - v1.x, y = v2.y - v1.y,\n\t\t\tdet = x * x + y * y, idet;\n\t\n\t\t\tif ( det === 0 ) return;\n\t\n\t\t\tidet = pixels / Math.sqrt( det );\n\t\n\t\t\tx *= idet; y *= idet;\n\t\n\t\t\tv2.x += x; v2.y += y;\n\t\t\tv1.x -= x; v1.y -= y;\n\t\n\t\t}\n\t\n\t\t// Context cached methods.\n\t\n\t\tfunction setOpacity( value ) {\n\t\n\t\t\tif ( _contextGlobalAlpha !== value ) {\n\t\n\t\t\t\t_context.globalAlpha = value;\n\t\t\t\t_contextGlobalAlpha = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setBlending( value ) {\n\t\n\t\t\tif ( _contextGlobalCompositeOperation !== value ) {\n\t\n\t\t\t\tif ( value === THREE.NormalBlending ) {\n\t\n\t\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\t\n\t\t\t\t} else if ( value === THREE.AdditiveBlending ) {\n\t\n\t\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\t\n\t\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\n\t\n\t\t\t\t\t_context.globalCompositeOperation = 'darker';\n\t\n\t\t\t\t} else if ( value === THREE.MultiplyBlending ) {\n\t\n\t\t\t\t\t_context.globalCompositeOperation = 'multiply';\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_contextGlobalCompositeOperation = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setLineWidth( value ) {\n\t\n\t\t\tif ( _contextLineWidth !== value ) {\n\t\n\t\t\t\t_context.lineWidth = value;\n\t\t\t\t_contextLineWidth = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setLineCap( value ) {\n\t\n\t\t\t// \"butt\", \"round\", \"square\"\n\t\n\t\t\tif ( _contextLineCap !== value ) {\n\t\n\t\t\t\t_context.lineCap = value;\n\t\t\t\t_contextLineCap = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setLineJoin( value ) {\n\t\n\t\t\t// \"round\", \"bevel\", \"miter\"\n\t\n\t\t\tif ( _contextLineJoin !== value ) {\n\t\n\t\t\t\t_context.lineJoin = value;\n\t\t\t\t_contextLineJoin = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setStrokeStyle( value ) {\n\t\n\t\t\tif ( _contextStrokeStyle !== value ) {\n\t\n\t\t\t\t_context.strokeStyle = value;\n\t\t\t\t_contextStrokeStyle = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setFillStyle( value ) {\n\t\n\t\t\tif ( _contextFillStyle !== value ) {\n\t\n\t\t\t\t_context.fillStyle = value;\n\t\t\t\t_contextFillStyle = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setLineDash( value ) {\n\t\n\t\t\tif ( _contextLineDash.length !== value.length ) {\n\t\n\t\t\t\t_context.setLineDash( value );\n\t\t\t\t_contextLineDash = value;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author julianwa / https://github.com/julianwa\n\t */\n\t\n\tTHREE.RenderableObject = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.object = null;\n\t\tthis.z = 0;\n\t\tthis.renderOrder = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableFace = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.v1 = new THREE.RenderableVertex();\n\t\tthis.v2 = new THREE.RenderableVertex();\n\t\tthis.v3 = new THREE.RenderableVertex();\n\t\n\t\tthis.normalModel = new THREE.Vector3();\n\t\n\t\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\t\tthis.vertexNormalsLength = 0;\n\t\n\t\tthis.color = new THREE.Color();\n\t\tthis.material = null;\n\t\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\n\t\n\t\tthis.z = 0;\n\t\tthis.renderOrder = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableVertex = function () {\n\t\n\t\tthis.position = new THREE.Vector3();\n\t\tthis.positionWorld = new THREE.Vector3();\n\t\tthis.positionScreen = new THREE.Vector4();\n\t\n\t\tthis.visible = true;\n\t\n\t};\n\t\n\tTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\t\n\t\tthis.positionWorld.copy( vertex.positionWorld );\n\t\tthis.positionScreen.copy( vertex.positionScreen );\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableLine = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.v1 = new THREE.RenderableVertex();\n\t\tthis.v2 = new THREE.RenderableVertex();\n\t\n\t\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\t\tthis.material = null;\n\t\n\t\tthis.z = 0;\n\t\tthis.renderOrder = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.RenderableSprite = function () {\n\t\n\t\tthis.id = 0;\n\t\n\t\tthis.object = null;\n\t\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.z = 0;\n\t\n\t\tthis.rotation = 0;\n\t\tthis.scale = new THREE.Vector2();\n\t\n\t\tthis.material = null;\n\t\tthis.renderOrder = 0;\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.Projector = function () {\n\t\n\t\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\n\t\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\t\n\t\t_renderData = { objects: [], lights: [], elements: [] },\n\t\n\t\t_vector3 = new THREE.Vector3(),\n\t\t_vector4 = new THREE.Vector4(),\n\t\n\t\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t\t_boundingBox = new THREE.Box3(),\n\t\t_points3 = new Array( 3 ),\n\t\t_points4 = new Array( 4 ),\n\t\n\t\t_viewMatrix = new THREE.Matrix4(),\n\t\t_viewProjectionMatrix = new THREE.Matrix4(),\n\t\n\t\t_modelMatrix,\n\t\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\t\n\t\t_normalMatrix = new THREE.Matrix3(),\n\t\n\t\t_frustum = new THREE.Frustum(),\n\t\n\t\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\t\n\t\t//\n\t\n\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\t\n\t\t};\n\t\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\t\n\t\t};\n\t\n\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tvar RenderList = function () {\n\t\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\tvar object = null;\n\t\t\tvar material = null;\n\t\n\t\t\tvar normalMatrix = new THREE.Matrix3();\n\t\n\t\t\tfunction setObject( value ) {\n\t\n\t\t\t\tobject = value;\n\t\t\t\tmaterial = object.material;\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\n\t\n\t\t\t\tnormals.length = 0;\n\t\t\t\tuvs.length = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectVertex( vertex ) {\n\t\n\t\t\t\tvar position = vertex.position;\n\t\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\t\tvar positionScreen = vertex.positionScreen;\n\t\n\t\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\t\n\t\t\t\tvar invW = 1 / positionScreen.w;\n\t\n\t\t\t\tpositionScreen.x *= invW;\n\t\t\t\tpositionScreen.y *= invW;\n\t\t\t\tpositionScreen.z *= invW;\n\t\n\t\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\n\t\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\n\t\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushVertex( x, y, z ) {\n\t\n\t\t\t\t_vertex = getNextVertexInPool();\n\t\t\t\t_vertex.position.set( x, y, z );\n\t\n\t\t\t\tprojectVertex( _vertex );\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushNormal( x, y, z ) {\n\t\n\t\t\t\tnormals.push( x, y, z );\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushUv( x, y ) {\n\t\n\t\t\t\tuvs.push( x, y );\n\t\n\t\t\t}\n\t\n\t\t\tfunction checkTriangleVisibility( v1, v2, v3 ) {\n\t\n\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\n\t\n\t\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t\t_points3[ 2 ] = v3.positionScreen;\n\t\n\t\t\t\treturn _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );\n\t\n\t\t\t}\n\t\n\t\t\tfunction checkBackfaceCulling( v1, v2, v3 ) {\n\t\n\t\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushLine( a, b ) {\n\t\n\t\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\t\tvar v2 = _vertexPool[ b ];\n\t\n\t\t\t\t_line = getNextLineInPool();\n\t\n\t\t\t\t_line.id = object.id;\n\t\t\t\t_line.v1.copy( v1 );\n\t\t\t\t_line.v2.copy( v2 );\n\t\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\n\t\t\t\t_line.renderOrder = object.renderOrder;\n\t\n\t\t\t\t_line.material = object.material;\n\t\n\t\t\t\t_renderData.elements.push( _line );\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushTriangle( a, b, c ) {\n\t\n\t\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\t\tvar v2 = _vertexPool[ b ];\n\t\t\t\tvar v3 = _vertexPool[ c ];\n\t\n\t\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\n\t\n\t\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\n\t\n\t\t\t\t\t_face = getNextFaceInPool();\n\t\n\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\t\t\t\t_face.renderOrder = object.renderOrder;\n\t\n\t\t\t\t\t// use first vertex normal as face normal\n\t\n\t\t\t\t\t_face.normalModel.fromArray( normals, a * 3 );\n\t\t\t\t\t_face.normalModel.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\n\t\t\t\t\t\tnormal.fromArray( normals, arguments[ i ] * 3 );\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t\tvar uv = _face.uvs[ i ];\n\t\t\t\t\t\tuv.fromArray( uvs, arguments[ i ] * 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_face.vertexNormalsLength = 3;\n\t\n\t\t\t\t\t_face.material = object.material;\n\t\n\t\t\t\t\t_renderData.elements.push( _face );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tsetObject: setObject,\n\t\t\t\tprojectVertex: projectVertex,\n\t\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\t\tpushVertex: pushVertex,\n\t\t\t\tpushNormal: pushNormal,\n\t\t\t\tpushUv: pushUv,\n\t\t\t\tpushLine: pushLine,\n\t\t\t\tpushTriangle: pushTriangle\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar renderList = new RenderList();\n\t\n\t\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\t\n\t\t\t_faceCount = 0;\n\t\t\t_lineCount = 0;\n\t\t\t_spriteCount = 0;\n\t\n\t\t\t_renderData.elements.length = 0;\n\t\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\t\n\t\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\t\n\t\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\t\n\t\t\t//\n\t\n\t\t\t_objectCount = 0;\n\t\n\t\t\t_renderData.objects.length = 0;\n\t\t\t_renderData.lights.length = 0;\n\t\n\t\t\tfunction addObject( object ) {\n\t\n\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t_object.id = object.id;\n\t\t\t\t_object.object = object;\n\t\n\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t\t_object.z = _vector3.z;\n\t\t\t\t_object.renderOrder = object.renderOrder;\n\t\n\t\t\t\t_renderData.objects.push( _object );\n\t\n\t\t\t}\n\t\n\t\t\tscene.traverseVisible( function ( object ) {\n\t\n\t\t\t\tif ( object instanceof THREE.Light ) {\n\t\n\t\t\t\t\t_renderData.lights.push( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\t\n\t\t\t\t\tif ( object.material.visible === false ) return;\n\t\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) return;\n\t\n\t\t\t\t\taddObject( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\tif ( object.material.visible === false ) return;\n\t\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) return;\n\t\n\t\t\t\t\taddObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t\tif ( sortObjects === true ) {\n\t\n\t\t\t\t_renderData.objects.sort( painterSort );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\t\n\t\t\t\tvar object = _renderData.objects[ o ].object;\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\trenderList.setObject( object );\n\t\n\t\t\t\t_modelMatrix = object.matrixWorld;\n\t\n\t\t\t\t_vertexCount = 0;\n\t\n\t\t\t\tif ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\t\t\tif ( attributes.position === undefined ) continue;\n\t\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.normal !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = geometry.index.array;\n\t\n\t\t\t\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var o = 0; o < groups.length; o ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar group = groups[ o ];\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\n\t\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\t\n\t\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\t\t\tvar vertex = vertices[ v ];\n\t\n\t\t\t\t\t\t\t_vector3.copy( vertex );\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\n\t\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\n\t\n\t\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\n\t\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\n\t\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tvar face = faces[ f ];\n\t\n\t\t\t\t\t\t\tmaterial = isFaceMaterial === true\n\t\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t\t\t : object.material;\n\t\n\t\t\t\t\t\t\tif ( material === undefined ) continue;\n\t\n\t\t\t\t\t\t\tvar side = material.side;\n\t\n\t\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\n\t\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\n\t\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\n\t\n\t\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\n\t\n\t\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\n\t\n\t\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\n\t\n\t\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\n\t\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face = getNextFaceInPool();\n\t\n\t\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\t\n\t\t\t\t\t\t\t_face.normalModel.copy( face.normal );\n\t\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\t\n\t\t\t\t\t\t\t\t_face.normalModel.negate();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\t\n\t\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalModel.negate();\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\t\n\t\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\n\t\n\t\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t\t_face.material = material;\n\t\n\t\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\t\t\t\t\t\t_face.renderOrder = object.renderOrder;\n\t\n\t\t\t\t\t\t\t_renderData.elements.push( _face );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.Line ) {\n\t\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\t\t\tif ( attributes.position !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t\t\t\t\tvar indices = geometry.index.array;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\t\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\n\t\t\t\t\t\tif ( vertices.length === 0 ) continue;\n\t\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\t\n\t\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\n\t\n\t\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\t\n\t\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\t\n\t\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\t\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\t\n\t\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\t\n\t\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\t\n\t\t\t\t\t\t\t\t_line = getNextLineInPool();\n\t\n\t\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\t\n\t\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\t\t\t\t\t\t\t\t_line.renderOrder = object.renderOrder;\n\t\n\t\t\t\t\t\t\t\t_line.material = object.material;\n\t\n\t\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\t\n\t\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_renderData.elements.push( _line );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\n\t\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\t\n\t\t\t\t\tvar invW = 1 / _vector4.w;\n\t\n\t\t\t\t\t_vector4.z *= invW;\n\t\n\t\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\n\t\n\t\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t\t_sprite.renderOrder = object.renderOrder;\n\t\t\t\t\t\t_sprite.object = object;\n\t\n\t\t\t\t\t\t_sprite.rotation = object.rotation;\n\t\n\t\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\n\t\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\n\t\n\t\t\t\t\t\t_sprite.material = object.material;\n\t\n\t\t\t\t\t\t_renderData.elements.push( _sprite );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( sortElements === true ) {\n\t\n\t\t\t\t_renderData.elements.sort( painterSort );\n\t\n\t\t\t}\n\t\n\t\t\treturn _renderData;\n\t\n\t\t};\n\t\n\t\t// Pools\n\t\n\t\tfunction getNextObjectInPool() {\n\t\n\t\t\tif ( _objectCount === _objectPoolLength ) {\n\t\n\t\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t\t_objectPool.push( object );\n\t\t\t\t_objectPoolLength ++;\n\t\t\t\t_objectCount ++;\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t\treturn _objectPool[ _objectCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextVertexInPool() {\n\t\n\t\t\tif ( _vertexCount === _vertexPoolLength ) {\n\t\n\t\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t\t_vertexPool.push( vertex );\n\t\t\t\t_vertexPoolLength ++;\n\t\t\t\t_vertexCount ++;\n\t\t\t\treturn vertex;\n\t\n\t\t\t}\n\t\n\t\t\treturn _vertexPool[ _vertexCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextFaceInPool() {\n\t\n\t\t\tif ( _faceCount === _facePoolLength ) {\n\t\n\t\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t\t_facePool.push( face );\n\t\t\t\t_facePoolLength ++;\n\t\t\t\t_faceCount ++;\n\t\t\t\treturn face;\n\t\n\t\t\t}\n\t\n\t\t\treturn _facePool[ _faceCount ++ ];\n\t\n\t\n\t\t}\n\t\n\t\tfunction getNextLineInPool() {\n\t\n\t\t\tif ( _lineCount === _linePoolLength ) {\n\t\n\t\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t\t_linePool.push( line );\n\t\t\t\t_linePoolLength ++;\n\t\t\t\t_lineCount ++;\n\t\t\t\treturn line;\n\t\n\t\t\t}\n\t\n\t\t\treturn _linePool[ _lineCount ++ ];\n\t\n\t\t}\n\t\n\t\tfunction getNextSpriteInPool() {\n\t\n\t\t\tif ( _spriteCount === _spritePoolLength ) {\n\t\n\t\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t\t_spritePool.push( sprite );\n\t\t\t\t_spritePoolLength ++;\n\t\t\t\t_spriteCount ++;\n\t\t\t\treturn sprite;\n\t\n\t\t\t}\n\t\n\t\t\treturn _spritePool[ _spriteCount ++ ];\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction painterSort( a, b ) {\n\t\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else if ( a.id !== b.id ) {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn 0;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction clipLine( s1, s2 ) {\n\t\n\t\t\tvar alpha1 = 0, alpha2 = 1,\n\t\n\t\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t\t// Z = -1 and Z = +1, respectively.\n\t\t\tbc1near =  s1.z + s1.w,\n\t\t\tbc2near =  s2.z + s2.w,\n\t\t\tbc1far =  - s1.z + s1.w,\n\t\t\tbc2far =  - s2.z + s2.w;\n\t\n\t\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\t\n\t\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\t\treturn true;\n\t\n\t\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\n\t\n\t\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\t\treturn false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// The line segment spans at least one clip plane.\n\t\n\t\t\t\tif ( bc1near < 0 ) {\n\t\n\t\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\t\n\t\t\t\t} else if ( bc2near < 0 ) {\n\t\n\t\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( bc1far < 0 ) {\n\t\n\t\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\t\n\t\t\t\t} else if ( bc2far < 0 ) {\n\t\n\t\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( alpha2 < alpha1 ) {\n\t\n\t\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n\t *\n\t * Copyright (c) 2014-2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\tvar isObject = __webpack_require__(10);\n\t\n\tfunction isObjectObject(o) {\n\t  return isObject(o) === true\n\t    && Object.prototype.toString.call(o) === '[object Object]';\n\t}\n\t\n\tmodule.exports = function isPlainObject(o) {\n\t  var ctor,prot;\n\t  \n\t  if (isObjectObject(o) === false) return false;\n\t  \n\t  // If has modified constructor\n\t  ctor = o.constructor;\n\t  if (typeof ctor !== 'function') return false;\n\t  \n\t  // If has modified prototype\n\t  prot = ctor.prototype;\n\t  if (isObjectObject(prot) === false) return false;\n\t  \n\t  // If constructor does not have an Object-specific method\n\t  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n\t    return false;\n\t  }\n\t  \n\t  // Most likely a plain Object\n\t  return true;\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * isobject <https://github.com/jonschlinkert/isobject>\n\t *\n\t * Copyright (c) 2014-2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\tmodule.exports = function isObject(val) {\n\t  return val != null && typeof val === 'object'\n\t    && !Array.isArray(val);\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * EventEmitter2\n\t * https://github.com/hij1nx/EventEmitter2\n\t *\n\t * Copyright (c) 2013 hij1nx\n\t * Licensed under the MIT license.\n\t */\n\t;!function(undefined) {\n\t\n\t  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n\t    return Object.prototype.toString.call(obj) === \"[object Array]\";\n\t  };\n\t  var defaultMaxListeners = 10;\n\t\n\t  function init() {\n\t    this._events = {};\n\t    if (this._conf) {\n\t      configure.call(this, this._conf);\n\t    }\n\t  }\n\t\n\t  function configure(conf) {\n\t    if (conf) {\n\t\n\t      this._conf = conf;\n\t\n\t      conf.delimiter && (this.delimiter = conf.delimiter);\n\t      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n\t      conf.wildcard && (this.wildcard = conf.wildcard);\n\t      conf.newListener && (this.newListener = conf.newListener);\n\t\n\t      if (this.wildcard) {\n\t        this.listenerTree = {};\n\t      }\n\t    }\n\t  }\n\t\n\t  function EventEmitter(conf) {\n\t    this._events = {};\n\t    this.newListener = false;\n\t    configure.call(this, conf);\n\t  }\n\t\n\t  //\n\t  // Attention, function return type now is array, always !\n\t  // It has zero elements if no any matches found and one or more\n\t  // elements (leafs) if there are matches\n\t  //\n\t  function searchListenerTree(handlers, type, tree, i) {\n\t    if (!tree) {\n\t      return [];\n\t    }\n\t    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n\t        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n\t    if (i === typeLength && tree._listeners) {\n\t      //\n\t      // If at the end of the event(s) list and the tree has listeners\n\t      // invoke those listeners.\n\t      //\n\t      if (typeof tree._listeners === 'function') {\n\t        handlers && handlers.push(tree._listeners);\n\t        return [tree];\n\t      } else {\n\t        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n\t          handlers && handlers.push(tree._listeners[leaf]);\n\t        }\n\t        return [tree];\n\t      }\n\t    }\n\t\n\t    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n\t      //\n\t      // If the event emitted is '*' at this part\n\t      // or there is a concrete match at this patch\n\t      //\n\t      if (currentType === '*') {\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n\t          }\n\t        }\n\t        return listeners;\n\t      } else if(currentType === '**') {\n\t        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n\t        if(endReached && tree._listeners) {\n\t          // The next element has a _listeners, add it to the handlers.\n\t          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n\t        }\n\t\n\t        for (branch in tree) {\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n\t            if(branch === '*' || branch === '**') {\n\t              if(tree[branch]._listeners && !endReached) {\n\t                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n\t              }\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            } else if(branch === nextType) {\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n\t            } else {\n\t              // No match on this one, shift into the tree but not in the type array.\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n\t            }\n\t          }\n\t        }\n\t        return listeners;\n\t      }\n\t\n\t      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n\t    }\n\t\n\t    xTree = tree['*'];\n\t    if (xTree) {\n\t      //\n\t      // If the listener tree will allow any match for this part,\n\t      // then recursively explore all branches of the tree\n\t      //\n\t      searchListenerTree(handlers, type, xTree, i+1);\n\t    }\n\t\n\t    xxTree = tree['**'];\n\t    if(xxTree) {\n\t      if(i < typeLength) {\n\t        if(xxTree._listeners) {\n\t          // If we have a listener on a '**', it will catch all, so add its handler.\n\t          searchListenerTree(handlers, type, xxTree, typeLength);\n\t        }\n\t\n\t        // Build arrays of matching next branches and others.\n\t        for(branch in xxTree) {\n\t          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n\t            if(branch === nextType) {\n\t              // We know the next element will match, so jump twice.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+2);\n\t            } else if(branch === currentType) {\n\t              // Current node matches, move into the tree.\n\t              searchListenerTree(handlers, type, xxTree[branch], i+1);\n\t            } else {\n\t              isolatedBranch = {};\n\t              isolatedBranch[branch] = xxTree[branch];\n\t              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n\t            }\n\t          }\n\t        }\n\t      } else if(xxTree._listeners) {\n\t        // We have reached the end and still on a '**'\n\t        searchListenerTree(handlers, type, xxTree, typeLength);\n\t      } else if(xxTree['*'] && xxTree['*']._listeners) {\n\t        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n\t      }\n\t    }\n\t\n\t    return listeners;\n\t  }\n\t\n\t  function growListenerTree(type, listener) {\n\t\n\t    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t\n\t    //\n\t    // Looks for two consecutive '**', if so, don't add the event at all.\n\t    //\n\t    for(var i = 0, len = type.length; i+1 < len; i++) {\n\t      if(type[i] === '**' && type[i+1] === '**') {\n\t        return;\n\t      }\n\t    }\n\t\n\t    var tree = this.listenerTree;\n\t    var name = type.shift();\n\t\n\t    while (name) {\n\t\n\t      if (!tree[name]) {\n\t        tree[name] = {};\n\t      }\n\t\n\t      tree = tree[name];\n\t\n\t      if (type.length === 0) {\n\t\n\t        if (!tree._listeners) {\n\t          tree._listeners = listener;\n\t        }\n\t        else if(typeof tree._listeners === 'function') {\n\t          tree._listeners = [tree._listeners, listener];\n\t        }\n\t        else if (isArray(tree._listeners)) {\n\t\n\t          tree._listeners.push(listener);\n\t\n\t          if (!tree._listeners.warned) {\n\t\n\t            var m = defaultMaxListeners;\n\t\n\t            if (typeof this._events.maxListeners !== 'undefined') {\n\t              m = this._events.maxListeners;\n\t            }\n\t\n\t            if (m > 0 && tree._listeners.length > m) {\n\t\n\t              tree._listeners.warned = true;\n\t              console.error('(node) warning: possible EventEmitter memory ' +\n\t                            'leak detected. %d listeners added. ' +\n\t                            'Use emitter.setMaxListeners() to increase limit.',\n\t                            tree._listeners.length);\n\t              console.trace();\n\t            }\n\t          }\n\t        }\n\t        return true;\n\t      }\n\t      name = type.shift();\n\t    }\n\t    return true;\n\t  }\n\t\n\t  // By default EventEmitters will print a warning if more than\n\t  // 10 listeners are added to it. This is a useful default which\n\t  // helps finding memory leaks.\n\t  //\n\t  // Obviously not all Emitters should be limited to 10. This function allows\n\t  // that to be increased. Set to zero for unlimited.\n\t\n\t  EventEmitter.prototype.delimiter = '.';\n\t\n\t  EventEmitter.prototype.setMaxListeners = function(n) {\n\t    this._events || init.call(this);\n\t    this._events.maxListeners = n;\n\t    if (!this._conf) this._conf = {};\n\t    this._conf.maxListeners = n;\n\t  };\n\t\n\t  EventEmitter.prototype.event = '';\n\t\n\t  EventEmitter.prototype.once = function(event, fn) {\n\t    this.many(event, 1, fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.many = function(event, ttl, fn) {\n\t    var self = this;\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('many only accepts instances of Function');\n\t    }\n\t\n\t    function listener() {\n\t      if (--ttl === 0) {\n\t        self.off(event, listener);\n\t      }\n\t      fn.apply(this, arguments);\n\t    }\n\t\n\t    listener._origin = fn;\n\t\n\t    this.on(event, listener);\n\t\n\t    return self;\n\t  };\n\t\n\t  EventEmitter.prototype.emit = function() {\n\t\n\t    this._events || init.call(this);\n\t\n\t    var type = arguments[0];\n\t\n\t    if (type === 'newListener' && !this.newListener) {\n\t      if (!this._events.newListener) { return false; }\n\t    }\n\t\n\t    // Loop through the *_all* functions and invoke them.\n\t    if (this._all) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t      for (i = 0, l = this._all.length; i < l; i++) {\n\t        this.event = type;\n\t        this._all[i].apply(this, args);\n\t      }\n\t    }\n\t\n\t    // If there is no 'error' event listener then throw.\n\t    if (type === 'error') {\n\t\n\t      if (!this._all &&\n\t        !this._events.error &&\n\t        !(this.wildcard && this.listenerTree.error)) {\n\t\n\t        if (arguments[1] instanceof Error) {\n\t          throw arguments[1]; // Unhandled 'error' event\n\t        } else {\n\t          throw new Error(\"Uncaught, unspecified 'error' event.\");\n\t        }\n\t        return false;\n\t      }\n\t    }\n\t\n\t    var handler;\n\t\n\t    if(this.wildcard) {\n\t      handler = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      handler = this._events[type];\n\t    }\n\t\n\t    if (typeof handler === 'function') {\n\t      this.event = type;\n\t      if (arguments.length === 1) {\n\t        handler.call(this);\n\t      }\n\t      else if (arguments.length > 1)\n\t        switch (arguments.length) {\n\t          case 2:\n\t            handler.call(this, arguments[1]);\n\t            break;\n\t          case 3:\n\t            handler.call(this, arguments[1], arguments[2]);\n\t            break;\n\t          // slower\n\t          default:\n\t            var l = arguments.length;\n\t            var args = new Array(l - 1);\n\t            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t            handler.apply(this, args);\n\t        }\n\t      return true;\n\t    }\n\t    else if (handler) {\n\t      var l = arguments.length;\n\t      var args = new Array(l - 1);\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\t\n\t      var listeners = handler.slice();\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\n\t        this.event = type;\n\t        listeners[i].apply(this, args);\n\t      }\n\t      return (listeners.length > 0) || !!this._all;\n\t    }\n\t    else {\n\t      return !!this._all;\n\t    }\n\t\n\t  };\n\t\n\t  EventEmitter.prototype.on = function(type, listener) {\n\t\n\t    if (typeof type === 'function') {\n\t      this.onAny(type);\n\t      return this;\n\t    }\n\t\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('on only accepts instances of Function');\n\t    }\n\t    this._events || init.call(this);\n\t\n\t    // To avoid recursion in the case that type == \"newListeners\"! Before\n\t    // adding it to the listeners, first emit \"newListeners\".\n\t    this.emit('newListener', type, listener);\n\t\n\t    if(this.wildcard) {\n\t      growListenerTree.call(this, type, listener);\n\t      return this;\n\t    }\n\t\n\t    if (!this._events[type]) {\n\t      // Optimize the case of one listener. Don't need the extra array object.\n\t      this._events[type] = listener;\n\t    }\n\t    else if(typeof this._events[type] === 'function') {\n\t      // Adding the second element, need to change to array.\n\t      this._events[type] = [this._events[type], listener];\n\t    }\n\t    else if (isArray(this._events[type])) {\n\t      // If we've already got an array, just append.\n\t      this._events[type].push(listener);\n\t\n\t      // Check for listener leak\n\t      if (!this._events[type].warned) {\n\t\n\t        var m = defaultMaxListeners;\n\t\n\t        if (typeof this._events.maxListeners !== 'undefined') {\n\t          m = this._events.maxListeners;\n\t        }\n\t\n\t        if (m > 0 && this._events[type].length > m) {\n\t\n\t          this._events[type].warned = true;\n\t          console.error('(node) warning: possible EventEmitter memory ' +\n\t                        'leak detected. %d listeners added. ' +\n\t                        'Use emitter.setMaxListeners() to increase limit.',\n\t                        this._events[type].length);\n\t          console.trace();\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.onAny = function(fn) {\n\t\n\t    if (typeof fn !== 'function') {\n\t      throw new Error('onAny only accepts instances of Function');\n\t    }\n\t\n\t    if(!this._all) {\n\t      this._all = [];\n\t    }\n\t\n\t    // Add the function to the event listener collection.\n\t    this._all.push(fn);\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t  EventEmitter.prototype.off = function(type, listener) {\n\t    if (typeof listener !== 'function') {\n\t      throw new Error('removeListener only takes instances of Function');\n\t    }\n\t\n\t    var handlers,leafs=[];\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t    }\n\t    else {\n\t      // does not use listeners(), so no side effect of creating _events[type]\n\t      if (!this._events[type]) return this;\n\t      handlers = this._events[type];\n\t      leafs.push({_listeners:handlers});\n\t    }\n\t\n\t    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t      var leaf = leafs[iLeaf];\n\t      handlers = leaf._listeners;\n\t      if (isArray(handlers)) {\n\t\n\t        var position = -1;\n\t\n\t        for (var i = 0, length = handlers.length; i < length; i++) {\n\t          if (handlers[i] === listener ||\n\t            (handlers[i].listener && handlers[i].listener === listener) ||\n\t            (handlers[i]._origin && handlers[i]._origin === listener)) {\n\t            position = i;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (position < 0) {\n\t          continue;\n\t        }\n\t\n\t        if(this.wildcard) {\n\t          leaf._listeners.splice(position, 1);\n\t        }\n\t        else {\n\t          this._events[type].splice(position, 1);\n\t        }\n\t\n\t        if (handlers.length === 0) {\n\t          if(this.wildcard) {\n\t            delete leaf._listeners;\n\t          }\n\t          else {\n\t            delete this._events[type];\n\t          }\n\t        }\n\t        return this;\n\t      }\n\t      else if (handlers === listener ||\n\t        (handlers.listener && handlers.listener === listener) ||\n\t        (handlers._origin && handlers._origin === listener)) {\n\t        if(this.wildcard) {\n\t          delete leaf._listeners;\n\t        }\n\t        else {\n\t          delete this._events[type];\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.offAny = function(fn) {\n\t    var i = 0, l = 0, fns;\n\t    if (fn && this._all && this._all.length > 0) {\n\t      fns = this._all;\n\t      for(i = 0, l = fns.length; i < l; i++) {\n\t        if(fn === fns[i]) {\n\t          fns.splice(i, 1);\n\t          return this;\n\t        }\n\t      }\n\t    } else {\n\t      this._all = [];\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\t\n\t  EventEmitter.prototype.removeAllListeners = function(type) {\n\t    if (arguments.length === 0) {\n\t      !this._events || init.call(this);\n\t      return this;\n\t    }\n\t\n\t    if(this.wildcard) {\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\t\n\t      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n\t        var leaf = leafs[iLeaf];\n\t        leaf._listeners = null;\n\t      }\n\t    }\n\t    else {\n\t      if (!this._events[type]) return this;\n\t      this._events[type] = null;\n\t    }\n\t    return this;\n\t  };\n\t\n\t  EventEmitter.prototype.listeners = function(type) {\n\t    if(this.wildcard) {\n\t      var handlers = [];\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\t      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n\t      return handlers;\n\t    }\n\t\n\t    this._events || init.call(this);\n\t\n\t    if (!this._events[type]) this._events[type] = [];\n\t    if (!isArray(this._events[type])) {\n\t      this._events[type] = [this._events[type]];\n\t    }\n\t    return this._events[type];\n\t  };\n\t\n\t  EventEmitter.prototype.listenersAny = function() {\n\t\n\t    if(this._all) {\n\t      return this._all;\n\t    }\n\t    else {\n\t      return [];\n\t    }\n\t\n\t  };\n\t\n\t  if (true) {\n\t     // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return EventEmitter;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    // CommonJS\n\t    exports.EventEmitter2 = EventEmitter;\n\t  }\n\t  else {\n\t    // Browser global.\n\t    window.EventEmitter2 = EventEmitter;\n\t  }\n\t}();\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {Promise: window['Promise']}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n\t * directory of this distribution and at\n\t * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n\t */\n\t;\n\t(function() {\n\t\n\t    /**\n\t     * Class for dimension change detection.\n\t     *\n\t     * @param {Element|Element[]|Elements|jQuery} element\n\t     * @param {Function} callback\n\t     *\n\t     * @constructor\n\t     */\n\t    var ResizeSensor = function(element, callback) {\n\t        /**\n\t         *\n\t         * @constructor\n\t         */\n\t        function EventQueue() {\n\t            this.q = [];\n\t            this.add = function(ev) {\n\t                this.q.push(ev);\n\t            };\n\t\n\t            var i, j;\n\t            this.call = function() {\n\t                for (i = 0, j = this.q.length; i < j; i++) {\n\t                    this.q[i].call();\n\t                }\n\t            };\n\t        }\n\t\n\t        /**\n\t         * @param {HTMLElement} element\n\t         * @param {String}      prop\n\t         * @returns {String|Number}\n\t         */\n\t        function getComputedStyle(element, prop) {\n\t            if (element.currentStyle) {\n\t                return element.currentStyle[prop];\n\t            } else if (window.getComputedStyle) {\n\t                return window.getComputedStyle(element, null).getPropertyValue(prop);\n\t            } else {\n\t                return element.style[prop];\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param {HTMLElement} element\n\t         * @param {Function}    resized\n\t         */\n\t        function attachResizeEvent(element, resized) {\n\t            if (!element.resizedAttached) {\n\t                element.resizedAttached = new EventQueue();\n\t                element.resizedAttached.add(resized);\n\t            } else if (element.resizedAttached) {\n\t                element.resizedAttached.add(resized);\n\t                return;\n\t            }\n\t\n\t            element.resizeSensor = document.createElement('div');\n\t            element.resizeSensor.className = 'resize-sensor';\n\t            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n\t            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\t\n\t            element.resizeSensor.style.cssText = style;\n\t            element.resizeSensor.innerHTML =\n\t                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n\t                    '<div style=\"' + styleChild + '\"></div>' +\n\t                '</div>' +\n\t                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n\t                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n\t                '</div>';\n\t            element.appendChild(element.resizeSensor);\n\t\n\t            if (!{fixed: 1, absolute: 1}[getComputedStyle(element, 'position')]) {\n\t                element.style.position = 'relative';\n\t            }\n\t\n\t            var expand = element.resizeSensor.childNodes[0];\n\t            var expandChild = expand.childNodes[0];\n\t            var shrink = element.resizeSensor.childNodes[1];\n\t            var shrinkChild = shrink.childNodes[0];\n\t\n\t            var lastWidth, lastHeight;\n\t\n\t            var reset = function() {\n\t                expandChild.style.width = expand.offsetWidth + 10 + 'px';\n\t                expandChild.style.height = expand.offsetHeight + 10 + 'px';\n\t                expand.scrollLeft = expand.scrollWidth;\n\t                expand.scrollTop = expand.scrollHeight;\n\t                shrink.scrollLeft = shrink.scrollWidth;\n\t                shrink.scrollTop = shrink.scrollHeight;\n\t                lastWidth = element.offsetWidth;\n\t                lastHeight = element.offsetHeight;\n\t            };\n\t\n\t            reset();\n\t\n\t            var changed = function() {\n\t                if (element.resizedAttached) {\n\t                    element.resizedAttached.call();\n\t                }\n\t            };\n\t\n\t            var addEvent = function(el, name, cb) {\n\t                if (el.attachEvent) {\n\t                    el.attachEvent('on' + name, cb);\n\t                } else {\n\t                    el.addEventListener(name, cb);\n\t                }\n\t            };\n\t\n\t            var onScroll = function() {\n\t              if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {\n\t                  changed();\n\t              }\n\t              reset();\n\t            };\n\t\n\t            addEvent(expand, 'scroll', onScroll);\n\t            addEvent(shrink, 'scroll', onScroll);\n\t        }\n\t\n\t        var elementType = Object.prototype.toString.call(element);\n\t        var isCollectionTyped = ('[object Array]' === elementType\n\t            || ('[object NodeList]' === elementType)\n\t            || ('[object HTMLCollection]' === elementType)\n\t            || ('undefined' !== typeof jQuery && element instanceof jQuery) //jquery\n\t            || ('undefined' !== typeof Elements && element instanceof Elements) //mootools\n\t        );\n\t\n\t        if (isCollectionTyped) {\n\t            var i = 0, j = element.length;\n\t            for (; i < j; i++) {\n\t                attachResizeEvent(element[i], callback);\n\t            }\n\t        } else {\n\t            attachResizeEvent(element, callback);\n\t        }\n\t\n\t        this.detach = function() {\n\t            if (isCollectionTyped) {\n\t                var i = 0, j = element.length;\n\t                for (; i < j; i++) {\n\t                    ResizeSensor.detach(element[i]);\n\t                }\n\t            } else {\n\t                ResizeSensor.detach(element);\n\t            }\n\t        };\n\t    };\n\t\n\t    ResizeSensor.detach = function(element) {\n\t        if (element.resizeSensor) {\n\t            element.removeChild(element.resizeSensor);\n\t            delete element.resizeSensor;\n\t            delete element.resizedAttached;\n\t        }\n\t    };\n\t\n\t    // make available to common module loader\n\t    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t        module.exports = ResizeSensor;\n\t    }\n\t    else {\n\t        window.ResizeSensor = ResizeSensor;\n\t    }\n\t\n\t})();\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar deps_1 = __webpack_require__(5);\r\n\t/**\r\n\t * this class uses as proxy for EventEmitter2\r\n\t */\r\n\tvar EventEmitter = (function () {\r\n\t    function EventEmitter() {\r\n\t        this.ee = new deps_1.EE2();\r\n\t    }\r\n\t    EventEmitter.prototype.emit = function (eventName) {\r\n\t        var args = [];\r\n\t        for (var _i = 1; _i < arguments.length; _i++) {\r\n\t            args[_i - 1] = arguments[_i];\r\n\t        }\r\n\t        (_a = this.ee).emit.apply(_a, [eventName].concat(args));\r\n\t        var _a;\r\n\t    };\r\n\t    EventEmitter.prototype.on = function (eventName, callback) {\r\n\t        return this.ee.on(eventName, callback);\r\n\t    };\r\n\t    EventEmitter.prototype.off = function (eventName, callback) {\r\n\t        return this.ee.off(eventName, callback);\r\n\t    };\r\n\t    EventEmitter.prototype.subscribe = function (eventName, callback) {\r\n\t        var _this = this;\r\n\t        this.on(eventName, callback);\r\n\t        return function () { return _this.off(eventName, callback); };\r\n\t    };\r\n\t    EventEmitter.prototype.setMaxListeners = function (listenersCount) {\r\n\t        this.ee.setMaxListeners(listenersCount);\r\n\t    };\r\n\t    EventEmitter.prototype.removeAllListeners = function (eventName) {\r\n\t        this.ee.removeAllListeners(eventName);\r\n\t    };\r\n\t    return EventEmitter;\r\n\t}());\r\n\texports.EventEmitter = EventEmitter;\r\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Trend_1 = __webpack_require__(16);\r\n\tvar EventEmmiter_1 = __webpack_require__(14);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar TrendsManager_1 = __webpack_require__(18);\r\n\tvar Screen_1 = __webpack_require__(19);\r\n\tvar AxisMarks_1 = __webpack_require__(20);\r\n\tvar interfaces_1 = __webpack_require__(21);\r\n\tvar deps_1 = __webpack_require__(5);\r\n\tvar CHART_STATE_EVENTS = {\r\n\t    INITIAL_STATE_APPLIED: 'initialStateApplied',\r\n\t    READY: 'ready',\r\n\t    DESTROY: 'destroy',\r\n\t    CHANGE: 'change',\r\n\t    TREND_CHANGE: 'trendChange',\r\n\t    TRENDS_CHANGE: 'trendsChange',\r\n\t    ZOOM: 'zoom',\r\n\t    RESIZE: 'resize',\r\n\t    SCROLL: 'scroll',\r\n\t    SCROLL_STOP: 'scrollStop',\r\n\t    PLUGINS_STATE_CHANGED: 'pluginsStateChanged'\r\n\t};\r\n\t/**\r\n\t *  class for manage chart state, all state changes caused only by State.setState method\r\n\t */\r\n\tvar ChartState = (function () {\r\n\t    function ChartState(initialState, plugins) {\r\n\t        if (plugins === void 0) { plugins = []; }\r\n\t        this.data = {\r\n\t            prevState: {},\r\n\t            zoom: 0,\r\n\t            xAxis: {\r\n\t                range: {\r\n\t                    type: interfaces_1.AXIS_RANGE_TYPE.ALL,\r\n\t                    from: 0,\r\n\t                    to: 0,\r\n\t                    scroll: 0,\r\n\t                    zoom: 1,\r\n\t                    padding: { start: 0, end: 5 },\r\n\t                    margin: { start: 0, end: 5 }\r\n\t                },\r\n\t                dataType: interfaces_1.AXIS_DATA_TYPE.NUMBER,\r\n\t                grid: { enabled: true, minSizePx: 100 },\r\n\t                autoScroll: true,\r\n\t                marks: [],\r\n\t            },\r\n\t            yAxis: {\r\n\t                range: {\r\n\t                    type: interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END,\r\n\t                    from: 0,\r\n\t                    to: 0,\r\n\t                    zoom: 1,\r\n\t                    padding: { start: 5, end: 5 },\r\n\t                    margin: { start: 5, end: 5 },\r\n\t                },\r\n\t                grid: { enabled: true, minSizePx: 50 },\r\n\t                dataType: interfaces_1.AXIS_DATA_TYPE.NUMBER,\r\n\t                marks: []\r\n\t            },\r\n\t            animations: {\r\n\t                enabled: true,\r\n\t                trendChangeSpeed: 0.5,\r\n\t                trendChangeEase: void 0,\r\n\t                zoomSpeed: 0.25,\r\n\t                zoomEase: void 0,\r\n\t                scrollSpeed: 0.5,\r\n\t                scrollEase: Linear.easeNone,\r\n\t                autoScrollSpeed: 1,\r\n\t                autoScrollEase: Linear.easeNone,\r\n\t            },\r\n\t            autoRender: { enabled: true, fps: 0 },\r\n\t            autoResize: true,\r\n\t            renderer: 'WebGLRenderer',\r\n\t            autoScroll: true,\r\n\t            controls: { enabled: true },\r\n\t            trendDefaultState: {\r\n\t                enabled: true,\r\n\t                type: Trend_1.TREND_TYPE.LINE,\r\n\t                data: [],\r\n\t                maxSegmentLength: 1000,\r\n\t                lineWidth: 2,\r\n\t                lineColor: 0xFFFFFF,\r\n\t                hasBackground: false,\r\n\t                backgroundColor: 'rgba(#5273BD, 0.15)',\r\n\t                hasBeacon: false,\r\n\t                settingsForTypes: {\r\n\t                    CANDLE: {\r\n\t                        minSegmentLengthInPx: 20,\r\n\t                        maxSegmentLengthInPx: 40,\r\n\t                    },\r\n\t                    LINE: {\r\n\t                        minSegmentLengthInPx: 2,\r\n\t                        maxSegmentLengthInPx: 10,\r\n\t                    }\r\n\t                }\r\n\t            },\r\n\t            cursor: {\r\n\t                dragMode: false,\r\n\t                x: 0,\r\n\t                y: 0\r\n\t            },\r\n\t            backgroundColor: 0x000000,\r\n\t            backgroundOpacity: 1,\r\n\t            showStats: false,\r\n\t            pluginsState: {},\r\n\t            eventEmitterMaxListeners: 20,\r\n\t            maxVisibleSegments: 1280\r\n\t        };\r\n\t        this.plugins = {};\r\n\t        /**\r\n\t         * true then chartState was initialized and ready to use\r\n\t         */\r\n\t        this.isReady = false;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.ee.setMaxListeners(initialState.eventEmitterMaxListeners || this.data.eventEmitterMaxListeners);\r\n\t        this.data = Utils_1.Utils.deepMerge(this.data, initialState);\r\n\t        this.trendsManager = new TrendsManager_1.TrendsManager(this, initialState);\r\n\t        initialState.trends = this.trendsManager.calculatedOptions;\r\n\t        initialState = this.installPlugins(plugins, initialState);\r\n\t        this.setState(initialState);\r\n\t        this.setState({ computedData: this.getComputedData() });\r\n\t        this.savePrevState();\r\n\t        this.screen = new Screen_1.Screen(this);\r\n\t        this.xAxisMarks = new AxisMarks_1.AxisMarks(this, interfaces_1.AXIS_TYPE.X);\r\n\t        this.yAxisMarks = new AxisMarks_1.AxisMarks(this, interfaces_1.AXIS_TYPE.Y);\r\n\t        this.initListeners();\r\n\t        // message to other modules that ChartState.data is ready for use \r\n\t        this.ee.emit(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, initialState);\r\n\t        // message to other modules that ChartState is ready for use\r\n\t        this.isReady = true;\r\n\t        this.ee.emit(CHART_STATE_EVENTS.READY, initialState);\r\n\t    }\r\n\t    /**\r\n\t     * destroy state, use Chart.destroy to completely destroy chart\r\n\t     */\r\n\t    ChartState.prototype.destroy = function () {\r\n\t        this.ee.emit(CHART_STATE_EVENTS.DESTROY);\r\n\t        this.ee.removeAllListeners();\r\n\t        this.data = {};\r\n\t    };\r\n\t    ChartState.prototype.onDestroy = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.DESTROY, cb);\r\n\t    };\r\n\t    ChartState.prototype.onInitialStateApplied = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, cb);\r\n\t    };\r\n\t    ChartState.prototype.onReady = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.READY, cb);\r\n\t    };\r\n\t    ChartState.prototype.onChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.CHANGE, cb);\r\n\t    };\r\n\t    ChartState.prototype.onTrendChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.TREND_CHANGE, cb);\r\n\t    };\r\n\t    ChartState.prototype.onTrendsChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.TRENDS_CHANGE, cb);\r\n\t    };\r\n\t    ChartState.prototype.onScrollStop = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.SCROLL_STOP, cb);\r\n\t    };\r\n\t    ChartState.prototype.onScroll = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.SCROLL, cb);\r\n\t    };\r\n\t    ChartState.prototype.onZoom = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.ZOOM, cb);\r\n\t    };\r\n\t    ChartState.prototype.onResize = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.RESIZE, cb);\r\n\t    };\r\n\t    ChartState.prototype.onPluginsStateChange = function (cb) {\r\n\t        return this.ee.subscribe(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, cb);\r\n\t    };\r\n\t    ChartState.prototype.getTrend = function (trendName) {\r\n\t        return this.trendsManager.getTrend(trendName);\r\n\t    };\r\n\t    ChartState.prototype.setState = function (newState, eventData, silent) {\r\n\t        if (silent === void 0) { silent = false; }\r\n\t        var stateData = this.data;\r\n\t        var newStateObj = newState;\r\n\t        var changedProps = {};\r\n\t        for (var key in newStateObj) {\r\n\t            if (stateData[key] !== newStateObj[key]) {\r\n\t                changedProps[key] = newStateObj[key];\r\n\t            }\r\n\t        }\r\n\t        this.savePrevState(changedProps);\r\n\t        // temporary remove trends data from newState by performance reasons\r\n\t        var trendsData = {};\r\n\t        if (newState.trends)\r\n\t            for (var trendName in newState.trends) {\r\n\t                var trendOptions = newState.trends[trendName];\r\n\t                if (trendOptions.data)\r\n\t                    trendsData[trendName] = trendOptions.data;\r\n\t                delete trendOptions.data;\r\n\t            }\r\n\t        var newStateContainsData = Object.keys(trendsData).length > 0;\r\n\t        this.data = Utils_1.Utils.deepMerge(this.data, newState, false);\r\n\t        // return data to state\r\n\t        if (newStateContainsData)\r\n\t            for (var trendName in trendsData) {\r\n\t                this.data.trends[trendName].data = trendsData[trendName];\r\n\t            }\r\n\t        if (silent)\r\n\t            return;\r\n\t        // recalculate all dynamic state props\r\n\t        var recalculateResult = this.recalculateState(changedProps);\r\n\t        changedProps = recalculateResult.changedProps;\r\n\t        this.emitChangedStateEvents(changedProps, eventData);\r\n\t    };\r\n\t    /**\r\n\t     * recalculate all computed state props\r\n\t     */\r\n\t    ChartState.prototype.recalculateState = function (changedProps) {\r\n\t        var data = this.data;\r\n\t        var patch = {};\r\n\t        var actualData = Utils_1.Utils.deepMerge({}, data);\r\n\t        // recalculate scroll position by changed cursor options\r\n\t        var cursorOptions = changedProps.cursor;\r\n\t        var isMouseDrag = cursorOptions && data.cursor.dragMode && data.prevState.cursor.dragMode;\r\n\t        if (isMouseDrag) {\r\n\t            var oldX = data.prevState.cursor.x;\r\n\t            var currentX = cursorOptions.x;\r\n\t            var currentScroll = data.xAxis.range.scroll;\r\n\t            var deltaXVal = this.pxToValueByXAxis(oldX - currentX);\r\n\t            patch.xAxis = { range: { scroll: currentScroll + deltaXVal } };\r\n\t            actualData = Utils_1.Utils.deepMerge(actualData, { xAxis: patch.xAxis });\r\n\t        }\r\n\t        var chartWasResized = changedProps.width != void 0 || changedProps.height != void 0;\r\n\t        var scrollXChanged = false;\r\n\t        var needToRecalculateXAxis = (isMouseDrag ||\r\n\t            chartWasResized ||\r\n\t            (changedProps.xAxis && (changedProps.xAxis.range)) ||\r\n\t            this.data.xAxis.range.zeroVal == void 0);\r\n\t        if (needToRecalculateXAxis) {\r\n\t            var xAxisPatch = this.recalculateXAxis(actualData, changedProps);\r\n\t            if (xAxisPatch) {\r\n\t                scrollXChanged = true;\r\n\t                patch = Utils_1.Utils.deepMerge(patch, { xAxis: xAxisPatch });\r\n\t                actualData = Utils_1.Utils.deepMerge(actualData, { xAxis: xAxisPatch });\r\n\t            }\r\n\t        }\r\n\t        // recalculate axis \"from\" and \"to\" for dynamics AXIS_RANGE_TYPE\r\n\t        var needToRecalculateYAxis = (chartWasResized ||\r\n\t            (data.yAxis.range.type === interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END ||\r\n\t                data.yAxis.range.type === interfaces_1.AXIS_RANGE_TYPE.AUTO ||\r\n\t                data.yAxis.range.isMirrorMode) &&\r\n\t                (scrollXChanged || changedProps.trends || changedProps.yAxis) ||\r\n\t            this.data.yAxis.range.zeroVal == void 0);\r\n\t        if (needToRecalculateYAxis) {\r\n\t            var yAxisPatch = this.recalculateYAxis(actualData);\r\n\t            if (yAxisPatch) {\r\n\t                patch = Utils_1.Utils.deepMerge(patch, { yAxis: yAxisPatch });\r\n\t                actualData = Utils_1.Utils.deepMerge(actualData, { yAxis: yAxisPatch });\r\n\t            }\r\n\t        }\r\n\t        this.savePrevState(patch);\r\n\t        var allChangedProps = Utils_1.Utils.deepMerge(changedProps, patch);\r\n\t        patch.computedData = this.getComputedData(allChangedProps);\r\n\t        this.savePrevState(patch);\r\n\t        this.data = Utils_1.Utils.deepMerge(this.data, patch);\r\n\t        return { changedProps: allChangedProps, patch: patch };\r\n\t    };\r\n\t    ChartState.prototype.getComputedData = function (changedProps) {\r\n\t        var computeAll = !changedProps;\r\n\t        var computedData = {};\r\n\t        if (computeAll || changedProps.trends && this.trendsManager) {\r\n\t            computedData.trends = {\r\n\t                maxXVal: this.trendsManager.getEndXVal(),\r\n\t                minXVal: this.trendsManager.getStartXVal()\r\n\t            };\r\n\t        }\r\n\t        return computedData;\r\n\t    };\r\n\t    ChartState.prototype.savePrevState = function (changedProps) {\r\n\t        if (!changedProps)\r\n\t            changedProps = this.data;\r\n\t        var prevState = this.data.prevState;\r\n\t        // prevent to store prev trend data by performance reasons\r\n\t        Utils_1.Utils.copyProps(this.data, prevState, changedProps, ['trends']);\r\n\t    };\r\n\t    ChartState.prototype.emitChangedStateEvents = function (changedProps, eventData) {\r\n\t        var prevState = this.data.prevState;\r\n\t        // emit common change event\r\n\t        this.ee.emit(CHART_STATE_EVENTS.CHANGE, changedProps, eventData);\r\n\t        // emit event for each changed state property\r\n\t        for (var key in changedProps) {\r\n\t            this.ee.emit(key + 'Change', changedProps[key], eventData);\r\n\t        }\r\n\t        if (!this.isReady)\r\n\t            return;\r\n\t        // emit special events based on changed state\r\n\t        var scrollStopEventNeeded = (changedProps.cursor &&\r\n\t            changedProps.cursor.dragMode === false &&\r\n\t            prevState.cursor.dragMode === true);\r\n\t        scrollStopEventNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL_STOP, changedProps);\r\n\t        var scrollChangeEventsNeeded = (changedProps.xAxis &&\r\n\t            changedProps.xAxis.range &&\r\n\t            changedProps.xAxis.range.scroll !== void 0);\r\n\t        scrollChangeEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL, changedProps);\r\n\t        var zoomEventsNeeded = ((changedProps.xAxis && changedProps.xAxis.range && changedProps.xAxis.range.zoom) ||\r\n\t            (changedProps.yAxis && changedProps.yAxis.range && changedProps.yAxis.range.zoom));\r\n\t        zoomEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.ZOOM, changedProps);\r\n\t        var resizeEventNeeded = (changedProps.width || changedProps.height);\r\n\t        resizeEventNeeded && this.ee.emit(CHART_STATE_EVENTS.RESIZE, changedProps);\r\n\t        var pluginStateChangedEventNeeded = !!(changedProps.pluginsState);\r\n\t        pluginStateChangedEventNeeded && this.ee.emit(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, changedProps.pluginsState);\r\n\t    };\r\n\t    /**\r\n\t     * init plugins and save plugins options in initialState\r\n\t     */\r\n\t    ChartState.prototype.installPlugins = function (plugins, initialState) {\r\n\t        var _this = this;\r\n\t        initialState.pluginsState = {};\r\n\t        plugins.forEach(function (plugin) {\r\n\t            var PluginClass = plugin.constructor;\r\n\t            var pluginName = PluginClass.NAME;\r\n\t            initialState.pluginsState[pluginName] = Utils_1.Utils.deepMerge({}, plugin.initialState);\r\n\t            _this.plugins[pluginName] = plugin;\r\n\t            plugin.setupChartState(_this);\r\n\t        });\r\n\t        return initialState;\r\n\t    };\r\n\t    /**\r\n\t     * returns plugin instance by plugin name\r\n\t     * @example\r\n\t     */\r\n\t    ChartState.prototype.getPlugin = function (pluginName) {\r\n\t        return this.plugins[pluginName];\r\n\t    };\r\n\t    ChartState.prototype.initListeners = function () {\r\n\t        var _this = this;\r\n\t        this.ee.on(CHART_STATE_EVENTS.TRENDS_CHANGE, function (changedTrends, newData) {\r\n\t            _this.handleTrendsChange(changedTrends, newData);\r\n\t        });\r\n\t    };\r\n\t    ChartState.prototype.handleTrendsChange = function (changedTrends, newData) {\r\n\t        for (var trendName in changedTrends) {\r\n\t            this.ee.emit(CHART_STATE_EVENTS.TREND_CHANGE, trendName, changedTrends[trendName], newData);\r\n\t        }\r\n\t    };\r\n\t    ChartState.prototype.recalculateXAxis = function (actualData, changedProps) {\r\n\t        var axisRange = actualData.xAxis.range;\r\n\t        var patch = { range: {} };\r\n\t        var isInitialize = axisRange.zeroVal == void 0;\r\n\t        var zeroVal, scaleFactor;\r\n\t        var zoom = axisRange.zoom;\r\n\t        if (axisRange.isMirrorMode) {\r\n\t            Utils_1.Utils.error('range.isMirrorMode available only for yAxis.range');\r\n\t        }\r\n\t        if (isInitialize) {\r\n\t            zeroVal = axisRange.from;\r\n\t            scaleFactor = actualData.width / (axisRange.to - axisRange.from);\r\n\t            patch = { range: { zeroVal: zeroVal, scaleFactor: scaleFactor } };\r\n\t        }\r\n\t        else {\r\n\t            zeroVal = axisRange.zeroVal;\r\n\t            scaleFactor = axisRange.scaleFactor;\r\n\t            // recalculate range.zoom and range.scroll then range.from or range.to was changed\r\n\t            if (changedProps.xAxis &&\r\n\t                (changedProps.xAxis.range.from != void 0 || changedProps.xAxis.range.to)) {\r\n\t                if (changedProps.xAxis.range.zoom) {\r\n\t                    Utils_1.Utils.error('Impossible to change \"range.zoom\" then \"range.from\" or \"range.to\" present');\r\n\t                }\r\n\t                var currentScaleFactor = actualData.width / (axisRange.to - axisRange.from);\r\n\t                patch.range.scroll = axisRange.from - zeroVal;\r\n\t                patch.range.zoom = currentScaleFactor / scaleFactor;\r\n\t                return patch;\r\n\t            }\r\n\t        }\r\n\t        // recalculate range.from and range.to then range.zoom or range.scroll was changed\r\n\t        do {\r\n\t            var from = zeroVal + axisRange.scroll;\r\n\t            var to = from + actualData.width / (scaleFactor * zoom);\r\n\t            var rangeLength = to - from;\r\n\t            var needToRecalculateZoom = false;\r\n\t            var rangeMoreThenMaxValue = (axisRange.maxLength && rangeLength > axisRange.maxLength);\r\n\t            var rangeLessThenMinValue = (axisRange.minLength && rangeLength < axisRange.minLength);\r\n\t            needToRecalculateZoom = rangeMoreThenMaxValue || rangeLessThenMinValue;\r\n\t            if (needToRecalculateZoom) {\r\n\t                var fixScale = rangeLength > axisRange.maxLength ?\r\n\t                    rangeLength / axisRange.maxLength :\r\n\t                    rangeLength / axisRange.minLength;\r\n\t                var zoom = zoom * fixScale;\r\n\t                patch.range.zoom = zoom;\r\n\t            }\r\n\t        } while (needToRecalculateZoom);\r\n\t        patch.range.from = from;\r\n\t        patch.range.to = to;\r\n\t        return patch;\r\n\t    };\r\n\t    ChartState.prototype.recalculateYAxis = function (actualData) {\r\n\t        var patch = { range: {} };\r\n\t        var yAxisRange = actualData.yAxis.range;\r\n\t        var isInitialize = yAxisRange.scaleFactor == void 0;\r\n\t        var trends = this.trendsManager;\r\n\t        var trendsEndXVal = trends.getEndXVal();\r\n\t        var trendsStartXVal = trends.getStartXVal();\r\n\t        var xRange = actualData.xAxis.range;\r\n\t        var xFrom = xRange.from, xTo = xRange.to;\r\n\t        var xRangeLength = xTo - xFrom;\r\n\t        var zeroVal, scaleFactor, scroll, zoom, needToZoom;\r\n\t        // check situation when chart was scrolled behind trends end or before trends start\r\n\t        if (xTo > trendsEndXVal) {\r\n\t            xTo = trendsEndXVal;\r\n\t            xFrom = xTo - xRangeLength;\r\n\t        }\r\n\t        else if (xFrom < trendsStartXVal) {\r\n\t            xFrom = trendsStartXVal;\r\n\t            xTo = xFrom + xRangeLength;\r\n\t        }\r\n\t        var maxY = trends.getMaxYVal(xFrom, xTo);\r\n\t        var minY = trends.getMinYVal(xFrom, xTo);\r\n\t        var trendLastY = trends.getMaxYVal(trendsEndXVal, trendsEndXVal);\r\n\t        if (yAxisRange.type == interfaces_1.AXIS_RANGE_TYPE.RELATIVE_END) {\r\n\t            if (trendLastY > maxY)\r\n\t                maxY = trendLastY;\r\n\t            if (trendLastY < minY)\r\n\t                minY = trendLastY;\r\n\t        }\r\n\t        if (yAxisRange.isMirrorMode) {\r\n\t            if (yAxisRange.zeroVal == void 0)\r\n\t                Utils_1.Utils.error('range.zeroVal must be set when range.isMirrorMode');\r\n\t            var distanceFromZeroValForMaxY = Math.abs(yAxisRange.zeroVal - maxY);\r\n\t            var distanceFromZeroValForMinY = Math.abs(yAxisRange.zeroVal - minY);\r\n\t            var maxDistanceFromZeroVal = Math.max(distanceFromZeroValForMaxY, distanceFromZeroValForMinY);\r\n\t            maxY = yAxisRange.zeroVal + maxDistanceFromZeroVal;\r\n\t            minY = yAxisRange.zeroVal - maxDistanceFromZeroVal;\r\n\t        }\r\n\t        var margin = yAxisRange.margin;\r\n\t        var padding = {\r\n\t            start: yAxisRange.padding.start + margin.start,\r\n\t            end: yAxisRange.padding.end + margin.end\r\n\t        };\r\n\t        if (padding.end + padding.start >= actualData.height) {\r\n\t            Utils_1.Utils.warn('Sum of padding and margins of yAxi more then available chart height. Trends can be rendered incorrectly');\r\n\t        }\r\n\t        var rangeLength = maxY - minY;\r\n\t        var paddingTopInPercents = padding.end / actualData.height;\r\n\t        var paddingBottomInPercents = padding.start / actualData.height;\r\n\t        var rangeLengthInPercents = 1 - paddingTopInPercents - paddingBottomInPercents;\r\n\t        var visibleRangeLength = rangeLength / rangeLengthInPercents;\r\n\t        var fromVal = minY - visibleRangeLength * paddingBottomInPercents;\r\n\t        var toVal = maxY + visibleRangeLength * paddingTopInPercents;\r\n\t        if (isInitialize) {\r\n\t            zeroVal = yAxisRange.zeroVal != void 0 ? yAxisRange.zeroVal : fromVal;\r\n\t            scaleFactor = actualData.height / (toVal - fromVal);\r\n\t            patch = { range: { zeroVal: zeroVal, scaleFactor: scaleFactor } };\r\n\t            needToZoom = true;\r\n\t        }\r\n\t        else {\r\n\t            scaleFactor = yAxisRange.scaleFactor;\r\n\t            zeroVal = yAxisRange.zeroVal;\r\n\t            var maxScreenY = Math.round(this.getScreenYByValue(maxY));\r\n\t            var minScreenY = Math.round(this.getScreenYByValue(minY));\r\n\t            needToZoom = (maxScreenY > actualData.height - margin.end ||\r\n\t                maxScreenY < actualData.height - padding.end ||\r\n\t                minScreenY < margin.start ||\r\n\t                minScreenY > padding.start);\r\n\t        }\r\n\t        if (!needToZoom)\r\n\t            return null;\r\n\t        scroll = fromVal - zeroVal;\r\n\t        zoom = (actualData.height / (toVal - fromVal)) / scaleFactor;\r\n\t        var currentAxisRange = this.data.yAxis.range;\r\n\t        if (currentAxisRange.from !== fromVal)\r\n\t            patch.range.from = fromVal;\r\n\t        if (currentAxisRange.to !== toVal)\r\n\t            patch.range.to = toVal;\r\n\t        if (currentAxisRange.scroll !== scroll)\r\n\t            patch.range.scroll = scroll;\r\n\t        if (currentAxisRange.zoom !== zoom)\r\n\t            patch.range.zoom = zoom;\r\n\t        return patch;\r\n\t    };\r\n\t    ChartState.prototype.zoom = function (zoomValue, origin) {\r\n\t        var _this = this;\r\n\t        if (origin === void 0) { origin = 0.5; }\r\n\t        var _a = this.data.xAxis.range, zoom = _a.zoom, scroll = _a.scroll, scaleFactor = _a.scaleFactor;\r\n\t        var newZoom = zoom * zoomValue;\r\n\t        var currentRange = this.data.width / (scaleFactor * zoom);\r\n\t        var nextRange = this.data.width / (scaleFactor * newZoom);\r\n\t        var newScroll = scroll + (currentRange - nextRange) * origin;\r\n\t        this.setState({ xAxis: { range: { zoom: newZoom, scroll: newScroll } } });\r\n\t        return new deps_1.Promise(function (resolve) {\r\n\t            var animationTime = _this.data.animations.enabled ? _this.data.animations.zoomSpeed : 0;\r\n\t            setTimeout(resolve, animationTime * 1000);\r\n\t        });\r\n\t    };\r\n\t    ChartState.prototype.zoomToRange = function (range, origin) {\r\n\t        var _a = this.data.xAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom;\r\n\t        var currentRange = this.data.width / (scaleFactor * zoom);\r\n\t        return this.zoom(currentRange / range, origin);\r\n\t    };\r\n\t    ChartState.prototype.scrollToEnd = function () {\r\n\t        var _this = this;\r\n\t        var state = this.data;\r\n\t        var endXVal = this.trendsManager.getEndXVal();\r\n\t        var range = state.xAxis.range;\r\n\t        var scroll = endXVal - this.pxToValueByXAxis(state.width) + this.pxToValueByXAxis(range.padding.end) - range.zeroVal;\r\n\t        this.setState({ xAxis: { range: { scroll: scroll } } });\r\n\t        return new deps_1.Promise(function (resolve) {\r\n\t            var animationTime = _this.data.animations.enabled ? _this.data.animations.scrollSpeed : 0;\r\n\t            setTimeout(resolve, animationTime * 1000);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal to xVal\r\n\t     */\r\n\t    ChartState.prototype.getPointOnXAxis = function (xVal) {\r\n\t        var _a = this.data.xAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom, zeroVal = _a.zeroVal;\r\n\t        return (xVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from yAxis.range.zeroVal to yVal\r\n\t     */\r\n\t    ChartState.prototype.getPointOnYAxis = function (yVal) {\r\n\t        var _a = this.data.yAxis.range, scaleFactor = _a.scaleFactor, zoom = _a.zoom, zeroVal = _a.zeroVal;\r\n\t        return (yVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     * returns value by offset in pixels from xAxis.range.zeroVal\r\n\t     */\r\n\t    ChartState.prototype.getValueOnXAxis = function (x) {\r\n\t        return this.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from xAxis.range\r\n\t     */\r\n\t    ChartState.prototype.valueToPxByXAxis = function (xVal) {\r\n\t        return xVal * this.data.xAxis.range.scaleFactor * this.data.xAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from yAxis.range\r\n\t     */\r\n\t    ChartState.prototype.valueToPxByYAxis = function (yVal) {\r\n\t        return yVal * this.data.yAxis.range.scaleFactor * this.data.yAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from xAxis.range\r\n\t     */\r\n\t    ChartState.prototype.pxToValueByXAxis = function (xVal) {\r\n\t        return xVal / this.data.xAxis.range.scaleFactor / this.data.xAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from yAxis.range\r\n\t     */\r\n\t    ChartState.prototype.pxToValueByYAxis = function (yVal) {\r\n\t        return yVal / this.data.yAxis.range.scaleFactor / this.data.yAxis.range.zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns x value by screen x coordinate\r\n\t     */\r\n\t    ChartState.prototype.getValueByScreenX = function (x) {\r\n\t        var _a = this.data.xAxis.range, zeroVal = _a.zeroVal, scroll = _a.scroll;\r\n\t        return zeroVal + scroll + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  returns y value by screen y coordinate\r\n\t     */\r\n\t    ChartState.prototype.getValueByScreenY = function (y) {\r\n\t        var _a = this.data.yAxis.range, zeroVal = _a.zeroVal, scroll = _a.scroll;\r\n\t        return zeroVal + scroll + this.pxToValueByYAxis(y);\r\n\t    };\r\n\t    /**\r\n\t     *  returns screen x value by screen y coordinate\r\n\t     */\r\n\t    ChartState.prototype.getScreenXByValue = function (xVal) {\r\n\t        var _a = this.data.xAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByXAxis(xVal - zeroVal - scroll);\r\n\t    };\r\n\t    /**\r\n\t     *  returns screen y value by screen y coordinate\r\n\t     */\r\n\t    ChartState.prototype.getScreenYByValue = function (yVal) {\r\n\t        var _a = this.data.yAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByYAxis(yVal - zeroVal - scroll);\r\n\t    };\r\n\t    /**\r\n\t     * returns screen x coordinate by offset in pixels from xAxis.range.zeroVal value\r\n\t     */\r\n\t    ChartState.prototype.getScreenXByPoint = function (xVal) {\r\n\t        return this.getScreenXByValue(this.getValueOnXAxis(xVal));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from xAxis.range.zeroVal value by screen x coordinate\r\n\t     */\r\n\t    ChartState.prototype.getPointByScreenX = function (screenX) {\r\n\t        return this.getPointOnXAxis(this.getValueByScreenX(screenX));\r\n\t    };\r\n\t    ChartState.prototype.getPointOnChart = function (xVal, yVal) {\r\n\t        return new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\r\n\t    };\r\n\t    ChartState.prototype.getScreenLeftVal = function () {\r\n\t        return this.getValueByScreenX(0);\r\n\t    };\r\n\t    ChartState.prototype.getScreenRightVal = function () {\r\n\t        return this.getValueByScreenX(this.data.width);\r\n\t    };\r\n\t    ChartState.prototype.getPaddingRight = function () {\r\n\t        return this.getValueByScreenX(this.data.width - this.data.xAxis.range.padding.end);\r\n\t    };\r\n\t    return ChartState;\r\n\t}());\r\n\texports.ChartState = ChartState;\r\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar TrendSegmentsManager_1 = __webpack_require__(17);\r\n\tvar EventEmmiter_1 = __webpack_require__(14);\r\n\tvar deps_1 = __webpack_require__(5);\r\n\tvar EVENTS = {\r\n\t    CHANGE: 'Change',\r\n\t    PREPEND_REQUEST: 'prependRequest'\r\n\t};\r\n\t(function (TREND_TYPE) {\r\n\t    TREND_TYPE[TREND_TYPE[\"LINE\"] = 0] = \"LINE\";\r\n\t    TREND_TYPE[TREND_TYPE[\"CANDLE\"] = 1] = \"CANDLE\";\r\n\t})(exports.TREND_TYPE || (exports.TREND_TYPE = {}));\r\n\tvar TREND_TYPE = exports.TREND_TYPE;\r\n\tvar Trend = (function () {\r\n\t    function Trend(chartState, trendName, initialState) {\r\n\t        this.minXVal = Infinity;\r\n\t        this.minYVal = Infinity;\r\n\t        this.maxXVal = -Infinity;\r\n\t        this.maxYVal = -Infinity;\r\n\t        var options = initialState.trends[trendName];\r\n\t        this.name = trendName;\r\n\t        this.chartState = chartState;\r\n\t        this.calculatedOptions = Utils_1.Utils.deepMerge(this.chartState.data.trendDefaultState, options);\r\n\t        this.calculatedOptions.name = trendName;\r\n\t        if (options.dataset)\r\n\t            this.calculatedOptions.data = Trend.prepareData(options.dataset);\r\n\t        this.calculatedOptions.dataset = [];\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    Trend.prototype.onInitialStateApplied = function () {\r\n\t        this.segmentsManager = new TrendSegmentsManager_1.TrendSegmentsManager(this.chartState, this);\r\n\t    };\r\n\t    Trend.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var chartState = this.chartState;\r\n\t        chartState.onInitialStateApplied(function () { return _this.onInitialStateApplied(); });\r\n\t        chartState.onScrollStop(function () { return _this.checkForPrependRequest(); });\r\n\t        chartState.onZoom(function () { return _this.checkForPrependRequest(); });\r\n\t        chartState.onTrendChange(function (trendName, changedOptions, newData) { return _this.ee.emit(EVENTS.CHANGE, changedOptions, newData); });\r\n\t        chartState.onDestroy(function () { return _this.ee.removeAllListeners(); });\r\n\t    };\r\n\t    Trend.prototype.getCalculatedOptions = function () {\r\n\t        return this.calculatedOptions;\r\n\t    };\r\n\t    Trend.prototype.appendData = function (rawData) {\r\n\t        var options = this.getOptions();\r\n\t        var newData = Trend.prepareData(rawData, this.getData());\r\n\t        var updatedTrendData = options.data.concat(newData);\r\n\t        this.changeData(updatedTrendData, newData);\r\n\t    };\r\n\t    Trend.prototype.prependData = function (rawData) {\r\n\t        var options = this.getOptions();\r\n\t        var newData = Trend.prepareData(rawData, this.getData(), true);\r\n\t        var updatedTrendData = newData.concat(options.data);\r\n\t        this.changeData(updatedTrendData, newData);\r\n\t    };\r\n\t    Trend.prototype.changeData = function (allData, newData) {\r\n\t        for (var _i = 0, newData_1 = newData; _i < newData_1.length; _i++) {\r\n\t            var item = newData_1[_i];\r\n\t            if (item.xVal < this.minXVal)\r\n\t                this.minXVal = item.xVal;\r\n\t            if (item.xVal > this.maxXVal)\r\n\t                this.maxXVal = item.xVal;\r\n\t            if (item.yVal < this.minYVal)\r\n\t                this.minYVal = item.yVal;\r\n\t            if (item.yVal > this.maxYVal)\r\n\t                this.maxYVal = item.yVal;\r\n\t        }\r\n\t        var options = this.getOptions();\r\n\t        var statePatch = { trends: (_a = {}, _a[options.name] = { data: allData }, _a) };\r\n\t        this.chartState.setState(statePatch, newData);\r\n\t        var _a;\r\n\t    };\r\n\t    Trend.prototype.getData = function (fromX, toX) {\r\n\t        var data = this.getOptions().data;\r\n\t        if (fromX == void 0 && toX == void 0)\r\n\t            return data;\r\n\t        fromX = fromX !== void 0 ? fromX : data[0].xVal;\r\n\t        toX = toX !== void 0 ? toX : data[data.length].xVal;\r\n\t        var filteredData = [];\r\n\t        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\r\n\t            var item = data_1[_i];\r\n\t            if (item.xVal < fromX)\r\n\t                continue;\r\n\t            if (item.xVal > toX)\r\n\t                break;\r\n\t            filteredData.push(item);\r\n\t        }\r\n\t        return filteredData;\r\n\t    };\r\n\t    Trend.prototype.getFirstItem = function () {\r\n\t        return this.getOptions().data[0];\r\n\t    };\r\n\t    Trend.prototype.getLastItem = function () {\r\n\t        var data = this.getOptions().data;\r\n\t        return data[data.length - 1];\r\n\t    };\r\n\t    Trend.prototype.getOptions = function () {\r\n\t        return this.chartState.data.trends[this.name];\r\n\t    };\r\n\t    Trend.prototype.setOptions = function (options) {\r\n\t        this.chartState.setState({ trends: (_a = {}, _a[this.name] = options, _a) });\r\n\t        var _a;\r\n\t    };\r\n\t    Trend.prototype.onPrependRequest = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on(EVENTS.PREPEND_REQUEST, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(EVENTS.PREPEND_REQUEST, cb);\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * shortcut for ChartState.onTrendChange\r\n\t     */\r\n\t    Trend.prototype.onChange = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on(EVENTS.CHANGE, cb);\r\n\t        return function () { _this.ee.off(EVENTS.CHANGE, cb); };\r\n\t    };\r\n\t    Trend.prototype.onDataChange = function (cb) {\r\n\t        var _this = this;\r\n\t        var onChangeCb = function (changedOptions, newData) {\r\n\t            if (newData)\r\n\t                cb(newData);\r\n\t        };\r\n\t        this.ee.on(EVENTS.CHANGE, onChangeCb);\r\n\t        return function () {\r\n\t            _this.ee.off(EVENTS.CHANGE, onChangeCb);\r\n\t        };\r\n\t    };\r\n\t    Trend.prototype.checkForPrependRequest = function () {\r\n\t        var _this = this;\r\n\t        if (this.prependRequest)\r\n\t            return;\r\n\t        var chartState = this.chartState;\r\n\t        var minXVal = chartState.data.computedData.trends.minXVal;\r\n\t        var minScreenX = chartState.getScreenXByValue(minXVal);\r\n\t        var needToRequest = minScreenX > 0;\r\n\t        var _a = chartState.data.xAxis.range, from = _a.from, to = _a.to;\r\n\t        var requestedDataLength = to - from;\r\n\t        if (!needToRequest)\r\n\t            return;\r\n\t        this.prependRequest = new deps_1.Promise(function (resolve, reject) {\r\n\t            _this.ee.emit(EVENTS.PREPEND_REQUEST, requestedDataLength, resolve, reject);\r\n\t        });\r\n\t        this.prependRequest.then(function (newData) {\r\n\t            _this.prependData(newData);\r\n\t            _this.prependRequest = null;\r\n\t        }, function () {\r\n\t            _this.prependRequest = null;\r\n\t        });\r\n\t    };\r\n\t    Trend.prepareData = function (newData, currentData, isPrepend) {\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var data = [];\r\n\t        if (typeof newData[0] == 'number') {\r\n\t            currentData = currentData || [];\r\n\t            var initialItem = void 0;\r\n\t            var xVal = void 0;\r\n\t            if (isPrepend) {\r\n\t                initialItem = currentData[0];\r\n\t                xVal = initialItem.xVal - newData.length;\r\n\t            }\r\n\t            else {\r\n\t                initialItem = currentData[currentData.length - 1];\r\n\t                xVal = initialItem ? initialItem.xVal + 1 : 0;\r\n\t            }\r\n\t            for (var _i = 0, _a = newData; _i < _a.length; _i++) {\r\n\t                var yVal = _a[_i];\r\n\t                data.push({ xVal: xVal, yVal: yVal, id: Utils_1.Utils.getUid() });\r\n\t                xVal++;\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            data = newData;\r\n\t        }\r\n\t        return data;\r\n\t    };\r\n\t    return Trend;\r\n\t}());\r\n\texports.Trend = Trend;\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar EventEmmiter_1 = __webpack_require__(14);\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Trend_1 = __webpack_require__(16);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar MAX_ANIMATED_SEGMENTS = 100;\r\n\tvar EVENTS = {\r\n\t    REBUILD: 'rebuild',\r\n\t    DISLPAYED_RANGE_CHANGED: 'displayedRangeChanged',\r\n\t    ANIMATION_FRAME: 'animationFrame'\r\n\t};\r\n\t/**\r\n\t *  Class helps to display and animate trends segments\r\n\t */\r\n\tvar TrendSegmentsManager = (function () {\r\n\t    function TrendSegmentsManager(chartState, trend) {\r\n\t        this.segmentsById = {};\r\n\t        this.segments = [];\r\n\t        this.animatedSegmentsIds = [];\r\n\t        this.segmentsLength = 0;\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        this.animatedSegmentsForPrepend = [];\r\n\t        this.nextEmptyId = 0;\r\n\t        this.startSegmentId = 0;\r\n\t        this.endSegmentId = 0;\r\n\t        this.chartState = chartState;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.trend = trend;\r\n\t        this.maxSegmentLength = trend.getOptions().maxSegmentLength;\r\n\t        this.tryToRebuildSegments();\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendSegmentsManager.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.trend.onChange(function (changedOptions, newData) { return _this.onTrendChangeHandler(changedOptions, newData); });\r\n\t        this.chartState.onZoom(function () { return _this.onZoomHandler(); });\r\n\t        this.chartState.onScroll(function () { return _this.recalculateDisplayedRange(); });\r\n\t        this.chartState.onDestroy(function () { return _this.onDestroyHandler(); });\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t        this.appendAnimation && this.appendAnimation.kill();\r\n\t        this.prependAnimation && this.prependAnimation.kill();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onZoomHandler = function () {\r\n\t        var segmentsRebuilded = this.tryToRebuildSegments();\r\n\t        if (!segmentsRebuilded) {\r\n\t            this.recalculateDisplayedRange();\r\n\t        }\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onTrendChangeHandler = function (changedOptions, newData) {\r\n\t        var needToRebuildSegments = (changedOptions.type != void 0 ||\r\n\t            changedOptions.maxSegmentLength != void 0);\r\n\t        if (needToRebuildSegments) {\r\n\t            this.tryToRebuildSegments(true);\r\n\t            return;\r\n\t        }\r\n\t        if (!newData)\r\n\t            return;\r\n\t        var data = this.trend.getData();\r\n\t        var isAppend = (!data.length || data[0].xVal < newData[0].xVal);\r\n\t        isAppend ? this.appendData(newData) : this.prependData(newData);\r\n\t        this.recalculateDisplayedRange();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getSegment = function (id) {\r\n\t        return this.segmentsById[id];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getEndSegment = function () {\r\n\t        return this.segmentsById[this.endSegmentId];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.getStartSegment = function () {\r\n\t        return this.segmentsById[this.startSegmentId];\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.tryToRebuildSegments = function (force) {\r\n\t        if (force === void 0) { force = false; }\r\n\t        var options = this.trend.getOptions();\r\n\t        var trendTypeName = Trend_1.TREND_TYPE[options.type];\r\n\t        var trendTypesSettings = options.settingsForTypes;\r\n\t        var trendTypeSettings = trendTypesSettings[trendTypeName];\r\n\t        var minSegmentLengthInPx = trendTypeSettings.minSegmentLengthInPx, maxSegmentLengthInPx = trendTypeSettings.maxSegmentLengthInPx;\r\n\t        var needToRebuild = this.segments.length === 0 || force;\r\n\t        var segmentLength = this.maxSegmentLength;\r\n\t        // call toFixed(2) to prevent floating segment error compare\r\n\t        var currentSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(segmentLength).toFixed(2));\r\n\t        var currentMaxSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(this.maxSegmentLength).toFixed(2));\r\n\t        if (currentSegmentLengthInPx < minSegmentLengthInPx) {\r\n\t            needToRebuild = true;\r\n\t            segmentLength = Math.ceil(this.chartState.pxToValueByXAxis(maxSegmentLengthInPx));\r\n\t        }\r\n\t        else if (currentMaxSegmentLengthInPx > maxSegmentLengthInPx) {\r\n\t            needToRebuild = true;\r\n\t            segmentLength = this.chartState.pxToValueByXAxis(minSegmentLengthInPx);\r\n\t        }\r\n\t        if (!needToRebuild)\r\n\t            return false;\r\n\t        this.maxSegmentLength = segmentLength;\r\n\t        this.segmentsById = {};\r\n\t        this.segments = [];\r\n\t        this.nextEmptyId = 0;\r\n\t        this.startSegmentId = 0;\r\n\t        this.endSegmentId = 0;\r\n\t        this.segmentsLength = 0;\r\n\t        this.stopAllAnimations();\r\n\t        this.appendData(null, true);\r\n\t        this.recalculateDisplayedRange(true);\r\n\t        this.ee.emit(EVENTS.REBUILD);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.stopAllAnimations = function () {\r\n\t        this.animatedSegmentsIds = [];\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        this.animatedSegmentsForAppend = [];\r\n\t        if (this.prependAnimation)\r\n\t            this.prependAnimation.kill();\r\n\t        if (this.appendAnimation)\r\n\t            this.appendAnimation.kill();\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.recalculateDisplayedRange = function (segmentsAreRebuilded) {\r\n\t        if (segmentsAreRebuilded === void 0) { segmentsAreRebuilded = false; }\r\n\t        var _a = this.chartState.data.xAxis.range, from = _a.from, to = _a.to;\r\n\t        var _b = this, firstDisplayedSegment = _b.firstDisplayedSegment, lastDisplayedSegment = _b.lastDisplayedSegment;\r\n\t        var displayedRange = to - from;\r\n\t        this.firstDisplayedSegmentInd = Utils_1.Utils.binarySearchClosestInd(this.segments, from - displayedRange, 'startXVal');\r\n\t        this.firstDisplayedSegment = this.segments[this.firstDisplayedSegmentInd];\r\n\t        this.lastDisplayedSegmentInd = Utils_1.Utils.binarySearchClosestInd(this.segments, to + displayedRange, 'endXVal');\r\n\t        this.lastDisplayedSegment = this.segments[this.lastDisplayedSegmentInd];\r\n\t        if (segmentsAreRebuilded)\r\n\t            return;\r\n\t        var displayedRangeChanged = (firstDisplayedSegment.id !== this.firstDisplayedSegment.id ||\r\n\t            lastDisplayedSegment.id !== this.lastDisplayedSegment.id);\r\n\t        if (displayedRangeChanged)\r\n\t            this.ee.emit(EVENTS.DISLPAYED_RANGE_CHANGED);\r\n\t    };\r\n\t    // getSegments(fromX?: number, toX?: number): TrendSegment[] {\r\n\t    // \tvar segments = this.segments;\r\n\t    // \tif (fromX == void 0 && toX == void 0) return segments;\r\n\t    // \tfromX = fromX !== void 0 ? fromX : segments[0].startXVal;\r\n\t    // \ttoX = toX !== void 0 ? toX : segments[this.segmentsLength].endXVal;\r\n\t    // \tvar startSegmentInd = Utils.closestBinarySearch(segments, fromX, 'xVal');\r\n\t    // \tvar endSegmentInd = Utils.closestBinarySearch(segments, toX, 'xVal');\r\n\t    // \treturn segments.slice(startSegmentInd, endSegmentInd);\r\n\t    // }\r\n\t    /**\r\n\t     * returns array of segments for values array\r\n\t     * values must be sorted!\r\n\t     */\r\n\t    TrendSegmentsManager.prototype.getSegmentsForXValues = function (values) {\r\n\t        var valueInd = 0;\r\n\t        var value = values[valueInd];\r\n\t        var lastValueInd = values.length - 1;\r\n\t        var results = [];\r\n\t        var segment = this.getStartSegment();\r\n\t        if (!segment.hasValue)\r\n\t            return [];\r\n\t        while (segment) {\r\n\t            while (value < segment.startXVal) {\r\n\t                results.push(void 0);\r\n\t                value = values[++valueInd];\r\n\t            }\r\n\t            while (value > segment.endXVal) {\r\n\t                segment = segment.getNext();\r\n\t                if (!segment)\r\n\t                    break;\r\n\t            }\r\n\t            var valueInPoint = (segment.startXVal == value || segment.endXVal == value ||\r\n\t                (segment.startXVal < value && segment.endXVal > value));\r\n\t            if (valueInPoint) {\r\n\t                results.push(segment);\r\n\t                value = values[++valueInd];\r\n\t            }\r\n\t            if (valueInd > lastValueInd)\r\n\t                break;\r\n\t        }\r\n\t        return results;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onAnimationFrame = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.ANIMATION_FRAME, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onRebuild = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.REBUILD, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onDisplayedRangeChanged = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.DISLPAYED_RANGE_CHANGED, cb);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.allocateNextSegment = function () {\r\n\t        var id = this.nextEmptyId++;\r\n\t        var segment = new TrendSegment(this, id);\r\n\t        var prevSegment = this.segmentsById[this.endSegmentId];\r\n\t        if (prevSegment && prevSegment.hasValue) {\r\n\t            prevSegment.nextId = id;\r\n\t            segment.prevId = prevSegment.id;\r\n\t        }\r\n\t        this.endSegmentId = id;\r\n\t        this.segmentsLength++;\r\n\t        this.segmentsById[id] = segment;\r\n\t        this.segments.push(segment);\r\n\t        return segment;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.allocatePrevSegment = function () {\r\n\t        var id = this.nextEmptyId++;\r\n\t        var segment = new TrendSegment(this, id);\r\n\t        var nextSegment = this.segmentsById[this.startSegmentId];\r\n\t        if (nextSegment && nextSegment.hasValue) {\r\n\t            nextSegment.prevId = id;\r\n\t            segment.nextId = nextSegment.id;\r\n\t        }\r\n\t        this.startSegmentId = id;\r\n\t        this.segmentsLength++;\r\n\t        this.segmentsById[id] = segment;\r\n\t        this.segments.unshift(segment);\r\n\t        return segment;\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.appendData = function (newData, needRebuildSegments) {\r\n\t        // WARNING: bottleneck method!\r\n\t        if (needRebuildSegments === void 0) { needRebuildSegments = false; }\r\n\t        // var t1 = performance.now();\r\n\t        var trendData = this.trend.getData();\r\n\t        if (needRebuildSegments) {\r\n\t            newData = trendData;\r\n\t            this.animatedSegmentsForAppend = [];\r\n\t        }\r\n\t        var startItemInd = trendData.length - newData.length;\r\n\t        var segment = this.getEndSegment() || this.allocateNextSegment();\r\n\t        var initialSegment = segment.hasValue ? segment : null;\r\n\t        var initialAnimationState = segment.createAnimationState();\r\n\t        var itemInd = 0;\r\n\t        while (itemInd < newData.length) {\r\n\t            var item = newData[itemInd];\r\n\t            var itemIsInserted = segment.appendItem(item);\r\n\t            var isLastItem = itemInd == newData.length - 1;\r\n\t            if (itemIsInserted) {\r\n\t                if (!isLastItem)\r\n\t                    itemInd++;\r\n\t            }\r\n\t            else {\r\n\t                if (!segment.isCompleted)\r\n\t                    segment.complete();\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted) {\r\n\t                segment.recalculateItems();\r\n\t            }\r\n\t            var segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\r\n\t            if (segmentIsReadyForAnimate) {\r\n\t                var id = segment.id;\r\n\t                if (!initialSegment)\r\n\t                    initialSegment = segment;\r\n\t                if (!initialAnimationState)\r\n\t                    initialAnimationState = initialSegment.createAnimationState();\r\n\t                segment.initialAnimationState = Utils_1.Utils.deepMerge({}, initialAnimationState);\r\n\t                if (this.animatedSegmentsForAppend.length > 0) {\r\n\t                    segment.initialAnimationState.startXVal = initialAnimationState.endXVal;\r\n\t                    segment.initialAnimationState.startYVal = initialAnimationState.endYVal;\r\n\t                }\r\n\t                segment.targetAnimationState = segment.createAnimationState();\r\n\t                this.animatedSegmentsForAppend.push(id);\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted)\r\n\t                break;\r\n\t            if (!segment.isCompleted)\r\n\t                continue;\r\n\t            segment = this.allocateNextSegment();\r\n\t            var prevItem = trendData[startItemInd + itemInd - 1];\r\n\t            segment.appendItem(prevItem);\r\n\t        }\r\n\t        var animationsOptions = this.chartState.data.animations;\r\n\t        var time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\r\n\t        // var t2 = performance.now();\r\n\t        // console.log(t2 - t1);\r\n\t        // do not create animation if segments was rebuilded\r\n\t        if (needRebuildSegments) {\r\n\t            for (var _i = 0, _a = this.animatedSegmentsForAppend; _i < _a.length; _i++) {\r\n\t                var segmentId = _a[_i];\r\n\t                var segment_1 = this.segmentsById[segmentId];\r\n\t                segment_1.currentAnimationState = segment_1.createAnimationState();\r\n\t            }\r\n\t            this.animatedSegmentsForAppend = [];\r\n\t            return;\r\n\t        }\r\n\t        if (this.animatedSegmentsForAppend.length > MAX_ANIMATED_SEGMENTS)\r\n\t            time = 0;\r\n\t        this.animate(time);\r\n\t    };\r\n\t    // TODO: refactor duplicated code from appendData\r\n\t    TrendSegmentsManager.prototype.prependData = function (newData) {\r\n\t        var trendData = this.trend.getData();\r\n\t        var segment = this.getStartSegment() || this.segmentsById[0];\r\n\t        var initialSegment = segment.hasValue ? segment : null;\r\n\t        var itemInd = newData.length - 1;\r\n\t        var initialAnimationState = segment.createAnimationState();\r\n\t        while (itemInd >= 0) {\r\n\t            var item = newData[itemInd];\r\n\t            var itemIsInserted = segment.prependItem(item);\r\n\t            var isLastItem = itemInd == 0;\r\n\t            if (itemIsInserted) {\r\n\t                if (!isLastItem)\r\n\t                    itemInd--;\r\n\t            }\r\n\t            else {\r\n\t                if (!segment.isCompleted)\r\n\t                    segment.complete();\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted) {\r\n\t                segment.recalculateItems();\r\n\t            }\r\n\t            var segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\r\n\t            if (segmentIsReadyForAnimate) {\r\n\t                var id = segment.id;\r\n\t                if (!initialSegment)\r\n\t                    initialSegment = segment;\r\n\t                if (!initialAnimationState)\r\n\t                    initialAnimationState = initialSegment.createAnimationState();\r\n\t                segment.initialAnimationState = Utils_1.Utils.deepMerge({}, initialAnimationState);\r\n\t                if (this.animatedSegmentsForPrepend.length > 0) {\r\n\t                    segment.initialAnimationState.endXVal = initialAnimationState.startXVal;\r\n\t                    segment.initialAnimationState.endYVal = initialAnimationState.startYVal;\r\n\t                }\r\n\t                segment.targetAnimationState = segment.createAnimationState();\r\n\t                this.animatedSegmentsForPrepend.push(id);\r\n\t            }\r\n\t            if (isLastItem && itemIsInserted)\r\n\t                break;\r\n\t            if (!segment.isCompleted)\r\n\t                continue;\r\n\t            segment = this.allocatePrevSegment();\r\n\t            var nextItem = trendData[itemInd + 1];\r\n\t            segment.prependItem(nextItem);\r\n\t        }\r\n\t        var animationsOptions = this.chartState.data.animations;\r\n\t        var time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\r\n\t        if (this.animatedSegmentsForPrepend.length > MAX_ANIMATED_SEGMENTS)\r\n\t            time = 0;\r\n\t        this.animate(time, true);\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.animate = function (time, isPrepend) {\r\n\t        var _this = this;\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\r\n\t        var animation = isPrepend ? this.prependAnimation : this.appendAnimation;\r\n\t        if ((animation && animation.isActive()) || time == 0) {\r\n\t            if (animation)\r\n\t                animation.kill();\r\n\t            this.onAnimationFrameHandler(1, isPrepend);\r\n\t            animatedSegmentsIds.length = 0;\r\n\t            return;\r\n\t        }\r\n\t        var animationsOptions = this.chartState.data.animations;\r\n\t        var ease = animationsOptions.trendChangeEase;\r\n\t        var objectToAnimate = { animationValue: 0 };\r\n\t        animation = TweenLite.to(objectToAnimate, time, { animationValue: 1, ease: ease });\r\n\t        animation.eventCallback('onUpdate', function () { return _this.onAnimationFrameHandler(objectToAnimate.animationValue, isPrepend); });\r\n\t        animation.eventCallback('onComplete', function () {\r\n\t            animatedSegmentsIds.length = 0;\r\n\t            _this.appendAnimation = null;\r\n\t        });\r\n\t        if (isPrepend) {\r\n\t            this.prependAnimation = animation;\r\n\t        }\r\n\t        else {\r\n\t            this.appendAnimation = animation;\r\n\t        }\r\n\t    };\r\n\t    TrendSegmentsManager.prototype.onAnimationFrameHandler = function (coefficient, isPrepend) {\r\n\t        if (isPrepend === void 0) { isPrepend = false; }\r\n\t        var animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\r\n\t        for (var _i = 0, animatedSegmentsIds_1 = animatedSegmentsIds; _i < animatedSegmentsIds_1.length; _i++) {\r\n\t            var segmentId = animatedSegmentsIds_1[_i];\r\n\t            var segment = this.segmentsById[segmentId];\r\n\t            for (var key in segment.targetAnimationState) {\r\n\t                var targetValue = segment.targetAnimationState[key];\r\n\t                var initialValue = segment.initialAnimationState[key];\r\n\t                var currentValue = initialValue + (targetValue - initialValue) * coefficient;\r\n\t                segment.currentAnimationState[key] = currentValue;\r\n\t            }\r\n\t        }\r\n\t        this.animatedSegmentsIds = this.animatedSegmentsForAppend.concat(this.animatedSegmentsForPrepend);\r\n\t        this.ee.emit(EVENTS.ANIMATION_FRAME, this);\r\n\t    };\r\n\t    return TrendSegmentsManager;\r\n\t}());\r\n\texports.TrendSegmentsManager = TrendSegmentsManager;\r\n\tvar TrendSegment = (function () {\r\n\t    function TrendSegment(trendPoints, id) {\r\n\t        this.isCompleted = false;\r\n\t        this.items = [];\r\n\t        this.initialAnimationState = {};\r\n\t        this.targetAnimationState = {};\r\n\t        this.currentAnimationState = {};\r\n\t        this.trendSegments = trendPoints;\r\n\t        this.id = id;\r\n\t        this.maxLength = trendPoints.maxSegmentLength;\r\n\t    }\r\n\t    TrendSegment.prototype.createAnimationState = function () {\r\n\t        var _a = this, xVal = _a.xVal, yVal = _a.yVal, startXVal = _a.startXVal, startYVal = _a.startYVal, endXVal = _a.endXVal, endYVal = _a.endYVal, maxYVal = _a.maxYVal, minYVal = _a.minYVal, maxLength = _a.maxLength;\r\n\t        return {\r\n\t            xVal: xVal,\r\n\t            yVal: yVal,\r\n\t            startXVal: startXVal,\r\n\t            startYVal: startYVal,\r\n\t            endXVal: endXVal,\r\n\t            endYVal: endYVal,\r\n\t            maxYVal: maxYVal,\r\n\t            minYVal: minYVal,\r\n\t            maxLength: maxLength\r\n\t        };\r\n\t    };\r\n\t    ;\r\n\t    TrendSegment.prototype.appendItem = function (item) {\r\n\t        if (this.isCompleted)\r\n\t            return false;\r\n\t        var items = this.items;\r\n\t        if (items.length < 2) {\r\n\t            this.items.push(item);\r\n\t            this.hasValue = true;\r\n\t            return true;\r\n\t        }\r\n\t        var startXVal = items[0].xVal;\r\n\t        if (item.xVal - startXVal > this.maxLength)\r\n\t            return false;\r\n\t        items.push(item);\r\n\t        return true;\r\n\t    };\r\n\t    TrendSegment.prototype.prependItem = function (item) {\r\n\t        if (this.isCompleted)\r\n\t            return false;\r\n\t        var items = this.items;\r\n\t        if (items.length < 2) {\r\n\t            this.items.unshift(item);\r\n\t            this.hasValue = true;\r\n\t            return true;\r\n\t        }\r\n\t        var endXVal = items[items.length - 1].xVal;\r\n\t        if (endXVal - item.xVal > this.maxLength)\r\n\t            return false;\r\n\t        items.unshift(item);\r\n\t        return true;\r\n\t    };\r\n\t    TrendSegment.prototype.complete = function () {\r\n\t        this.isCompleted = true;\r\n\t        this.recalculateItems();\r\n\t        this.items = []; // free memory for completed ranges\r\n\t    };\r\n\t    TrendSegment.prototype.recalculateItems = function () {\r\n\t        var items = this.items;\r\n\t        var itemsLength = items.length;\r\n\t        if (itemsLength === 0)\r\n\t            Utils_1.Utils.error('Unable to create TrendSegment without TrendItems');\r\n\t        var endItem = items[itemsLength - 1];\r\n\t        var endXVal = endItem.xVal, endYVal = endItem.yVal;\r\n\t        var startXVal, startYVal;\r\n\t        var startItem = items[0];\r\n\t        startXVal = startItem.xVal;\r\n\t        startYVal = startItem.yVal;\r\n\t        var minX = Math.min(startXVal, endXVal);\r\n\t        var maxX = Math.max(startXVal, endXVal);\r\n\t        var middleXVal = minX + (maxX - minX) / 2;\r\n\t        var minY = Math.min(startYVal, endYVal);\r\n\t        var maxY = Math.max(startYVal, endYVal);\r\n\t        var middleYVal = minY + (maxY - minY) / 2;\r\n\t        var yVals = items.map(function (item) { return item.yVal; });\r\n\t        this.startXVal = startXVal;\r\n\t        this.startYVal = startYVal;\r\n\t        this.endXVal = endXVal;\r\n\t        this.endYVal = endYVal;\r\n\t        this.xVal = middleXVal;\r\n\t        this.yVal = middleYVal;\r\n\t        this.maxYVal = Math.max.apply(Math, yVals);\r\n\t        this.minYVal = Math.min.apply(Math, yVals);\r\n\t        if (!this.currentAnimationState)\r\n\t            this.currentAnimationState = this.createAnimationState();\r\n\t    };\r\n\t    TrendSegment.prototype.getNext = function () {\r\n\t        var nextPoint = this.trendSegments.segmentsById[this.nextId];\r\n\t        return nextPoint && nextPoint.hasValue ? nextPoint : null;\r\n\t    };\r\n\t    TrendSegment.prototype.getPrev = function () {\r\n\t        var prevPoint = this.trendSegments.segmentsById[this.prevId];\r\n\t        return prevPoint && prevPoint.hasValue ? prevPoint : null;\r\n\t    };\r\n\t    TrendSegment.prototype.getFrameVal = function () {\r\n\t        var _a = this.createAnimationState(), xVal = _a.xVal, yVal = _a.yVal;\r\n\t        return new Vector3(xVal, yVal, 0);\r\n\t    };\r\n\t    TrendSegment.prototype.getFramePoint = function () {\r\n\t        var frameVal = this.getFrameVal();\r\n\t        return this.trendSegments.chartState.screen.getPointOnChart(frameVal.x, frameVal.y);\r\n\t    };\r\n\t    return TrendSegment;\r\n\t}());\r\n\texports.TrendSegment = TrendSegment;\r\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Trend_1 = __webpack_require__(16);\r\n\tvar EventEmmiter_1 = __webpack_require__(14);\r\n\tvar EVENTS = {\r\n\t    SEGMENTS_REBUILDED: 'segmentsRebuilded'\r\n\t};\r\n\t/**\r\n\t * Trends manager\r\n\t */\r\n\tvar TrendsManager = (function () {\r\n\t    function TrendsManager(state, initialState) {\r\n\t        this.trends = {};\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.chartState = state;\r\n\t        var trendsCalculatedOptions = {};\r\n\t        for (var trendName in initialState.trends) {\r\n\t            var trend = this.createTrend(state, trendName, initialState);\r\n\t            trendsCalculatedOptions[trendName] = trend.getCalculatedOptions();\r\n\t        }\r\n\t        this.calculatedOptions = trendsCalculatedOptions;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendsManager.prototype.getTrend = function (trendName) {\r\n\t        return this.trends[trendName];\r\n\t    };\r\n\t    TrendsManager.prototype.getEnabledTrends = function () {\r\n\t        var enabledTrends = [];\r\n\t        var allTrends = this.trends;\r\n\t        for (var trendName in allTrends) {\r\n\t            var trend = allTrends[trendName];\r\n\t            trend.getOptions().enabled && enabledTrends.push(trend);\r\n\t        }\r\n\t        return enabledTrends;\r\n\t    };\r\n\t    TrendsManager.prototype.getStartXVal = function () {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        return trends[0].getData()[0].xVal;\r\n\t    };\r\n\t    TrendsManager.prototype.getEndXVal = function () {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        var firstTrendData = trends[0].getData();\r\n\t        return firstTrendData[firstTrendData.length - 1].xVal;\r\n\t    };\r\n\t    TrendsManager.prototype.getExtremumYVal = function (extremumIsMax, fromX, toX) {\r\n\t        var trends = this.getEnabledTrends();\r\n\t        var compareFn;\r\n\t        var result;\r\n\t        if (extremumIsMax) {\r\n\t            result = -Infinity;\r\n\t            compareFn = Math.max;\r\n\t        }\r\n\t        else {\r\n\t            result = Infinity;\r\n\t            compareFn = Math.min;\r\n\t        }\r\n\t        for (var _i = 0, trends_1 = trends; _i < trends_1.length; _i++) {\r\n\t            var trend = trends_1[_i];\r\n\t            var trendData = trend.getData(fromX, toX);\r\n\t            var trendYValues = trendData.map(function (dataItem) { return dataItem.yVal; });\r\n\t            result = compareFn.apply(void 0, [result].concat(trendYValues));\r\n\t        }\r\n\t        if (result == Infinity || result == -Infinity)\r\n\t            result = NaN;\r\n\t        return result;\r\n\t    };\r\n\t    TrendsManager.prototype.getMaxYVal = function (fromX, toX) { return this.getExtremumYVal(true, fromX, toX); };\r\n\t    TrendsManager.prototype.getMinYVal = function (fromX, toX) { return this.getExtremumYVal(false, fromX, toX); };\r\n\t    TrendsManager.prototype.onSegmentsRebuilded = function (cb) {\r\n\t        return this.ee.subscribe(EVENTS.SEGMENTS_REBUILDED, cb);\r\n\t    };\r\n\t    TrendsManager.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chartState.onInitialStateApplied(function () { return _this.onInitialStateAppliedHandler(); });\r\n\t    };\r\n\t    TrendsManager.prototype.onInitialStateAppliedHandler = function () {\r\n\t        var _this = this;\r\n\t        var _loop_1 = function(trendName) {\r\n\t            this_1.trends[trendName].segmentsManager.onRebuild(function () { return _this.ee.emit(EVENTS.SEGMENTS_REBUILDED, trendName); });\r\n\t        };\r\n\t        var this_1 = this;\r\n\t        for (var trendName in this.trends) {\r\n\t            _loop_1(trendName);\r\n\t        }\r\n\t    };\r\n\t    TrendsManager.prototype.createTrend = function (state, trendName, initialState) {\r\n\t        var trend = new Trend_1.Trend(state, trendName, initialState);\r\n\t        this.trends[trendName] = trend;\r\n\t        return trend;\r\n\t    };\r\n\t    return TrendsManager;\r\n\t}());\r\n\texports.TrendsManager = TrendsManager;\r\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar EventEmmiter_1 = __webpack_require__(14);\r\n\t/**\r\n\t * manage camera, and contains methods for transforming pixels to values\r\n\t */\r\n\tvar Screen = (function () {\r\n\t    function Screen(chartState) {\r\n\t        this.options = { scrollXVal: 0, scrollX: 0, scrollYVal: 0, scrollY: 0, zoomX: 1, zoomY: 1 };\r\n\t        this.currentScrollX = { x: 0 };\r\n\t        this.currentScrollY = { y: 0 };\r\n\t        this.currentZoomX = { val: 1 };\r\n\t        this.currentZoomY = { val: 1 };\r\n\t        this.chartState = chartState;\r\n\t        var _a = chartState.data, w = _a.width, h = _a.height;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.transform({\r\n\t            scrollY: this.valueToPxByYAxis(this.chartState.data.yAxis.range.scroll),\r\n\t            zoomY: 1\r\n\t        });\r\n\t        this.bindEvents();\r\n\t        //camera.position.z = 1500;\r\n\t    }\r\n\t    Screen.prototype.getCameraSettings = function () {\r\n\t        var _a = this.chartState.data, w = _a.width, h = _a.height;\r\n\t        // settings for pixel-perfect camera\r\n\t        var FOV = 75;\r\n\t        var vFOV = FOV * (Math.PI / 180);\r\n\t        return {\r\n\t            FOV: FOV,\r\n\t            aspect: w / h,\r\n\t            near: 0.1,\r\n\t            far: 5000,\r\n\t            z: h / (2 * Math.tan(vFOV / 2)),\r\n\t            // move 0,0 to left-bottom corner\r\n\t            x: w / 2,\r\n\t            y: h / 2\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.onZoomFrame = function (cb) {\r\n\t        var _this = this;\r\n\t        var eventName = 'zoomFrame';\r\n\t        this.ee.on(eventName, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(eventName, cb);\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.onScrollFrame = function (cb) {\r\n\t        var _this = this;\r\n\t        var eventName = 'scrollFrame';\r\n\t        this.ee.on(eventName, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(eventName, cb);\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.onTransformationFrame = function (cb) {\r\n\t        var _this = this;\r\n\t        var eventName = 'transformationFrame';\r\n\t        this.ee.on(eventName, cb);\r\n\t        return function () {\r\n\t            _this.ee.off(eventName, cb);\r\n\t        };\r\n\t    };\r\n\t    Screen.prototype.cameraIsMoving = function () {\r\n\t        return !!(this.scrollXAnimation && this.scrollXAnimation.isActive() ||\r\n\t            this.zoomXAnimation && this.zoomXAnimation.isActive());\r\n\t    };\r\n\t    Screen.prototype.transform = function (options, silent) {\r\n\t        if (silent === void 0) { silent = false; }\r\n\t        var scrollX = options.scrollX, scrollY = options.scrollY, zoomX = options.zoomX, zoomY = options.zoomY;\r\n\t        if (scrollX != void 0)\r\n\t            this.options.scrollX = scrollX;\r\n\t        if (scrollY != void 0)\r\n\t            this.options.scrollY = scrollY;\r\n\t        if (zoomX != void 0)\r\n\t            this.options.zoomX = zoomX;\r\n\t        if (zoomY != void 0)\r\n\t            this.options.zoomY = zoomY;\r\n\t        if (scrollX != void 0 || zoomX) {\r\n\t            options.scrollXVal = this.pxToValueByXAxis(scrollX != void 0 ? scrollX : this.options.scrollX);\r\n\t            this.options.scrollXVal = options.scrollXVal;\r\n\t        }\r\n\t        if (scrollY != void 0 || zoomY) {\r\n\t            options.scrollYVal = this.pxToValueByYAxis(scrollY != void 0 ? scrollY : this.options.scrollY);\r\n\t            this.options.scrollYVal = options.scrollYVal;\r\n\t        }\r\n\t        if (silent)\r\n\t            return;\r\n\t        this.ee.emit('transformationFrame', options);\r\n\t        if (options.scrollXVal != void 0 || options.scrollYVal != void 0) {\r\n\t            this.ee.emit('scrollFrame', options);\r\n\t        }\r\n\t        if (options.zoomX != void 0 || options.zoomY != void 0) {\r\n\t            this.ee.emit('zoomFrame', options);\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        // handle scroll and zoom\r\n\t        state.onChange(function (changedProps) {\r\n\t            if (changedProps.xAxis && changedProps.xAxis.range) {\r\n\t                if (changedProps.xAxis.range.scroll != void 0)\r\n\t                    _this.onScrollXHandler(changedProps);\r\n\t                if (changedProps.xAxis.range.zoom)\r\n\t                    _this.onZoomXHandler();\r\n\t            }\r\n\t            if (changedProps.yAxis && changedProps.yAxis.range) {\r\n\t                if (changedProps.yAxis.range.scroll != void 0)\r\n\t                    _this.onScrollYHandler();\r\n\t                if (changedProps.yAxis.range.zoom)\r\n\t                    _this.onZoomYHandler();\r\n\t            }\r\n\t        });\r\n\t        state.onDestroy(function () { return _this.onDestroyHandler(); });\r\n\t    };\r\n\t    Screen.prototype.onDestroyHandler = function () {\r\n\t        this.ee.removeAllListeners();\r\n\t        this.scrollXAnimation && this.scrollXAnimation.kill();\r\n\t        this.scrollYAnimation && this.scrollYAnimation.kill();\r\n\t        this.zoomXAnimation && this.zoomXAnimation.kill();\r\n\t        this.zoomYAnimation && this.zoomYAnimation.kill();\r\n\t    };\r\n\t    Screen.prototype.onScrollXHandler = function (changedProps) {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var isDragMode = state.data.cursor.dragMode;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled && !isDragMode;\r\n\t        var zoomXChanged = changedProps.xAxis.range.zoom;\r\n\t        var isAutoscroll = state.data.autoScroll && !isDragMode && !zoomXChanged;\r\n\t        var time = isAutoscroll ? animations.autoScrollSpeed : animations.zoomSpeed;\r\n\t        var ease = isAutoscroll ? animations.autoScrollEase : animations.zoomEase;\r\n\t        if (this.scrollXAnimation)\r\n\t            this.scrollXAnimation.pause();\r\n\t        var range = state.data.xAxis.range;\r\n\t        var targetX = range.scroll * range.scaleFactor * range.zoom;\r\n\t        this.currentScrollX.x = this.options.scrollX;\r\n\t        var cb = function () {\r\n\t            _this.transform({ scrollX: _this.currentScrollX.x });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.scrollXAnimation = TweenLite.to(this.currentScrollX, time, {\r\n\t                x: targetX, ease: ease\r\n\t            });\r\n\t            this.scrollXAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentScrollX.x = targetX;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.onScrollYHandler = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled;\r\n\t        var time = animations.zoomSpeed;\r\n\t        if (this.scrollYAnimation)\r\n\t            this.scrollYAnimation.pause();\r\n\t        var range = state.data.yAxis.range;\r\n\t        var targetY = range.scroll * range.scaleFactor * range.zoom;\r\n\t        this.currentScrollY.y = this.options.scrollY;\r\n\t        var cb = function () {\r\n\t            _this.transform({ scrollY: _this.currentScrollY.y });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.scrollYAnimation = TweenLite.to(this.currentScrollY, time, {\r\n\t                y: targetY, ease: animations.zoomEase\r\n\t            });\r\n\t            this.scrollYAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentScrollY.y = targetY;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.onZoomXHandler = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled;\r\n\t        var time = animations.zoomSpeed;\r\n\t        var targetZoom = state.data.xAxis.range.zoom;\r\n\t        if (this.zoomXAnimation)\r\n\t            this.zoomXAnimation.pause();\r\n\t        var cb = function () {\r\n\t            _this.transform({ zoomX: _this.currentZoomX.val });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.zoomXAnimation = TweenLite.to(this.currentZoomX, time, {\r\n\t                val: targetZoom, ease: animations.zoomEase\r\n\t            });\r\n\t            this.zoomXAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentZoomX.val = targetZoom;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    Screen.prototype.onZoomYHandler = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        var animations = state.data.animations;\r\n\t        var canAnimate = animations.enabled;\r\n\t        var time = animations.zoomSpeed;\r\n\t        var targetZoom = state.data.yAxis.range.zoom;\r\n\t        if (this.zoomYAnimation)\r\n\t            this.zoomYAnimation.pause();\r\n\t        var cb = function () {\r\n\t            _this.transform({ zoomY: _this.currentZoomY.val });\r\n\t        };\r\n\t        if (canAnimate) {\r\n\t            this.zoomYAnimation = TweenLite.to(this.currentZoomY, time, {\r\n\t                val: targetZoom, ease: animations.zoomEase\r\n\t            });\r\n\t            this.zoomYAnimation.eventCallback('onUpdate', cb);\r\n\t        }\r\n\t        else {\r\n\t            this.currentZoomY.val = targetZoom;\r\n\t            cb();\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal to scrollXVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnXAxis = function (xVal) {\r\n\t        var _a = this.chartState.data.xAxis.range, scaleFactor = _a.scaleFactor, zeroVal = _a.zeroVal;\r\n\t        var zoom = this.options.zoomX;\r\n\t        return (xVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from yAxis.range.zeroVal to scrollYVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnYAxis = function (yVal) {\r\n\t        var _a = this.chartState.data.yAxis.range, scaleFactor = _a.scaleFactor, zeroVal = _a.zeroVal;\r\n\t        var zoom = this.options.zoomY;\r\n\t        return (yVal - zeroVal) * scaleFactor * zoom;\r\n\t    };\r\n\t    /**\r\n\t     *  returns offset in pixels from xAxis.range.zeroVal and from yAxis.range.zeroVal to scrollXVal and scrollYVal\r\n\t     */\r\n\t    Screen.prototype.getPointOnChart = function (xVal, yVal) {\r\n\t        return new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\r\n\t    };\r\n\t    /**\r\n\t     * returns value by offset in pixels from xAxis.range.zeroVal\r\n\t     */\r\n\t    Screen.prototype.getValueOnXAxis = function (x) {\r\n\t        return this.chartState.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from xAxis.range\r\n\t     */\r\n\t    Screen.prototype.valueToPxByXAxis = function (xVal) {\r\n\t        return xVal * this.chartState.data.xAxis.range.scaleFactor * this.options.zoomX;\r\n\t    };\r\n\t    /**\r\n\t     *  convert value to pixels by using settings from yAxis.range\r\n\t     */\r\n\t    Screen.prototype.valueToPxByYAxis = function (yVal) {\r\n\t        return yVal * this.chartState.data.yAxis.range.scaleFactor * this.options.zoomY;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from xAxis.range\r\n\t     */\r\n\t    Screen.prototype.pxToValueByXAxis = function (xVal) {\r\n\t        return xVal / this.chartState.data.xAxis.range.scaleFactor / this.options.zoomX;\r\n\t    };\r\n\t    /**\r\n\t     *  convert pixels to value by using settings from yAxis.range\r\n\t     */\r\n\t    Screen.prototype.pxToValueByYAxis = function (yVal) {\r\n\t        return yVal / this.chartState.data.yAxis.range.scaleFactor / this.options.zoomY;\r\n\t    };\r\n\t    /**\r\n\t     *  returns scrollX value by screen scrollX coordinate\r\n\t     */\r\n\t    Screen.prototype.getValueByScreenX = function (x) {\r\n\t        return this.chartState.data.xAxis.range.zeroVal + this.options.scrollXVal + this.pxToValueByXAxis(x);\r\n\t    };\r\n\t    /**\r\n\t     *  returns scrollY value by screen scrollY coordinate\r\n\t     */\r\n\t    Screen.prototype.getValueByScreenY = function (y) {\r\n\t        return this.chartState.data.yAxis.range.zeroVal + this.options.scrollYVal + this.pxToValueByYAxis(y);\r\n\t    };\r\n\t    //\r\n\t    /**\r\n\t     *  returns screen scrollX value by screen scrollY coordinate\r\n\t     */\r\n\t    Screen.prototype.getScreenXByValue = function (xVal) {\r\n\t        var _a = this.chartState.data.xAxis.range, scroll = _a.scroll, zeroVal = _a.zeroVal;\r\n\t        return this.valueToPxByXAxis(xVal - zeroVal - scroll);\r\n\t    };\r\n\t    // /**\r\n\t    //  *  returns screen scrollY value by screen scrollY coordinate\r\n\t    //  */\r\n\t    // getScreenYByValue(scrollYVal: number): number {\r\n\t    // \tvar {scroll, zeroVal} = this.data.yAxis.range;\r\n\t    // \treturn this.valueToPxByYAxis(scrollYVal - zeroVal - scroll)\r\n\t    // }\r\n\t    //\r\n\t    //\r\n\t    /**\r\n\t     * returns screen scrollX coordinate by offset in pixels from xAxis.range.zeroVal value\r\n\t     */\r\n\t    Screen.prototype.getScreenXByPoint = function (xVal) {\r\n\t        return this.getScreenXByValue(this.getValueOnXAxis(xVal));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from xAxis.range.zeroVal value by screen scrollX coordinate\r\n\t     */\r\n\t    Screen.prototype.getPointByScreenX = function (screenX) {\r\n\t        return this.getPointOnXAxis(this.getValueByScreenX(screenX));\r\n\t    };\r\n\t    /**\r\n\t     * returns offset in pixels from yAxis.range.zeroVal value by screen scrollY coordinate\r\n\t     */\r\n\t    Screen.prototype.getPointByScreenY = function (screenY) {\r\n\t        return this.getPointOnYAxis(this.getValueByScreenY(screenY));\r\n\t    };\r\n\t    Screen.prototype.getTop = function () {\r\n\t        return this.getPointByScreenY(this.chartState.data.height);\r\n\t    };\r\n\t    Screen.prototype.getBottom = function () {\r\n\t        return this.getPointByScreenY(0);\r\n\t    };\r\n\t    Screen.prototype.getLeft = function () {\r\n\t        return this.getPointByScreenX(0);\r\n\t    };\r\n\t    Screen.prototype.getScreenRightVal = function () {\r\n\t        return this.getValueByScreenX(this.chartState.data.width);\r\n\t    };\r\n\t    Screen.prototype.getTopVal = function () {\r\n\t        return this.getValueByScreenY(this.chartState.data.height);\r\n\t    };\r\n\t    Screen.prototype.getBottomVal = function () {\r\n\t        return this.getValueByScreenY(0);\r\n\t    };\r\n\t    Screen.prototype.getCenterYVal = function () {\r\n\t        return this.getValueByScreenY(this.chartState.data.height / 2);\r\n\t    };\r\n\t    return Screen;\r\n\t}());\r\n\texports.Screen = Screen;\r\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar interfaces_1 = __webpack_require__(21);\r\n\tvar EventEmmiter_1 = __webpack_require__(14);\r\n\tvar AXIS_MARK_DEFAULT_OPTIONS = {\r\n\t    type: 'simple',\r\n\t    lineWidth: 1,\r\n\t    value: 0,\r\n\t    showValue: false,\r\n\t    stickToEdges: false,\r\n\t    lineColor: '#FFFFFF',\r\n\t    title: ''\r\n\t};\r\n\tvar AxisMarks = (function () {\r\n\t    function AxisMarks(chartState, axisType) {\r\n\t        this.items = {};\r\n\t        this.chartState = chartState;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.axisType = axisType;\r\n\t        var marks = this.items;\r\n\t        var axisMarksOptions = axisType == interfaces_1.AXIS_TYPE.X ? chartState.data.xAxis.marks : chartState.data.yAxis.marks;\r\n\t        for (var _i = 0, axisMarksOptions_1 = axisMarksOptions; _i < axisMarksOptions_1.length; _i++) {\r\n\t            var options = axisMarksOptions_1[_i];\r\n\t            var axisMark = void 0;\r\n\t            options = Utils_1.Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\r\n\t            // set mark name\r\n\t            if (!options.name)\r\n\t                options.name = Utils_1.Utils.getUid().toString();\r\n\t            if (marks[options.name])\r\n\t                Utils_1.Utils.error('duplicated mark name ' + options.name);\r\n\t            // create mark instance based on type option\r\n\t            if (options.type == 'timeleft') {\r\n\t                axisMark = new AxisTimeleftMark(chartState, axisType, options);\r\n\t            }\r\n\t            else {\r\n\t                axisMark = new AxisMark(chartState, axisType, options);\r\n\t            }\r\n\t            marks[options.name] = axisMark;\r\n\t        }\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    AxisMarks.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chartState.onTrendChange(function (trendName, changedOptions, newData) {\r\n\t            _this.onTrendChange(trendName, newData);\r\n\t        });\r\n\t        this.chartState.onDestroy(function () { return _this.ee.removeAllListeners(); });\r\n\t    };\r\n\t    AxisMarks.prototype.onTrendChange = function (trendName, newData) {\r\n\t        if (!newData)\r\n\t            return;\r\n\t        var startVal = newData[0].xVal;\r\n\t        var endVal = newData[newData.length - 1].xVal;\r\n\t        var marks = this.items;\r\n\t        for (var markName in marks) {\r\n\t            var mark = marks[markName];\r\n\t            var markVal = mark.options.value;\r\n\t            var markWasCrossed = (startVal == markVal || endVal == markVal || (startVal < markVal && endVal > markVal));\r\n\t            if (markWasCrossed)\r\n\t                this.ee.emit('markCrossed', trendName, newData);\r\n\t        }\r\n\t    };\r\n\t    AxisMarks.prototype.getItems = function () {\r\n\t        return this.items;\r\n\t    };\r\n\t    AxisMarks.prototype.getItem = function (markName) {\r\n\t        return this.items[markName];\r\n\t    };\r\n\t    return AxisMarks;\r\n\t}());\r\n\texports.AxisMarks = AxisMarks;\r\n\tvar AxisMark = (function () {\r\n\t    function AxisMark(chartState, axisType, options) {\r\n\t        this.renderOnTrendsChange = false;\r\n\t        this.ee = new EventEmmiter_1.EventEmitter();\r\n\t        this.options = options;\r\n\t        this.axisType = axisType;\r\n\t        this.chartState = chartState;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    AxisMark.prototype.bindEvents = function () { };\r\n\t    AxisMark.prototype.setOptions = function (newOptions) {\r\n\t        var value = this.options.value;\r\n\t        this.options = Utils_1.Utils.deepMerge(this.options, newOptions);\r\n\t        if (this.options.value !== value)\r\n\t            this.ee.emit('valueChange');\r\n\t        this.ee.emit('onDisplayedValueChange');\r\n\t    };\r\n\t    AxisMark.prototype.getDisplayedVal = function () {\r\n\t        var _a = this.options, value = _a.value, displayedValue = _a.displayedValue;\r\n\t        return String(displayedValue !== void 0 ? displayedValue : value);\r\n\t    };\r\n\t    AxisMark.prototype.onMarkCrossed = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on('markCrossed', cb);\r\n\t        return function () {\r\n\t            _this.ee.off('markCrossed', cb);\r\n\t        };\r\n\t    };\r\n\t    AxisMark.prototype.onValueChange = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on('valueChange', cb);\r\n\t        return function () {\r\n\t            _this.ee.off('valueChange', cb);\r\n\t        };\r\n\t    };\r\n\t    AxisMark.prototype.onDisplayedValueChange = function (cb) {\r\n\t        var _this = this;\r\n\t        this.ee.on('onDisplayedValueChange', cb);\r\n\t        return function () {\r\n\t            _this.ee.off('onDisplayedValueChange', cb);\r\n\t        };\r\n\t    };\r\n\t    AxisMark.typeName = 'simple';\r\n\t    return AxisMark;\r\n\t}());\r\n\texports.AxisMark = AxisMark;\r\n\tvar AxisTimeleftMark = (function (_super) {\r\n\t    __extends(AxisTimeleftMark, _super);\r\n\t    function AxisTimeleftMark() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.renderOnTrendsChange = true;\r\n\t    }\r\n\t    AxisTimeleftMark.prototype.getDisplayedVal = function () {\r\n\t        var markVal = this.options.value;\r\n\t        var maxXVal = this.chartState.data.computedData.trends.maxXVal;\r\n\t        var time = markVal - maxXVal;\r\n\t        if (time < 0)\r\n\t            time = 0;\r\n\t        return Utils_1.Utils.msToTimeString(time);\r\n\t    };\r\n\t    AxisTimeleftMark.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.chartState.onTrendsChange(function () { return _this.onTrendsChange(); });\r\n\t    };\r\n\t    AxisTimeleftMark.prototype.onTrendsChange = function () {\r\n\t        this.ee.emit('onDisplayedValueChange');\r\n\t    };\r\n\t    AxisTimeleftMark.typeName = 'timeleft';\r\n\t    return AxisTimeleftMark;\r\n\t}(AxisMark));\r\n\texports.AxisTimeleftMark = AxisTimeleftMark;\r\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t(function (AXIS_RANGE_TYPE) {\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"FIXED\"] = 0] = \"FIXED\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"RELATIVE_END\"] = 1] = \"RELATIVE_END\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"AUTO\"] = 2] = \"AUTO\";\r\n\t    AXIS_RANGE_TYPE[AXIS_RANGE_TYPE[\"ALL\"] = 3] = \"ALL\"; // TODO: AXIS_RANGE_TYPE.ALL\r\n\t})(exports.AXIS_RANGE_TYPE || (exports.AXIS_RANGE_TYPE = {}));\r\n\tvar AXIS_RANGE_TYPE = exports.AXIS_RANGE_TYPE;\r\n\t;\r\n\t(function (AXIS_TYPE) {\r\n\t    AXIS_TYPE[AXIS_TYPE[\"X\"] = 0] = \"X\";\r\n\t    AXIS_TYPE[AXIS_TYPE[\"Y\"] = 1] = \"Y\";\r\n\t})(exports.AXIS_TYPE || (exports.AXIS_TYPE = {}));\r\n\tvar AXIS_TYPE = exports.AXIS_TYPE;\r\n\t(function (AXIS_DATA_TYPE) {\r\n\t    AXIS_DATA_TYPE[AXIS_DATA_TYPE[\"NUMBER\"] = 0] = \"NUMBER\";\r\n\t    AXIS_DATA_TYPE[AXIS_DATA_TYPE[\"DATE\"] = 1] = \"DATE\";\r\n\t})(exports.AXIS_DATA_TYPE || (exports.AXIS_DATA_TYPE = {}));\r\n\tvar AXIS_DATA_TYPE = exports.AXIS_DATA_TYPE;\r\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t/**\r\n\t * base class for all widgets\r\n\t * each widget must have widgetName static property\r\n\t */\r\n\tvar ChartWidget = (function () {\r\n\t    function ChartWidget() {\r\n\t        this.unbindList = [];\r\n\t    }\r\n\t    ChartWidget.prototype.setupChartState = function (chartState) {\r\n\t        this.chartState = chartState;\r\n\t    };\r\n\t    ChartWidget.prototype.bindEvent = function () {\r\n\t        var args = [];\r\n\t        for (var _i = 0; _i < arguments.length; _i++) {\r\n\t            args[_i - 0] = arguments[_i];\r\n\t        }\r\n\t        var unbindList = [];\r\n\t        if (!Array.isArray(args[0])) {\r\n\t            unbindList.push(args[0]);\r\n\t        }\r\n\t        else {\r\n\t            unbindList.push.apply(unbindList, (args));\r\n\t        }\r\n\t        (_a = this.unbindList).push.apply(_a, unbindList);\r\n\t        var _a;\r\n\t    };\r\n\t    ChartWidget.prototype.unbindEvents = function () {\r\n\t        this.unbindList.forEach(function (unbindEvent) { return unbindEvent(); });\r\n\t        this.unbindList.length = 0;\r\n\t    };\r\n\t    ChartWidget.widgetName = '';\r\n\t    return ChartWidget;\r\n\t}());\r\n\texports.ChartWidget = ChartWidget;\r\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar GridWidget_1 = __webpack_require__(24);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar interfaces_1 = __webpack_require__(21);\r\n\t/**\r\n\t * widget for drawing axis\r\n\t */\r\n\tvar AxisWidget = (function (_super) {\r\n\t    __extends(AxisWidget, _super);\r\n\t    function AxisWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.isDestroyed = false;\r\n\t    }\r\n\t    AxisWidget.prototype.onReadyHandler = function () {\r\n\t        var _this = this;\r\n\t        this.object3D = new Object3D();\r\n\t        this.axisXObject = new Object3D();\r\n\t        this.axisYObject = new Object3D();\r\n\t        this.object3D.add(this.axisXObject);\r\n\t        this.object3D.add(this.axisYObject);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t        // canvas drawing is expensive operation, so when we scroll, redraw must be called only once per second\r\n\t        this.updateAxisXRequest = Utils_1.Utils.throttle(function () { return _this.updateAxis(interfaces_1.AXIS_TYPE.X); }, 1000);\r\n\t        this.onScrollChange(this.chartState.screen.options.scrollX, this.chartState.screen.options.scrollY);\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    AxisWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        this.bindEvent(state.screen.onTransformationFrame(function (options) {\r\n\t            _this.onScrollChange(options.scrollX, options.scrollY);\r\n\t        }), state.screen.onZoomFrame(function (options) { _this.onZoomFrame(options); }), state.onDestroy(function () { return _this.onDestroy(); }), state.onResize(function () { return _this.onResize(); }));\r\n\t    };\r\n\t    AxisWidget.prototype.onDestroy = function () {\r\n\t        this.isDestroyed = true;\r\n\t        this.unbindEvents();\r\n\t    };\r\n\t    AxisWidget.prototype.onScrollChange = function (x, y) {\r\n\t        if (y != void 0) {\r\n\t            this.axisYObject.position.y = y;\r\n\t            this.axisXObject.position.y = y;\r\n\t        }\r\n\t        if (x != void 0) {\r\n\t            this.axisYObject.position.x = x;\r\n\t            this.updateAxisXRequest();\r\n\t        }\r\n\t    };\r\n\t    AxisWidget.prototype.onResize = function () {\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        this.setupAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t    };\r\n\t    AxisWidget.prototype.setupAxis = function (orientation) {\r\n\t        var _this = this;\r\n\t        var isXAxis = orientation == interfaces_1.AXIS_TYPE.X;\r\n\t        var _a = this.chartState.data, visibleWidth = _a.width, visibleHeight = _a.height;\r\n\t        var canvasWidth = 0, canvasHeight = 0;\r\n\t        // clean meshes\r\n\t        if (isXAxis) {\r\n\t            this.axisXObject.traverse(function (obj) { return _this.axisXObject.remove(obj); });\r\n\t            canvasWidth = visibleWidth * 3;\r\n\t            canvasHeight = 50;\r\n\t        }\r\n\t        else {\r\n\t            this.axisYObject.traverse(function (obj) { return _this.axisYObject.remove(obj); });\r\n\t            canvasWidth = 50;\r\n\t            canvasHeight = visibleHeight * 3;\r\n\t        }\r\n\t        var texture = Utils_1.Utils.createPixelPerfectTexture(canvasWidth, canvasHeight, function (ctx) {\r\n\t            ctx.beginPath();\r\n\t            ctx.font = \"10px Arial\";\r\n\t            ctx.fillStyle = \"rgba(255,255,255,0.5)\";\r\n\t            ctx.strokeStyle = \"rgba(255,255,255,0.1)\";\r\n\t        });\r\n\t        var material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });\r\n\t        material.transparent = true;\r\n\t        var axisMesh = new Mesh(new THREE.PlaneGeometry(canvasWidth, canvasHeight), material);\r\n\t        if (isXAxis) {\r\n\t            axisMesh.position.set(canvasWidth / 2, canvasHeight / 2, 0);\r\n\t            this.axisXObject.add(axisMesh);\r\n\t        }\r\n\t        else {\r\n\t            axisMesh.position.set(visibleWidth - canvasWidth / 2, canvasHeight / 2, 0);\r\n\t            this.axisYObject.add(axisMesh);\r\n\t        }\r\n\t        this.updateAxis(orientation);\r\n\t    };\r\n\t    AxisWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    AxisWidget.prototype.updateAxis = function (orientation) {\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        var isXAxis = orientation == interfaces_1.AXIS_TYPE.X;\r\n\t        var _a = this.chartState.data, visibleWidth = _a.width, visibleHeight = _a.height;\r\n\t        var _b = this.chartState.screen.options, scrollX = _b.scrollX, scrollY = _b.scrollY, zoomX = _b.zoomX, zoomY = _b.zoomY;\r\n\t        var axisOptions;\r\n\t        var axisMesh;\r\n\t        var axisGridParams;\r\n\t        if (isXAxis) {\r\n\t            axisMesh = this.axisXObject.children[0];\r\n\t            axisOptions = this.chartState.data.xAxis;\r\n\t            axisGridParams = GridWidget_1.GridWidget.getGridParamsForAxis(axisOptions, visibleWidth, zoomX);\r\n\t        }\r\n\t        else {\r\n\t            axisMesh = this.axisYObject.children[0];\r\n\t            axisOptions = this.chartState.data.yAxis;\r\n\t            axisGridParams = GridWidget_1.GridWidget.getGridParamsForAxis(axisOptions, visibleHeight, zoomY);\r\n\t        }\r\n\t        var geometry = axisMesh.geometry;\r\n\t        var canvasWidth = geometry.parameters.width;\r\n\t        var canvasHeight = geometry.parameters.height;\r\n\t        var texture = axisMesh.material.map;\r\n\t        var ctx = texture.image.getContext('2d');\r\n\t        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\t        if (isXAxis) {\r\n\t            axisMesh.position.x = canvasWidth / 2 - visibleWidth + scrollX;\r\n\t        }\r\n\t        // TODO: draw text and lines in different loops\r\n\t        var edgeOffset = axisGridParams.segmentsCount * axisGridParams.step;\r\n\t        var startVal = axisGridParams.start - edgeOffset;\r\n\t        var endVal = axisGridParams.end + edgeOffset;\r\n\t        ctx.beginPath();\r\n\t        for (var val = startVal; val <= endVal; val += axisGridParams.step) {\r\n\t            var displayedValue = '';\r\n\t            if (isXAxis) {\r\n\t                var pxVal = this.chartState.screen.getPointOnXAxis(val) - scrollX + visibleWidth;\r\n\t                ctx.textAlign = \"center\";\r\n\t                // uncomment for dots\r\n\t                // ctx.moveTo(pxVal + 0.5, canvasHeight);\r\n\t                // ctx.lineTo(pxVal + 0.5, canvasHeight - 5);\r\n\t                if (axisOptions.dataType == interfaces_1.AXIS_DATA_TYPE.DATE) {\r\n\t                    displayedValue = AxisWidget.getDateStr(val, axisGridParams);\r\n\t                }\r\n\t                else {\r\n\t                    displayedValue = Number(val.toFixed(14)).toString();\r\n\t                }\r\n\t                ctx.fillText(displayedValue, pxVal, canvasHeight - 10);\r\n\t            }\r\n\t            else {\r\n\t                var pxVal = canvasHeight - this.chartState.screen.getPointOnYAxis(val) + scrollY;\r\n\t                ctx.textAlign = \"right\";\r\n\t                // uncomment for dots\r\n\t                // ctx.moveTo(canvasWidth, pxVal + 0.5);\r\n\t                // ctx.lineTo(canvasWidth - 5, pxVal + 0.5);\r\n\t                displayedValue = Number(val.toFixed(14)).toString();\r\n\t                ctx.fillText(displayedValue, canvasWidth - 15, pxVal + 3);\r\n\t            }\r\n\t            ctx.stroke();\r\n\t        }\r\n\t        // uncomment to preview canvas borders\r\n\t        // ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\t        ctx.stroke();\r\n\t        ctx.closePath();\r\n\t        texture.needsUpdate = true;\r\n\t    };\r\n\t    AxisWidget.prototype.onZoomFrame = function (options) {\r\n\t        if (options.zoomX) {\r\n\t            this.updateAxis(interfaces_1.AXIS_TYPE.X);\r\n\t        }\r\n\t        if (options.zoomY) {\r\n\t            this.updateAxis(interfaces_1.AXIS_TYPE.Y);\r\n\t        }\r\n\t    };\r\n\t    // private temporaryHideAxis(orientation: AXIS_TYPE) {\r\n\t    // \tvar isXAxis = orientation == AXIS_TYPE.X;\r\n\t    // \tvar timeoutId = setTimeout(() => {\r\n\t    // \t\t\tthis.showAxis(orientation);\r\n\t    // \t}, 200);\r\n\t    //\r\n\t    // \tif (isXAxis) {\r\n\t    // \t\t(this.axisXObject.children[0] as Mesh).material.opacity = 0;\r\n\t    // \t\tclearTimeout(this.showAxisXTimeout);\r\n\t    // \t\tthis.showAxisXTimeout =\ttimeoutId;\r\n\t    // \t} else {\r\n\t    // \t\tclearTimeout(this.showAxisYTimeout);\r\n\t    // \t\t(this.axisYObject.children[0] as Mesh).material.opacity = 0;\r\n\t    // \t\tthis.showAxisYTimeout = timeoutId;\r\n\t    // \t}\r\n\t    // }\r\n\t    // private showAxis(orientation: AXIS_TYPE) {\r\n\t    // \tvar isXAxis = orientation == AXIS_TYPE.X;\r\n\t    // \tvar material: MeshBasicMaterial;\r\n\t    // \tif (isXAxis) {\r\n\t    // \t\tmaterial = (this.axisXObject.children[0] as Mesh).material as MeshBasicMaterial;\r\n\t    // \t} else {\r\n\t    // \t\tmaterial = (this.axisYObject.children[0] as Mesh).material as MeshBasicMaterial;\r\n\t    // \t}\r\n\t    // \tthis.updateAxis(orientation);\r\n\t    // \tTweenLite.to(material, 0.3, {opacity: 1});\r\n\t    // }\r\n\t    AxisWidget.getDateStr = function (timestamp, gridParams) {\r\n\t        var sec = 1000;\r\n\t        var min = sec * 60;\r\n\t        var hour = min * 60;\r\n\t        var day = hour * 60;\r\n\t        var step = gridParams.step;\r\n\t        var d = new Date(timestamp);\r\n\t        var tf = function (num) { return Utils_1.Utils.toFixed(num, 2); };\r\n\t        return tf(d.getHours()) + ':' + tf(d.getMinutes()) + ':' + tf(d.getSeconds());\r\n\t    };\r\n\t    AxisWidget.widgetName = 'Axis';\r\n\t    return AxisWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.AxisWidget = AxisWidget;\r\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar LineSegments = THREE.LineSegments;\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\t/**\r\n\t * widget for drawing chart grid\r\n\t */\r\n\tvar GridWidget = (function (_super) {\r\n\t    __extends(GridWidget, _super);\r\n\t    function GridWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.isDestroyed = false;\r\n\t    }\r\n\t    GridWidget.prototype.onReadyHandler = function () {\r\n\t        var _a = this.chartState.data, width = _a.width, height = _a.height, xAxis = _a.xAxis, yAxis = _a.yAxis;\r\n\t        this.gridSizeH = Math.floor(width / xAxis.grid.minSizePx) * 3;\r\n\t        this.gridSizeV = Math.floor(height / yAxis.grid.minSizePx) * 3;\r\n\t        this.initGrid();\r\n\t        this.updateGrid();\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    GridWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        // grid is bigger then screen, so it's no need to update it on each scroll event\r\n\t        var updateGridThrottled = Utils_1.Utils.throttle(function () { return _this.updateGrid(); }, 1000);\r\n\t        this.bindEvent(this.chartState.onScroll(function () { return updateGridThrottled(); }), this.chartState.screen.onZoomFrame(function (options) {\r\n\t            updateGridThrottled();\r\n\t            _this.onZoomFrame(options);\r\n\t        }), this.chartState.onDestroy(function () {\r\n\t            _this.isDestroyed = true;\r\n\t            _this.unbindEvents();\r\n\t        }), this.chartState.onResize(function () {\r\n\t            _this.updateGrid();\r\n\t        }));\r\n\t    };\r\n\t    GridWidget.prototype.initGrid = function () {\r\n\t        var geometry = new THREE.Geometry();\r\n\t        var material = new THREE.LineBasicMaterial({ linewidth: 1, opacity: 0.1, transparent: true });\r\n\t        var xLinesCount = this.gridSizeH;\r\n\t        var yLinesCount = this.gridSizeV;\r\n\t        while (xLinesCount--)\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t        while (yLinesCount--)\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t        this.lineSegments = new LineSegments(geometry, material);\r\n\t        this.lineSegments.position.setZ(-1);\r\n\t        this.lineSegments.frustumCulled = false;\r\n\t    };\r\n\t    GridWidget.prototype.updateGrid = function () {\r\n\t        if (this.isDestroyed)\r\n\t            return;\r\n\t        var _a = this.chartState.data, yAxis = _a.yAxis, xAxis = _a.xAxis, width = _a.width, height = _a.height;\r\n\t        var axisXGrid = GridWidget.getGridParamsForAxis(xAxis, width, xAxis.range.zoom);\r\n\t        var axisYGrid = GridWidget.getGridParamsForAxis(yAxis, height, yAxis.range.zoom);\r\n\t        var scrollXInSegments = Math.ceil(xAxis.range.scroll / axisXGrid.step);\r\n\t        var scrollYInSegments = Math.ceil(yAxis.range.scroll / axisYGrid.step);\r\n\t        var gridScrollXVal = scrollXInSegments * axisXGrid.step;\r\n\t        var gridScrollYVal = scrollYInSegments * axisYGrid.step;\r\n\t        var startXVal = axisXGrid.start + gridScrollXVal;\r\n\t        var startYVal = axisYGrid.start + gridScrollYVal;\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        var vertices = geometry.vertices;\r\n\t        var lineInd = 0;\r\n\t        for (var i = -this.gridSizeH / 3; i < this.gridSizeH * 2 / 3; i++) {\r\n\t            var value = startXVal + i * axisXGrid.step;\r\n\t            var lineSegment = this.getVerticalLineSegment(value, gridScrollXVal, gridScrollYVal);\r\n\t            vertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\r\n\t            vertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\r\n\t            lineInd++;\r\n\t        }\r\n\t        for (var i = -this.gridSizeV / 3; i < this.gridSizeV * 2 / 3; i++) {\r\n\t            var value = startYVal + i * axisYGrid.step;\r\n\t            var lineSegment = this.getHorizontalLineSegment(value, gridScrollXVal, gridScrollYVal);\r\n\t            vertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\r\n\t            vertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\r\n\t            lineInd++;\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t        this.lineSegments.scale.set(xAxis.range.scaleFactor * xAxis.range.zoom, yAxis.range.scaleFactor * yAxis.range.zoom, 1);\r\n\t    };\r\n\t    GridWidget.prototype.getHorizontalLineSegment = function (yVal, scrollXVal, scrollYVal) {\r\n\t        var chartState = this.chartState;\r\n\t        var localYVal = yVal - chartState.data.yAxis.range.zeroVal - scrollYVal;\r\n\t        var widthVal = chartState.pxToValueByXAxis(chartState.data.width);\r\n\t        return [\r\n\t            new THREE.Vector3(widthVal * 2 + scrollXVal, localYVal, 0),\r\n\t            new THREE.Vector3(-widthVal + scrollXVal, localYVal, 0)\r\n\t        ];\r\n\t    };\r\n\t    GridWidget.prototype.getVerticalLineSegment = function (xVal, scrollXVal, scrollYVal) {\r\n\t        var chartState = this.chartState;\r\n\t        var localXVal = xVal - chartState.data.xAxis.range.zeroVal - scrollXVal;\r\n\t        var heightVal = chartState.pxToValueByYAxis(chartState.data.height);\r\n\t        return [\r\n\t            new THREE.Vector3(localXVal, heightVal * 2 + scrollYVal, 0),\r\n\t            new THREE.Vector3(localXVal, -heightVal + scrollYVal, 0)\r\n\t        ];\r\n\t    };\r\n\t    GridWidget.prototype.onZoomFrame = function (options) {\r\n\t        var _a = this.chartState.data, xAxis = _a.xAxis, yAxis = _a.yAxis;\r\n\t        if (options.zoomX)\r\n\t            this.lineSegments.scale.setX(xAxis.range.scaleFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            this.lineSegments.scale.setY(yAxis.range.scaleFactor * options.zoomY);\r\n\t    };\r\n\t    // TODO: move this code to core\r\n\t    GridWidget.getGridParamsForAxis = function (axisOptions, axisWidth, zoom) {\r\n\t        var axisRange = axisOptions.range;\r\n\t        var from = axisRange.from;\r\n\t        var to = axisRange.to;\r\n\t        var axisLength = to - from;\r\n\t        var gridStep = 0;\r\n\t        var gridStepInPixels = 0;\r\n\t        var minGridStepInPixels = axisOptions.grid.minSizePx;\r\n\t        var axisLengthStr = String(axisLength);\r\n\t        var axisLengthPointPosition = axisLengthStr.indexOf('.');\r\n\t        var intPartLength = axisLengthPointPosition !== -1 ? axisLengthPointPosition : axisLengthStr.length;\r\n\t        var gridStepFound = false;\r\n\t        var digitPos = 0;\r\n\t        while (!gridStepFound) {\r\n\t            var power = intPartLength - digitPos - 1;\r\n\t            var multiplier = (Math.pow(10, power) || 1);\r\n\t            var dividers = [1, 2, 5];\r\n\t            for (var dividerInd = 0; dividerInd < dividers.length; dividerInd++) {\r\n\t                var nextGridStep = multiplier / dividers[dividerInd];\r\n\t                var nextGridStepInPixels = nextGridStep / axisLength * axisWidth;\r\n\t                if (nextGridStepInPixels >= minGridStepInPixels) {\r\n\t                    gridStep = nextGridStep;\r\n\t                    gridStepInPixels = nextGridStepInPixels;\r\n\t                }\r\n\t                else {\r\n\t                    gridStepFound = true;\r\n\t                    if (gridStep === 0) {\r\n\t                        gridStep = nextGridStep;\r\n\t                        gridStepInPixels = nextGridStepInPixels;\r\n\t                    }\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (!gridStepFound)\r\n\t                digitPos++;\r\n\t        }\r\n\t        var gridStart = Math.floor(from / gridStep) * gridStep;\r\n\t        var gridEnd = Math.floor(to / gridStep) * gridStep;\r\n\t        return {\r\n\t            start: gridStart,\r\n\t            end: gridEnd,\r\n\t            step: gridStep,\r\n\t            stepInPx: gridStepInPixels,\r\n\t            length: gridEnd - gridStart,\r\n\t            segmentsCount: Math.round((gridEnd - gridStart) / gridStep)\r\n\t        };\r\n\t    };\r\n\t    GridWidget.prototype.getObject3D = function () {\r\n\t        return this.lineSegments;\r\n\t    };\r\n\t    GridWidget.widgetName = 'Grid';\r\n\t    return GridWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.GridWidget = GridWidget;\r\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar TrendsWidget_1 = __webpack_require__(26);\r\n\tvar Color_1 = __webpack_require__(27);\r\n\tvar TrendsGradientWidget = (function (_super) {\r\n\t    __extends(TrendsGradientWidget, _super);\r\n\t    function TrendsGradientWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsGradientWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendGradient;\r\n\t    };\r\n\t    TrendsGradientWidget.widgetName = \"TrendsGradient\";\r\n\t    return TrendsGradientWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsGradientWidget = TrendsGradientWidget;\r\n\tvar TrendGradient = (function (_super) {\r\n\t    __extends(TrendGradient, _super);\r\n\t    function TrendGradient(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        this.visibleSegmentsCnt = 0;\r\n\t        this.trend = chartState.trendsManager.getTrend(trendName);\r\n\t        this.segmentsIds = new Uint16Array(chartState.data.maxVisibleSegments);\r\n\t        this.initGradient();\r\n\t        this.updateSegments();\r\n\t    }\r\n\t    TrendGradient.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.hasBackground;\r\n\t    };\r\n\t    TrendGradient.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            // TODO: optimize updateSegments for onDisplayedRangeChanged\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.chartState.onZoom(function () {\r\n\t            _this.updateSegments();\r\n\t        }));\r\n\t    };\r\n\t    TrendGradient.prototype.getObject3D = function () {\r\n\t        return this.gradient;\r\n\t    };\r\n\t    TrendGradient.prototype.initGradient = function () {\r\n\t        var geometry = new Geometry();\r\n\t        for (var i = 0; i < this.segmentsIds.length; i++) {\r\n\t            geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3());\r\n\t            var ind = i * 4;\r\n\t            // gradient segment scheme\r\n\t            //\r\n\t            // vert0 +---+ vert3\r\n\t            //       |\\  |\r\n\t            // face1 | \\ | face2\r\n\t            // \t     |  \\|\r\n\t            // vert1 +---+ vert2\r\n\t            geometry.faces.push(new THREE.Face3(ind, ind + 1, ind + 2), new THREE.Face3(ind + 3, ind, ind + 2));\r\n\t        }\r\n\t        var color = new Color_1.ChartColor(this.trend.getOptions().backgroundColor);\r\n\t        this.gradient = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: color.value, transparent: true, opacity: color.a }));\r\n\t        var _a = this.chartState.data.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = this.chartState.data.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.gradient.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.gradient.frustumCulled = false;\r\n\t    };\r\n\t    TrendGradient.prototype.onZoomFrame = function (options) {\r\n\t        var state = this.chartState.data;\r\n\t        var scaleXFactor = state.xAxis.range.scaleFactor;\r\n\t        var scaleYFactor = state.yAxis.range.scaleFactor;\r\n\t        var currentScale = this.gradient.scale;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendGradient.prototype.onSegmentsAnimate = function (trendSegmentsManager) {\r\n\t        var animatedSegmentsIds = trendSegmentsManager.animatedSegmentsIds;\r\n\t        for (var i = 0; i < this.visibleSegmentsCnt; i++) {\r\n\t            var segmentId = this.segmentsIds[i];\r\n\t            if (!animatedSegmentsIds.includes(segmentId))\r\n\t                continue;\r\n\t            this.setupSegmentVertices(i, trendSegmentsManager.getSegment(segmentId).currentAnimationState);\r\n\t        }\r\n\t        this.gradient.geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendGradient.prototype.updateSegments = function () {\r\n\t        var geometry = this.gradient.geometry;\r\n\t        var _a = this.trend.segmentsManager, trendSegments = _a.segments, segmentInd = _a.firstDisplayedSegmentInd, lastDisplayedSegmentInd = _a.lastDisplayedSegmentInd;\r\n\t        var prevVisibleSegmentsCnt = this.visibleSegmentsCnt;\r\n\t        this.visibleSegmentsCnt = lastDisplayedSegmentInd - segmentInd + 1;\r\n\t        var segmentsToProcessCnt = Math.max(prevVisibleSegmentsCnt, this.visibleSegmentsCnt);\r\n\t        if (segmentsToProcessCnt > this.segmentsIds.length) {\r\n\t            Utils_1.Utils.error(TrendsGradientWidget.widgetName + ': MAX_SEGMENTS reached');\r\n\t        }\r\n\t        // setup visible segments and collapse invisible\r\n\t        for (var i = 0; i <= segmentsToProcessCnt; i++) {\r\n\t            if (segmentInd <= lastDisplayedSegmentInd) {\r\n\t                var segment = trendSegments[segmentInd];\r\n\t                this.setupSegmentVertices(i, segment.currentAnimationState);\r\n\t                this.segmentsIds[i] = segment.id;\r\n\t                segmentInd++;\r\n\t            }\r\n\t            else {\r\n\t                this.setupSegmentVertices(i);\r\n\t            }\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    /**\r\n\t     * setup gradient segment by segmentState\r\n\t     * if segmentState is undefined, then collapse vertices to 0,0,0\r\n\t     */\r\n\t    TrendGradient.prototype.setupSegmentVertices = function (segmentInd, segmentState) {\r\n\t        var gradientSegmentInd = segmentInd * 4;\r\n\t        var vertices = this.gradient.geometry.vertices;\r\n\t        var topLeft = vertices[gradientSegmentInd];\r\n\t        var bottomLeft = vertices[gradientSegmentInd + 1];\r\n\t        var bottomRight = vertices[gradientSegmentInd + 2];\r\n\t        var topRight = vertices[gradientSegmentInd + 3];\r\n\t        var screenHeightVal = Math.max(this.chartState.pxToValueByYAxis(this.chartState.data.height), this.chartState.screen.pxToValueByYAxis(this.chartState.data.height));\r\n\t        if (segmentState) {\r\n\t            var startX = this.toLocalX(segmentState.startXVal);\r\n\t            var startY = this.toLocalY(segmentState.startYVal);\r\n\t            var endX = this.toLocalX(segmentState.endXVal);\r\n\t            var endY = this.toLocalY(segmentState.endYVal);\r\n\t            topLeft.set(startX, startY, 0);\r\n\t            topRight.set(endX, endY, 0);\r\n\t            bottomLeft.set(topLeft.x, topLeft.y - screenHeightVal, 0);\r\n\t            bottomRight.set(topRight.x, topRight.y - screenHeightVal, 0);\r\n\t        }\r\n\t        else {\r\n\t            topLeft.set(0, 0, 0);\r\n\t            topRight.set(0, 0, 0);\r\n\t            bottomLeft.set(0, 0, 0);\r\n\t            bottomRight.set(0, 0, 0);\r\n\t        }\r\n\t    };\r\n\t    TrendGradient.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chartState.data.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendGradient.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chartState.data.yAxis.range.zeroVal;\r\n\t    };\r\n\t    return TrendGradient;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendGradient = TrendGradient;\r\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Widget_1 = __webpack_require__(22);\r\n\tvar Object3D = THREE.Object3D;\r\n\t/**\r\n\t * abstract manager class for all trends widgets\r\n\t */\r\n\tvar TrendsWidget = (function (_super) {\r\n\t    __extends(TrendsWidget, _super);\r\n\t    function TrendsWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t        this.widgets = {};\r\n\t    }\r\n\t    TrendsWidget.prototype.onReadyHandler = function () {\r\n\t        this.object3D = new Object3D();\r\n\t        this.onTrendsChange();\r\n\t        this.bindEvents();\r\n\t    };\r\n\t    TrendsWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        var state = this.chartState;\r\n\t        state.onTrendsChange(function () { return _this.onTrendsChange(); });\r\n\t        state.onTrendChange(function (trendName, changedOptions, newData) {\r\n\t            _this.onTrendChange(trendName, changedOptions, newData);\r\n\t        });\r\n\t    };\r\n\t    TrendsWidget.prototype.onTrendsChange = function () {\r\n\t        var trendsOptions = this.chartState.data.trends;\r\n\t        var TrendWidgetClass = this.getTrendWidgetClass();\r\n\t        for (var trendName in trendsOptions) {\r\n\t            var trendOptions = trendsOptions[trendName];\r\n\t            var widgetCanBeEnabled = TrendWidgetClass.widgetIsEnabled(trendOptions, this.chartState);\r\n\t            if (widgetCanBeEnabled && !this.widgets[trendName]) {\r\n\t                this.createTrendWidget(trendName);\r\n\t            }\r\n\t            else if (!widgetCanBeEnabled && this.widgets[trendName]) {\r\n\t                this.destroyTrendWidget(trendName);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    TrendsWidget.prototype.onTrendChange = function (trendName, changedOptions, newData) {\r\n\t        var widget = this.widgets[trendName];\r\n\t        if (!widget)\r\n\t            return;\r\n\t        widget.onTrendChange(changedOptions);\r\n\t        if (newData) {\r\n\t            var data = this.chartState.getTrend(trendName).getData();\r\n\t            var isAppend = (!data.length || data[0].xVal < newData[0].xVal);\r\n\t            isAppend ? widget.appendData(newData) : widget.prependData(newData);\r\n\t        }\r\n\t    };\r\n\t    TrendsWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendsWidget.prototype.createTrendWidget = function (trendName) {\r\n\t        var WidgetConstructor = this.getTrendWidgetClass();\r\n\t        var widget = new WidgetConstructor(this.chartState, trendName);\r\n\t        this.widgets[trendName] = widget;\r\n\t        var widgetObject = widget.getObject3D();\r\n\t        widgetObject.name = trendName;\r\n\t        this.object3D.add(widget.getObject3D());\r\n\t    };\r\n\t    TrendsWidget.prototype.destroyTrendWidget = function (trendName) {\r\n\t        this.widgets[trendName].onDestroy();\r\n\t        delete this.widgets[trendName];\r\n\t        var widgetObject = this.object3D.getObjectByName(trendName);\r\n\t        this.object3D.remove(widgetObject);\r\n\t    };\r\n\t    return TrendsWidget;\r\n\t}(Widget_1.ChartWidget));\r\n\texports.TrendsWidget = TrendsWidget;\r\n\t/**\r\n\t * based class for all trends widgets\r\n\t */\r\n\tvar TrendWidget = (function () {\r\n\t    function TrendWidget(chartState, trendName) {\r\n\t        this.chartState = chartState;\r\n\t        this.trendName = trendName;\r\n\t        this.unbindList = [];\r\n\t        this.trend = chartState.trendsManager.getTrend(trendName);\r\n\t        this.chartState = chartState;\r\n\t        this.bindEvents();\r\n\t    }\r\n\t    TrendWidget.widgetIsEnabled = function (trendOptions, chartState) {\r\n\t        return trendOptions.enabled;\r\n\t    };\r\n\t    TrendWidget.prototype.appendData = function (newData) { };\r\n\t    ;\r\n\t    TrendWidget.prototype.prependData = function (newData) { };\r\n\t    ;\r\n\t    TrendWidget.prototype.onTrendChange = function (changedOptions) { };\r\n\t    TrendWidget.prototype.onDestroy = function () {\r\n\t        for (var _i = 0, _a = this.unbindList; _i < _a.length; _i++) {\r\n\t            var unsubscriber = _a[_i];\r\n\t            unsubscriber();\r\n\t        }\r\n\t    };\r\n\t    TrendWidget.prototype.onSegmentsAnimate = function (segments) {\r\n\t    };\r\n\t    TrendWidget.prototype.onZoomFrame = function (options) {\r\n\t    };\r\n\t    TrendWidget.prototype.onTransformationFrame = function (options) {\r\n\t    };\r\n\t    TrendWidget.prototype.onZoom = function () {\r\n\t    };\r\n\t    TrendWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        this.bindEvent(this.trend.segmentsManager.onAnimationFrame(function (trendPoints) { return _this.onSegmentsAnimate(trendPoints); }));\r\n\t        this.bindEvent(this.chartState.screen.onTransformationFrame(function (options) { return _this.onTransformationFrame(options); }));\r\n\t        this.bindEvent(this.chartState.screen.onZoomFrame(function (options) { return _this.onZoomFrame(options); }));\r\n\t        this.bindEvent(this.chartState.onZoom(function () { return _this.onZoom(); }));\r\n\t    };\r\n\t    ;\r\n\t    TrendWidget.prototype.bindEvent = function (unbind) {\r\n\t        this.unbindList.push(unbind);\r\n\t    };\r\n\t    return TrendWidget;\r\n\t}());\r\n\texports.TrendWidget = TrendWidget;\r\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar ChartColor = (function () {\r\n\t    function ChartColor(color) {\r\n\t        this.set(color);\r\n\t    }\r\n\t    /**!\r\n\t     * @preserve $.parseColor\r\n\t     * Copyright 2011 THEtheChad Elliott\r\n\t     * Released under the MIT and GPL licenses.\r\n\t     */\r\n\t    /**\r\n\t     * Parse hex/rgb{a} color syntax.\r\n\t     * @input string\r\n\t     * @returns array [r,g,b{,o}]\r\n\t     */\r\n\t    ChartColor.parseColor = function (color) {\r\n\t        var cache, p = parseInt // Use p as a byte saving reference to parseInt\r\n\t        , color = color.replace(/\\s\\s*/g, ''); //var\r\n\t        // Checks for 6 digit hex and converts string to integer\r\n\t        if (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\r\n\t        else if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\r\n\t            cache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\r\n\t        else if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\r\n\t            cache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\r\n\t        else if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3], +cache[4]];\r\n\t        else if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\r\n\t            cache = [+cache[1], +cache[2], +cache[3]];\r\n\t        else\r\n\t            throw Error(color + ' is not supported by parseColor');\r\n\t        // Performs RGBA conversion by default\r\n\t        isNaN(cache[3]) && (cache[3] = 1);\r\n\t        return cache;\r\n\t        // Adds or removes 4th value based on rgba support\r\n\t        // Support is flipped twice to prevent erros if\r\n\t        // it's not defined\r\n\t        //return cache.slice(0,3 + !!$.support.rgba);\r\n\t    };\r\n\t    ChartColor.prototype.set = function (color) {\r\n\t        if (typeof color == 'number')\r\n\t            color = '#' + color.toString(16);\r\n\t        var colorStr = color;\r\n\t        var rgba = ChartColor.parseColor(colorStr);\r\n\t        this.r = rgba[0];\r\n\t        this.g = rgba[1];\r\n\t        this.b = rgba[2];\r\n\t        this.a = rgba[3];\r\n\t        this.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\r\n\t        this.hexStr = '#' + this.value.toString(16);\r\n\t        this.rgbaStr = \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.a + \")\";\r\n\t    };\r\n\t    return ChartColor;\r\n\t}());\r\n\texports.ChartColor = ChartColor;\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar LineBasicMaterial = THREE.LineBasicMaterial;\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar TrendsWidget_1 = __webpack_require__(26);\r\n\tvar LineSegments = THREE.LineSegments;\r\n\tvar Trend_1 = __webpack_require__(16);\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\t/**\r\n\t * widget for drawing trends lines\r\n\t */\r\n\tvar TrendsLineWidget = (function (_super) {\r\n\t    __extends(TrendsLineWidget, _super);\r\n\t    function TrendsLineWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsLineWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendLine;\r\n\t    };\r\n\t    TrendsLineWidget.widgetName = \"TrendsLine\";\r\n\t    return TrendsLineWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsLineWidget = TrendsLineWidget;\r\n\tvar TrendLine = (function (_super) {\r\n\t    __extends(TrendLine, _super);\r\n\t    function TrendLine(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        // contains indexes of free segments\r\n\t        this.freeSegmentsInds = [];\r\n\t        // contains segments to display\r\n\t        this.displayedSegments = {};\r\n\t        var options = this.trend.getOptions();\r\n\t        this.material = new LineBasicMaterial({ color: options.lineColor, linewidth: options.lineWidth });\r\n\t        this.initLine();\r\n\t    }\r\n\t    TrendLine.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.type == Trend_1.TREND_TYPE.LINE;\r\n\t    };\r\n\t    TrendLine.prototype.getObject3D = function () {\r\n\t        return this.lineSegments;\r\n\t    };\r\n\t    TrendLine.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.destroySegments();\r\n\t            _this.setupSegments();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            _this.setupSegments();\r\n\t        }));\r\n\t    };\r\n\t    TrendLine.prototype.initLine = function () {\r\n\t        var geometry = new Geometry();\r\n\t        var _a = this.chartState.data.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = this.chartState.data.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.lineSegments = new LineSegments(geometry, this.material);\r\n\t        this.lineSegments.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.lineSegments.frustumCulled = false;\r\n\t        for (var i = 0; i < this.chartState.data.maxVisibleSegments; i++) {\r\n\t            geometry.vertices.push(new Vector3(), new Vector3());\r\n\t            this.freeSegmentsInds.push(i);\r\n\t        }\r\n\t        this.vertices = geometry.vertices;\r\n\t        this.setupSegments();\r\n\t    };\r\n\t    TrendLine.prototype.setupSegments = function () {\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        var _a = this.trend.segmentsManager, firstDisplayedSegment = _a.firstDisplayedSegment, lastDisplayedSegment = _a.lastDisplayedSegment;\r\n\t        for (var segmentId in this.displayedSegments) {\r\n\t            var lineSegment = this.displayedSegments[segmentId];\r\n\t            var segment_1 = this.trend.segmentsManager.segments[lineSegment.segmentId];\r\n\t            var segmentIsNotDisplayed = (segment_1.startXVal < firstDisplayedSegment.startXVal ||\r\n\t                segment_1.endXVal > lastDisplayedSegment.endXVal);\r\n\t            if (segmentIsNotDisplayed)\r\n\t                this.destroySegment(Number(segmentId));\r\n\t        }\r\n\t        var segment = firstDisplayedSegment;\r\n\t        while (segment && segment.xVal <= lastDisplayedSegment.xVal) {\r\n\t            this.setupSegment(segment.id, segment.currentAnimationState);\r\n\t            segment = segment.getNext();\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendLine.prototype.setupSegment = function (segmentId, segmentState) {\r\n\t        var lineSegment = this.displayedSegments[segmentId];\r\n\t        if (!lineSegment) {\r\n\t            if (this.freeSegmentsInds.length == 0)\r\n\t                Utils_1.Utils.error('Max allocated segments reached');\r\n\t            var ind = this.freeSegmentsInds.pop();\r\n\t            lineSegment = this.displayedSegments[segmentId] = { segmentId: segmentId, ind: ind };\r\n\t        }\r\n\t        var segmentInd = lineSegment.ind;\r\n\t        var lineStartVertex = this.vertices[segmentInd * 2];\r\n\t        var lineEndVertex = this.vertices[segmentInd * 2 + 1];\r\n\t        lineStartVertex.set(this.toLocalX(segmentState.startXVal), this.toLocalY(segmentState.startYVal), 0);\r\n\t        lineEndVertex.set(this.toLocalX(segmentState.endXVal), this.toLocalY(segmentState.endYVal), 0);\r\n\t    };\r\n\t    TrendLine.prototype.destroySegments = function () {\r\n\t        for (var segmentId in this.displayedSegments)\r\n\t            this.destroySegment(Number(segmentId));\r\n\t    };\r\n\t    TrendLine.prototype.destroySegment = function (segmentId) {\r\n\t        var lineSegment = this.displayedSegments[segmentId];\r\n\t        var lineStartVertex = this.vertices[lineSegment.ind * 2];\r\n\t        var lineEndVertex = this.vertices[lineSegment.ind * 2 + 1];\r\n\t        lineStartVertex.set(0, 0, 0);\r\n\t        lineEndVertex.set(0, 0, 0);\r\n\t        delete this.displayedSegments[segmentId];\r\n\t        this.freeSegmentsInds.push(lineSegment.ind);\r\n\t    };\r\n\t    TrendLine.prototype.onZoomFrame = function (options) {\r\n\t        var currentScale = this.lineSegments.scale;\r\n\t        var state = this.chartState.data;\r\n\t        var scaleXFactor = state.xAxis.range.scaleFactor;\r\n\t        var scaleYFactor = state.yAxis.range.scaleFactor;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendLine.prototype.onSegmentsAnimate = function (trendSegments) {\r\n\t        var geometry = this.lineSegments.geometry;\r\n\t        for (var _i = 0, _a = trendSegments.animatedSegmentsIds; _i < _a.length; _i++) {\r\n\t            var segmentId = _a[_i];\r\n\t            if (!this.displayedSegments[segmentId])\r\n\t                continue;\r\n\t            this.setupSegment(segmentId, trendSegments.segmentsById[segmentId].currentAnimationState);\r\n\t        }\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chartState.data.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chartState.data.yAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendLine.prototype.toLocalVec = function (vec) {\r\n\t        return new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\r\n\t    };\r\n\t    return TrendLine;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendLine = TrendLine;\r\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar TrendsWidget_1 = __webpack_require__(26);\r\n\tvar Object3D = THREE.Object3D;\r\n\tvar Geometry = THREE.Geometry;\r\n\tvar Vector3 = THREE.Vector3;\r\n\tvar Mesh = THREE.Mesh;\r\n\tvar Line = THREE.Line;\r\n\tvar MeshBasicMaterial = THREE.MeshBasicMaterial;\r\n\tvar PlaneGeometry = THREE.PlaneGeometry;\r\n\tvar Trend_1 = __webpack_require__(16);\r\n\tvar LineBasicMaterial = THREE.LineBasicMaterial;\r\n\tvar Utils_1 = __webpack_require__(4);\r\n\tvar RISE_COLOR = 0x2CAC40;\r\n\tvar FALL_COLOR = 0xEE5533;\r\n\tvar MARGIN_PERCENT = 0.3;\r\n\tvar MAX_CANDLES = 100;\r\n\t/**\r\n\t * widget for drawing trends candles\r\n\t */\r\n\tvar TrendsCandlesWidget = (function (_super) {\r\n\t    __extends(TrendsCandlesWidget, _super);\r\n\t    function TrendsCandlesWidget() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    TrendsCandlesWidget.prototype.getTrendWidgetClass = function () {\r\n\t        return TrendCandlesWidget;\r\n\t    };\r\n\t    TrendsCandlesWidget.widgetName = \"TrendsCandles\";\r\n\t    return TrendsCandlesWidget;\r\n\t}(TrendsWidget_1.TrendsWidget));\r\n\texports.TrendsCandlesWidget = TrendsCandlesWidget;\r\n\tvar TrendCandlesWidget = (function (_super) {\r\n\t    __extends(TrendCandlesWidget, _super);\r\n\t    function TrendCandlesWidget(chartState, trendName) {\r\n\t        _super.call(this, chartState, trendName);\r\n\t        // contains indexes of free candles\r\n\t        this.freeCandlesInds = [];\r\n\t        this.candlesPool = [];\r\n\t        this.candles = {};\r\n\t        this.initObject();\r\n\t    }\r\n\t    TrendCandlesWidget.widgetIsEnabled = function (trendOptions) {\r\n\t        return trendOptions.enabled && trendOptions.type == Trend_1.TREND_TYPE.CANDLE;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.getObject3D = function () {\r\n\t        return this.object3D;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.bindEvents = function () {\r\n\t        var _this = this;\r\n\t        _super.prototype.bindEvents.call(this);\r\n\t        this.bindEvent(this.trend.segmentsManager.onRebuild(function () {\r\n\t            _this.destroyCandles();\r\n\t            _this.setupCandles();\r\n\t        }));\r\n\t        this.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(function () {\r\n\t            _this.setupCandles();\r\n\t        }));\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.initObject = function () {\r\n\t        var stateData = this.chartState.data;\r\n\t        var _a = stateData.xAxis.range, scaleXFactor = _a.scaleFactor, zoomX = _a.zoom;\r\n\t        var _b = stateData.yAxis.range, scaleYFactor = _b.scaleFactor, zoomY = _b.zoom;\r\n\t        this.scaleXFactor = scaleXFactor;\r\n\t        this.scaleYFactor = scaleYFactor;\r\n\t        this.object3D = new Object3D();\r\n\t        this.object3D.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\r\n\t        this.object3D.frustumCulled = false;\r\n\t        for (var i = 0; i < MAX_CANDLES; i++)\r\n\t            this.freeCandlesInds.push(i);\r\n\t        this.setupCandles();\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.setupCandles = function () {\r\n\t        // remove invisible\r\n\t        var _a = this.trend.segmentsManager, firstDisplayedSegment = _a.firstDisplayedSegment, lastDisplayedSegment = _a.lastDisplayedSegment;\r\n\t        for (var segmentId in this.candles) {\r\n\t            var segment_1 = this.candles[segmentId].segment;\r\n\t            var segmentIsNotDisplayed = (segment_1.startXVal < firstDisplayedSegment.startXVal ||\r\n\t                segment_1.endXVal > lastDisplayedSegment.endXVal);\r\n\t            if (segmentIsNotDisplayed)\r\n\t                this.destroyCandle(Number(segmentId));\r\n\t        }\r\n\t        var segment = firstDisplayedSegment;\r\n\t        while (segment && segment.xVal <= lastDisplayedSegment.xVal) {\r\n\t            this.setupCandle(segment.id, segment.currentAnimationState);\r\n\t            segment = segment.getNext();\r\n\t        }\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.destroyCandles = function () {\r\n\t        for (var segmentId in this.candles)\r\n\t            this.destroyCandle(Number(segmentId));\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.destroyCandle = function (segmentId) {\r\n\t        var candle = this.candles[segmentId];\r\n\t        this.object3D.remove(candle.getObject3D());\r\n\t        delete this.candles[segmentId];\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.onZoomFrame = function (options) {\r\n\t        var currentScale = this.object3D.scale;\r\n\t        if (options.zoomX)\r\n\t            currentScale.setX(this.scaleXFactor * options.zoomX);\r\n\t        if (options.zoomY)\r\n\t            currentScale.setY(this.scaleYFactor * options.zoomY);\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.onSegmentsAnimate = function (trendSegments) {\r\n\t        for (var _i = 0, _a = trendSegments.animatedSegmentsIds; _i < _a.length; _i++) {\r\n\t            var segmentId = _a[_i];\r\n\t            if (!this.candles[segmentId])\r\n\t                continue;\r\n\t            var segmentState = trendSegments.segmentsById[segmentId].currentAnimationState;\r\n\t            this.setupCandle(segmentId, segmentState);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * create or modify candle\r\n\t     */\r\n\t    TrendCandlesWidget.prototype.setupCandle = function (candleId, segmentState) {\r\n\t        var candleInd = candleId % MAX_CANDLES;\r\n\t        // get candle from candlesPool to avoid creating new Objects by performance reasons\r\n\t        var candle = this.candlesPool[candleInd];\r\n\t        if (!candle) {\r\n\t            candle = this.candlesPool[candleInd] = new CandleWidget();\r\n\t        }\r\n\t        if (!this.candles[candleId]) {\r\n\t            this.candles[candleId] = candle;\r\n\t            this.object3D.add(candle.getObject3D());\r\n\t        }\r\n\t        candle.getObject3D().position.set(this.toLocalX(segmentState.xVal), this.toLocalY(segmentState.yVal), 0);\r\n\t        candle.setSegment(segmentState);\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalX = function (xVal) {\r\n\t        return xVal - this.chartState.data.xAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalY = function (yVal) {\r\n\t        return yVal - this.chartState.data.yAxis.range.zeroVal;\r\n\t    };\r\n\t    TrendCandlesWidget.prototype.toLocalVec = function (vec) {\r\n\t        return new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\r\n\t    };\r\n\t    return TrendCandlesWidget;\r\n\t}(TrendsWidget_1.TrendWidget));\r\n\texports.TrendCandlesWidget = TrendCandlesWidget;\r\n\tvar CandleWidget = (function () {\r\n\t    function CandleWidget() {\r\n\t        this.initObject();\r\n\t    }\r\n\t    CandleWidget.prototype.getObject3D = function () {\r\n\t        return this.rect;\r\n\t    };\r\n\t    CandleWidget.prototype.setSegment = function (segment) {\r\n\t        this.segment = segment;\r\n\t        var color = segment.endYVal < segment.startYVal ? FALL_COLOR : RISE_COLOR;\r\n\t        // update rect\r\n\t        var geometry = this.rect.geometry;\r\n\t        var material = this.rect.material;\r\n\t        var width = segment.endXVal - segment.startXVal;\r\n\t        width -= width * MARGIN_PERCENT;\r\n\t        var height = Math.max(segment.startYVal, segment.endYVal) - Math.min(segment.startYVal, segment.endYVal);\r\n\t        var _a = geometry.vertices, leftTop = _a[0], rightTop = _a[1], leftBottom = _a[2], rightBottom = _a[3];\r\n\t        leftTop.set(-width / 2, height / 2, 0);\r\n\t        rightTop.set(width / 2, height / 2, 0);\r\n\t        leftBottom.set(-width / 2, -height / 2, 0);\r\n\t        rightBottom.set(width / 2, -height / 2, 0);\r\n\t        // prevent to draw bars with height < 1px\r\n\t        if (Utils_1.Utils.getDistance(leftTop.y, leftBottom.y) < 1) {\r\n\t            leftBottom.setY(leftBottom.y + 1);\r\n\t            rightBottom.setY(rightBottom.y + 1);\r\n\t        }\r\n\t        material.color.set(color);\r\n\t        geometry.verticesNeedUpdate = true;\r\n\t        // update lines\r\n\t        var vLineGeometry = this.vLine.geometry;\r\n\t        var vLineMaterial = this.vLine.material;\r\n\t        var lineTop = segment.maxYVal - segment.yVal;\r\n\t        var lineBottom = segment.minYVal - segment.yVal;\r\n\t        vLineGeometry.vertices[0].set(0, lineTop, 0);\r\n\t        vLineGeometry.vertices[1].set(0, lineBottom, 0);\r\n\t        vLineMaterial.color.set(color);\r\n\t        vLineGeometry.verticesNeedUpdate = true;\r\n\t        var hLineGeometry = this.hLine.geometry;\r\n\t        var hLineMaterial = this.hLine.material;\r\n\t        var lineLeft = (-width) / 2;\r\n\t        var lineRight = width / 2;\r\n\t        hLineGeometry.vertices[0].set(lineLeft, 0, 0);\r\n\t        hLineGeometry.vertices[1].set(lineRight, 0, 0);\r\n\t        hLineMaterial.color.set(color);\r\n\t        hLineGeometry.verticesNeedUpdate = true;\r\n\t    };\r\n\t    CandleWidget.prototype.initObject = function () {\r\n\t        this.rect = new Mesh(new PlaneGeometry(1, 1), new MeshBasicMaterial());\r\n\t        var vLineGeometry = new Geometry();\r\n\t        var hLineGeometry = new Geometry();\r\n\t        vLineGeometry.vertices.push(new Vector3(), new Vector3);\r\n\t        hLineGeometry.vertices.push(new Vector3(), new Vector3);\r\n\t        this.vLine = new Line(vLineGeometry, new LineBasicMaterial({ linewidth: 1 }));\r\n\t        this.hLine = new Line(hLineGeometry, new LineBasicMaterial({ linewidth: 1 }));\r\n\t        this.rect.add(this.vLine);\r\n\t        this.rect.add(this.hLine);\r\n\t    };\r\n\t    return CandleWidget;\r\n\t}());\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ThreeChart.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap aa8a96c64dad3de6cbf0\n **/","export * from './src/index';\n\n\n/** WEBPACK FOOTER **\n ** ./index.ts\n **/","export * from './Chart';\nexport * from './interfaces';\nexport * from './AxisMarks';\nexport * from './Screen';\nexport * from './State';\nexport * from './Trend';\nexport * from './TrendSegmentsManager';\nexport * from './TrendsManager';\nexport * from './Utils';\nexport * from './Widget';\nexport * from './Plugin';\nexport * from './widgets/TrendsWidget';\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.ts\n **/","// deps must be always on top\nimport { ChartPlugin } from './Plugin';\nrequire('./deps/deps');\n\nimport { Trend } from \"./Trend\";\nimport Vector3 = THREE.Vector3;\nimport PerspectiveCamera = THREE.PerspectiveCamera;\nimport Scene = THREE.Scene;\nimport Renderer = THREE.Renderer;\nimport WebGLRenderer = THREE.WebGLRenderer;\nimport Object3D = THREE.Object3D;\nimport { ChartState, IChartState } from \"./State\";\nimport { ChartWidget, IChartWidgetConstructor } from \"./Widget\";\nimport { Utils } from \"./Utils\";\nimport { IScreenTransformOptions } from \"./Screen\";\nimport { AxisWidget } from \"./widgets/AxisWidget\";\nimport { GridWidget } from \"./widgets/GridWidget\";\nimport { TrendsGradientWidget } from \"./widgets/TrendsGradientWidget\";\nimport { TrendsLoadingWidget } from \"./widgets/TrendsLoadingWidget\";\nimport { AxisMarksWidget } from \"./widgets/AxisMarksWidget\";\nimport { BorderWidget } from \"./widgets/BorderWidget\";\nimport { TrendsIndicatorWidget } from \"./widgets/TrendsIndicatorWidget\";\nimport { TrendsLineWidget } from \"./widgets/TrendsLineWidget\";\nimport { TrendsCandlesWidget } from './widgets/TrendsCandleWidget';\nimport { TrendsBeaconWidget } from \"./widgets/TrendsBeaconWidget\";\nimport { ResizeSensor, ResizeSensorType } from './deps';\nimport OrthographicCamera = THREE.OrthographicCamera;\n\n\nexport class Chart {\n\n\tstatic devicePixelRatio = window.devicePixelRatio;\n\tstatic preinstalledWidgets: typeof ChartWidget[] = [];\n\tstatic renderers: {[rendererName: string]: any} = {\n\t\tCanvasRenderer: (THREE as any).CanvasRenderer,\n\t\tWebGLRenderer: THREE.WebGLRenderer\n\t};\n\n\tstate: ChartState;\n\tisStopped: boolean;\n\tisDestroyed: boolean;\n\tprivate $container: Element;\n\tprivate $el: HTMLElement;\n\tprivate renderer: Renderer;\n\tprivate scene: Scene;\n\tprivate camera: PerspectiveCamera;\n\tprivate cameraInitialPosition: Vector3;\n\tprivate widgets: Array<ChartWidget> = [];\n\tprivate stats: Stats;\n\tprivate zoomThrottled: Function;\n\tprivate unsubscribers: Function[];\n\tprivate resizeSensor: ResizeSensorType;\n\tprivate pluginsAndWidgets: Array<ChartPlugin | ChartWidget>;\n\n\tconstructor(state: IChartState, $container: Element, pluginsAndWidgets: Array<ChartPlugin | ChartWidget> = []) {\n\n\t\tif (!THREE || !THREE.REVISION) Utils.error('three.js not found');\n\n\t\tif (!$container) {\n\t\t\tUtils.error('$el must be set');\n\t\t}\n\t\t// calculate chart size\n\t\tlet style = getComputedStyle($container);\n\t\tstate.width = parseInt(style.width);\n\t\tstate.height = parseInt(style.height);\n\n\t\tlet plugins = pluginsAndWidgets.filter(pluginOrWidget => pluginOrWidget instanceof ChartPlugin) as ChartPlugin[];\n\n\t\tthis.state = new ChartState(state, plugins);\n\t\tthis.pluginsAndWidgets = pluginsAndWidgets;\n\t\tthis.zoomThrottled = Utils.throttle((zoomValue: number, origin: number) => this.zoom(zoomValue, origin), 200);\n\t\tthis.$container = $container;\n\t\tthis.init($container);\n\t};\n\n\tstatic installWidget<WidgetClass extends typeof ChartWidget>(Widget: WidgetClass) {\n\t\tif (!Widget.widgetName) Utils.error('unnamed widget');\n\t\tthis.preinstalledWidgets.push(Widget);\n\t}\n\n\tprivate init($container: Element) {\n\t\tvar state = this.state;\n\t\tvar {width: w, height: h, showStats, autoRender} = state.data;\n\t\tthis.scene = new THREE.Scene();\n\t\tthis.isStopped = !autoRender.enabled;\n\n\t\tvar renderer = this.renderer = new (Chart.renderers[this.state.data.renderer] as any)({\n\t\t\tantialias: true,\n\t\t\talpha: true\n\t\t});\n\t\trenderer.setSize(w, h);\n\t\trenderer.setPixelRatio(Chart.devicePixelRatio);\n\t\trenderer.setClearColor(state.data.backgroundColor, state.data.backgroundOpacity);\n\t\t$container.appendChild(renderer.domElement);\n\t\tthis.$el = renderer.domElement;\n\t\tthis.$el.style.display = 'block';\n\n\t\tif (showStats) {\n\t\t\tthis.stats = new Stats();\n\t\t\t$container.appendChild(this.stats.domElement);\n\t\t}\n\n\t\tthis.setupCamera();\n\t\tthis.initWidgets();\n\t\tthis.bindEvents();\n\t\tthis.renderLoop();\n\t}\n\n\t/**\n\t * collect and init widgets from preinstalled widgets, plugins widgets and custom widgets\n\t */\n\tprivate initWidgets() {\n\t\tlet preinstalledWidgetsClasses = (this.constructor as typeof Chart).preinstalledWidgets;\n\t\tlet customWidgets: ChartWidget[] = [];\n\n\t\tthis.pluginsAndWidgets.forEach(pluginOrWidget => {\n\t\t\tif (pluginOrWidget instanceof ChartWidget) {\n\t\t\t\tcustomWidgets.push(pluginOrWidget);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(pluginOrWidget instanceof ChartPlugin)) return;\n\t\t\tlet pluginWidgetClasses = (pluginOrWidget.constructor as typeof ChartPlugin).providedWidgets;\n\t\t\tpreinstalledWidgetsClasses.push(...pluginWidgetClasses);\n\t\t});\n\n\t\tthis.widgets = customWidgets.concat(\n\t\t\tpreinstalledWidgetsClasses.map((WidgetClass: IChartWidgetConstructor) => new WidgetClass())\n\t\t);\n\n\t\tthis.widgets.forEach(widget => {\n\t\t\twidget.setupChartState(this.state);\n\t\t\twidget.onReadyHandler();\n\t\t\tthis.scene.add(widget.getObject3D());\n\t\t});\n\t}\n\n\tprivate renderLoop() {\n\t\tif (this.isDestroyed) return;\n\t\tthis.stats && this.stats.begin();\n\t\tthis.render();\n\t\tif (this.isStopped) return;\n\t\tvar fpsLimit = this.state.data.autoRender.fps;\n\n\t\tif (fpsLimit) {\n\t\t\tlet delay = 1000 / fpsLimit;\n\t\t\tsetTimeout(() => requestAnimationFrame(() => this.renderLoop()), delay);\n\t\t} else {\n\t\t\trequestAnimationFrame(() => this.renderLoop());\n\t\t}\n\t\tthis.stats && this.stats.end();\n\t}\n\n\trender() {\n\t\tthis.renderer.render(this.scene, this.camera);\n\t}\n\n\tstop() {\n\t\tthis.isStopped = true;\n\t}\n\n\trun() {\n\t\tthis.isStopped = false;\n\t\tthis.renderLoop();\n\t}\n\n\t/**\n\t * call to destroy chart an init garbage collection\n\t */\n\tdestroy() {\n\t\tthis.isDestroyed = true;\n\t\tthis.stop();\n\t\tthis.state.destroy();\n\t\tthis.unbindEvents();\n\t\t// WARNING! undocumented method for free webgl context\n\t\ttry {\n\t\t\t(this.renderer as any).forceContextLoss();\n\t\t} catch (wtf) {\n\t\t\t// sometimes with many chart instances forceContextLoss not working\n\t\t}\n\t\t(this.renderer as any).context = null;\n\t\tthis.renderer.domElement = null;\n\t\tthis.renderer = null;\n\t}\n\n\tgetState(): IChartState {\n\t\treturn this.state.data\n\t}\n\n\t/**\n\t * shortcut for Chart.state.getTrend\n\t */\n\tgetTrend(trendName: string): Trend {\n\t\treturn this.state.getTrend(trendName);\n\t}\n\n\t/**\n\t * shortcut for Chart.state.setState\n\t */\n\tsetState(state: IChartState) {\n\t\treturn this.state.setState(state);\n\t}\n\n\n\tprivate bindEvents() {\n\t\tvar $el = this.$el;\n\t\tif (this.state.data.controls.enabled) {\n\t\t\t$el.addEventListener('mousewheel', (ev: MouseWheelEvent) => {\n\t\t\t\tthis.onMouseWheel(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('mousemove', (ev: MouseEvent) => {\n\t\t\t\tthis.onMouseMove(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('mousedown', (ev: MouseEvent) => this.onMouseDown(ev));\n\t\t\t$el.addEventListener('mouseup', (ev: MouseEvent) => this.onMouseUp(ev));\n\t\t\t$el.addEventListener('touchmove', (ev: TouchEvent) => {\n\t\t\t\tthis.onTouchMove(ev)\n\t\t\t});\n\t\t\t$el.addEventListener('touchend', (ev: TouchEvent) => {\n\t\t\t\tthis.onTouchEnd(ev)\n\t\t\t});\n\t\t}\n\t\tif (this.state.data.autoResize) {\n\t\t\t// this.resizeSensor = new ResizeSensor(this.$container, () => {\n\t\t\t// \tthis.onChartContainerResizeHandler(this.$container.clientWidth, this.$container.clientHeight);\n\t\t\t// });\n\t\t}\n\n\t\tthis.unsubscribers = [\n\t\t\tthis.state.onTrendsChange(() => this.autoscroll()),\n\t\t\tthis.state.screen.onTransformationFrame((options) => this.onScreenTransformHandler(options)),\n\t\t\tthis.state.onResize((options) => this.onChartResize())\n\t\t];\n\t}\n\n\tprivate unbindEvents() {\n\t\t// TODO: unbind events correctly\n\t\ttry {\n\t\t\tthis.resizeSensor && this.resizeSensor.detach();\n\t\t} catch (e) {\n\t\t\t// ups.. somebody already removed resizeSensor childNode\n\t\t\t// detected in angular2 apps\n\t\t}\n\t\tthis.$el.remove();\n\t\tthis.unsubscribers.forEach(unsubscribe => unsubscribe());\n\t}\n\n\tprivate setupCamera() {\n\t\tlet camSettings = this.state.screen.getCameraSettings();\n\t\tif (!this.camera) {\n\t\t\tthis.camera = new PerspectiveCamera(camSettings.FOV, camSettings.aspect, camSettings.near, camSettings.far);\n\t\t\tthis.scene.add(this.camera);\n\t\t} else {\n\t\t\tthis.camera.fov = camSettings.FOV;\n\t\t\tthis.camera.aspect = camSettings.aspect;\n\t\t\tthis.camera.far = camSettings.far;\n\t\t\tthis.camera.near = camSettings.near;\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t}\n\t\tthis.camera.position.set(camSettings.x, camSettings.y, camSettings.z);\n\t\tthis.cameraInitialPosition = this.camera.position.clone();\n\t\tthis.onScreenTransformHandler(this.state.screen.options);\n\t}\n\n\tprivate onScreenTransformHandler(options: IScreenTransformOptions) {\n\t\tif (options.scrollX != void 0) {\n\t\t\tlet scrollX = this.cameraInitialPosition.x + options.scrollX;\n\t\t\t// scrollX =  Math.round(scrollX); // prevent to set camera beetween pixels\n\t\t\tthis.camera.position.setX(scrollX);\n\t\t}\n\t\tif (options.scrollY != void 0) {\n\t\t\tlet scrollY = this.cameraInitialPosition.y + options.scrollY;\n\t\t\t// scrollY = Math.round(scrollY); // prevent to set camera beetween pixels\n\t\t\tthis.camera.position.setY(scrollY);\n\t\t}\n\t}\n\n\tprivate autoscroll() {\n\t\tvar state = this.state;\n\t\tif (!state.data.autoScroll) return;\n\t\tvar oldTrendsMaxX = state.data.prevState.computedData.trends.maxXVal;\n\t\tvar trendsMaxXDelta = state.data.computedData.trends.maxXVal - oldTrendsMaxX;\n\t\tif (trendsMaxXDelta > 0) {\n\t\t\tvar maxVisibleX = this.state.screen.getScreenRightVal();\n\t\t\tvar paddingRightX = this.state.getPaddingRight();\n\t\t\tvar currentScroll = state.data.xAxis.range.scroll;\n\t\t\tif (oldTrendsMaxX < paddingRightX || oldTrendsMaxX > maxVisibleX) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar scrollDelta = trendsMaxXDelta;\n\t\t\tthis.setState({xAxis: {range: {scroll: currentScroll + scrollDelta}}});\n\t\t}\n\t}\n\n\tprivate onScrollStop() {\n\t\t// var tendsXMax = this.state.data.computedData.trends.maxX;\n\t\t// var paddingRightX = this.state.getPaddingRight();\n\t\t// if (tendsXMax < paddingRightX) {\n\t\t// \tthis.state.scrollToEnd();\n\t\t// }\n\t}\n\n\tprivate onMouseDown(ev: MouseEvent) {\n\t\tthis.setState({cursor: {dragMode: true, x: ev.clientX, y: ev.clientY}});\n\t}\n\n\tprivate onMouseUp(ev: MouseEvent) {\n\t\tthis.setState({cursor: {dragMode: false}});\n\t}\n\n\tprivate onMouseMove(ev: MouseEvent) {\n\t\tif (this.state.data.cursor.dragMode) {\n\t\t\tthis.setState({cursor: {dragMode: true, x: ev.clientX, y: ev.clientY}});\n\t\t}\n\t}\n\n\tprivate onMouseWheel(ev: MouseWheelEvent) {\n\t\tev.stopPropagation();\n\t\tev.preventDefault();\n\t\tlet zoomOrigin = ev.layerX / this.state.data.width;\n\t\tlet zoomValue = 1 + ev.wheelDeltaY * 0.001;\n\t\tthis.zoom(zoomValue, zoomOrigin);\n\t}\n\n\tprivate onTouchMove(ev: TouchEvent) {\n\t\tthis.setState({cursor: {dragMode: true, x: ev.touches[0].clientX, y: ev.touches[0].clientY}});\n\t}\n\n\tprivate onTouchEnd(ev: TouchEvent) {\n\t\tthis.setState({cursor: {dragMode: false}});\n\t}\n\n\tprivate onChartContainerResizeHandler(width: number, height: number) {\n\t\tthis.setState({width, height});\n\t}\n\n\tprivate onChartResize() {\n\t\tlet {width, height} = this.state.data;\n\t\tthis.renderer.setSize(width, height);\n\t\tthis.setupCamera();\n\t}\n\n\tprivate zoom(zoomValue: number, zoomOrigin: number) {\n\t\tconst MAX_ZOOM_VALUE = 1.5;\n\t\tconst MIN_ZOOM_VALUE = 0.7;\n\t\tzoomValue = Math.min(zoomValue, MAX_ZOOM_VALUE);\n\t\tzoomValue = Math.max(zoomValue, MIN_ZOOM_VALUE);\n\t\tlet autoScrollIsEnabled = this.state.data.autoScroll;\n\t\tif (autoScrollIsEnabled) this.state.setState({autoScroll: false});\n\t\tthis.state.zoom(zoomValue, zoomOrigin).then(() => {\n\t\t\tif (autoScrollIsEnabled) this.setState({autoScroll: true});\n\t\t});\n\t}\n\n\n}\n\n// install built-in widgets\nChart.installWidget(TrendsLineWidget);\nChart.installWidget(TrendsCandlesWidget);\nChart.installWidget(AxisWidget);\nChart.installWidget(GridWidget);\nChart.installWidget(TrendsGradientWidget);\n\n\n/** WEBPACK FOOTER **\n ** ./src/Chart.ts\n **/","import { ChartState, IChartState } from \"./State\";\nimport { Utils } from './Utils';\nimport { EventEmitter } from './EventEmmiter';\nimport { ChartWidget } from './Widget';\n\nexport interface IChartPluginState {\n}\n\nexport interface IChartPluginConfig {\n\tinstallPluginWidgets?: boolean;\n}\n\nexport const DEFAULT_CONFIG: IChartPluginConfig = {\n\tinstallPluginWidgets: true\n};\n\n/**\n * base class for all plugins\n * NAME is mandatory\n */\nexport abstract class ChartPlugin {\n\tstatic NAME: string = '';\n\tstatic providedWidgets: typeof ChartWidget[] = [];\n\n\tinitialState: IChartPluginState;\n\tconfig: IChartPluginConfig;\n\tname: string;\n\tprotected chartState: ChartState;\n\tprotected unsubscribers: Function[] = [];\n\tprotected ee: EventEmitter;\n\n\tconstructor (options?: IChartPluginState, config: IChartPluginConfig = {}) {\n\t\tthis.initialState = options;\n\t\tthis.config = Utils.deepMerge(DEFAULT_CONFIG, config);\n\t\tthis.name = (this.constructor as typeof ChartPlugin).NAME;\n\t\tif (!this.name) Utils.error('Unnamed plugin detected');\n\t}\n\n\tsetupChartState(chartState: ChartState) {\n\t\tthis.chartState = chartState;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.bindEvent(\n\t\t\tthis.chartState.onInitialStateApplied(initialState => this.onInitialStateAppliedHandler(initialState)),\n\t\t\tthis.chartState.onReady(() => this.onReadyHandler()),\n\t\t\tthis.chartState.onDestroy(() => this.onDestroyHandler()),\n\t\t\tthis.chartState.onPluginsStateChange(changedPluginsStates => changedPluginsStates[this.name] && this.onStateChanged(changedPluginsStates[this.name]))\n\t\t)\n\t}\n\n\tgetOptions(): IChartPluginState {\n\t\treturn this.chartState.data.pluginsState[this.name];\n\t}\n\n\tprotected onInitialStateAppliedHandler(initialState: IChartState) {\n\t}\n\n\tprotected onReadyHandler() {\n\t}\n\n\tprotected onStateChanged(changedState: IChartPluginState) {\n\t}\n\n\tprotected onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t}\n\n\tprotected bindEvent(...args: Array<Function | Function[]>): void {\n\t\tlet unsubscribers: Function[] = [];\n\t\tif (!Array.isArray(args[0])) {\n\t\t\tunsubscribers.push(args[0] as Function);\n\t\t} else {\n\t\t\tunsubscribers.push(...args as Function[]);\n\t\t}\n\t\tthis.unsubscribers.push(...unsubscribers);\n\t}\n\n\n\tprotected unbindEvents() {\n\t\tthis.unsubscribers.forEach(unsubscriber => unsubscriber());\n\t\tthis.unsubscribers.length = 0;\n\t}\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Plugin.ts\n **/","import Texture = THREE.Texture;\nimport Color = THREE.Color;\nimport { TIteralable, IIteralable } from \"./interfaces\";\nimport { isPlainObject } from './deps/deps';\n\nfunction deepmerge(target: any, src: any, mergeArrays = true) {\n\tvar array = Array.isArray(src);\n\tvar dst: any = array && [] || {};\n\n\tif (array) {\n\t\ttarget = target || [];\n\t\tif (mergeArrays) {\n\t\t\tdst = dst.concat(target);\n\t\t}\n\t\tsrc.forEach(function(e: any, i: any) {\n\t\t\tif (typeof dst[i] === 'undefined') {\n\t\t\t\tdst[i] = e;\n\t\t\t} else if (typeof e === 'object') {\n\t\t\t\tdst[i] = deepmerge(target[i], e, mergeArrays);\n\t\t\t} else {\n\t\t\t\tif (target.indexOf(e) === -1) {\n\t\t\t\t\tdst.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} else {\n\t\tif (target && typeof target === 'object') {\n\t\t\tObject.keys(target).forEach(function (key) {\n\t\t\t\tdst[key] = target[key];\n\t\t\t})\n\t\t}\n\t\tObject.keys(src).forEach(function (key) {\n\t\t\tif (typeof src[key] !== 'object' || !src[key]) {\n\t\t\t\tdst[key] = src[key];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t} else {\n\t\t\t\t\tdst[key] = deepmerge(target[key], src[key], mergeArrays);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn dst;\n}\n\n\n\nexport declare type TUid = number;\n\n/**\n * project utils static class\n */\nexport class Utils {\n\n\tprivate static currentId: TUid = 1;\n\n\t/**\n\t * deepMerge based on https://www.npmjs.com/package/deepmerge\n\t */\n\tstatic deepMerge<T> (obj1: T, obj2: T, mergeArrays?: boolean) {\n\t\treturn deepmerge(obj1, obj2, mergeArrays) as T;\n\t}\n\n\t/**\n\t * deepCopy based on JSON.stringify function\n\t * @deprecated\n\t */\n\tstatic deepCopy<T> (obj: T) {\n\t\t// TODO: use deepMerge function to copy\n\t\treturn JSON.parse(JSON.stringify(obj)) as T;\n\t}\n\n\t/**\n\t *\n\t * @example\n\t * // returns \"000015\"\n\t * Utils.toFixed(15, 6);\n\t */\n\tstatic toFixed(num: number, digitsCount: number): string {\n\t\tvar maxDigits = 15;\n\t\tvar result = '';\n\t\tvar intVal = Math.floor(num);\n\t\tvar intStr = intVal.toString();\n\t\tvar lengthDiff = digitsCount - intStr.length;\n\t\tif (lengthDiff > 0 ) {\n\t\t\tresult = (<any>'0').repeat(lengthDiff) + intStr;\n\t\t} else {\n\t\t\tresult = intStr;\n\t\t}\n\t\tvar afterPointDigitsCount = maxDigits - intStr.length;\n\t\tvar afterPointStr = num.toString().split('.')[1];\n\t\tif (afterPointStr) {\n\t\t\tresult += '.' + afterPointStr.substr(0, afterPointDigitsCount);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic bindEvent() {\n\n\t}\n\n\t/**\n\t * generate texture from canvas context\n\t * @example\n\t * \t// create texture with rect\n\t *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\n\t */\n\tstatic createTexture(width: number, height: number, fn: (ctx: CanvasRenderingContext2D) => void ): Texture {\n\t\tvar canvas: HTMLCanvasElement = document.createElement('canvas');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\tvar ctx = canvas.getContext('2d');\n\t\tfn(ctx);\n\t\tvar texture = new THREE.Texture(canvas);\n\t\ttexture.needsUpdate = true;\n\t\treturn texture;\n\t}\n\n\t/**\n\t * generate texture from canvas context with NearestFilter\n\t * @example\n\t * \t// create texture with rect\n\t *  var texture = Utils.createTexture(20, 20, (ctx) => {ctx.fillRect(0, 0, 10, 10)});\n\t */\n\tstatic createPixelPerfectTexture(width: number, height: number, fn: (ctx: CanvasRenderingContext2D) => void ): Texture{\n\t\tvar texture = this.createTexture(width, height, fn);\n\t\t// texture.magFilter = THREE.NearestFilter;\n\t\ttexture.minFilter = THREE.NearestFilter;\n\t\treturn texture;\n\t}\n\n\t/**\n\t * throw error\n\t */\n\tstatic error(msg: string) {\n\t\tconsole.error('Chart error: ' + msg);\n\t\tthrow 'Chart: ' + msg;\n\t}\n\n\t/**\n\t * throw error\n\t */\n\tstatic warn(msg: string) {\n\t\tconsole.warn('Chart warning: ' + msg);\n\t}\n\n\t/**\n\t * @returns new unique id\n\t */\n\tstatic getUid(): TUid {\n\t\treturn this.currentId++;\n\t}\n\n\t/**\n\t * @returns distance between numbers\n\t */\n\tstatic getDistance(num1: number, num2: number) {\n\t\treturn Math.max(num1, num2) - Math.min(num1, num2);\n\t}\n\n\tstatic binarySearchClosestInd(arr: IIteralable[], num: number, key: string): number {\n\t\tvar mid: number;\n\t\tvar lo = 0;\n\t\tvar hi = arr.length - 1;\n\t\twhile (hi - lo > 1) {\n\t\t\tmid = Math.floor ((lo + hi) / 2);\n\t\t\tif (arr[mid][key] < num) {\n\t\t\t\tlo = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\tif (num - arr[lo][key] <= arr[hi][key] - num) {\n\t\t\treturn lo;\n\t\t}\n\t\treturn hi;\n\t}\n\t\n\tstatic binarySearchClosest<ArrayItem>(arr: ArrayItem[], num: number, key: string): ArrayItem {\n\t\tlet ind = this.binarySearchClosestInd(arr, num, key);\n\t\treturn arr[ind];\n\t}\n\n\n\tstatic rectsIntersect(r1: number[], r2: number[]) {\n\t\tlet [left1, top1, width1, height1] = r1;\n\t\tlet [left2, top2, width2, height2] = r2;\n\t\tlet [right1, right2, bottom1, bottom2] = [left1 + width1, left2 + width2, top1 + height1, top2 + height2];\n\t\treturn !(left2 > right1 ||\n\t\t\tright2 < left1 ||\n\t\t\ttop2 > bottom1 ||\n\t\t\tbottom2 < top1\n\t\t);\n\t}\n\n\n\tstatic throttle(func: Function, ms: number) {\n\n\t\tvar isThrottled = false,\n\t\t\tsavedArgs: any,\n\t\t\tsavedThis: any;\n\n\t\tfunction wrapper() {\n\n\t\t\tif (isThrottled) { // (2)\n\t\t\t\tsavedArgs = arguments;\n\t\t\t\tsavedThis = this;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfunc.apply(this, arguments); // (1)\n\n\t\t\tisThrottled = true;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tisThrottled = false; // (3)\n\t\t\t\tif (savedArgs) {\n\t\t\t\t\twrapper.apply(savedThis, savedArgs);\n\t\t\t\t\tsavedArgs = savedThis = null;\n\t\t\t\t}\n\t\t\t}, ms);\n\t\t}\n\n\t\treturn wrapper;\n\t}\n\n\tstatic msToTimeString(timestamp: number) {\n\t\tvar h = Math.floor(timestamp / 360000);\n\t\tvar m =  Math.floor(timestamp / 60000);\n\t\tvar s =  Math.floor(timestamp / 1000);\n\t\treturn h + ':' + m + ':' + s;\n\t}\n\t\n\tstatic getRandomItem<T>(arr: Array<T>): T {\n\t\tvar ind = Math.floor(Math.random() * arr.length);\n\t\treturn arr[ind];\n\t}\n\n\tstatic copyProps(srcObject: TIteralable, dstObject: TIteralable, props: TIteralable, excludeProps: string[] = []) {\n\t\tfor (var key in props) {\n\t\t\tif (excludeProps.indexOf(key) !== -1) continue;\n\t\t\tif (srcObject[key] == void 0) continue;\n\t\t\tif (isPlainObject(props[key]) && dstObject[key] !== void 0) {\n\t\t\t\tthis.copyProps(srcObject[key], dstObject[key], props[key])\n\t\t\t} else {\n\t\t\t\tdstObject[key] = this.deepCopy(srcObject[key]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Utils.ts\n **/","/// <reference path=\"./ResizeSensor.ts\" />\n\n// TODO: think about different bundles\n\nimport { ResizeSensorType } from './ResizeSensor';\n(<any>window).TweenLite = TweenMax;\n(<any>window).Stats = require('three/examples/js/libs/stats.min');\n\n//require('gsap/src/uncompressed/easing/EasePack.js');\nrequire('three/examples/js/renderers/CanvasRenderer.js');\nrequire('three/examples/js/renderers/Projector.js');\nexport const isPlainObject = require('is-plain-object') as Function;\nexport const EE2 = require('EventEmitter2') as typeof EventEmitter2;\n\n\nexport { Promise } from '../polyfills/es6-promise';\n\nexport * from './ResizeSensor';\nexport const ResizeSensor = require('css-element-queries/src/ResizeSensor') as ResizeSensorType;\n\n\n/** WEBPACK FOOTER **\n ** ./src/deps/deps.ts\n **/","// stats.js - http://github.com/mrdoob/stats.js\nvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\nif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\nStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\nv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/examples/js/libs/stats.min.js\n ** module id = 6\n ** module chunks = 0 1\n **/","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpriteCanvasMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'SpriteCanvasMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.program = function ( context, color ) {};\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.SpriteCanvasMaterial.prototype.constructor = THREE.SpriteCanvasMaterial;\n\nTHREE.SpriteCanvasMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.SpriteCanvasMaterial();\n\n\tmaterial.copy( this );\n\tmaterial.color.copy( this.color );\n\tmaterial.program = this.program;\n\n\treturn material;\n\n};\n\n//\n\nTHREE.CanvasRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _this = this,\n\t_renderData, _elements, _lights,\n\t_projector = new THREE.Projector(),\n\n\t_canvas = parameters.canvas !== undefined\n\t\t\t ? parameters.canvas\n\t\t\t : document.createElement( 'canvas' ),\n\n\t_canvasWidth = _canvas.width,\n\t_canvasHeight = _canvas.height,\n\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),\n\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),\n\n\t_viewportX = 0,\n\t_viewportY = 0,\n\t_viewportWidth = _canvasWidth,\n\t_viewportHeight = _canvasHeight,\n\n\t_pixelRatio = 1,\n\n\t_context = _canvas.getContext( '2d', {\n\t\talpha: parameters.alpha === true\n\t} ),\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = parameters.alpha === true ? 0 : 1,\n\n\t_contextGlobalAlpha = 1,\n\t_contextGlobalCompositeOperation = 0,\n\t_contextStrokeStyle = null,\n\t_contextFillStyle = null,\n\t_contextLineWidth = null,\n\t_contextLineCap = null,\n\t_contextLineJoin = null,\n\t_contextLineDash = [],\n\n\t_camera,\n\n\t_v1, _v2, _v3, _v4,\n\t_v5 = new THREE.RenderableVertex(),\n\t_v6 = new THREE.RenderableVertex(),\n\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\n\n\t_color = new THREE.Color(),\n\t_color1 = new THREE.Color(),\n\t_color2 = new THREE.Color(),\n\t_color3 = new THREE.Color(),\n\t_color4 = new THREE.Color(),\n\n\t_diffuseColor = new THREE.Color(),\n\t_emissiveColor = new THREE.Color(),\n\n\t_lightColor = new THREE.Color(),\n\n\t_patterns = {},\n\n\t_image, _uvs,\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\n\n\t_clipBox = new THREE.Box2(),\n\t_clearBox = new THREE.Box2(),\n\t_elemBox = new THREE.Box2(),\n\n\t_ambientLight = new THREE.Color(),\n\t_directionalLights = new THREE.Color(),\n\t_pointLights = new THREE.Color(),\n\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\n\t_centroid = new THREE.Vector3(),\n\t_normal = new THREE.Vector3(),\n\t_normalViewMatrix = new THREE.Matrix3();\n\n\t/* TODO\n\t_canvas.mozImageSmoothingEnabled = false;\n\t_canvas.webkitImageSmoothingEnabled = false;\n\t_canvas.msImageSmoothingEnabled = false;\n\t_canvas.imageSmoothingEnabled = false;\n\t*/\n\n\t// dash+gap fallbacks for Firefox and everything else\n\n\tif ( _context.setLineDash === undefined ) {\n\n\t\t_context.setLineDash = function () {};\n\n\t}\n\n\tthis.domElement = _canvas;\n\n\tthis.autoClear = true;\n\tthis.sortObjects = true;\n\tthis.sortElements = true;\n\n\tthis.info = {\n\n\t\trender: {\n\n\t\t\tvertices: 0,\n\t\t\tfaces: 0\n\n\t\t}\n\n\t};\n\n\t// WebGLRenderer compatibility\n\n\tthis.supportsVertexTextures = function () {};\n\tthis.setFaceCulling = function () {};\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _context;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _context.getContextAttributes();\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value !== undefined ) _pixelRatio = value;\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_canvasWidth = width * _pixelRatio;\n\t\t_canvasHeight = height * _pixelRatio;\n\n\t\t_canvas.width = _canvasWidth;\n\t\t_canvas.height = _canvasHeight;\n\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\t_clipBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\n\t\t_clipBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\n\n\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\n\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\n\n\t\t_contextGlobalAlpha = 1;\n\t\t_contextGlobalCompositeOperation = 0;\n\t\t_contextStrokeStyle = null;\n\t\t_contextFillStyle = null;\n\t\t_contextLineWidth = null;\n\t\t_contextLineCap = null;\n\t\t_contextLineJoin = null;\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t_viewportX = x * _pixelRatio;\n\t\t_viewportY = y * _pixelRatio;\n\n\t\t_viewportWidth = width * _pixelRatio;\n\t\t_viewportHeight = height * _pixelRatio;\n\n\t};\n\n\tthis.setScissor = function () {};\n\tthis.setScissorTest = function () {};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\n\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\n\n\t};\n\n\tthis.setClearColorHex = function ( hex, alpha ) {\n\n\t\tconsole.warn( 'THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\t\tthis.setClearColor( hex, alpha );\n\n\t};\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn 0;\n\n\t};\n\n\tthis.clear = function () {\n\n\t\tif ( _clearBox.isEmpty() === false ) {\n\n\t\t\t_clearBox.intersect( _clipBox );\n\t\t\t_clearBox.expandByScalar( 2 );\n\n\t\t\t_clearBox.min.x = _clearBox.min.x + _canvasWidthHalf;\n\t\t\t_clearBox.min.y =  - _clearBox.min.y + _canvasHeightHalf;\t\t// higher y value !\n\t\t\t_clearBox.max.x = _clearBox.max.x + _canvasWidthHalf;\n\t\t\t_clearBox.max.y =  - _clearBox.max.y + _canvasHeightHalf;\t\t// lower y value !\n\n\t\t\tif ( _clearAlpha < 1 ) {\n\n\t\t\t\t_context.clearRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.max.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.min.y - _clearBox.max.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( _clearAlpha > 0 ) {\n\n\t\t\t\tsetBlending( THREE.NormalBlending );\n\t\t\t\tsetOpacity( 1 );\n\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );\n\n\t\t\t\t_context.fillRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.max.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.min.y - _clearBox.max.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t_clearBox.makeEmpty();\n\n\t\t}\n\n\t};\n\n\t// compatibility\n\n\tthis.clearColor = function () {};\n\tthis.clearDepth = function () {};\n\tthis.clearStencil = function () {};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.autoClear === true ) this.clear();\n\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\n\t\t_context.setTransform( _viewportWidth / _canvasWidth, 0, 0, - _viewportHeight / _canvasHeight, _viewportX, _canvasHeight - _viewportY );\n\t\t_context.translate( _canvasWidthHalf, _canvasHeightHalf );\n\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\n\t\t_elements = _renderData.elements;\n\t\t_lights = _renderData.lights;\n\t\t_camera = camera;\n\n\t\t_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );\n\n\t\t/* DEBUG\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n\t\t*/\n\n\t\tcalculateLights();\n\n\t\tfor ( var e = 0, el = _elements.length; e < el; e ++ ) {\n\n\t\t\tvar element = _elements[ e ];\n\n\t\t\tvar material = element.material;\n\n\t\t\tif ( material === undefined || material.opacity === 0 ) continue;\n\n\t\t\t_elemBox.makeEmpty();\n\n\t\t\tif ( element instanceof THREE.RenderableSprite ) {\n\n\t\t\t\t_v1 = element;\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\n\n\t\t\t\trenderSprite( _v1, element, material );\n\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t_v2.positionScreen\n\t\t\t\t] );\n\n\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\n\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( element instanceof THREE.RenderableFace ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\n\n\t\t\t\tif ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) continue;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\tif ( material.overdraw > 0 ) {\n\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen, material.overdraw );\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen, material.overdraw );\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen, material.overdraw );\n\n\t\t\t\t}\n\n\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t_v2.positionScreen,\n\t\t\t\t\t_v3.positionScreen\n\t\t\t\t] );\n\n\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\n\n\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* DEBUG\n\t\t\tsetLineWidth( 1 );\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n\t\t\t*/\n\n\t\t\t_clearBox.union( _elemBox );\n\n\t\t}\n\n\t\t/* DEBUG\n\t\tsetLineWidth( 1 );\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n\t\t*/\n\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n\t};\n\n\t//\n\n\tfunction calculateLights() {\n\n\t\t_ambientLight.setRGB( 0, 0, 0 );\n\t\t_directionalLights.setRGB( 0, 0, 0 );\n\t\t_pointLights.setRGB( 0, 0, 0 );\n\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = _lights[ l ];\n\t\t\tvar lightColor = light.color;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\t_ambientLight.add( lightColor );\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_directionalLights.add( lightColor );\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_pointLights.add( lightColor );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction calculateLight( position, normal, color ) {\n\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = _lights[ l ];\n\n\t\t\t_lightColor.copy( light.color );\n\n\t\t\tif ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\n\n\t\t\t\tvar amount = normal.dot( lightPosition );\n\n\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\n\n\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\n\n\t\t\t\tif ( amount == 0 ) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderSprite( v1, element, material ) {\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\tvar scaleX = element.scale.x * _canvasWidthHalf;\n\t\tvar scaleY = element.scale.y * _canvasHeightHalf;\n\n\t\tvar dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite\n\t\t_elemBox.min.set( v1.x - dist, v1.y - dist );\n\t\t_elemBox.max.set( v1.x + dist, v1.y + dist );\n\n\t\tif ( material instanceof THREE.SpriteMaterial ) {\n\n\t\t\tvar texture = material.map;\n\n\t\t\tif ( texture !== null ) {\n\n\t\t\t\tvar pattern = _patterns[ texture.id ];\n\n\t\t\t\tif ( pattern === undefined || pattern.version !== texture.version ) {\n\n\t\t\t\t\tpattern = textureToPattern( texture );\n\t\t\t\t\t_patterns[ texture.id ] = pattern;\n\n\t\t\t\t}\n\n\t\t\t\tif ( pattern.canvas !== undefined ) {\n\n\t\t\t\t\tsetFillStyle( pattern.canvas );\n\n\t\t\t\t\tvar bitmap = texture.image;\n\n\t\t\t\t\tvar ox = bitmap.width * texture.offset.x;\n\t\t\t\t\tvar oy = bitmap.height * texture.offset.y;\n\n\t\t\t\t\tvar sx = bitmap.width * texture.repeat.x;\n\t\t\t\t\tvar sy = bitmap.height * texture.repeat.y;\n\n\t\t\t\t\tvar cx = scaleX / sx;\n\t\t\t\t\tvar cy = scaleY / sy;\n\n\t\t\t\t\t_context.save();\n\t\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t\t_context.translate( - scaleX / 2, - scaleY / 2 );\n\t\t\t\t\t_context.scale( cx, cy );\n\t\t\t\t\t_context.translate( - ox, - oy );\n\t\t\t\t\t_context.fillRect( ox, oy, sx, sy );\n\t\t\t\t\t_context.restore();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// no texture\n\n\t\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t_context.scale( scaleX, - scaleY );\n\t\t\t\t_context.fillRect( - 0.5, - 0.5, 1, 1 );\n\t\t\t\t_context.restore();\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.SpriteCanvasMaterial ) {\n\n\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t_context.save();\n\t\t\t_context.translate( v1.x, v1.y );\n\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t_context.scale( scaleX, scaleY );\n\n\t\t\tmaterial.program( _context );\n\n\t\t\t_context.restore();\n\n\t\t}\n\n\t\t/* DEBUG\n\t\tsetStrokeStyle( 'rgb(255,255,0)' );\n\t\t_context.beginPath();\n\t\t_context.moveTo( v1.x - 10, v1.y );\n\t\t_context.lineTo( v1.x + 10, v1.y );\n\t\t_context.moveTo( v1.x, v1.y - 10 );\n\t\t_context.lineTo( v1.x, v1.y + 10 );\n\t\t_context.stroke();\n\t\t*/\n\n\t}\n\n\tfunction renderLine( v1, v2, element, material ) {\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\t_context.beginPath();\n\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\n\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\n\n\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\tsetLineWidth( material.linewidth );\n\t\t\tsetLineCap( material.linecap );\n\t\t\tsetLineJoin( material.linejoin );\n\n\t\t\tif ( material.vertexColors !== THREE.VertexColors ) {\n\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\n\t\t\t} else {\n\n\t\t\t\tvar colorStyle1 = element.vertexColors[ 0 ].getStyle();\n\t\t\t\tvar colorStyle2 = element.vertexColors[ 1 ].getStyle();\n\n\t\t\t\tif ( colorStyle1 === colorStyle2 ) {\n\n\t\t\t\t\tsetStrokeStyle( colorStyle1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tvar grad = _context.createLinearGradient(\n\t\t\t\t\t\t\tv1.positionScreen.x,\n\t\t\t\t\t\t\tv1.positionScreen.y,\n\t\t\t\t\t\t\tv2.positionScreen.x,\n\t\t\t\t\t\t\tv2.positionScreen.y\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgrad.addColorStop( 0, colorStyle1 );\n\t\t\t\t\t\tgrad.addColorStop( 1, colorStyle2 );\n\n\t\t\t\t\t} catch ( exception ) {\n\n\t\t\t\t\t\tgrad = colorStyle1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsetStrokeStyle( grad );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_context.stroke();\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\tsetLineWidth( material.linewidth );\n\t\t\tsetLineCap( material.linecap );\n\t\t\tsetLineJoin( material.linejoin );\n\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\tsetLineDash( [ material.dashSize, material.gapSize ] );\n\n\t\t\t_context.stroke();\n\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t\tsetLineDash( [] );\n\n\t\t}\n\n\t}\n\n\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\n\n\t\t_this.info.render.vertices += 3;\n\t\t_this.info.render.faces ++;\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\n\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\n\n\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\n\n\t\t\t_diffuseColor.copy( material.color );\n\t\t\t_emissiveColor.copy( material.emissive );\n\n\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t_diffuseColor.multiply( element.color );\n\n\t\t\t}\n\n\t\t\t_color.copy( _ambientLight );\n\n\t\t\t_centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );\n\n\t\t\tcalculateLight( _centroid, element.normalModel, _color );\n\n\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\n\n\t\t\tmaterial.wireframe === true\n\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t : fillPath( _color );\n\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t    material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t    material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tvar mapping = material.map.mapping;\n\n\t\t\t\tif ( mapping === THREE.UVMapping ) {\n\n\t\t\t\t\t_uvs = element.uvs;\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material.envMap !== null ) {\n\n\t\t\t\tif ( material.envMap.mapping === THREE.SphericalReflectionMapping ) {\n\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );\n\t\t\t\t\t_uv1x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t_uv1y = 0.5 * _normal.y + 0.5;\n\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );\n\t\t\t\t\t_uv2x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t_uv2y = 0.5 * _normal.y + 0.5;\n\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );\n\t\t\t\t\t_uv3x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t_uv3y = 0.5 * _normal.y + 0.5;\n\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_color.copy( material.color );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_color.multiply( element.color );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t : fillPath( _color );\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );\n\n\t\t\t_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\tmaterial.wireframe === true\n\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t : fillPath( _color );\n\n\t\t} else {\n\n\t\t\t_color.setRGB( 1, 1, 1 );\n\n\t\t\tmaterial.wireframe === true\n\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t : fillPath( _color );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\n\n\t\t_context.beginPath();\n\t\t_context.moveTo( x0, y0 );\n\t\t_context.lineTo( x1, y1 );\n\t\t_context.lineTo( x2, y2 );\n\t\t_context.closePath();\n\n\t}\n\n\tfunction strokePath( color, linewidth, linecap, linejoin ) {\n\n\t\tsetLineWidth( linewidth );\n\t\tsetLineCap( linecap );\n\t\tsetLineJoin( linejoin );\n\t\tsetStrokeStyle( color.getStyle() );\n\n\t\t_context.stroke();\n\n\t\t_elemBox.expandByScalar( linewidth * 2 );\n\n\t}\n\n\tfunction fillPath( color ) {\n\n\t\tsetFillStyle( color.getStyle() );\n\t\t_context.fill();\n\n\t}\n\n\tfunction textureToPattern( texture ) {\n\n\t\tif ( texture.version === 0 ||\n\t\t\ttexture instanceof THREE.CompressedTexture ||\n\t\t\ttexture instanceof THREE.DataTexture ) {\n\n\t\t\treturn {\n\t\t\t\tcanvas: undefined,\n\t\t\t\tversion: texture.version\n\t\t\t};\n\n\t\t}\n\n\t\tvar image = texture.image;\n\n\t\tif ( image.complete === false ) {\n\n\t\t\treturn {\n\t\t\t\tcanvas: undefined,\n\t\t\t\tversion: 0\n\t\t\t};\n\n\t\t}\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = image.width;\n\t\tcanvas.height = image.height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.setTransform( 1, 0, 0, - 1, 0, image.height );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\tvar repeatX = texture.wrapS === THREE.RepeatWrapping;\n\t\tvar repeatY = texture.wrapT === THREE.RepeatWrapping;\n\n\t\tvar repeat = 'no-repeat';\n\n\t\tif ( repeatX === true && repeatY === true ) {\n\n\t\t\trepeat = 'repeat';\n\n\t\t} else if ( repeatX === true ) {\n\n\t\t\trepeat = 'repeat-x';\n\n\t\t} else if ( repeatY === true ) {\n\n\t\t\trepeat = 'repeat-y';\n\n\t\t}\n\n\t\tvar pattern = _context.createPattern( canvas, repeat );\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\treturn {\n\t\t\tcanvas: pattern,\n\t\t\tversion: texture.version\n\t\t};\n\n\t}\n\n\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\n\n\t\tvar pattern = _patterns[ texture.id ];\n\n\t\tif ( pattern === undefined || pattern.version !== texture.version ) {\n\n\t\t\tpattern = textureToPattern( texture );\n\t\t\t_patterns[ texture.id ] = pattern;\n\n\t\t}\n\n\t\tif ( pattern.canvas !== undefined ) {\n\n\t\t\tsetFillStyle( pattern.canvas );\n\n\t\t} else {\n\n\t\t\tsetFillStyle( 'rgba( 0, 0, 0, 1)' );\n\t\t\t_context.fill();\n\t\t\treturn;\n\n\t\t}\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a, b, c, d, e, f, det, idet,\n\t\toffsetX = texture.offset.x / texture.repeat.x,\n\t\toffsetY = texture.offset.y / texture.repeat.y,\n\t\twidth = texture.image.width * texture.repeat.x,\n\t\theight = texture.image.height * texture.repeat.y;\n\n\t\tu0 = ( u0 + offsetX ) * width;\n\t\tv0 = ( v0 + offsetY ) * height;\n\n\t\tu1 = ( u1 + offsetX ) * width;\n\t\tv1 = ( v1 + offsetY ) * height;\n\n\t\tu2 = ( u2 + offsetX ) * width;\n\t\tv2 = ( v2 + offsetY ) * height;\n\n\t\tx1 -= x0; y1 -= y0;\n\t\tx2 -= x0; y2 -= y0;\n\n\t\tu1 -= u0; v1 -= v0;\n\t\tu2 -= u0; v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tif ( det === 0 ) return;\n\n\t\tidet = 1 / det;\n\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform( a, b, c, d, e, f );\n\t\t_context.fill();\n\t\t_context.restore();\n\n\t}\n\n\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a, b, c, d, e, f, det, idet,\n\t\twidth = image.width - 1,\n\t\theight = image.height - 1;\n\n\t\tu0 *= width; v0 *= height;\n\t\tu1 *= width; v1 *= height;\n\t\tu2 *= width; v2 *= height;\n\n\t\tx1 -= x0; y1 -= y0;\n\t\tx2 -= x0; y2 -= y0;\n\n\t\tu1 -= u0; v1 -= v0;\n\t\tu2 -= u0; v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tidet = 1 / det;\n\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform( a, b, c, d, e, f );\n\t\t_context.clip();\n\t\t_context.drawImage( image, 0, 0 );\n\t\t_context.restore();\n\n\t}\n\n\t// Hide anti-alias gaps\n\n\tfunction expand( v1, v2, pixels ) {\n\n\t\tvar x = v2.x - v1.x, y = v2.y - v1.y,\n\t\tdet = x * x + y * y, idet;\n\n\t\tif ( det === 0 ) return;\n\n\t\tidet = pixels / Math.sqrt( det );\n\n\t\tx *= idet; y *= idet;\n\n\t\tv2.x += x; v2.y += y;\n\t\tv1.x -= x; v1.y -= y;\n\n\t}\n\n\t// Context cached methods.\n\n\tfunction setOpacity( value ) {\n\n\t\tif ( _contextGlobalAlpha !== value ) {\n\n\t\t\t_context.globalAlpha = value;\n\t\t\t_contextGlobalAlpha = value;\n\n\t\t}\n\n\t}\n\n\tfunction setBlending( value ) {\n\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\n\n\t\t\tif ( value === THREE.NormalBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'darker';\n\n\t\t\t} else if ( value === THREE.MultiplyBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'multiply';\n\n\t\t\t}\n\n\t\t\t_contextGlobalCompositeOperation = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineWidth( value ) {\n\n\t\tif ( _contextLineWidth !== value ) {\n\n\t\t\t_context.lineWidth = value;\n\t\t\t_contextLineWidth = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineCap( value ) {\n\n\t\t// \"butt\", \"round\", \"square\"\n\n\t\tif ( _contextLineCap !== value ) {\n\n\t\t\t_context.lineCap = value;\n\t\t\t_contextLineCap = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineJoin( value ) {\n\n\t\t// \"round\", \"bevel\", \"miter\"\n\n\t\tif ( _contextLineJoin !== value ) {\n\n\t\t\t_context.lineJoin = value;\n\t\t\t_contextLineJoin = value;\n\n\t\t}\n\n\t}\n\n\tfunction setStrokeStyle( value ) {\n\n\t\tif ( _contextStrokeStyle !== value ) {\n\n\t\t\t_context.strokeStyle = value;\n\t\t\t_contextStrokeStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setFillStyle( value ) {\n\n\t\tif ( _contextFillStyle !== value ) {\n\n\t\t\t_context.fillStyle = value;\n\t\t\t_contextFillStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineDash( value ) {\n\n\t\tif ( _contextLineDash.length !== value.length ) {\n\n\t\t\t_context.setLineDash( value );\n\t\t\t_contextLineDash = value;\n\n\t\t}\n\n\t}\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/examples/js/renderers/CanvasRenderer.js\n ** module id = 7\n ** module chunks = 0 1\n **/","/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\tthis.z = 0;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.RenderableFace = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.normalModel = new THREE.Vector3();\n\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsLength = 0;\n\n\tthis.color = new THREE.Color();\n\tthis.material = null;\n\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\n\n\tthis.z = 0;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.RenderableVertex = function () {\n\n\tthis.position = new THREE.Vector3();\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n};\n\n//\n\nTHREE.RenderableLine = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\tthis.material = null;\n\n\tthis.z = 0;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.RenderableSprite = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\n\tthis.rotation = 0;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\n\t_renderData = { objects: [], lights: [], elements: [] },\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t_boundingBox = new THREE.Box3(),\n\t_points3 = new Array( 3 ),\n\t_points4 = new Array( 4 ),\n\n\t_viewMatrix = new THREE.Matrix4(),\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\n\t_modelMatrix,\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_normalMatrix = new THREE.Matrix3(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\n\t//\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n\t//\n\n\tvar RenderList = function () {\n\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tvar object = null;\n\t\tvar material = null;\n\n\t\tvar normalMatrix = new THREE.Matrix3();\n\n\t\tfunction setObject( value ) {\n\n\t\t\tobject = value;\n\t\t\tmaterial = object.material;\n\n\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\n\n\t\t\tnormals.length = 0;\n\t\t\tuvs.length = 0;\n\n\t\t}\n\n\t\tfunction projectVertex( vertex ) {\n\n\t\t\tvar position = vertex.position;\n\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\tvar positionScreen = vertex.positionScreen;\n\n\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\n\t\t\tvar invW = 1 / positionScreen.w;\n\n\t\t\tpositionScreen.x *= invW;\n\t\t\tpositionScreen.y *= invW;\n\t\t\tpositionScreen.z *= invW;\n\n\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\n\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\n\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\n\n\t\t}\n\n\t\tfunction pushVertex( x, y, z ) {\n\n\t\t\t_vertex = getNextVertexInPool();\n\t\t\t_vertex.position.set( x, y, z );\n\n\t\t\tprojectVertex( _vertex );\n\n\t\t}\n\n\t\tfunction pushNormal( x, y, z ) {\n\n\t\t\tnormals.push( x, y, z );\n\n\t\t}\n\n\t\tfunction pushUv( x, y ) {\n\n\t\t\tuvs.push( x, y );\n\n\t\t}\n\n\t\tfunction checkTriangleVisibility( v1, v2, v3 ) {\n\n\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\n\n\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t_points3[ 2 ] = v3.positionScreen;\n\n\t\t\treturn _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );\n\n\t\t}\n\n\t\tfunction checkBackfaceCulling( v1, v2, v3 ) {\n\n\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t}\n\n\t\tfunction pushLine( a, b ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\n\t\t\t_line = getNextLineInPool();\n\n\t\t\t_line.id = object.id;\n\t\t\t_line.v1.copy( v1 );\n\t\t\t_line.v2.copy( v2 );\n\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\n\t\t\t_line.renderOrder = object.renderOrder;\n\n\t\t\t_line.material = object.material;\n\n\t\t\t_renderData.elements.push( _line );\n\n\t\t}\n\n\t\tfunction pushTriangle( a, b, c ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\t\t\tvar v3 = _vertexPool[ c ];\n\n\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\n\n\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\n\n\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t_face.id = object.id;\n\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\t\t\t_face.renderOrder = object.renderOrder;\n\n\t\t\t\t// use first vertex normal as face normal\n\n\t\t\t\t_face.normalModel.fromArray( normals, a * 3 );\n\t\t\t\t_face.normalModel.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\n\t\t\t\t\tnormal.fromArray( normals, arguments[ i ] * 3 );\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\tvar uv = _face.uvs[ i ];\n\t\t\t\t\tuv.fromArray( uvs, arguments[ i ] * 2 );\n\n\t\t\t\t}\n\n\t\t\t\t_face.vertexNormalsLength = 3;\n\n\t\t\t\t_face.material = object.material;\n\n\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetObject: setObject,\n\t\t\tprojectVertex: projectVertex,\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\tpushVertex: pushVertex,\n\t\t\tpushNormal: pushNormal,\n\t\t\tpushUv: pushUv,\n\t\t\tpushLine: pushLine,\n\t\t\tpushTriangle: pushTriangle\n\t\t}\n\n\t};\n\n\tvar renderList = new RenderList();\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\t_faceCount = 0;\n\t\t_lineCount = 0;\n\t\t_spriteCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\t//\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tfunction addObject( object ) {\n\n\t\t\t_object = getNextObjectInPool();\n\t\t\t_object.id = object.id;\n\t\t\t_object.object = object;\n\n\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t_object.z = _vector3.z;\n\t\t\t_object.renderOrder = object.renderOrder;\n\n\t\t\t_renderData.objects.push( _object );\n\n\t\t}\n\n\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\t_renderData.lights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\n\t\t\t\tif ( object.material.visible === false ) return;\n\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) return;\n\n\t\t\t\taddObject( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.material.visible === false ) return;\n\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) return;\n\n\t\t\t\taddObject( object );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( sortObjects === true ) {\n\n\t\t\t_renderData.objects.sort( painterSort );\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\n\t\t\tvar object = _renderData.objects[ o ].object;\n\t\t\tvar geometry = object.geometry;\n\n\t\t\trenderList.setObject( object );\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\tif ( attributes.position === undefined ) continue;\n\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.normal !== undefined ) {\n\n\t\t\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\tvar indices = geometry.index.array;\n\n\t\t\t\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\t\t\t\tfor ( var o = 0; o < groups.length; o ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\t\t\t\t\tfor ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\n\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ v ];\n\n\t\t\t\t\t\t_vector3.copy( vertex );\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\n\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\n\n\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\n\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\n\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\n\t\t\t\t\t\tmaterial = isFaceMaterial === true\n\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t\t : object.material;\n\n\t\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\n\n\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\n\n\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\n\n\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\n\n\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\n\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t_face.normalModel.copy( face.normal );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t_face.normalModel.negate();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t\tnormalModel.negate();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\n\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\n\n\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\t\t\t\t\t_face.renderOrder = object.renderOrder;\n\n\t\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\n\t\t\t\t\tif ( attributes.position !== undefined ) {\n\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\t\tvar indices = geometry.index.array;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\n\t\t\t\t\tvar vertices = object.geometry.vertices;\n\n\t\t\t\t\tif ( vertices.length === 0 ) continue;\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t\t_line = getNextLineInPool();\n\n\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\t\t\t\t\t\t\t_line.renderOrder = object.renderOrder;\n\n\t\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\n\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\n\t\t\t\tvar invW = 1 / _vector4.w;\n\n\t\t\t\t_vector4.z *= invW;\n\n\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\n\n\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t_sprite.renderOrder = object.renderOrder;\n\t\t\t\t\t_sprite.object = object;\n\n\t\t\t\t\t_sprite.rotation = object.rotation;\n\n\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\n\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\n\n\t\t\t\t\t_sprite.material = object.material;\n\n\t\t\t\t\t_renderData.elements.push( _sprite );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) {\n\n\t\t\t_renderData.elements.sort( painterSort );\n\n\t\t}\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFaceInPool() {\n\n\t\tif ( _faceCount === _facePoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t_facePool.push( face );\n\t\t\t_facePoolLength ++;\n\t\t\t_faceCount ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _facePool[ _faceCount ++ ];\n\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++;\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextSpriteInPool() {\n\n\t\tif ( _spriteCount === _spritePoolLength ) {\n\n\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t_spritePool.push( sprite );\n\t\t\t_spritePoolLength ++;\n\t\t\t_spriteCount ++;\n\t\t\treturn sprite;\n\n\t\t}\n\n\t\treturn _spritePool[ _spriteCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else if ( a.id !== b.id ) {\n\n\t\t\treturn a.id - b.id;\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/examples/js/renderers/Projector.js\n ** module id = 8\n ** module chunks = 0 1\n **/","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n  \n  if (isObjectObject(o) === false) return false;\n  \n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n  \n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n  \n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n  \n  // Most likely a plain Object\n  return true;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-plain-object/index.js\n ** module id = 9\n ** module chunks = 0 1\n **/","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object'\n    && !Array.isArray(val);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isobject/index.js\n ** module id = 10\n ** module chunks = 0 1\n **/","/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || !!this._all;\n    }\n    else {\n      return !!this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  }\n  else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/EventEmitter2/lib/eventemitter2.js\n ** module id = 11\n ** module chunks = 0 1\n **/","module.exports = {Promise: window['Promise']}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/polyfills/es6-promise.js\n ** module id = 12\n ** module chunks = 0 1\n **/","/**\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n;\n(function() {\n\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n    var ResizeSensor = function(element, callback) {\n        /**\n         *\n         * @constructor\n         */\n        function EventQueue() {\n            this.q = [];\n            this.add = function(ev) {\n                this.q.push(ev);\n            };\n\n            var i, j;\n            this.call = function() {\n                for (i = 0, j = this.q.length; i < j; i++) {\n                    this.q[i].call();\n                }\n            };\n        }\n\n        /**\n         * @param {HTMLElement} element\n         * @param {String}      prop\n         * @returns {String|Number}\n         */\n        function getComputedStyle(element, prop) {\n            if (element.currentStyle) {\n                return element.currentStyle[prop];\n            } else if (window.getComputedStyle) {\n                return window.getComputedStyle(element, null).getPropertyValue(prop);\n            } else {\n                return element.style[prop];\n            }\n        }\n\n        /**\n         *\n         * @param {HTMLElement} element\n         * @param {Function}    resized\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element.resizedAttached) {\n                element.resizedAttached = new EventQueue();\n                element.resizedAttached.add(resized);\n            } else if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.className = 'resize-sensor';\n            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n            element.resizeSensor.style.cssText = style;\n            element.resizeSensor.innerHTML =\n                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + '\"></div>' +\n                '</div>' +\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n                '</div>';\n            element.appendChild(element.resizeSensor);\n\n            if (!{fixed: 1, absolute: 1}[getComputedStyle(element, 'position')]) {\n                element.style.position = 'relative';\n            }\n\n            var expand = element.resizeSensor.childNodes[0];\n            var expandChild = expand.childNodes[0];\n            var shrink = element.resizeSensor.childNodes[1];\n            var shrinkChild = shrink.childNodes[0];\n\n            var lastWidth, lastHeight;\n\n            var reset = function() {\n                expandChild.style.width = expand.offsetWidth + 10 + 'px';\n                expandChild.style.height = expand.offsetHeight + 10 + 'px';\n                expand.scrollLeft = expand.scrollWidth;\n                expand.scrollTop = expand.scrollHeight;\n                shrink.scrollLeft = shrink.scrollWidth;\n                shrink.scrollTop = shrink.scrollHeight;\n                lastWidth = element.offsetWidth;\n                lastHeight = element.offsetHeight;\n            };\n\n            reset();\n\n            var changed = function() {\n                if (element.resizedAttached) {\n                    element.resizedAttached.call();\n                }\n            };\n\n            var addEvent = function(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent('on' + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            var onScroll = function() {\n              if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {\n                  changed();\n              }\n              reset();\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n        }\n\n        var elementType = Object.prototype.toString.call(element);\n        var isCollectionTyped = ('[object Array]' === elementType\n            || ('[object NodeList]' === elementType)\n            || ('[object HTMLCollection]' === elementType)\n            || ('undefined' !== typeof jQuery && element instanceof jQuery) //jquery\n            || ('undefined' !== typeof Elements && element instanceof Elements) //mootools\n        );\n\n        if (isCollectionTyped) {\n            var i = 0, j = element.length;\n            for (; i < j; i++) {\n                attachResizeEvent(element[i], callback);\n            }\n        } else {\n            attachResizeEvent(element, callback);\n        }\n\n        this.detach = function() {\n            if (isCollectionTyped) {\n                var i = 0, j = element.length;\n                for (; i < j; i++) {\n                    ResizeSensor.detach(element[i]);\n                }\n            } else {\n                ResizeSensor.detach(element);\n            }\n        };\n    };\n\n    ResizeSensor.detach = function(element) {\n        if (element.resizeSensor) {\n            element.removeChild(element.resizeSensor);\n            delete element.resizeSensor;\n            delete element.resizedAttached;\n        }\n    };\n\n    // make available to common module loader\n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n        module.exports = ResizeSensor;\n    }\n    else {\n        window.ResizeSensor = ResizeSensor;\n    }\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-element-queries/src/ResizeSensor.js\n ** module id = 13\n ** module chunks = 0 1\n **/","import {EE2} from './deps/deps';\n\n/**\n * this class uses as proxy for EventEmitter2\n */\nexport class EventEmitter {\n\tprivate ee: EventEmitter2;\n\tconstructor() {\n\t\tthis.ee = new EE2();\n\t}\n\temit(eventName: string, ...args: any[]) {\n\t\tthis.ee.emit(eventName, ...args)\n\t}\n\ton(eventName: string, callback: Function) {\n\t\treturn this.ee.on(eventName, callback)\n\t}\n\toff(eventName: string, callback: Function) {\n\t\treturn this.ee.off(eventName, callback);\n\t}\n\tsubscribe(eventName: string, callback: Function): Function {\n\t\tthis.on(eventName, callback);\n\t\treturn () => this.off(eventName, callback);\n\t}\n\tsetMaxListeners(listenersCount: number) {\n\t\tthis.ee.setMaxListeners(listenersCount);\n\t}\n\tremoveAllListeners(eventName?: string) {\n\t\tthis.ee.removeAllListeners(eventName);\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/EventEmmiter.ts\n **/","import Vector3 = THREE.Vector3;\nimport { ITrendOptions, Trend, ITrendData, TREND_TYPE } from \"./Trend\";\nimport {EventEmitter} from './EventEmmiter';\nimport {Utils} from './Utils';\nimport {TrendsManager, ITrendsOptions} from \"./TrendsManager\";\nimport {Screen} from \"./Screen\";\nimport {AxisMarks} from \"./AxisMarks\";\nimport {\n\tAXIS_TYPE, AXIS_DATA_TYPE, IAxisOptions, IAnimationsOptions, AXIS_RANGE_TYPE\n} from \"./interfaces\";\nimport { Promise } from './deps/deps';\nimport { ChartPlugin } from './Plugin';\n\n\ninterface IRecalculatedStateResult {\n\tchangedProps: IChartState,\n\tpatch: IChartState\n}\n\nconst CHART_STATE_EVENTS = {\n\tINITIAL_STATE_APPLIED: 'initialStateApplied',\n\tREADY: 'ready',\n\tDESTROY: 'destroy',\n\tCHANGE: 'change',\n\tTREND_CHANGE: 'trendChange',\n\tTRENDS_CHANGE: 'trendsChange',\n\tZOOM: 'zoom',\n\tRESIZE: 'resize',\n\tSCROLL: 'scroll',\n\tSCROLL_STOP: 'scrollStop',\n\tPLUGINS_STATE_CHANGED: 'pluginsStateChanged'\n};\n\n/**\n * readonly computed state data\n * calculated after recalculateState() call\n * contains cached values\n */\nexport interface IChartStateComputedData {\n\ttrends?: {\n\t\tmaxXVal: number,\n\t\tminXVal: number\n\t}\n}\n\nexport interface IChartState {\n\tprevState?: IChartState,\n\twidth?: number;\n\theight?: number;\n\tzoom?: number;\n\txAxis?: IAxisOptions,\n\tyAxis?: IAxisOptions,\n\tanimations?: IAnimationsOptions,\n\ttrends?: ITrendsOptions,\n\ttrendDefaultState?: ITrendOptions;\n\tcursor?: {\n\t\tdragMode?: boolean,\n\t\tx?: number,\n\t\ty?: number\n\t},\n\n\t/**\n\t * use fps = 0 for no limits\n\t */\n\tautoRender?: {enabled?: boolean, fps?: number};\n\n\t/**\n\t * by default 'WebGLRenderer'\n\t * also available 'CanvasRenderer'\n\t */\n\trenderer?: 'WebGLRenderer' | 'CanvasRenderer';\n\n\n\t/**\n\t * buffer size for displayed segments\n\t * used by widgets\n\t */\n\tmaxVisibleSegments?: number;\n\tautoResize?: boolean;\n\tcontrols?: {enabled: boolean};\n\tautoScroll?: boolean;\n\tshowStats?: boolean;\n\tbackgroundColor?: number;\n\tbackgroundOpacity?: number;\n\tcomputedData?: IChartStateComputedData,\n\tpluginsState?: {[pluginName: string]: any};\n\teventEmitterMaxListeners?: number;\n}\n\n/**\n *  class for manage chart state, all state changes caused only by State.setState method\n */\nexport class ChartState {\n\n\tdata: IChartState = {\n\t\tprevState: {},\n\t\tzoom: 0,\n\t\txAxis: {\n\t\t\trange: {\n\t\t\t\ttype: AXIS_RANGE_TYPE.ALL,\n\t\t\t\tfrom: 0,\n\t\t\t\tto: 0,\n\t\t\t\tscroll: 0,\n\t\t\t\tzoom: 1,\n\t\t\t\tpadding: {start: 0, end: 5},\n\t\t\t\tmargin: {start: 0, end: 5}\n\t\t\t},\n\t\t\tdataType: AXIS_DATA_TYPE.NUMBER,\n\t\t\tgrid: {enabled: true, minSizePx:  100},\n\t\t\tautoScroll: true,\n\t\t\tmarks: [],\n\t\t},\n\t\tyAxis: {\n\t\t\trange: {\n\t\t\t\ttype: AXIS_RANGE_TYPE.RELATIVE_END,\n\t\t\t\tfrom: 0,\n\t\t\t\tto: 0,\n\t\t\t\tzoom: 1,\n\t\t\t\tpadding: {start: 5, end: 5},\n\t\t\t\tmargin: {start: 5, end: 5},\n\t\t\t},\n\t\t\tgrid: {enabled: true, minSizePx:  50},\n\t\t\tdataType: AXIS_DATA_TYPE.NUMBER,\n\t\t\tmarks: []\n\t\t},\n\t\tanimations: {\n\t\t\tenabled: true,\n\t\t\ttrendChangeSpeed: 0.5,\n\t\t\ttrendChangeEase: void 0,\n\t\t\tzoomSpeed: 0.25,\n\t\t\tzoomEase:  void 0,\n\t\t\tscrollSpeed: 0.5,\n\t\t\tscrollEase: Linear.easeNone,\n\t\t\tautoScrollSpeed: 1,\n\t\t\tautoScrollEase: Linear.easeNone,\n\t\t},\n\t\tautoRender: {enabled: true, fps: 0},\n\t\tautoResize: true,\n\t\trenderer: 'WebGLRenderer',\n\t\tautoScroll: true,\n\t\tcontrols: {enabled: true},\n\t\ttrendDefaultState: {\n\t\t\tenabled: true,\n\t\t\ttype: TREND_TYPE.LINE,\n\t\t\tdata: [],\n\t\t\tmaxSegmentLength: 1000,\n\t\t\tlineWidth: 2,\n\t\t\tlineColor: 0xFFFFFF,\n\t\t\thasBackground: false,\n\t\t\tbackgroundColor: 'rgba(#5273BD, 0.15)',\n\t\t\thasBeacon: false,\n\t\t\tsettingsForTypes: {\n\t\t\t\tCANDLE: {\n\t\t\t\t\tminSegmentLengthInPx: 20,\n\t\t\t\t\tmaxSegmentLengthInPx: 40,\n\t\t\t\t},\n\t\t\t\tLINE: {\n\t\t\t\t\tminSegmentLengthInPx: 2,\n\t\t\t\t\tmaxSegmentLengthInPx: 10,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcursor: {\n\t\t\tdragMode: false,\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t},\n\t\tbackgroundColor: 0x000000,\n\t\tbackgroundOpacity: 1,\n\t\tshowStats: false,\n\t\tpluginsState: {},\n\t\teventEmitterMaxListeners: 20,\n\t\tmaxVisibleSegments: 1280\n\t};\n\tplugins: {[pluginName: string]: ChartPlugin} = {};\n\ttrendsManager: TrendsManager;\n\tscreen: Screen;\n\txAxisMarks: AxisMarks;\n\tyAxisMarks: AxisMarks;\n\n\t/**\n\t * true then chartState was initialized and ready to use\n\t */\n\tisReady = false;\n\n\n\tprivate ee: EventEmitter;\n\n\tconstructor(\n\t\tinitialState: IChartState,\n\t\tplugins: ChartPlugin[] = []\n\t) {\n\t\tthis.ee = new EventEmitter();\n\t\tthis.ee.setMaxListeners(initialState.eventEmitterMaxListeners || this.data.eventEmitterMaxListeners);\n\n\t\tthis.data = Utils.deepMerge(this.data, initialState);\n\t\tthis.trendsManager = new TrendsManager(this, initialState);\n\t\tinitialState.trends = this.trendsManager.calculatedOptions;\n\t\tinitialState = this.installPlugins(plugins, initialState);\n\t\tthis.setState(initialState);\n\t\tthis.setState({computedData: this.getComputedData()});\n\t\tthis.savePrevState();\n\n\t\tthis.screen = new Screen(this);\n\t\tthis.xAxisMarks = new AxisMarks(this, AXIS_TYPE.X);\n\t\tthis.yAxisMarks = new AxisMarks(this, AXIS_TYPE.Y);\n\t\tthis.initListeners();\n\t\t\n\t\t// message to other modules that ChartState.data is ready for use \n\t\tthis.ee.emit(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, initialState);\n\n\t\t// message to other modules that ChartState is ready for use\n\t\tthis.isReady = true;\n\t\tthis.ee.emit(CHART_STATE_EVENTS.READY, initialState);\n\t}\n\n\t/**\n\t * destroy state, use Chart.destroy to completely destroy chart\n\t */\n\tdestroy() {\n\t\tthis.ee.emit(CHART_STATE_EVENTS.DESTROY);\n\t\tthis.ee.removeAllListeners();\n\t\tthis.data = {};\n\t}\n\n\tonDestroy(cb: Function) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.DESTROY, cb);\n\t}\n\n\tonInitialStateApplied(cb: (initialState: IChartState) => void ): Function {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.INITIAL_STATE_APPLIED, cb);\n\t}\n\n\tonReady(cb: (initialState: IChartState) => void ): Function {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.READY, cb);\n\t}\n\n\tonChange(cb: (changedProps: IChartState) => void ) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.CHANGE, cb);\n\t}\n\n\tonTrendChange(cb: (trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.TREND_CHANGE, cb);\n\t}\n\n\tonTrendsChange(cb: (trendsOptions: ITrendsOptions) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.TRENDS_CHANGE, cb);\n\t}\n\n\tonScrollStop(cb: () => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.SCROLL_STOP, cb);\n\t}\n\n\tonScroll(cb: (scrollOptions: {deltaX: number}) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.SCROLL, cb);\n\t}\n\n\tonZoom(cb: (changedProps: IChartState) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.ZOOM, cb);\n\t}\n\n\tonResize(cb: (changedProps: IChartState) => void) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.RESIZE, cb);\n\t}\n\n\tonPluginsStateChange(cb: (changedPluginsStates: {[pluginName: string]: Plugin}) => any) {\n\t\treturn this.ee.subscribe(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, cb);\n\t}\n\t\n\tgetTrend(trendName: string): Trend {\n\t\treturn this.trendsManager.getTrend(trendName);\n\t}\n\n\tsetState(newState: IChartState, eventData?: any, silent = false) {\n\t\tlet stateData = this.data as {[key: string]: any};\n\t\tlet newStateObj = newState as {[key: string]: any};\n\n\t\tvar changedProps: {[key: string]: any} = {};\n\t\tfor (let key in newStateObj) {\n\t\t\tif (stateData[key] !== newStateObj[key]) {\n\t\t\t\tchangedProps[key] = newStateObj[key] as any;\n\t\t\t}\n\t\t}\n\n\t\tthis.savePrevState(changedProps as IChartState);\n\n\n\t\t// temporary remove trends data from newState by performance reasons\n\t\tlet trendsData: {[trendName: string]: ITrendData} = {};\n\t\tif (newState.trends) for (let trendName in newState.trends) {\n\t\t\tlet trendOptions = newState.trends[trendName];\n\t\t\tif (trendOptions.data) trendsData[trendName] = trendOptions.data;\n\t\t\tdelete trendOptions.data;\n\t\t}\n\t\tlet newStateContainsData = Object.keys(trendsData).length > 0;\n\t\t\n\n\t\tthis.data = Utils.deepMerge(this.data, newState, false);\n\n\t\t// return data to state\n\t\tif (newStateContainsData) for (let trendName in trendsData) {\n\t\t\tthis.data.trends[trendName].data = trendsData[trendName];\n\t\t}\n\n\t\tif (silent) return;\n\n\t\t// recalculate all dynamic state props\n\t\tvar recalculateResult = this.recalculateState(changedProps);\n\t\tchangedProps = recalculateResult.changedProps;\n\t\t\n\t\tthis.emitChangedStateEvents(changedProps, eventData);\n\n\t}\n\n\t/**\n\t * recalculate all computed state props\n\t */\n\tprivate recalculateState(changedProps?: IChartState): IRecalculatedStateResult {\n\t\tvar data = this.data;\n\t\tvar patch: IChartState = {};\n\t\tvar actualData = Utils.deepMerge({}, data);\n\n\t\t// recalculate scroll position by changed cursor options\n\t\tvar cursorOptions = changedProps.cursor;\n\t\tvar isMouseDrag = cursorOptions && data.cursor.dragMode && data.prevState.cursor.dragMode;\n\t\tif (isMouseDrag) {\n\t\t\tvar oldX = data.prevState.cursor.x;\n\t\t\tvar currentX =  cursorOptions.x;\n\t\t\tvar currentScroll = data.xAxis.range.scroll;\n\t\t\tvar deltaXVal = this.pxToValueByXAxis(oldX - currentX);\n\t\t\tpatch.xAxis = {range: {scroll: currentScroll + deltaXVal}};\n\t\t\tactualData = Utils.deepMerge(actualData, {xAxis: patch.xAxis} as IChartState)\n\t\t}\n\n\t\tlet chartWasResized = changedProps.width != void 0 || changedProps.height != void 0;\n\n\t\tlet scrollXChanged = false;\n\t\tlet needToRecalculateXAxis = (\n\t\t\tisMouseDrag ||\n\t\t\tchartWasResized ||\n\t\t\t(changedProps.xAxis && (changedProps.xAxis.range)) ||\n\t\t\tthis.data.xAxis.range.zeroVal == void 0\n\t\t);\n\t\tif (needToRecalculateXAxis) {\n\t\t\tlet xAxisPatch = this.recalculateXAxis(actualData, changedProps);\n\t\t\tif (xAxisPatch) {\n\t\t\t\tscrollXChanged = true;\n\t\t\t\tpatch = Utils.deepMerge(patch, {xAxis: xAxisPatch});\n\t\t\t\tactualData = Utils.deepMerge(actualData, {xAxis: xAxisPatch} as IChartState);\n\t\t\t}\n\t\t}\n\n\n\n\t\t// recalculate axis \"from\" and \"to\" for dynamics AXIS_RANGE_TYPE\n\t\tlet needToRecalculateYAxis = (\n\t\t\tchartWasResized ||\n\t\t\t(\n\t\t\t\tdata.yAxis.range.type === AXIS_RANGE_TYPE.RELATIVE_END ||\n\t\t\t\tdata.yAxis.range.type === AXIS_RANGE_TYPE.AUTO ||\n\t\t\t\tdata.yAxis.range.isMirrorMode\n\t\t\t) &&\n\t\t\t(scrollXChanged || changedProps.trends || changedProps.yAxis) ||\n\t\t\tthis.data.yAxis.range.zeroVal == void 0\n\t\t);\n\t\tif (needToRecalculateYAxis){\n\t\t\tlet yAxisPatch = this.recalculateYAxis(actualData);\n\t\t\tif (yAxisPatch) {\n\t\t\t\tpatch = Utils.deepMerge(patch, {yAxis: yAxisPatch});\n\t\t\t\tactualData = Utils.deepMerge(actualData, {yAxis: yAxisPatch} as IChartState);\n\t\t\t}\n\t\t}\n\n\t\tthis.savePrevState(patch);\n\t\tlet allChangedProps = Utils.deepMerge(changedProps, patch);\n\t\tpatch.computedData = this.getComputedData(allChangedProps);\n\t\tthis.savePrevState(patch);\n\t\tthis.data = Utils.deepMerge(this.data, patch);\n\t\treturn {changedProps: allChangedProps, patch: patch}\n\t}\n\n\tprivate getComputedData(changedProps?: IChartState): IChartStateComputedData {\n\t\tvar computeAll = !changedProps;\n\t\tvar computedData: IChartStateComputedData = {};\n\n\t\tif (computeAll || changedProps.trends && this.trendsManager) {\n\t\t\tcomputedData.trends = {\n\t\t\t\tmaxXVal: this.trendsManager.getEndXVal(),\n\t\t\t\tminXVal: this.trendsManager.getStartXVal()\n\t\t\t}\n\t\t}\n\t\treturn computedData;\n\t}\n\n\tprivate savePrevState(changedProps?: IChartState) {\n\t\tif (!changedProps) changedProps = this.data;\n\t\tvar prevState = this.data.prevState;\n\n\t\t// prevent to store prev trend data by performance reasons\n\t\tUtils.copyProps(this.data, prevState, changedProps, ['trends']);\n\n\t}\n\n\tprivate emitChangedStateEvents(changedProps: IChartState, eventData: any) {\n\t\tvar prevState = this.data.prevState;\n\n\t\t// emit common change event\n\t\tthis.ee.emit(CHART_STATE_EVENTS.CHANGE, changedProps, eventData);\n\n\t\t// emit event for each changed state property\n\t\tfor (let key in changedProps) {\n\t\t\tthis.ee.emit(key + 'Change', (changedProps as {[key: string]: any})[key], eventData);\n\t\t}\n\n\t\tif (!this.isReady) return;\n\n\t\t// emit special events based on changed state\n\t\tlet scrollStopEventNeeded = (\n\t\t\tchangedProps.cursor &&\n\t\t\tchangedProps.cursor.dragMode === false &&\n\t\t\tprevState.cursor.dragMode === true\n\t\t);\n\t\tscrollStopEventNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL_STOP, changedProps);\n\n\t\tlet scrollChangeEventsNeeded = (\n\t\t\tchangedProps.xAxis &&\n\t\t\tchangedProps.xAxis.range &&\n\t\t\tchangedProps.xAxis.range.scroll !== void 0\n\t\t);\n\t\tscrollChangeEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.SCROLL, changedProps);\n\n\t\tlet zoomEventsNeeded = (\n\t\t\t(changedProps.xAxis && changedProps.xAxis.range && changedProps.xAxis.range.zoom) ||\n\t\t\t(changedProps.yAxis && changedProps.yAxis.range && changedProps.yAxis.range.zoom)\n\t\t);\n\t\tzoomEventsNeeded && this.ee.emit(CHART_STATE_EVENTS.ZOOM, changedProps);\n\n\t\tlet resizeEventNeeded = (changedProps.width || changedProps.height);\n\t\tresizeEventNeeded && this.ee.emit(CHART_STATE_EVENTS.RESIZE, changedProps);\n\n\t\tlet pluginStateChangedEventNeeded = !!(changedProps.pluginsState);\n\t\tpluginStateChangedEventNeeded && this.ee.emit(CHART_STATE_EVENTS.PLUGINS_STATE_CHANGED, changedProps.pluginsState);\n\t}\n\n\n\t/**\n\t * init plugins and save plugins options in initialState\n\t */\n\tprivate installPlugins(plugins: ChartPlugin[], initialState: IChartState): IChartState {\n\t\tinitialState.pluginsState = {};\n\t\tplugins.forEach(plugin => {\n\t\t\tlet PluginClass = plugin.constructor as typeof ChartPlugin;\n\t\t\tlet pluginName = PluginClass.NAME;\n\t\t\tinitialState.pluginsState[pluginName] = Utils.deepMerge({}, plugin.initialState);\n\t\t\tthis.plugins[pluginName] = plugin;\n\t\t\tplugin.setupChartState(this);\n\t\t});\n\t\treturn initialState;\n\t}\n\n\n\t/**\n\t * returns plugin instance by plugin name\n\t * @example\n\t */\n\tgetPlugin(pluginName: string): ChartPlugin {\n\t\treturn this.plugins[pluginName];\n\t}\n\n\n\tprivate initListeners() {\n\t\tthis.ee.on(CHART_STATE_EVENTS.TRENDS_CHANGE, (changedTrends: ITrendsOptions, newData: ITrendData) => {\n\t\t\tthis.handleTrendsChange(changedTrends, newData)\n\t\t});\n\t}\n\n\tprivate handleTrendsChange(changedTrends: ITrendsOptions, newData: ITrendData) {\n\t\tfor (let trendName in changedTrends) {\n\t\t\tthis.ee.emit(CHART_STATE_EVENTS.TREND_CHANGE, trendName, changedTrends[trendName], newData);\n\t\t}\n\t}\n\n\tprivate recalculateXAxis(actualData: IChartState, changedProps: IChartState): IAxisOptions {\n\t\tvar axisRange = actualData.xAxis.range;\n\t\tvar patch: IAxisOptions = {range: {}};\n\t\tvar isInitialize = axisRange.zeroVal == void 0;\n\t\tvar zeroVal: number, scaleFactor: number;\n\t\tvar zoom = axisRange.zoom;\n\n\t\tif (axisRange.isMirrorMode) {\n\t\t\tUtils.error('range.isMirrorMode available only for yAxis.range');\n\t\t}\n\n\t\tif (isInitialize) {\n\t\t\tzeroVal = axisRange.from;\n\t\t\tscaleFactor = actualData.width / (axisRange.to - axisRange.from);\n\t\t\tpatch = { range: {zeroVal: zeroVal, scaleFactor: scaleFactor}};\n\t\t} else {\n\t\t\tzeroVal = axisRange.zeroVal;\n\t\t\tscaleFactor = axisRange.scaleFactor;\n\n\t\t\t// recalculate range.zoom and range.scroll then range.from or range.to was changed\n\t\t\tif (\n\t\t\t\tchangedProps.xAxis &&\n\t\t\t\t(changedProps.xAxis.range.from != void 0 || changedProps.xAxis.range.to)\n\t\t\t) {\n\t\t\t\tif (changedProps.xAxis.range.zoom) {\n\t\t\t\t\tUtils.error('Impossible to change \"range.zoom\" then \"range.from\" or \"range.to\" present');\n\t\t\t\t}\n\t\t\t\tlet currentScaleFactor = actualData.width / (axisRange.to - axisRange.from);\n\t\t\t\tpatch.range.scroll = axisRange.from - zeroVal;\n\t\t\t\tpatch.range.zoom = currentScaleFactor / scaleFactor;\n\t\t\t\treturn patch;\n\t\t\t}\n\t\t}\n\n\n\t\t// recalculate range.from and range.to then range.zoom or range.scroll was changed\n\t\tdo {\n\t\t\tvar from = zeroVal + axisRange.scroll;\n\t\t\tvar to = from + actualData.width / (scaleFactor * zoom);\n\t\t\tvar rangeLength = to - from;\n\t\t\tvar needToRecalculateZoom = false;\n\t\t\tvar rangeMoreThenMaxValue = (axisRange.maxLength && rangeLength > axisRange.maxLength);\n\t\t\tvar rangeLessThenMinValue = (axisRange.minLength && rangeLength < axisRange.minLength);\n\t\t\tneedToRecalculateZoom = rangeMoreThenMaxValue || rangeLessThenMinValue;\n\t\t\tif (needToRecalculateZoom) {\n\t\t\t\tvar fixScale = rangeLength > axisRange.maxLength ?\n\t\t\t\t\trangeLength / axisRange.maxLength :\n\t\t\t\t\trangeLength / axisRange.minLength;\n\t\t\t\tvar zoom = zoom * fixScale;\n\t\t\t\tpatch.range.zoom = zoom;\n\t\t\t}\n\t\t} while (needToRecalculateZoom);\n\n\t\tpatch.range.from = from;\n\t\tpatch.range.to = to;\n\t\treturn patch;\n\t}\n\n\n\tprivate recalculateYAxis(actualData: IChartState): IAxisOptions {\n\t\tvar patch: IAxisOptions = {range: {}};\n\t\tvar yAxisRange = actualData.yAxis.range;\n\t\tvar isInitialize = yAxisRange.scaleFactor == void 0;\n\t\tvar trends = this.trendsManager;\n\t\tvar trendsEndXVal = trends.getEndXVal();\n\t\tvar trendsStartXVal = trends.getStartXVal();\n\t\tvar xRange = actualData.xAxis.range;\n\t\tvar {from: xFrom, to: xTo} = xRange;\n\t\tvar xRangeLength = xTo - xFrom;\n\t\tvar zeroVal: number, scaleFactor: number, scroll: number, zoom: number, needToZoom: boolean;\n\n\t\t// check situation when chart was scrolled behind trends end or before trends start\n\t\tif (xTo > trendsEndXVal) {\n\t\t\txTo = trendsEndXVal;\n\t\t\txFrom = xTo - xRangeLength;\n\t\t} else if (xFrom < trendsStartXVal) {\n\t\t\txFrom = trendsStartXVal;\n\t\t\txTo = xFrom + xRangeLength;\n\t\t}\n\n\t\tvar maxY = trends.getMaxYVal(xFrom, xTo);\n\t\tvar minY = trends.getMinYVal(xFrom, xTo);\n\n\t\tvar trendLastY = trends.getMaxYVal(trendsEndXVal, trendsEndXVal);\n\t\tif (yAxisRange.type == AXIS_RANGE_TYPE.RELATIVE_END) {\n\t\t\tif (trendLastY > maxY) maxY = trendLastY;\n\t\t\tif (trendLastY < minY) minY = trendLastY;\n\t\t}\n\n\t\tif (yAxisRange.isMirrorMode) {\n\t\t\tif (yAxisRange.zeroVal == void 0) Utils.error('range.zeroVal must be set when range.isMirrorMode');\n\t\t\tlet distanceFromZeroValForMaxY = Math.abs(yAxisRange.zeroVal - maxY);\n\t\t\tlet distanceFromZeroValForMinY = Math.abs(yAxisRange.zeroVal - minY);\n\t\t\tlet maxDistanceFromZeroVal = Math.max(distanceFromZeroValForMaxY, distanceFromZeroValForMinY);\n\t\t\tmaxY = yAxisRange.zeroVal + maxDistanceFromZeroVal;\n\t\t\tminY = yAxisRange.zeroVal - maxDistanceFromZeroVal;\n\t\t}\n\t\tlet margin = yAxisRange.margin;\n\t\tlet padding = {\n\t\t\tstart: yAxisRange.padding.start + margin.start,\n\t\t\tend: yAxisRange.padding.end + margin.end\n\t\t};\n\n\t\tif (padding.end + padding.start >= actualData.height) {\n\t\t\tUtils.warn('Sum of padding and margins of yAxi more then available chart height. Trends can be rendered incorrectly');\n\t\t}\n\n\t\tlet rangeLength = maxY - minY;\n\t\tlet paddingTopInPercents = padding.end / actualData.height;\n\t\tlet paddingBottomInPercents = padding.start / actualData.height;\n\t\tlet rangeLengthInPercents = 1 - paddingTopInPercents - paddingBottomInPercents;\n\t\tlet visibleRangeLength = rangeLength / rangeLengthInPercents;\n\t\tlet fromVal = minY - visibleRangeLength * paddingBottomInPercents;\n\t\tlet toVal = maxY + visibleRangeLength * paddingTopInPercents;\n\t\t\n\t\tif (isInitialize) {\n\t\t\tzeroVal = yAxisRange.zeroVal != void 0 ? yAxisRange.zeroVal : fromVal;\n\t\t\tscaleFactor = actualData.height / (toVal - fromVal);\n\t\t\tpatch = { range: {zeroVal: zeroVal, scaleFactor: scaleFactor}};\n\t\t\tneedToZoom = true;\n\t\t} else {\n\t\t\tscaleFactor = yAxisRange.scaleFactor;\n\t\t\tzeroVal = yAxisRange.zeroVal;\n\n\t\t\tlet maxScreenY = Math.round(this.getScreenYByValue(maxY));\n\t\t\tlet minScreenY = Math.round(this.getScreenYByValue(minY));\n\t\t\tneedToZoom = (\n\t\t\t\tmaxScreenY > actualData.height - margin.end ||\n\t\t\t\tmaxScreenY < actualData.height - padding.end ||\n\t\t\t\tminScreenY < margin.start ||\n\t\t\t\tminScreenY > padding.start\n\t\t\t);\n\t\t}\n\n\t\tif (!needToZoom) return null;\n\n\t\tscroll = fromVal - zeroVal;\n\t\tzoom = (actualData.height / (toVal - fromVal)) / scaleFactor ;\n\n\t\tvar currentAxisRange = this.data.yAxis.range;\n\t\tif (currentAxisRange.from !== fromVal) patch.range.from = fromVal;\n\t\tif (currentAxisRange.to !== toVal) patch.range.to = toVal;\n\t\tif (currentAxisRange.scroll !== scroll) patch.range.scroll = scroll;\n\t\tif (currentAxisRange.zoom !== zoom) patch.range.zoom = zoom;\n\t\t\n\t\treturn patch;\n\t}\n\n\tzoom(zoomValue: number, origin = 0.5): Promise<void> {\n\t\tlet {zoom, scroll, scaleFactor} = this.data.xAxis.range;\n\t\tlet newZoom = zoom * zoomValue;\n\t\tlet currentRange = this.data.width / (scaleFactor * zoom);\n\t\tlet nextRange = this.data.width / (scaleFactor * newZoom);\n\t\tlet newScroll = scroll + (currentRange - nextRange) * origin;\n\t\tthis.setState({xAxis: {range: {zoom: newZoom, scroll: newScroll}}});\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tlet animationTime = this.data.animations.enabled ? this.data.animations.zoomSpeed : 0;\n\t\t\tsetTimeout(resolve, animationTime * 1000);\n\t\t});\n\t}\n\t\n\tzoomToRange(range: number, origin?: number): Promise<void> {\n\t\tvar {scaleFactor, zoom} = this.data.xAxis.range;\n\t\tlet currentRange = this.data.width / (scaleFactor * zoom);\n\t\treturn this.zoom(currentRange / range, origin);\n\t}\n\n\tscrollToEnd(): Promise<void> {\n\t\tlet state = this.data;\n\t\tlet endXVal = this.trendsManager.getEndXVal();\n\t\tlet range = state.xAxis.range;\n\t\tvar scroll = endXVal - this.pxToValueByXAxis(state.width) + this.pxToValueByXAxis(range.padding.end) - range.zeroVal;\n\t\tthis.setState({xAxis: {range: {scroll: scroll}}});\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tlet animationTime = this.data.animations.enabled ? this.data.animations.scrollSpeed : 0;\n\t\t\tsetTimeout(resolve, animationTime * 1000);\n\t\t});\n\t}\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal to xVal\n\t */\n\tgetPointOnXAxis(xVal: number): number {\n\t\tvar {scaleFactor, zoom, zeroVal} = this.data.xAxis.range;\n\t\treturn (xVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from yAxis.range.zeroVal to yVal\n\t */\n\tgetPointOnYAxis(yVal: number): number {\n\t\tvar {scaleFactor, zoom, zeroVal} = this.data.yAxis.range;\n\t\treturn (yVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t * returns value by offset in pixels from xAxis.range.zeroVal\n\t */\n\tgetValueOnXAxis(x: number): number {\n\t\treturn this.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from xAxis.range\n\t */\n\tvalueToPxByXAxis(xVal: number) {\n\t\treturn xVal * this.data.xAxis.range.scaleFactor * this.data.xAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from yAxis.range\n\t */\n\tvalueToPxByYAxis(yVal: number) {\n\t\treturn yVal * this.data.yAxis.range.scaleFactor * this.data.yAxis.range.zoom;\n\t}\n\n\t/**\n\t *  convert pixels to value by using settings from xAxis.range\n\t */\n\tpxToValueByXAxis(xVal: number) {\n\t\treturn xVal / this.data.xAxis.range.scaleFactor / this.data.xAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  convert pixels to value by using settings from yAxis.range\n\t */\n\tpxToValueByYAxis(yVal: number) {\n\t\treturn yVal / this.data.yAxis.range.scaleFactor / this.data.yAxis.range.zoom;\n\t}\n\n\n\t/**\n\t *  returns x value by screen x coordinate\n\t */\n\tgetValueByScreenX(x: number): number {\n\t\tvar {zeroVal, scroll} = this.data.xAxis.range;\n\t\treturn zeroVal + scroll + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  returns y value by screen y coordinate\n\t */\n\tgetValueByScreenY(y: number): number {\n\t\tvar {zeroVal, scroll} = this.data.yAxis.range;\n\t\treturn zeroVal + scroll + this.pxToValueByYAxis(y);\n\t}\n\n\n\t/**\n\t *  returns screen x value by screen y coordinate\n\t */\n\tgetScreenXByValue(xVal: number): number {\n\t\tvar {scroll, zeroVal} = this.data.xAxis.range;\n\t\treturn this.valueToPxByXAxis(xVal - zeroVal - scroll)\n\t}\n\n\t/**\n\t *  returns screen y value by screen y coordinate\n\t */\n\tgetScreenYByValue(yVal: number): number {\n\t\tvar {scroll, zeroVal} = this.data.yAxis.range;\n\t\treturn this.valueToPxByYAxis(yVal - zeroVal - scroll)\n\t}\n\n\n\t/**\n\t * returns screen x coordinate by offset in pixels from xAxis.range.zeroVal value\n\t */\n\tgetScreenXByPoint(xVal: number): number {\n\t\treturn this.getScreenXByValue(this.getValueOnXAxis(xVal));\n\t}\n\n\n\t/**\n\t * returns offset in pixels from xAxis.range.zeroVal value by screen x coordinate\n\t */\n\tgetPointByScreenX(screenX: number): number {\n\t\treturn this.getPointOnXAxis(this.getValueByScreenX(screenX));\n\t}\n\n\n\tgetPointOnChart(xVal: number, yVal: number): Vector3 {\n\t\treturn new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\n\t}\n\n\n\tgetScreenLeftVal() {\n\t\treturn this.getValueByScreenX(0);\n\t}\n\n\n\tgetScreenRightVal() {\n\t\treturn this.getValueByScreenX(this.data.width);\n\t}\n\n\n\tgetPaddingRight(): number {\n\t\treturn this.getValueByScreenX(this.data.width - this.data.xAxis.range.padding.end);\n\t}\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/State.ts\n **/","import {ChartState, IChartState} from \"./State\";\nimport {Utils} from \"./Utils\";\nimport {TrendSegmentsManager} from \"./TrendSegmentsManager\";\nimport {EventEmitter} from './EventEmmiter';\nimport {Promise} from './deps/deps';\nimport { TChartColor } from './Color';\n\nexport interface IPrependPromiseExecutor {\n\t(requestedDataLength: number, resolve: (data: TTrendRawData) => void, reject: () => void): void;\n}\nconst EVENTS = {\n\tCHANGE: 'Change',\n\tPREPEND_REQUEST: 'prependRequest'\n};\nexport enum TREND_TYPE {LINE, CANDLE}\nexport type TTrendRawData = ITrendData | number[];\nexport interface ITrendItem {xVal: number, yVal: number, id?: number}\nexport interface ITrendData extends Array<ITrendItem>{}\nexport interface ITrendTypeSettings {\n\tminSegmentLengthInPx?: number;\n\tmaxSegmentLengthInPx?: number;\n}\nexport interface ITrendOptions {\n\tenabled?: boolean,\n\tdata?: ITrendData\n\tdataset?: ITrendData | number[];\n\tname?: string;\n\ttype?: TREND_TYPE;\n\tlineWidth?: number;\n\tlineColor?: TChartColor;\n\tbackgroundColor?: TChartColor;\n\thasIndicator?: boolean;\n\thasBackground?: boolean;\n\thasBeacon?: boolean;\n\tmaxSegmentLength?: number;\n\tsettingsForTypes?: {\n\t\tCANDLE?: ITrendTypeSettings,\n\t\tLINE?: ITrendTypeSettings\n\t}\n}\n\nexport class Trend {\n\tname: string;\n\tsegmentsManager: TrendSegmentsManager;\n\tminXVal = Infinity;\n\tminYVal = Infinity;\n\tmaxXVal = -Infinity;\n\tmaxYVal = -Infinity;\n\tprivate chartState: ChartState;\n\tprivate calculatedOptions: ITrendOptions;\n\tprivate prependRequest: Promise<TTrendRawData>;\n\tprivate ee: EventEmitter;\n\t\n\tconstructor(chartState: ChartState, trendName: string, initialState: IChartState) {\n\t\tvar options = initialState.trends[trendName];\n\t\tthis.name = trendName;\n\t\tthis.chartState = chartState;\n\t\tthis.calculatedOptions = Utils.deepMerge(this.chartState.data.trendDefaultState, options);\n\t\tthis.calculatedOptions.name = trendName;\n\t\tif (options.dataset) this.calculatedOptions.data = Trend.prepareData(options.dataset);\n\t\tthis.calculatedOptions.dataset = [];\n\t\tthis.ee = new EventEmitter();\n\t\tthis.bindEvents();\n\t}\n\n\tprivate onInitialStateApplied() {\n\t\tthis.segmentsManager = new TrendSegmentsManager(this.chartState, this);\n\t}\n\n\tprivate bindEvents() {\n\t\tvar chartState = this.chartState;\n\t\tchartState.onInitialStateApplied(() => this.onInitialStateApplied());\n\t\tchartState.onScrollStop(() => this.checkForPrependRequest());\n\t\tchartState.onZoom(() => this.checkForPrependRequest());\n\t\tchartState.onTrendChange((trendName, changedOptions, newData) => this.ee.emit(EVENTS.CHANGE, changedOptions, newData));\n\t\tchartState.onDestroy(() => this.ee.removeAllListeners());\n\t}\n\n\tgetCalculatedOptions() {\n\t\treturn this.calculatedOptions;\n\t}\n\n\tappendData(rawData: TTrendRawData) {\n\t\tvar options = this.getOptions();\n\t\tvar newData = Trend.prepareData(rawData, this.getData());\n\t\tvar updatedTrendData = options.data.concat(newData);\n\t\tthis.changeData(updatedTrendData, newData);\n\t}\n\n\tprependData(rawData: TTrendRawData) {\n\t\tvar options = this.getOptions();\n\t\tvar newData = Trend.prepareData(rawData, this.getData(), true);\n\t\tvar updatedTrendData = newData.concat(options.data);\n\t\tthis.changeData(updatedTrendData, newData);\n\t}\n\n\tprivate changeData(allData: ITrendData, newData: ITrendData) {\n\t\tfor (let item of newData) {\n\t\t\tif (item.xVal < this.minXVal) this.minXVal = item.xVal;\n\t\t\tif (item.xVal > this.maxXVal) this.maxXVal = item.xVal;\n\t\t\tif (item.yVal < this.minYVal) this.minYVal = item.yVal;\n\t\t\tif (item.yVal > this.maxYVal) this.maxYVal = item.yVal;\n\t\t}\n\t\tvar options = this.getOptions();\n\t\tvar statePatch: IChartState = {trends: {[options.name]: {data: allData}}};\n\t\tthis.chartState.setState(statePatch, newData);\n\t}\n\t\n\tgetData(fromX?: number, toX?: number): ITrendData {\n\t\tvar data = this.getOptions().data;\n\t\tif (fromX == void 0 && toX == void 0) return data;\n\n\t\tfromX = fromX !== void 0 ? fromX : data[0].xVal;\n\t\ttoX = toX !== void 0 ? toX : data[data.length].xVal;\n\t\tvar filteredData: ITrendData = [];\n\t\tfor (let item of data) {\n\t\t\tif (item.xVal < fromX) continue;\n\t\t\tif (item.xVal > toX) break;\n\t\t\tfilteredData.push(item)\n\t\t}\n\t\treturn filteredData;\n\t}\n\n\tgetFirstItem(): ITrendItem {\n\t\treturn this.getOptions().data[0];\n\t}\n\t\n\tgetLastItem(): ITrendItem {\n\t\tvar data = this.getOptions().data;\n\t\treturn data[data.length - 1];\n\t}\n\n\tgetOptions() {\n\t\treturn this.chartState.data.trends[this.name]\n\t}\n\n\tsetOptions(options: ITrendOptions) {\n\t\tthis.chartState.setState({trends: {[this.name]: options}});\n\t}\n\n\tonPrependRequest(cb: IPrependPromiseExecutor): Function {\n\t\tthis.ee.on(EVENTS.PREPEND_REQUEST, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(EVENTS.PREPEND_REQUEST, cb);\n\t\t}\n\t}\n\n\t/**\n\t * shortcut for ChartState.onTrendChange\n\t */\n\tonChange(cb: (changedOptions: ITrendOptions, newData: ITrendData) => void): Function {\n\t\tthis.ee.on(EVENTS.CHANGE, cb);\n\t\treturn () => { this.ee.off(EVENTS.CHANGE, cb);}\n\t}\n\n\tonDataChange(cb: (newData: ITrendData) => void): Function {\n\t\tvar onChangeCb = (changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tif (newData) cb(newData);\n\t\t};\n\t\tthis.ee.on(EVENTS.CHANGE, onChangeCb);\n\t\treturn () => {\n\t\t\tthis.ee.off(EVENTS.CHANGE, onChangeCb);\n\t\t}\n\t}\n\n\tprivate checkForPrependRequest() {\n\t\tif (this.prependRequest) return;\n\t\tvar chartState = this.chartState;\n\t\tvar minXVal = chartState.data.computedData.trends.minXVal;\n\t\tvar minScreenX = chartState.getScreenXByValue(minXVal);\n\t\tvar needToRequest = minScreenX > 0;\n\t\tvar {from, to} = chartState.data.xAxis.range;\n\t\tvar requestedDataLength = to - from;\n\t\tif (!needToRequest) return;\n\t\t\n\t\tthis.prependRequest = new Promise<TTrendRawData>((resolve: Function, reject: Function) => {\n\t\t\tthis.ee.emit(EVENTS.PREPEND_REQUEST, requestedDataLength, resolve, reject);\n\t\t});\n\n\t\tthis.prependRequest.then((newData: TTrendRawData) => {\n\t\t\tthis.prependData(newData);\n\t\t\tthis.prependRequest = null;\n\t\t}, () => {\n\t\t\tthis.prependRequest = null;\n\t\t})\n\t\n\t}\n\n\tstatic prepareData (newData: TTrendRawData, currentData?: ITrendData, isPrepend = false): ITrendData {\n\t\tvar data: ITrendData = [];\n\t\tif (typeof newData[0] == 'number') {\n\t\t\tcurrentData = currentData || [];\n\t\t\tlet initialItem: ITrendItem;\n\t\t\tlet xVal: number;\n\t\t\tif (isPrepend) {\n\t\t\t\tinitialItem = currentData[0];\n\t\t\t\txVal = initialItem.xVal - newData.length;\n\t\t\t} else {\n\t\t\t\tinitialItem = currentData[currentData.length - 1];\n\t\t\t\txVal = initialItem ? initialItem.xVal + 1 : 0;\n\t\t\t}\n\t\t\tfor (let yVal of newData as number[]) {\n\t\t\t\tdata.push({xVal: xVal, yVal: yVal, id: Utils.getUid()});\n\t\t\t\txVal++;\n\t\t\t}\n\t\t} else {\n\t\t\tdata = newData as ITrendData;\n\t\t}\n\t\treturn data;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Trend.ts\n **/","import { IIteralable } from \"./interfaces\";\nimport { EventEmitter } from './EventEmmiter';\nimport { ChartState } from \"./State\";\nimport Vector3 = THREE.Vector3;\nimport { ITrendData, ITrendOptions, ITrendItem, Trend, TREND_TYPE, ITrendTypeSettings } from \"./Trend\";\nimport { Utils } from \"./Utils\";\n\nconst MAX_ANIMATED_SEGMENTS = 100;\nconst EVENTS = {\n\tREBUILD: 'rebuild',\n\tDISLPAYED_RANGE_CHANGED: 'displayedRangeChanged',\n\tANIMATION_FRAME: 'animationFrame'\n};\n\n/**\n *  Class helps to display and animate trends segments\n */\nexport class TrendSegmentsManager {\n\tsegmentsById: {[id: string]: TrendSegment} = {};\n\tsegments: TrendSegment[] = [];\n\tchartState: ChartState;\n\tanimatedSegmentsIds: number[] = [];\n\tmaxSegmentLength: number;\n\tsegmentsLength = 0;\n\tfirstDisplayedSegmentInd: number;\n\tfirstDisplayedSegment: TrendSegment;\n\tlastDisplayedSegmentInd: number;\n\tlastDisplayedSegment: TrendSegment;\n\tprivate appendAnimation: TweenLite;\n\tprivate prependAnimation: TweenLite;\n\tprivate animatedSegmentsForAppend: number[] = [];\n\tprivate animatedSegmentsForPrepend: number[] = [];\n\tprivate nextEmptyId = 0;\n\tprivate startSegmentId = 0;\n\tprivate endSegmentId = 0;\n\tprivate trend: Trend;\n\tprivate ee: EventEmitter;\n\n\tconstructor (chartState: ChartState, trend: Trend) {\n\t\tthis.chartState = chartState;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.trend = trend;\n\t\tthis.maxSegmentLength = trend.getOptions().maxSegmentLength;\n\t\tthis.tryToRebuildSegments();\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.trend.onChange((changedOptions, newData) => this.onTrendChangeHandler(changedOptions, newData));\n\t\tthis.chartState.onZoom(() => this.onZoomHandler());\n\t\tthis.chartState.onScroll(() => this.recalculateDisplayedRange());\n\t\tthis.chartState.onDestroy(() => this.onDestroyHandler());\n\t}\n\n\tprivate onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t\tthis.appendAnimation && this.appendAnimation.kill();\n\t\tthis.prependAnimation && this.prependAnimation.kill();\n\t}\n\n\tprivate onZoomHandler() {\n\t\tlet segmentsRebuilded = this.tryToRebuildSegments();\n\t\tif (!segmentsRebuilded) {\n\t\t\tthis.recalculateDisplayedRange()\n\t\t}\n\t}\n\n\tprivate onTrendChangeHandler(changedOptions: ITrendOptions, newData: ITrendData) {\n\t\tvar needToRebuildSegments = (\n\t\t\tchangedOptions.type != void 0 ||\n\t\t\tchangedOptions.maxSegmentLength != void 0\n\t\t);\n\n\n\t\tif (needToRebuildSegments) {\n\t\t\tthis.tryToRebuildSegments(true);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!newData) return;\n\n\t\tvar data = this.trend.getData();\n\t\tvar isAppend = (!data.length || data[0].xVal < newData[0].xVal);\n\t\tisAppend ? this.appendData(newData) : this.prependData(newData);\n\t\tthis.recalculateDisplayedRange();\n\t}\n\n\tgetSegment(id: number) {\n\t\treturn this.segmentsById[id];\n\t}\n\n\tgetEndSegment(): TrendSegment {\n\t\treturn this.segmentsById[this.endSegmentId];\n\t}\n\n\tgetStartSegment(): TrendSegment {\n\t\treturn this.segmentsById[this.startSegmentId];\n\t}\n\t\n\tprivate tryToRebuildSegments(force = false): boolean {\n\t\tlet options = this.trend.getOptions();\n\t\tlet trendTypeName = TREND_TYPE[options.type] as string;\n\t\tlet trendTypesSettings =  options.settingsForTypes as IIteralable;\n\t\tlet trendTypeSettings = trendTypesSettings[trendTypeName] as ITrendTypeSettings;\n\t\tlet {\n\t\t\tminSegmentLengthInPx,\n\t\t\tmaxSegmentLengthInPx\n\t\t} = trendTypeSettings;\n\n\t\tlet needToRebuild = this.segments.length === 0 || force;\n\t\tlet segmentLength = this.maxSegmentLength;\n\n\t\t// call toFixed(2) to prevent floating segment error compare\n\t\tlet currentSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(segmentLength).toFixed(2));\n\t\tlet currentMaxSegmentLengthInPx = Number(this.chartState.valueToPxByXAxis(this.maxSegmentLength).toFixed(2));\n\n\t\tif (currentSegmentLengthInPx < minSegmentLengthInPx) {\n\t\t\tneedToRebuild = true;\n\t\t\tsegmentLength = Math.ceil(this.chartState.pxToValueByXAxis(maxSegmentLengthInPx));\n\t\t} else if (currentMaxSegmentLengthInPx > maxSegmentLengthInPx) {\n\t\t\tneedToRebuild = true;\n\t\t\tsegmentLength = this.chartState.pxToValueByXAxis(minSegmentLengthInPx);\n\t\t}\n\n\t\tif (!needToRebuild) return false;\n\n\t\tthis.maxSegmentLength = segmentLength;\n\t\tthis.segmentsById = {};\n\t\tthis.segments = [];\n\t\tthis.nextEmptyId = 0;\n\t\tthis.startSegmentId = 0;\n\t\tthis.endSegmentId = 0;\n\t\tthis.segmentsLength = 0;\n\t\tthis.stopAllAnimations();\n\t\tthis.appendData(null, true);\n\t\tthis.recalculateDisplayedRange(true);\n\t\tthis.ee.emit(EVENTS.REBUILD);\n\t}\n\n\tprivate stopAllAnimations() {\n\t\tthis.animatedSegmentsIds = [];\n\t\tthis.animatedSegmentsForAppend = [];\n\t\tthis.animatedSegmentsForAppend = [];\n\t\tif (this.prependAnimation) this.prependAnimation.kill();\n\t\tif (this.appendAnimation) this.appendAnimation.kill();\n\t}\n\t\n\tprivate recalculateDisplayedRange(segmentsAreRebuilded = false) {\n\t\tvar {from, to} = this.chartState.data.xAxis.range;\n\t\tvar {firstDisplayedSegment, lastDisplayedSegment} = this;\n\t\tvar displayedRange = to - from;\n\n\t\tthis.firstDisplayedSegmentInd = Utils.binarySearchClosestInd(this.segments, from - displayedRange, 'startXVal');\n\t\tthis.firstDisplayedSegment = this.segments[this.firstDisplayedSegmentInd];\n\t\tthis.lastDisplayedSegmentInd = Utils.binarySearchClosestInd(this.segments, to + displayedRange, 'endXVal');\n\t\tthis.lastDisplayedSegment = this.segments[this.lastDisplayedSegmentInd];\n\t\tif (segmentsAreRebuilded) return;\n\n\t\tvar displayedRangeChanged = (\n\t\t\tfirstDisplayedSegment.id !== this.firstDisplayedSegment.id ||\n\t\t\tlastDisplayedSegment.id !== this.lastDisplayedSegment.id\n\t\t);\n\t\tif (displayedRangeChanged) this.ee.emit(EVENTS.DISLPAYED_RANGE_CHANGED);\n\t}\n\n\t// getSegments(fromX?: number, toX?: number): TrendSegment[] {\n\t// \tvar segments = this.segments;\n\t// \tif (fromX == void 0 && toX == void 0) return segments;\n\t// \tfromX = fromX !== void 0 ? fromX : segments[0].startXVal;\n\t// \ttoX = toX !== void 0 ? toX : segments[this.segmentsLength].endXVal;\n\t// \tvar startSegmentInd = Utils.closestBinarySearch(segments, fromX, 'xVal');\n\t// \tvar endSegmentInd = Utils.closestBinarySearch(segments, toX, 'xVal');\n\t// \treturn segments.slice(startSegmentInd, endSegmentInd);\n\t// }\n\n\t/**\n\t * returns array of segments for values array\n\t * values must be sorted!\n\t */\n\tgetSegmentsForXValues(values: number[]): TrendSegment[] {\n\t\tvar valueInd = 0;\n\t\tvar value = values[valueInd];\n\t\tvar lastValueInd = values.length - 1;\n\t\tvar results: TrendSegment[] = [];\n\t\tvar segment = this.getStartSegment();\n\t\tif (!segment.hasValue) return [];\n\t\twhile (segment) {\n\t\t\n\t\t\twhile (value < segment.startXVal) {\n\t\t\t\tresults.push(void 0);\n\t\t\t\tvalue = values[++valueInd];\n\t\t\t}\n\t\t\n\t\t\twhile (value > segment.endXVal) {\n\t\t\t\tsegment = segment.getNext();\n\t\t\t\tif (!segment) break;\n\t\t\t}\n\t\t\n\t\t\tvar valueInPoint = (\n\t\t\t\tsegment.startXVal == value || segment.endXVal == value ||\n\t\t\t\t(segment.startXVal < value && segment.endXVal > value)\n\t\t\t);\n\t\t\tif (valueInPoint) {\n\t\t\t\tresults.push(segment);\n\t\t\t\tvalue = values[++valueInd];\n\t\t\t}\n\t\t\tif (valueInd > lastValueInd) break;\n\t\t}\n\t\treturn results;\n\t}\n\n\tonAnimationFrame(cb: (animationState: TrendSegmentsManager) => void): Function {\n\t\treturn this.ee.subscribe(EVENTS.ANIMATION_FRAME, cb);\n\t}\n\n\tonRebuild(cb: Function) {\n\t\treturn this.ee.subscribe(EVENTS.REBUILD, cb);\n\t}\n\n\tonDisplayedRangeChanged(cb: Function) {\n\t\treturn this.ee.subscribe(EVENTS.DISLPAYED_RANGE_CHANGED, cb);\n\t}\n\t\n\tallocateNextSegment() {\n\t\tvar id = this.nextEmptyId++;\n\t\tvar segment = new TrendSegment(this, id);\n\t\tvar prevSegment = this.segmentsById[this.endSegmentId];\n\t\tif (prevSegment && prevSegment.hasValue) {\n\t\t\tprevSegment.nextId = id;\n\t\t\tsegment.prevId = prevSegment.id;\n\t\t}\n\t\tthis.endSegmentId = id;\n\t\tthis.segmentsLength++;\n\t\tthis.segmentsById[id] = segment;\n\t\tthis.segments.push(segment);\n\t\treturn segment;\n\t}\n\n\tallocatePrevSegment() {\n\t\tvar id = this.nextEmptyId++;\n\t\tvar segment = new TrendSegment(this, id);\n\t\tvar nextSegment = this.segmentsById[this.startSegmentId];\n\t\tif (nextSegment && nextSegment.hasValue) {\n\t\t\tnextSegment.prevId = id;\n\t\t\tsegment.nextId = nextSegment.id;\n\t\t}\n\t\tthis.startSegmentId = id;\n\t\tthis.segmentsLength++;\n\t\tthis.segmentsById[id] = segment;\n\t\tthis.segments.unshift(segment);\n\t\treturn segment;\n\t}\n\n\tprivate appendData(newData: ITrendData, needRebuildSegments = false) {\n\n\t\t// WARNING: bottleneck method!\n\n\t\t// var t1 = performance.now();\n\t\tvar trendData = this.trend.getData();\n\t\tif (needRebuildSegments) {\n\t\t\tnewData = trendData;\n\t\t\tthis.animatedSegmentsForAppend = [];\n\t\t}\n\n\t\tvar startItemInd = trendData.length - newData.length;\n\t\tvar segment = this.getEndSegment() || this.allocateNextSegment();\n\t\tvar initialSegment = segment.hasValue ? segment : null;\n\t\tvar initialAnimationState = segment.createAnimationState();\n\t\tvar itemInd = 0;\n\t\twhile (itemInd < newData.length) {\n\t\t\tlet item = newData[itemInd];\n\t\t\tlet itemIsInserted = segment.appendItem(item);\n\t\t\tlet isLastItem = itemInd == newData.length - 1;\n\n\t\t\tif (itemIsInserted) {\n\t\t\t\tif (!isLastItem) itemInd++;\n\t\t\t} else {\n\t\t\t\tif (!segment.isCompleted) segment.complete();\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) {\n\t\t\t\tsegment.recalculateItems();\n\t\t\t}\n\n\t\t\tlet segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\n\t\t\tif (segmentIsReadyForAnimate) {\n\t\t\t\tlet id = segment.id;\n\t\t\t\tif (!initialSegment) initialSegment = segment;\n\t\t\t\tif (!initialAnimationState) initialAnimationState = initialSegment.createAnimationState();\n\n\t\t\t\tsegment.initialAnimationState = Utils.deepMerge({}, initialAnimationState);\n\t\t\t\tif (this.animatedSegmentsForAppend.length > 0) {\n\t\t\t\t\tsegment.initialAnimationState.startXVal = initialAnimationState.endXVal;\n\t\t\t\t\tsegment.initialAnimationState.startYVal = initialAnimationState.endYVal;\n\t\t\t\t}\n\n\t\t\t\tsegment.targetAnimationState = segment.createAnimationState();\n\t\t\t\tthis.animatedSegmentsForAppend.push(id);\n\n\t\t\t}\n\n\n\t\t\tif (isLastItem && itemIsInserted) break;\n\t\t\tif (!segment.isCompleted) continue;\n\n\t\t\tsegment = this.allocateNextSegment();\n\t\t\tlet prevItem = trendData[startItemInd + itemInd - 1];\n\t\t\tsegment.appendItem(prevItem);\n\n\t\t}\n\n\t\tvar animationsOptions = this.chartState.data.animations;\n\t\tvar time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\n\n\t\t// var t2 = performance.now();\n\t\t// console.log(t2 - t1);\n\n\t\t// do not create animation if segments was rebuilded\n\t\tif (needRebuildSegments) {\n\t\t\tfor (let segmentId of this.animatedSegmentsForAppend) {\n\t\t\t\tlet segment = this.segmentsById[segmentId];\n\t\t\t\tsegment.currentAnimationState = segment.createAnimationState();\n\t\t\t}\n\t\t\tthis.animatedSegmentsForAppend = [];\n\t\t\treturn;\n\t\t}\n\t\tif (this.animatedSegmentsForAppend.length > MAX_ANIMATED_SEGMENTS) time = 0;\n\t\tthis.animate(time);\n\t}\n\n\n\t// TODO: refactor duplicated code from appendData\n\tprivate prependData(newData: ITrendData) {\n\t\tvar trendData = this.trend.getData();\n\t\tvar segment = this.getStartSegment() || this.segmentsById[0];\n\t\tvar initialSegment = segment.hasValue ? segment : null;\n\t\tvar itemInd = newData.length - 1;\n\t\tvar initialAnimationState = segment.createAnimationState();\n\t\twhile (itemInd >= 0) {\n\t\t\tlet item = newData[itemInd];\n\t\t\tlet itemIsInserted = segment.prependItem(item);\n\t\t\tlet isLastItem = itemInd == 0;\n\n\t\t\tif (itemIsInserted) {\n\t\t\t\tif (!isLastItem) itemInd--;\n\t\t\t} else {\n\t\t\t\tif (!segment.isCompleted) segment.complete();\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) {\n\t\t\t\tsegment.recalculateItems();\n\t\t\t}\n\n\t\t\tlet segmentIsReadyForAnimate = segment.isCompleted || (isLastItem && itemIsInserted);\n\t\t\tif (segmentIsReadyForAnimate) {\n\t\t\t\tlet id = segment.id;\n\t\t\t\tif (!initialSegment) initialSegment = segment;\n\t\t\t\tif (!initialAnimationState) initialAnimationState = initialSegment.createAnimationState();\n\n\t\t\t\tsegment.initialAnimationState = Utils.deepMerge({}, initialAnimationState);\n\t\t\t\tif (this.animatedSegmentsForPrepend.length > 0) {\n\t\t\t\t\tsegment.initialAnimationState.endXVal = initialAnimationState.startXVal;\n\t\t\t\t\tsegment.initialAnimationState.endYVal =  initialAnimationState.startYVal;\n\t\t\t\t}\n\n\t\t\t\tsegment.targetAnimationState = segment.createAnimationState();\n\t\t\t\tthis.animatedSegmentsForPrepend.push(id);\n\n\t\t\t}\n\n\t\t\tif (isLastItem && itemIsInserted) break;\n\t\t\tif (!segment.isCompleted) continue;\n\n\t\t\tsegment = this.allocatePrevSegment();\n\t\t\tlet nextItem = trendData[itemInd + 1];\n\t\t\tsegment.prependItem(nextItem);\n\n\t\t}\n\n\t\tvar animationsOptions = this.chartState.data.animations;\n\t\tvar time = animationsOptions.enabled ? animationsOptions.trendChangeSpeed : 0;\n\n\t\tif (this.animatedSegmentsForPrepend.length > MAX_ANIMATED_SEGMENTS) time = 0;\n\t\tthis.animate(time, true);\n\t}\n\n\tprivate animate(time: number, isPrepend = false) {\n\n\t\tvar animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\n\t\tvar animation = isPrepend ? this.prependAnimation : this.appendAnimation;\n\n\t\tif ((animation && animation.isActive()) || time == 0) {\n\t\t\tif (animation) animation.kill();\n\t\t\tthis.onAnimationFrameHandler(1, isPrepend);\n\t\t\tanimatedSegmentsIds.length = 0;\n\t\t\treturn;\n\t\t}\n\t\tvar animationsOptions = this.chartState.data.animations;\n\t\tvar ease = animationsOptions.trendChangeEase;\n\t\tvar objectToAnimate = {animationValue: 0};\n\t\tanimation = TweenLite.to(objectToAnimate, time, {animationValue: 1, ease});\n\t\tanimation.eventCallback('onUpdate', () => this.onAnimationFrameHandler(objectToAnimate.animationValue, isPrepend));\n\t\tanimation.eventCallback('onComplete', () => {\n\t\t\tanimatedSegmentsIds.length = 0;\n\t\t\tthis.appendAnimation = null;\n\t\t});\n\n\t\tif (isPrepend) {\n\t\t\tthis.prependAnimation = animation;\n\t\t} else {\n\t\t\tthis.appendAnimation = animation;\n\t\t}\n\t}\n\n\tprivate onAnimationFrameHandler(coefficient: number, isPrepend = false) {\n\t\tlet animatedSegmentsIds = isPrepend ? this.animatedSegmentsForPrepend : this.animatedSegmentsForAppend;\n\t\tfor (let segmentId of animatedSegmentsIds) {\n\t\t\tlet segment = this.segmentsById[segmentId];\n\t\t\tfor (let key in segment.targetAnimationState) {\n\t\t\t\tlet targetValue = segment.targetAnimationState[key] as number;\n\t\t\t\tlet initialValue = segment.initialAnimationState[key] as number;\n\t\t\t\tlet currentValue = initialValue + (targetValue - initialValue) * coefficient;\n\t\t\t\tsegment.currentAnimationState[key] = currentValue;\n\t\t\t}\n\t\t}\n\t\tthis.animatedSegmentsIds = this.animatedSegmentsForAppend.concat(this.animatedSegmentsForPrepend);\n\t\tthis.ee.emit(EVENTS.ANIMATION_FRAME, this);\n\t}\n\n}\n\nexport interface ITrendSegmentState extends IIteralable {\n\txVal?: number;\n\tyVal?: number;\n\tstartXVal?: number;\n\tstartYVal?: number;\n\tendXVal?: number;\n\tendYVal?: number;\n\tmaxYVal?: number;\n\tminYVal?: number;\n\tmaxLength?: number;\n}\n\nexport class TrendSegment implements ITrendSegmentState {\n\tid: number;\n\tprevId: number;\n\tnextId: number;\n\thasValue: boolean;\n\txVal: number;\n\tyVal: number;\n\tstartXVal: number;\n\tstartYVal: number;\n\tendXVal: number;\n\tendYVal: number;\n\tmaxYVal: number;\n\tminYVal: number;\n\tisCompleted = false;\n\tmaxLength: number;\n\titems: ITrendItem[] = [];\n\n\tinitialAnimationState: ITrendSegmentState = {};\n\ttargetAnimationState: ITrendSegmentState = {};\n\tcurrentAnimationState: ITrendSegmentState = {};\n\n\tprivate trendSegments: TrendSegmentsManager;\n\t\n\tconstructor(trendPoints: TrendSegmentsManager, id: number) {\n\t\tthis.trendSegments = trendPoints;\n\t\tthis.id = id;\n\t\tthis.maxLength = trendPoints.maxSegmentLength;\n\t}\n\n\tcreateAnimationState(): ITrendSegmentState {\n\t\tvar {\n\t\t\txVal,\n\t\t\tyVal,\n\t\t\tstartXVal,\n\t\t\tstartYVal,\n\t\t\tendXVal,\n\t\t\tendYVal,\n\t\t\tmaxYVal,\n\t\t\tminYVal,\n\t\t\tmaxLength\n\t\t} = this;\n\t\treturn {\n\t\t\txVal,\n\t\t\tyVal,\n\t\t\tstartXVal,\n\t\t\tstartYVal,\n\t\t\tendXVal,\n\t\t\tendYVal,\n\t\t\tmaxYVal,\n\t\t\tminYVal,\n\t\t\tmaxLength\n\t\t}\n\t};\n\t\n\tappendItem(item: ITrendItem): boolean {\n\t\tif (this.isCompleted) return false;\n\n\t\tvar items = this.items;\n\t\tif (items.length < 2) {\n\t\t\tthis.items.push(item);\n\t\t\tthis.hasValue = true;\n\t\t\treturn true;\n\t\t}\n\t\tvar startXVal = items[0].xVal;\n\t\tif (item.xVal - startXVal > this.maxLength) return false;\n\t\titems.push(item);\n\t\treturn true;\n\t}\n\n\tprependItem(item: ITrendItem): boolean {\n\t\tif (this.isCompleted) return false;\n\t\tvar items = this.items;\n\t\tif (items.length < 2) {\n\t\t\tthis.items.unshift(item);\n\t\t\tthis.hasValue = true;\n\t\t\treturn true;\n\t\t}\n\t\tvar endXVal = items[items.length - 1].xVal;\n\t\tif (endXVal - item.xVal > this.maxLength) return false;\n\t\titems.unshift(item);\n\t\treturn true;\n\t}\n\n\tcomplete() {\n\t\tthis.isCompleted = true;\n\t\tthis.recalculateItems();\n\t\tthis.items = []; // free memory for completed ranges\n\t}\n\n\trecalculateItems() {\n\t\tlet items = this.items;\n\t\tlet itemsLength = items.length;\n\t\tif (itemsLength === 0) Utils.error('Unable to create TrendSegment without TrendItems');\n\t\tlet endItem = items[itemsLength - 1];\n\t\tlet {xVal: endXVal, yVal: endYVal} = endItem;\n\t\tlet startXVal: number, startYVal: number;\n\n\n\t\tlet startItem = items[0];\n\t\tstartXVal = startItem.xVal;\n\t\tstartYVal = startItem.yVal;\n\n\t\tlet minX = Math.min(startXVal, endXVal);\n\t\tlet maxX = Math.max(startXVal, endXVal);\n\t\tlet middleXVal = minX + (maxX - minX) / 2;\n\n\t\tlet minY = Math.min(startYVal, endYVal);\n\t\tlet maxY = Math.max(startYVal, endYVal);\n\t\tlet middleYVal = minY + (maxY - minY) / 2;\n\n\t\tlet yVals = items.map(item => item.yVal);\n\n\t\tthis.startXVal = startXVal;\n\t\tthis.startYVal = startYVal;\n\t\tthis.endXVal = endXVal;\n\t\tthis.endYVal = endYVal;\n\t\tthis.xVal = middleXVal;\n\t\tthis.yVal = middleYVal;\n\t\tthis.maxYVal = Math.max(...yVals);\n\t\tthis.minYVal = Math.min(...yVals);\n\t\tif (!this.currentAnimationState) this.currentAnimationState = this.createAnimationState();\n\t}\n\n\tgetNext() {\n\t\tvar nextPoint = this.trendSegments.segmentsById[this.nextId];\n\t\treturn nextPoint && nextPoint.hasValue ? nextPoint : null;\n\t}\n\n\tgetPrev() {\n\t\tvar prevPoint = this.trendSegments.segmentsById[this.prevId];\n\t\treturn prevPoint && prevPoint.hasValue ? prevPoint : null;\n\t}\n\t\n\tgetFrameVal(): Vector3 {\n\t\tlet {xVal, yVal} = this.createAnimationState();\n\t\treturn new Vector3(xVal, yVal, 0);\n\t}\n\n\tgetFramePoint(): Vector3 {\n\t\tvar frameVal = this.getFrameVal();\n\t\treturn this.trendSegments.chartState.screen.getPointOnChart(frameVal.x, frameVal.y);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/TrendSegmentsManager.ts\n **/","\nimport {Trend, ITrendOptions} from \"./Trend\";\nimport {ChartState, IChartState} from \"./State\";\nimport { EventEmitter } from './EventEmmiter';\n\nexport interface ITrendsOptions {\n\t[trendName: string]: ITrendOptions;\n}\n\nconst EVENTS = {\n\tSEGMENTS_REBUILDED: 'segmentsRebuilded'\n};\n\n/**\n * Trends manager\n */\nexport class TrendsManager {\n\ttrends: {[name: string]: Trend} = {};\n\tcalculatedOptions: ITrendsOptions;\n\tprivate ee = new EventEmitter();\n\tprivate chartState: ChartState;\n\t\n\tconstructor(state: ChartState, initialState: IChartState) {\n\t\tthis.chartState = state;\n\t\tvar trendsCalculatedOptions: ITrendsOptions = {};\n\t\tfor (let trendName in initialState.trends) {\n\t\t\tlet trend = this.createTrend(state, trendName, initialState);\n\t\t\ttrendsCalculatedOptions[trendName] = trend.getCalculatedOptions();\n\t\t}\n\t\tthis.calculatedOptions = trendsCalculatedOptions;\n\t\tthis.bindEvents();\n\t}\n\n\tgetTrend(trendName: string) {\n\t\treturn this.trends[trendName];\n\t}\n\t\n\tgetEnabledTrends(): Trend[] {\n\t\tvar enabledTrends: Trend[] = [];\n\t\tvar allTrends = this.trends;\n\t\tfor (let trendName in allTrends) {\n\t\t\tlet trend = allTrends[trendName];\n\t\t\ttrend.getOptions().enabled && enabledTrends.push(trend);\n\t\t}\n\t\treturn enabledTrends;\n\t}\n\n\n\tgetStartXVal() {\n\t\tvar trends = this.getEnabledTrends();\n\t\treturn trends[0].getData()[0].xVal;\n\t}\n\n\n\tgetEndXVal(): number {\n\t\tvar trends = this.getEnabledTrends();\n\t\tvar firstTrendData = trends[0].getData();\n\t\treturn firstTrendData[firstTrendData.length - 1].xVal;\n\t}\n\t\n\t\n\tgetExtremumYVal(extremumIsMax: boolean, fromX?: number, toX?: number) {\n\t\tvar trends = this.getEnabledTrends();\n\t\tvar compareFn: Function;\n\t\tvar result: number;\n\t\tif (extremumIsMax) {\n\t\t\tresult = -Infinity;\n\t\t\tcompareFn = Math.max;\n\t\t} else {\n\t\t\tresult = Infinity;\n\t\t\tcompareFn = Math.min;\n\t\t}\n\t\tfor (let trend of trends) {\n\t\t\tvar trendData = trend.getData(fromX, toX);\n\t\t\tvar trendYValues = trendData.map((dataItem) => dataItem.yVal);\n\t\t\tresult = compareFn(result, ...trendYValues);\n\t\t}\n\t\tif (result == Infinity || result == -Infinity) result = NaN;\n\t\treturn result;\n\t}\n\n\tgetMaxYVal(fromX?: number, toX?: number) {return this.getExtremumYVal(true, fromX, toX)}\n\tgetMinYVal(fromX?: number, toX?: number) {return this.getExtremumYVal(false, fromX, toX)}\n\n\tonSegmentsRebuilded(cb: (trendName: string) => any) {\n\t\treturn this.ee.subscribe(EVENTS.SEGMENTS_REBUILDED, cb);\n\t}\n\n\tprivate bindEvents() {\n\t\tthis.chartState.onInitialStateApplied(() => this.onInitialStateAppliedHandler());\n\t}\n\n\tprivate onInitialStateAppliedHandler() {\n\t\tfor (let trendName in this.trends) {\n\t\t\tthis.trends[trendName].segmentsManager.onRebuild(() => this.ee.emit(EVENTS.SEGMENTS_REBUILDED, trendName));\n\t\t}\n\t}\n\n\tprivate createTrend(state: ChartState, trendName: string, initialState: IChartState): Trend {\n\t\tlet trend = new Trend(state, trendName, initialState);\n\t\tthis.trends[trendName] = trend;\n\t\treturn trend;\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/TrendsManager.ts\n **/","import PerspectiveCamera = THREE.PerspectiveCamera;\nimport Vector3 = THREE.Vector3;\nimport {ChartState, IChartState} from \"./State\";\nimport forestgreen = THREE.ColorKeywords.forestgreen;\nimport {EventEmitter} from './EventEmmiter';\n\nexport interface IScreenTransformOptions {\n\tscrollXVal?: number,\n\tscrollYVal?: number,\n\tscrollX?: number,\n\tscrollY?: number,\n\tzoomX?: number,\n\tzoomY?: number\n}\n\n/**\n * manage camera, and contains methods for transforming pixels to values\n */\nexport class Screen {\n\toptions: IScreenTransformOptions = {scrollXVal: 0, scrollX: 0, scrollYVal: 0, scrollY: 0, zoomX: 1, zoomY: 1};\n\tprivate chartState: ChartState;\n\tprivate scrollXAnimation: TweenLite;\n\tprivate scrollYAnimation: TweenLite;\n\tprivate zoomXAnimation: TweenLite;\n\tprivate zoomYAnimation: TweenLite;\n\tprivate currentScrollX = {x: 0};\n\tprivate currentScrollY = {y: 0};\n\tprivate currentZoomX = {val: 1};\n\tprivate currentZoomY = {val: 1};\n\tprivate ee: EventEmitter;\n\n\tconstructor(chartState: ChartState) {\n\t\tthis.chartState = chartState;\n\t\tvar {width: w, height: h} = chartState.data;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.transform({\n\t\t\tscrollY: this.valueToPxByYAxis(this.chartState.data.yAxis.range.scroll),\n\t\t\tzoomY: 1\n\t\t});\n\t\tthis.bindEvents();\n\n\t\t//camera.position.z = 1500;\n\t}\n\t\n\tgetCameraSettings() {\n\n\t\tvar {width: w, height: h} = this.chartState.data;\n\n\t\t// settings for pixel-perfect camera\n\t\tvar FOV = 75;\n\t\tvar vFOV = FOV * (Math.PI / 180);\n\t\t\n\t\treturn {\n\t\t\tFOV: FOV,\n\t\t\taspect: w / h,\n\t\t\tnear: 0.1,\n\t\t\tfar: 5000,\n\t\t\tz: h / (2 * Math.tan(vFOV / 2) ),\n\n\t\t\t// move 0,0 to left-bottom corner\n\t\t\tx: w / 2,\n\t\t\ty: h / 2\n\t\t}\n\t}\n\n\tonZoomFrame(cb: (zoomX: number, zoomY: number) => void): Function {\n\t\tvar eventName = 'zoomFrame';\n\t\tthis.ee.on(eventName, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(eventName, cb);\n\t\t}\n\t}\n\n\tonScrollFrame(cb: (options: IScreenTransformOptions) => void): Function {\n\t\tvar eventName = 'scrollFrame';\n\t\tthis.ee.on(eventName, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(eventName, cb);\n\t\t}\n\t}\n\n\tonTransformationFrame(cb: (options: IScreenTransformOptions) => void): Function {\n\t\tvar eventName = 'transformationFrame';\n\t\tthis.ee.on(eventName, cb);\n\t\treturn () => {\n\t\t\tthis.ee.off(eventName, cb);\n\t\t}\n\t}\n\n\tcameraIsMoving(): boolean {\n\t\treturn !!(\n\t\t\tthis.scrollXAnimation && this.scrollXAnimation.isActive() ||\n\t\t\t\tthis.zoomXAnimation && this.zoomXAnimation.isActive()\n\t\t);\n\t}\n\n\tprivate transform (options: IScreenTransformOptions, silent = false) {\n\t\tvar {scrollX, scrollY, zoomX, zoomY} = options;\n\t\t\n\t\tif (scrollX != void 0) this.options.scrollX = scrollX;\n\t\tif (scrollY != void 0) this.options.scrollY = scrollY;\n\t\tif (zoomX != void 0) this.options.zoomX = zoomX;\n\t\tif (zoomY != void 0) this.options.zoomY = zoomY;\n\n\t\tif (scrollX != void 0 || zoomX) {\n\t\t\toptions.scrollXVal = this.pxToValueByXAxis(scrollX != void 0 ? scrollX : this.options.scrollX);\n\t\t\tthis.options.scrollXVal = options.scrollXVal;\n\t\t}\n\n\t\tif (scrollY != void 0 || zoomY) {\n\t\t\toptions.scrollYVal = this.pxToValueByYAxis(scrollY != void 0 ? scrollY : this.options.scrollY);\n\t\t\tthis.options.scrollYVal = options.scrollYVal;\n\t\t}\n\n\t\tif (silent) return;\n\n\t\tthis.ee.emit('transformationFrame', options);\n\t\t\n\t\tif (options.scrollXVal != void 0 || options.scrollYVal != void 0) {\n\t\t\tthis.ee.emit('scrollFrame', options);\n\t\t}\n\t\t\n\t\tif (options.zoomX != void 0 || options.zoomY != void 0) {\n\t\t\tthis.ee.emit('zoomFrame', options);\n\t\t}\n\t}\n\n\n\tprivate bindEvents() {\n\t\tvar state = this.chartState;\n\n\t\t// handle scroll and zoom\n\t\tstate.onChange((changedProps) => {\n\t\t\tif (changedProps.xAxis && changedProps.xAxis.range) {\n\t\t\t\tif (changedProps.xAxis.range.scroll != void 0) this.onScrollXHandler(changedProps);\n\t\t\t\tif (changedProps.xAxis.range.zoom) this.onZoomXHandler();\n\t\t\t}\n\t\t\tif (changedProps.yAxis && changedProps.yAxis.range){\n\t\t\t\tif (changedProps.yAxis.range.scroll != void 0) this.onScrollYHandler();\n\t\t\t\tif (changedProps.yAxis.range.zoom) this.onZoomYHandler();\n\t\t\t}\n\t\t});\n\t\tstate.onDestroy(() => this.onDestroyHandler());\n\t}\n\n\tprivate onDestroyHandler() {\n\t\tthis.ee.removeAllListeners();\n\t\tthis.scrollXAnimation && this.scrollXAnimation.kill();\n\t\tthis.scrollYAnimation && this.scrollYAnimation.kill();\n\t\tthis.zoomXAnimation && this.zoomXAnimation.kill();\n\t\tthis.zoomYAnimation && this.zoomYAnimation.kill();\n\t}\n\n\tprivate onScrollXHandler(changedProps: IChartState) {\n\t\tvar state = this.chartState;\n\t\tvar isDragMode = state.data.cursor.dragMode;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled && !isDragMode;\n\t\tvar zoomXChanged = changedProps.xAxis.range.zoom;\n\t\tvar isAutoscroll = state.data.autoScroll && !isDragMode && !zoomXChanged;\n\t\tvar time = isAutoscroll ? animations.autoScrollSpeed : animations.zoomSpeed;\n\t\tvar ease = isAutoscroll ? animations.autoScrollEase : animations.zoomEase;\n\t\tif (this.scrollXAnimation) this.scrollXAnimation.pause();\n\n\t\tvar range = state.data.xAxis.range;\n\t\tvar targetX = range.scroll * range.scaleFactor * range.zoom;\n\t\tthis.currentScrollX.x = this.options.scrollX;\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({scrollX: this.currentScrollX.x});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.scrollXAnimation = TweenLite.to(this.currentScrollX, time, {\n\t\t\t\tx: targetX, ease: ease\n\t\t\t});\n\t\t\tthis.scrollXAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentScrollX.x = targetX;\n\t\t\tcb();\n\t\t}\n\n\t}\n\n\tprivate onScrollYHandler() {\n\t\tvar state = this.chartState;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled;\n\t\tvar time = animations.zoomSpeed;\n\t\tif (this.scrollYAnimation) this.scrollYAnimation.pause();\n\t\tvar range = state.data.yAxis.range;\n\t\tvar targetY = range.scroll * range.scaleFactor * range.zoom;\n\n\t\tthis.currentScrollY.y = this.options.scrollY;\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({scrollY: this.currentScrollY.y});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.scrollYAnimation = TweenLite.to(this.currentScrollY, time, {\n\t\t\t\ty: targetY, ease: animations.zoomEase\n\t\t\t});\n\t\t\tthis.scrollYAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentScrollY.y = targetY;\n\t\t\tcb();\n\t\t}\n\t}\n\n\tprivate onZoomXHandler() {\n\t\tvar state = this.chartState;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled;\n\t\tvar time = animations.zoomSpeed;\n\t\tvar targetZoom = state.data.xAxis.range.zoom;\n\t\tif (this.zoomXAnimation) this.zoomXAnimation.pause();\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({zoomX: this.currentZoomX.val});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.zoomXAnimation = TweenLite.to(this.currentZoomX, time, {\n\t\t\t\tval: targetZoom, ease: animations.zoomEase\n\t\t\t});\n\t\t\tthis.zoomXAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentZoomX.val = targetZoom;\n\t\t\tcb();\n\t\t}\n\t}\n\n\tprivate onZoomYHandler() {\n\t\tvar state = this.chartState;\n\t\tvar animations =  state.data.animations;\n\t\tvar canAnimate = animations.enabled;\n\t\tvar time = animations.zoomSpeed;\n\t\tvar targetZoom = state.data.yAxis.range.zoom;\n\t\tif (this.zoomYAnimation) this.zoomYAnimation.pause();\n\n\t\tvar cb = () => {\n\t\t\tthis.transform({zoomY: this.currentZoomY.val});\n\t\t};\n\n\t\tif (canAnimate) {\n\t\t\tthis.zoomYAnimation = TweenLite.to(this.currentZoomY, time, {\n\t\t\t\tval: targetZoom, ease: animations.zoomEase\n\t\t\t});\n\t\t\tthis.zoomYAnimation.eventCallback('onUpdate', cb);\n\t\t} else {\n\t\t\tthis.currentZoomY.val = targetZoom;\n\t\t\tcb();\n\t\t}\n\t}\n\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal to scrollXVal\n\t */\n\tgetPointOnXAxis(xVal: number): number {\n\t\tvar {scaleFactor, zeroVal} = this.chartState.data.xAxis.range;\n\t\tvar zoom = this.options.zoomX;\n\t\treturn (xVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from yAxis.range.zeroVal to scrollYVal\n\t */\n\tgetPointOnYAxis(yVal: number): number {\n\t\tvar {scaleFactor, zeroVal} =  this.chartState.data.yAxis.range;\n\t\tvar zoom = this.options.zoomY;\n\t\treturn (yVal - zeroVal) * scaleFactor * zoom;\n\t}\n\n\t/**\n\t *  returns offset in pixels from xAxis.range.zeroVal and from yAxis.range.zeroVal to scrollXVal and scrollYVal\n\t */\n\tgetPointOnChart(xVal: number, yVal: number): Vector3 {\n\t\treturn new Vector3(this.getPointOnXAxis(xVal), this.getPointOnYAxis(yVal), 0);\n\t}\n\t\n\t/**\n\t * returns value by offset in pixels from xAxis.range.zeroVal\n\t */\n\tgetValueOnXAxis(x: number): number {\n\t\treturn this.chartState.data.xAxis.range.zeroVal + this.pxToValueByXAxis(x);\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from xAxis.range\n\t */\n\tvalueToPxByXAxis(xVal: number) {\n\t\treturn xVal * this.chartState.data.xAxis.range.scaleFactor * this.options.zoomX;\n\t}\n\n\n\t/**\n\t *  convert value to pixels by using settings from yAxis.range\n\t */\n\tvalueToPxByYAxis(yVal: number) {\n\t\treturn yVal * this.chartState.data.yAxis.range.scaleFactor * this.options.zoomY;\n\t}\n\t\n\t/**\n\t *  convert pixels to value by using settings from xAxis.range\n\t */\n\tpxToValueByXAxis(xVal: number) {\n\t\treturn xVal / this.chartState.data.xAxis.range.scaleFactor / this.options.zoomX;\n\t}\n\n\n\t/**\n\t *  convert pixels to value by using settings from yAxis.range\n\t */\n\tpxToValueByYAxis(yVal: number) {\n\t\treturn yVal / this.chartState.data.yAxis.range.scaleFactor / this.options.zoomY;\n\t}\n\n\n\t/**\n\t *  returns scrollX value by screen scrollX coordinate\n\t */\n\tgetValueByScreenX(x: number): number {\n\t\treturn this.chartState.data.xAxis.range.zeroVal + this.options.scrollXVal + this.pxToValueByXAxis(x);\n\t}\n\t\n\t\n\t/**\n\t *  returns scrollY value by screen scrollY coordinate\n\t */\n\tgetValueByScreenY(y: number): number {\n\t\treturn this.chartState.data.yAxis.range.zeroVal + this.options.scrollYVal + this.pxToValueByYAxis(y);\n\t}\n\t\n\t//\n\t/**\n\t *  returns screen scrollX value by screen scrollY coordinate\n\t */\n\tgetScreenXByValue(xVal: number): number {\n\t\tvar {scroll, zeroVal} = this.chartState.data.xAxis.range;\n\t\treturn this.valueToPxByXAxis(xVal - zeroVal - scroll)\n\t}\n\n\t// /**\n\t//  *  returns screen scrollY value by screen scrollY coordinate\n\t//  */\n\t// getScreenYByValue(scrollYVal: number): number {\n\t// \tvar {scroll, zeroVal} = this.data.yAxis.range;\n\t// \treturn this.valueToPxByYAxis(scrollYVal - zeroVal - scroll)\n\t// }\n\t//\n\t//\n\t/**\n\t * returns screen scrollX coordinate by offset in pixels from xAxis.range.zeroVal value\n\t */\n\tgetScreenXByPoint(xVal: number): number {\n\t\treturn this.getScreenXByValue(this.getValueOnXAxis(xVal));\n\t}\n\n\n\t/**\n\t * returns offset in pixels from xAxis.range.zeroVal value by screen scrollX coordinate\n\t */\n\tgetPointByScreenX(screenX: number): number {\n\t\treturn this.getPointOnXAxis(this.getValueByScreenX(screenX));\n\t}\n\n\t/**\n\t * returns offset in pixels from yAxis.range.zeroVal value by screen scrollY coordinate\n\t */\n\tgetPointByScreenY(screenY: number): number {\n\t\treturn this.getPointOnYAxis(this.getValueByScreenY(screenY));\n\t}\n\n\tgetTop(): number {\n\t\treturn this.getPointByScreenY(this.chartState.data.height);\n\t}\n\t\n\tgetBottom(): number {\n\t\treturn this.getPointByScreenY(0);\n\t}\n\n\tgetLeft(): number {\n\t\treturn this.getPointByScreenX(0);\n\t}\n\n\tgetScreenRightVal() {\n\t\treturn this.getValueByScreenX(this.chartState.data.width);\n\t}\n\n\tgetTopVal() {\n\t\treturn this.getValueByScreenY(this.chartState.data.height);\n\t}\n\t\n\tgetBottomVal() {\n\t\treturn this.getValueByScreenY(0);\n\t}\n\n\tgetCenterYVal() {\n\t\treturn this.getValueByScreenY(this.chartState.data.height / 2);\n\t}\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Screen.ts\n **/","\nimport {ChartState} from \"./State\";\nimport {Utils} from \"./Utils\";\nimport {AXIS_TYPE} from \"./interfaces\";\nimport {ITrendData, ITrendOptions} from \"./Trend\";\nimport {EventEmitter} from './EventEmmiter';\n\nexport interface IAxisMarkUpdateOptions {\n\tvalue: number,\n\tdisplayedValue?: string\n}\n\nexport interface IAxisMarkOptions extends IAxisMarkUpdateOptions {\n\tname?: string;\n\ttitle?: string;\n\ttype?: string;\n\tlineColor?: string;\n\tlineWidth?: number;\n\tshowValue?: boolean;\n\tstickToEdges?: boolean;\n}\n\nconst AXIS_MARK_DEFAULT_OPTIONS: IAxisMarkOptions = {\n\ttype: 'simple',\n\tlineWidth: 1,\n\tvalue: 0,\n\tshowValue: false,\n\tstickToEdges: false,\n\tlineColor: '#FFFFFF',\n\ttitle: ''\n};\n\nexport class AxisMarks {\n\tprivate chartState: ChartState;\n\tprivate axisType: AXIS_TYPE;\n\tprivate ee: EventEmitter;\n\tprivate items: {[name: string]: AxisMark} = {};\n\n\tconstructor(chartState: ChartState, axisType: AXIS_TYPE) {\n\t\tthis.chartState = chartState;\n\t\tthis.ee = new EventEmitter();\n\t\tthis.axisType = axisType;\n\t\tvar marks = this.items;\n\t\tvar axisMarksOptions = axisType == AXIS_TYPE.X ? chartState.data.xAxis.marks : chartState.data.yAxis.marks;\n\t\t\n\t\tfor (let options of axisMarksOptions) {\n\t\t\tlet axisMark: AxisMark;\n\t\t\toptions = Utils.deepMerge(AXIS_MARK_DEFAULT_OPTIONS, options);\n\t\t\t\n\t\t\t// set mark name\n\t\t\tif (!options.name) options.name = Utils.getUid().toString();\n\t\t\tif (marks[options.name]) Utils.error('duplicated mark name ' + options.name);\n\t\t\t\n\t\t\t// create mark instance based on type option\n\t\t\tif (options.type == 'timeleft') {\n\t\t\t\taxisMark = new AxisTimeleftMark(chartState, axisType, options);\n\t\t\t} else {\n\t\t\t\taxisMark = new AxisMark(chartState, axisType, options);\n\t\t\t}\n\t\t\tmarks[options.name] = axisMark;\n\t\t}\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.chartState.onTrendChange((trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tthis.onTrendChange(trendName, newData)\n\t\t});\n\t\tthis.chartState.onDestroy(() => this.ee.removeAllListeners());\n\t}\n\n\tprivate onTrendChange(trendName: string, newData: ITrendData) {\n\t\tif (!newData) return;\n\t\tvar startVal = newData[0].xVal;\n\t\tvar endVal = newData[newData.length - 1].xVal;\n\t\tvar marks = this.items;\n\n\t\tfor (let markName in marks) {\n\t\t\tlet mark = marks[markName];\n\t\t\tlet markVal = mark.options.value;\n\t\t\tlet markWasCrossed = (startVal == markVal || endVal == markVal || (startVal < markVal && endVal > markVal));\n\t\t\tif (markWasCrossed) this.ee.emit('markCrossed', trendName, newData);\n\t\t}\n\t}\n\n\n\tgetItems() {\n\t\treturn this.items;\n\t}\n\t\n\tgetItem(markName: string) {\n\t\treturn this.items[markName];\n\t}\n\n}\n\nexport class AxisMark {\n\tstatic typeName = 'simple';\n\toptions: IAxisMarkOptions;\n\taxisType: AXIS_TYPE;\n\tprotected chartState: ChartState;\n\tprotected renderOnTrendsChange = false;\n\tprotected ee: EventEmitter;\n\n\tconstructor(chartState: ChartState, axisType: AXIS_TYPE, options: IAxisMarkOptions) {\n\t\tthis.ee = new EventEmitter();\n\t\tthis.options = options;\n\t\tthis.axisType = axisType;\n\t\tthis.chartState = chartState;\n\t\tthis.bindEvents();\n\t}\n\t\n\tprotected bindEvents() {}\n\n\tsetOptions(newOptions: IAxisMarkUpdateOptions) {\n\t\tvar value = this.options.value;\n\t\tthis.options = Utils.deepMerge(this.options, newOptions);\n\t\tif (this.options.value !== value) this.ee.emit('valueChange');\n\t\tthis.ee.emit('onDisplayedValueChange');\n\t}\n\n\tgetDisplayedVal(): string {\n\t\tlet {value, displayedValue} = this.options;\n\t\treturn String(displayedValue !== void 0 ? displayedValue : value);\n\t}\n\n\tonMarkCrossed(cb: (trendName: string, newData: ITrendData) => void): Function {\n\t\tthis.ee.on('markCrossed', cb);\n\t\treturn () => {\n\t\t\tthis.ee.off('markCrossed', cb);\n\t\t}\n\t}\n\n\tonValueChange(cb: () => void) {\n\t\tthis.ee.on('valueChange', cb);\n\t\treturn () => {\n\t\t\tthis.ee.off('valueChange', cb);\n\t\t}\n\t}\n\n\tonDisplayedValueChange(cb: () => void) {\n\t\tthis.ee.on('onDisplayedValueChange', cb);\n\t\treturn () => {\n\t\t\tthis.ee.off('onDisplayedValueChange', cb);\n\t\t}\n\t}\n}\n\nexport class AxisTimeleftMark extends AxisMark {\n\tstatic typeName = 'timeleft';\n\tprotected renderOnTrendsChange = true;\n\t\n\tgetDisplayedVal(): string {\n\t\tvar markVal = this.options.value;\n\t\tvar maxXVal = this.chartState.data.computedData.trends.maxXVal;\n\t\tvar time = markVal - maxXVal;\n\t\tif (time < 0) time = 0;\n\t\treturn Utils.msToTimeString(time);\n\t}\n\n\tprotected bindEvents() {\n\t\tthis.chartState.onTrendsChange(() => this.onTrendsChange());\n\t}\n\n\tprotected onTrendsChange() {\n\t\tthis.ee.emit('onDisplayedValueChange');\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/AxisMarks.ts\n **/","\n\n/**\n * defines how axis range will be calculated\n * FIXED - directly use range.from and range.to value\n * AUTO - automatically sets range.from and range.to by visible part of opposite axis\n * RELATIVE_END - same as AUTO, but trend end always present in range\n * ALL - automatically sets range.from and range.to by all values of opposite axis\n *\n */\nimport {IAxisMarkOptions} from \"./AxisMarks\";\nexport enum AXIS_RANGE_TYPE {\n\tFIXED,\n\tRELATIVE_END,\n\tAUTO,\n\tALL // TODO: AXIS_RANGE_TYPE.ALL\n}\n\n/**\n * Animation ease type\n */\nexport declare type TEase = Ease | Linear;\n\nexport declare type TIteralable = {[key: string]: any};\nexport interface IIteralable {[key: string]: any};\n\nexport enum AXIS_TYPE {X, Y}\n\nexport interface IAxisRange {\n\ttype?: AXIS_RANGE_TYPE,\n\tfrom?: number,\n\tto?: number,\n\tzoom?: number,\n\tscroll?: number,\n\n\t/**\n\t * Mode only for Y axis. When true displayed center of Y axis never changed. To use set range.zeroVal as center value.\n\t */\n\tisMirrorMode?: boolean,\n\n\tpadding?: {\n\t\tstart?: number,\n\t\tend?: number\n\t},\n\n\tmargin?: {\n\t\tstart?: number,\n\t\tend?: number\n\t},\n\n\tmaxLength?: number;\n\tminLength?: number;\n\n\t/**\n\t * value in world center coordinate\n\t */\n\tzeroVal?: number,\n\n\t/**\n\t * ratio between 1 pixel and 1 value for zoom = 1\n\t */\n\tscaleFactor?: number,\n}\n\nexport enum AXIS_DATA_TYPE {NUMBER, DATE}\n\nexport interface IAxisOptions {\n\trange?: IAxisRange;\n\tdataType?: AXIS_DATA_TYPE;\n\tautoScroll?: boolean;\n\tmarks?: IAxisMarkOptions[];\n\tgrid?: IGridOptions\n}\n\nexport interface IGridOptions {\n\tenabled: boolean;\n\tminSizePx?: number;\n}\n\nexport interface IAnimationsOptions {\n\tenabled?: boolean,\n\ttrendChangeSpeed?: number,\n\ttrendChangeEase?: TEase,\n\tscrollSpeed?: number,\n\tscrollEase?: TEase,\n\tautoScrollSpeed?: number,\n\tautoScrollEase?: TEase,\n\tzoomSpeed?: number,\n\tzoomEase?: TEase,\n}\n\nexport interface PromiseExecutor<T> {\n\t(resolve: (data: T) => void, reject: (data: T) => void): void;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/interfaces.ts\n **/","import {ChartState} from \"./State\";\nimport Object3D = THREE.Object3D;\n\nexport interface IChartWidgetConstructor {\n\tnew (): ChartWidget;\n\twidgetName: string;\n}\n\n/**\n * base class for all widgets\n * each widget must have widgetName static property\n */\nexport abstract class ChartWidget {\n\tstatic widgetName = '';\n\tprotected chartState: ChartState;\n\tprivate unbindList: Function[] = [];\n\n\n\tsetupChartState(chartState: ChartState) {\n\t\tthis.chartState = chartState;\n\t}\n\n\tabstract onReadyHandler(): any;\n\tabstract getObject3D(): Object3D;\n\n\n\tprotected bindEvent(...args: Array<Function | Function[]>): void {\n\t\tlet unbindList: Function[] = [];\n\t\tif (!Array.isArray(args[0])) {\n\t\t\tunbindList.push(args[0] as Function);\n\t\t} else {\n\t\t\tunbindList.push(...args as Function[]);\n\t\t}\n\t\tthis.unbindList.push(...unbindList);\n\t}\n\tprotected unbindEvents() {\n\t\tthis.unbindList.forEach(unbindEvent => unbindEvent());\n\t\tthis.unbindList.length = 0;\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Widget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport UVMapping = THREE.UVMapping;\nimport GridHelper = THREE.GridHelper;\nimport {ChartWidget} from \"../Widget\";\nimport {ChartState} from \"../State\";\nimport {GridWidget, IGridParamsForAxis} from \"./GridWidget\";\nimport {Utils} from \"../Utils\";\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport OrthographicCamera = THREE.OrthographicCamera;\nimport {IScreenTransformOptions} from \"../Screen\";\nimport {AXIS_TYPE, AXIS_DATA_TYPE, IAxisOptions} from \"../interfaces\";\n\n/**\n * widget for drawing axis\n */\nexport class AxisWidget extends ChartWidget {\n\tstatic widgetName = 'Axis';\n\tprivate isDestroyed = false;\n\tprivate object3D: Object3D;\n\tprivate axisXObject: Object3D;\n\tprivate axisYObject: Object3D;\n\tprivate updateAxisXRequest: () => void;\n\n\tonReadyHandler() {\n\t\tthis.object3D = new Object3D();\n\t\tthis.axisXObject = new Object3D();\n\t\tthis.axisYObject = new Object3D();\n\t\tthis.object3D.add(this.axisXObject);\n\t\tthis.object3D.add(this.axisYObject);\n\t\tthis.setupAxis(AXIS_TYPE.X);\n\t\tthis.setupAxis(AXIS_TYPE.Y);\n\n\t\t// canvas drawing is expensive operation, so when we scroll, redraw must be called only once per second\n\t\tthis.updateAxisXRequest = Utils.throttle(() => this.updateAxis(AXIS_TYPE.X), 1000);\n\n\t\tthis.onScrollChange(\n\t\t\tthis.chartState.screen.options.scrollX,\n\t\t\tthis.chartState.screen.options.scrollY\n\t\t);\n\t\tthis.bindEvents();\n\t}\n\n\tbindEvents() {\n\t\tvar state = this.chartState;\n\n\t\tthis.bindEvent(\n\t\t\tstate.screen.onTransformationFrame((options) => {\n\t\t\t\tthis.onScrollChange(options.scrollX, options.scrollY);\n\t\t\t}),\n\t\t\tstate.screen.onZoomFrame((options) => {this.onZoomFrame(options)}),\n\t\t\tstate.onDestroy(() => this.onDestroy()),\n\t\t\tstate.onResize(() => this.onResize())\n\t\t);\n\t}\n\n\tprivate onDestroy() {\n\t\tthis.isDestroyed = true;\n\t\tthis.unbindEvents();\n\t}\n\n\tprivate onScrollChange(x: number, y: number) {\n\n\t\tif (y != void 0) {\n\t\t\tthis.axisYObject.position.y = y;\n\t\t\tthis.axisXObject.position.y = y;\n\t\t}\n\n\t\tif (x != void 0) {\n\t\t\tthis.axisYObject.position.x = x;\n\t\t\tthis.updateAxisXRequest();\n\t\t}\n\n\t}\n\n\tprivate onResize() {\n\t\tthis.setupAxis(AXIS_TYPE.X);\n\t\tthis.setupAxis(AXIS_TYPE.Y);\n\t}\n\n\tprivate setupAxis(orientation: AXIS_TYPE) {\n\n\t\tlet isXAxis = orientation == AXIS_TYPE.X;\n\t\tlet {width: visibleWidth, height: visibleHeight} = this.chartState.data;\n\t\tlet canvasWidth = 0, canvasHeight = 0;\n\n\t\t// clean meshes\n\t\tif (isXAxis) {\n\t\t\tthis.axisXObject.traverse(obj => this.axisXObject.remove(obj));\n\t\t\tcanvasWidth = visibleWidth * 3;\n\t\t\tcanvasHeight = 50;\n\t\t} else {\n\t\t\tthis.axisYObject.traverse(obj => this.axisYObject.remove(obj));\n\t\t\tcanvasWidth = 50;\n\t\t\tcanvasHeight = visibleHeight * 3;\n\t\t}\n\n\t\tvar texture = Utils.createPixelPerfectTexture(canvasWidth, canvasHeight, (ctx) => {\n\t\t\tctx.beginPath();\n\t\t\tctx.font = \"10px Arial\";\n\t\t\tctx.fillStyle = \"rgba(255,255,255,0.5)\";\n\t\t\tctx.strokeStyle = \"rgba(255,255,255,0.1)\";\n\t\t});\n\n\n\t\tvar material = new THREE.MeshBasicMaterial( {map: texture, side: THREE.FrontSide} );\n\t\tmaterial.transparent = true;\n\n\t\tvar axisMesh = new Mesh(\n\t\t\tnew THREE.PlaneGeometry(canvasWidth, canvasHeight),\n\t\t\tmaterial\n\t\t);\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh.position.set(canvasWidth / 2, canvasHeight / 2, 0);\n\t\t\tthis.axisXObject.add(axisMesh);\n\t\t} else {\n\t\t\taxisMesh.position.set(visibleWidth - canvasWidth / 2, canvasHeight / 2, 0);\n\t\t\tthis.axisYObject.add(axisMesh);\n\t\t}\n\n\t\tthis.updateAxis(orientation);\n\n\t}\n\t\n\tgetObject3D(): Object3D {\n\t\treturn this.object3D;\n\t}\n\n\tprivate updateAxis(orientation: AXIS_TYPE) {\n\t\tif (this.isDestroyed) return;\n\t\tvar isXAxis = orientation == AXIS_TYPE.X;\n\t\tvar {width: visibleWidth, height: visibleHeight} = this.chartState.data;\n\t\tvar {scrollX, scrollY, zoomX, zoomY} = this.chartState.screen.options;\n\t\tvar axisOptions: IAxisOptions;\n\t\tvar axisMesh: Mesh;\n\t\tvar axisGridParams: IGridParamsForAxis;\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh = this.axisXObject.children[0] as Mesh;\n\t\t\taxisOptions = this.chartState.data.xAxis;\n\t\t\taxisGridParams = GridWidget.getGridParamsForAxis(axisOptions, visibleWidth, zoomX);\n\t\t} else {\n\t\t\taxisMesh = this.axisYObject.children[0] as Mesh;\n\t\t\taxisOptions = this.chartState.data.yAxis;\n\t\t\taxisGridParams = GridWidget.getGridParamsForAxis(axisOptions, visibleHeight, zoomY);\n\t\t}\n\n\t\tvar geometry = axisMesh.geometry as PlaneGeometry;\n\t\tvar canvasWidth = geometry.parameters.width;\n\t\tvar canvasHeight = geometry.parameters.height;\n\t\tvar texture = (axisMesh.material as MeshBasicMaterial).map;\n\t\tvar ctx = texture.image.getContext('2d');\n\t\tctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n\t\tif (isXAxis) {\n\t\t\taxisMesh.position.x = canvasWidth / 2 - visibleWidth + scrollX;\n\t\t}\n\n\n\t\t// TODO: draw text and lines in different loops\n\t\tvar edgeOffset = axisGridParams.segmentsCount * axisGridParams.step;\n\t\tvar startVal = axisGridParams.start  - edgeOffset;\n\t\tvar endVal = axisGridParams.end + edgeOffset;\n\n\t\tctx.beginPath();\n\t\tfor (let val = startVal; val <= endVal; val += axisGridParams.step) {\n\t\t\tlet displayedValue = '';\n\t\t\tif (isXAxis) {\n\t\t\t\tlet pxVal = this.chartState.screen.getPointOnXAxis(val) - scrollX + visibleWidth;\n\t\t\t\tctx.textAlign = \"center\";\n\t\t\t\t// uncomment for dots\n\t\t\t\t// ctx.moveTo(pxVal + 0.5, canvasHeight);\n\t\t\t\t// ctx.lineTo(pxVal + 0.5, canvasHeight - 5);\n\t\t\t\tif (axisOptions.dataType == AXIS_DATA_TYPE.DATE) {\n\t\t\t\t\tdisplayedValue = AxisWidget.getDateStr(val, axisGridParams);\n\t\t\t\t} else {\n\t\t\t\t\tdisplayedValue = Number(val.toFixed(14)).toString();\n\t\t\t\t}\n\n\t\t\t\tctx.fillText(displayedValue, pxVal, canvasHeight - 10);\n\t\t\t} else {\n\t\t\t\tlet pxVal = canvasHeight - this.chartState.screen.getPointOnYAxis(val) + scrollY;\n\t\t\t\tctx.textAlign = \"right\";\n\t\t\t\t// uncomment for dots\n\t\t\t\t// ctx.moveTo(canvasWidth, pxVal + 0.5);\n\t\t\t\t// ctx.lineTo(canvasWidth - 5, pxVal + 0.5);\n\n\t\t\t\tdisplayedValue = Number(val.toFixed(14)).toString();\n\t\t\t\tctx.fillText(displayedValue, canvasWidth - 15 , pxVal + 3);\n\n\t\t\t\t// uncomment for left-side axis\n\t\t\t\t// ctx.moveTo(0, pxVal + 0.5);\n\t\t\t\t// ctx.lineTo(5, pxVal + 0.5);\n\t\t\t\t// ctx.fillText(Number(val.toFixed(14)).toString(), 15 , pxVal + 3);\n\t\t\t}\n\t\t\tctx.stroke();\n\t\t}\n\t\t// uncomment to preview canvas borders\n\t\t// ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\t\tctx.stroke();\n\t\tctx.closePath();\n\t\ttexture.needsUpdate = true;\n\t}\n\n\tprivate onZoomFrame(options: IScreenTransformOptions) {\n\t\tif (options.zoomX) {\n\t\t\tthis.updateAxis(AXIS_TYPE.X);\n\t\t\t//this.temporaryHideAxis(AXIS_ORIENTATION.H)\n\t\t}\n\t\tif (options.zoomY) {\n\t\t\tthis.updateAxis(AXIS_TYPE.Y);\n\t\t\t//this.temporaryHideAxis(AXIS_ORIENTATION.V)\n\t\t}\n\t}\n\n\t// private temporaryHideAxis(orientation: AXIS_TYPE) {\n\t// \tvar isXAxis = orientation == AXIS_TYPE.X;\n\t// \tvar timeoutId = setTimeout(() => {\n\t// \t\t\tthis.showAxis(orientation);\n\t// \t}, 200);\n\t//\n\t// \tif (isXAxis) {\n\t// \t\t(this.axisXObject.children[0] as Mesh).material.opacity = 0;\n\t// \t\tclearTimeout(this.showAxisXTimeout);\n\t// \t\tthis.showAxisXTimeout =\ttimeoutId;\n\t// \t} else {\n\t// \t\tclearTimeout(this.showAxisYTimeout);\n\t// \t\t(this.axisYObject.children[0] as Mesh).material.opacity = 0;\n\t// \t\tthis.showAxisYTimeout = timeoutId;\n\t// \t}\n\t// }\n\n\t// private showAxis(orientation: AXIS_TYPE) {\n\t// \tvar isXAxis = orientation == AXIS_TYPE.X;\n\t// \tvar material: MeshBasicMaterial;\n\t// \tif (isXAxis) {\n\t// \t\tmaterial = (this.axisXObject.children[0] as Mesh).material as MeshBasicMaterial;\n\t// \t} else {\n\t// \t\tmaterial = (this.axisYObject.children[0] as Mesh).material as MeshBasicMaterial;\n\t// \t}\n\t// \tthis.updateAxis(orientation);\n\t// \tTweenLite.to(material, 0.3, {opacity: 1});\n\t// }\n\n\tstatic getDateStr(timestamp: number, gridParams: IGridParamsForAxis): string {\n\t\tvar sec = 1000;\n\t\tvar min = sec * 60;\n\t\tvar hour = min * 60;\n\t\tvar day = hour * 60;\n\t\tvar step = gridParams.step;\n\t\tvar d = new Date(timestamp);\n\t\tvar tf = (num: number) => Utils.toFixed(num, 2);\n\t\treturn tf(d.getHours()) + ':' + tf(d.getMinutes()) + ':' + tf(d.getSeconds());\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/AxisWidget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport {ChartWidget} from \"../Widget\";\nimport LineSegments = THREE.LineSegments;\nimport {Utils} from \"../Utils\";\nimport {IScreenTransformOptions} from \"../Screen\";\nimport {IAxisOptions} from \"../interfaces\";\n\nexport interface IGridParamsForAxis {\n\tstart: number,\n\tend: number,\n\tstep: number,\n\tstepInPx: number,\n\tlength: number,\n\tsegmentsCount: number\n}\n\n/**\n * widget for drawing chart grid\n */\nexport class GridWidget extends ChartWidget{\n\tstatic widgetName = 'Grid';\n\tprivate lineSegments: LineSegments;\n\tprivate gridSizeH: number;\n\tprivate gridSizeV: number;\n\tprivate isDestroyed = false;\n\n\tonReadyHandler() {\n\t\tvar {width, height, xAxis, yAxis} = this.chartState.data;\n\t\tthis.gridSizeH = Math.floor(width / xAxis.grid.minSizePx) * 3;\n\t\tthis.gridSizeV = Math.floor(height / yAxis.grid.minSizePx) * 3;\n\t\tthis.initGrid();\n\t\tthis.updateGrid();\n\t\tthis.bindEvents();\n\t}\n\n\tbindEvents() {\n\t\t// grid is bigger then screen, so it's no need to update it on each scroll event\n\t\tlet updateGridThrottled = Utils.throttle(() => this.updateGrid(), 1000);\n\t\tthis.bindEvent(this.chartState.onScroll(() => updateGridThrottled()),\n\t\t\tthis.chartState.screen.onZoomFrame((options) => {\n\t\t\t\tupdateGridThrottled();\n\t\t\t\tthis.onZoomFrame(options);\n\t\t\t}),\n\t\t\tthis.chartState.onDestroy(() => {\n\t\t\t\tthis.isDestroyed = true;\n\t\t\t\tthis.unbindEvents();\n\t\t\t}),\n\t\t\tthis.chartState.onResize(() => {\n\t\t\t\tthis.updateGrid();\n\t\t\t})\n\t\t);\n\n\t}\n\n\tprivate initGrid() {\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.LineBasicMaterial( { linewidth: 1, opacity: 0.1, transparent: true});\n\t\tvar xLinesCount = this.gridSizeH;\n\t\tvar yLinesCount = this.gridSizeV;\n\t\twhile (xLinesCount--) geometry.vertices.push(new Vector3(), new Vector3());\n\t\twhile (yLinesCount--) geometry.vertices.push(new Vector3(), new Vector3());\n\t\tthis.lineSegments = new LineSegments(geometry, material);\n\t\tthis.lineSegments.position.setZ(-1);\n\t\tthis.lineSegments.frustumCulled = false;\n\t}\n\n\tprivate updateGrid() {\n\t\tif (this.isDestroyed) return;\n\t\tvar {yAxis, xAxis, width, height} = this.chartState.data;\n\t\tvar axisXGrid = GridWidget.getGridParamsForAxis(xAxis, width, xAxis.range.zoom);\n\t\tvar axisYGrid = GridWidget.getGridParamsForAxis(yAxis, height, yAxis.range.zoom);\n\t\tvar scrollXInSegments = Math.ceil(xAxis.range.scroll / axisXGrid.step);\n\t\tvar scrollYInSegments = Math.ceil(yAxis.range.scroll / axisYGrid.step);\n\t\tvar gridScrollXVal = scrollXInSegments * axisXGrid.step;\n\t\tvar gridScrollYVal = scrollYInSegments * axisYGrid.step;\n\t\tvar startXVal = axisXGrid.start + gridScrollXVal;\n\t\tvar startYVal = axisYGrid.start + gridScrollYVal;\n\t\tvar geometry = this.lineSegments.geometry as Geometry;\n\t\tvar vertices = geometry.vertices;\n\t\tvar lineInd = 0;\n\n\t\tfor (let i =  -this.gridSizeH / 3; i < this.gridSizeH * 2/3; i++) {\n\t\t\tlet value = startXVal + i * axisXGrid.step;\n\t\t\tlet lineSegment = this.getVerticalLineSegment(value, gridScrollXVal, gridScrollYVal);\n\t\t\tvertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\n\t\t\tvertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\n\t\t\tlineInd++;\n\t\t}\n\n\t\tfor (let i =  -this.gridSizeV / 3; i < this.gridSizeV * 2/3; i++) {\n\t\t\tlet value = startYVal + i * axisYGrid.step;\n\t\t\tlet lineSegment = this.getHorizontalLineSegment(value, gridScrollXVal, gridScrollYVal);\n\t\t\tvertices[lineInd * 2].set(lineSegment[0].x, lineSegment[0].y, 0);\n\t\t\tvertices[lineInd * 2 + 1].set(lineSegment[1].x, lineSegment[1].y, 0);\n\t\t\tlineInd++;\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tthis.lineSegments.scale.set(\n\t\t\txAxis.range.scaleFactor * xAxis.range.zoom,\n\t\t\tyAxis.range.scaleFactor * yAxis.range.zoom,\n\t\t\t1\n\t\t)\n\t}\n\n\tprivate getHorizontalLineSegment(yVal: number, scrollXVal: number, scrollYVal: number): Vector3[] {\n\t\tvar chartState = this.chartState;\n\t\tvar localYVal = yVal - chartState.data.yAxis.range.zeroVal - scrollYVal;\n\t\tvar widthVal = chartState.pxToValueByXAxis(chartState.data.width);\n\t\treturn [\n\t\t\tnew THREE.Vector3(widthVal * 2 + scrollXVal, localYVal, 0 ),\n\t\t\tnew THREE.Vector3( -widthVal + scrollXVal, localYVal, 0 )\n\t\t];\n\t}\n\n\tprivate getVerticalLineSegment(xVal: number, scrollXVal: number, scrollYVal: number): Vector3[] {\n\t\tvar chartState = this.chartState;\n\t\tvar localXVal = xVal - chartState.data.xAxis.range.zeroVal - scrollXVal;\n\t\tvar heightVal = chartState.pxToValueByYAxis(chartState.data.height);\n\t\treturn [\n\t\t\tnew THREE.Vector3(localXVal, heightVal * 2 + scrollYVal, 0 ),\n\t\t\tnew THREE.Vector3(localXVal, -heightVal + scrollYVal, 0 )\n\t\t];\n\t}\n\n\tprivate onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar {xAxis, yAxis} = this.chartState.data;\n\t\tif (options.zoomX) this.lineSegments.scale.setX(xAxis.range.scaleFactor * options.zoomX);\n\t\tif (options.zoomY) this.lineSegments.scale.setY(yAxis.range.scaleFactor * options.zoomY);\n\t}\n\n\n\t// TODO: move this code to core\n\tstatic getGridParamsForAxis(axisOptions: IAxisOptions, axisWidth: number, zoom: number): IGridParamsForAxis {\n\t\tlet axisRange = axisOptions.range;\n\t\tlet from = axisRange.from;\n\t\tlet to = axisRange.to;\n\t\tlet axisLength = to - from;\n\t\tlet gridStep = 0;\n\t\tlet gridStepInPixels = 0;\n\t\tlet minGridStepInPixels = axisOptions.grid.minSizePx;\n\t\tlet axisLengthStr = String(axisLength);\n\t\tlet axisLengthPointPosition = axisLengthStr.indexOf('.');\n\t\tlet intPartLength = axisLengthPointPosition !== -1 ? axisLengthPointPosition : axisLengthStr.length;\n\n\t\tlet gridStepFound = false;\n\t\tlet digitPos = 0;\n\t\twhile (!gridStepFound) {\n\n\t\t\tlet power = intPartLength - digitPos - 1;\n\t\t\tlet multiplier = (Math.pow(10, power) || 1);\n\t\t\tlet dividers = [1, 2, 5];\n\t\t\tfor (let dividerInd = 0; dividerInd < dividers.length; dividerInd++) {\n\t\t\t\tlet nextGridStep = multiplier / dividers[dividerInd];\n\t\t\t\tlet nextGridStepInPixels = nextGridStep / axisLength * axisWidth;\n\t\t\t\tif (nextGridStepInPixels >= minGridStepInPixels) {\n\t\t\t\t\tgridStep = nextGridStep;\n\t\t\t\t\tgridStepInPixels = nextGridStepInPixels;\n\t\t\t\t} else {\n\t\t\t\t\tgridStepFound = true;\n\t\t\t\t\tif (gridStep === 0) {\n\t\t\t\t\t\tgridStep = nextGridStep;\n\t\t\t\t\t\tgridStepInPixels = nextGridStepInPixels;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!gridStepFound) digitPos++\n\n\t\t}\n\n\t\tvar gridStart = Math.floor(from / gridStep) * gridStep;\n\t\tvar gridEnd = Math.floor(to / gridStep) * gridStep;\n\n\t\treturn {\n\t\t\tstart: gridStart,\n\t\t\tend: gridEnd,\n\t\t\tstep: gridStep,\n\t\t\tstepInPx: gridStepInPixels,\n\t\t\tlength: gridEnd - gridStart,\n\t\t\tsegmentsCount: Math.round((gridEnd - gridStart) / gridStep)\n\t\t}\n\t}\n\t\n\tgetObject3D() {\n\t\treturn this.lineSegments;\n\t}\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/GridWidget.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport {ChartState} from \"../State\";\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport {ITrendOptions} from \"../Trend\";\nimport {Utils} from \"../Utils\";\nimport {TrendsWidget, TrendWidget} from \"./TrendsWidget\";\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport { IScreenTransformOptions } from '../Screen';\nimport { TrendSegmentsManager, ITrendSegmentState } from '../TrendSegmentsManager';\nimport { ChartColor } from '../Color';\n\nexport class TrendsGradientWidget extends TrendsWidget<TrendGradient> {\n\tstatic widgetName = \"TrendsGradient\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendGradient;\n\t}\n}\n\n\nexport class TrendGradient extends TrendWidget {\n\tprivate gradient: Mesh;\n\tprivate visibleSegmentsCnt = 0;\n\tprivate segmentsIds: Uint16Array;\n\t\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.hasBackground;\n\t}\n\n\tconstructor (chartState: ChartState, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tthis.trend = chartState.trendsManager.getTrend(trendName);\n\t\tthis.segmentsIds = new Uint16Array(chartState.data.maxVisibleSegments)\n\t\tthis.initGradient();\n\t\tthis.updateSegments();\n\t}\n\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.updateSegments();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\t// TODO: optimize updateSegments for onDisplayedRangeChanged\n\t\t\tthis.updateSegments();\n\t\t}));\n\t\tthis.bindEvent(this.chartState.onZoom(() => {\n\t\t\tthis.updateSegments();\n\t\t}));\n\t}\n\n\n\tgetObject3D(): Object3D {\n\t\treturn this.gradient;\n\t}\n\n\n\tinitGradient() {\n\t\tlet geometry = new Geometry();\n\n\n\t\tfor (let i = 0; i < this.segmentsIds.length; i++) {\n\t\t\tgeometry.vertices.push(\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3()\n\t\t\t);\n\t\t\tlet ind = i * 4;\n\n\t\t\t// gradient segment scheme\n\t\t\t//\n\t\t\t// vert0 +---+ vert3\n\t\t\t//       |\\  |\n\t\t\t// face1 | \\ | face2\n\t\t\t// \t     |  \\|\n\t\t\t// vert1 +---+ vert2\n\n\t\t\tgeometry.faces.push(\n\t\t\t\tnew THREE.Face3( ind, ind + 1, ind + 2 ),\n\t\t\t\tnew THREE.Face3( ind + 3, ind, ind + 2 )\n\t\t\t);\n\t\t}\n\n\t\tlet color = new ChartColor(this.trend.getOptions().backgroundColor);\n\t\tthis.gradient = new THREE.Mesh(\n\t\t\tgeometry,\n\t\t\tnew THREE.MeshBasicMaterial( {color: color.value, transparent: true, opacity: color.a} )\n\t\t);\n\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = this.chartState.data.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = this.chartState.data.yAxis.range;\n\t\tthis.gradient.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.gradient.frustumCulled = false;\n\t}\n\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tlet state = this.chartState.data;\n\t\tlet scaleXFactor = state.xAxis.range.scaleFactor;\n\t\tlet scaleYFactor = state.yAxis.range.scaleFactor;\n\t\tvar currentScale = this.gradient.scale;\n\t\tif (options.zoomX) currentScale.setX(scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(scaleYFactor * options.zoomY);\n\t}\n\n\n\tprotected onSegmentsAnimate(trendSegmentsManager: TrendSegmentsManager) {\n\t\tlet animatedSegmentsIds = trendSegmentsManager.animatedSegmentsIds;\n\t\tfor (let i = 0; i < this.visibleSegmentsCnt; i++) {\n\t\t\tlet segmentId = this.segmentsIds[i];\n\t\t\tif (!animatedSegmentsIds.includes(segmentId)) continue;\n\t\t\tthis.setupSegmentVertices(i, trendSegmentsManager.getSegment(segmentId).currentAnimationState);\n\t\t}\n\t\t(this.gradient.geometry as PlaneGeometry).verticesNeedUpdate = true;\n\t}\n\n\n\tprivate updateSegments() {\n\t\tlet geometry = this.gradient.geometry as PlaneGeometry;\n\t\tlet {\n\t\t\tsegments: trendSegments,\n\t\t\tfirstDisplayedSegmentInd: segmentInd,\n\t\t\tlastDisplayedSegmentInd\n\t\t} = this.trend.segmentsManager;\n\t\tlet prevVisibleSegmentsCnt = this.visibleSegmentsCnt;\n\t\tthis.visibleSegmentsCnt = lastDisplayedSegmentInd - segmentInd + 1;\n\t\tlet segmentsToProcessCnt = Math.max(prevVisibleSegmentsCnt, this.visibleSegmentsCnt);\n\n\t\tif (segmentsToProcessCnt > this.segmentsIds.length) {\n\t\t\tUtils.error(TrendsGradientWidget.widgetName + ': MAX_SEGMENTS reached');\n\t\t}\n\n\t\t// setup visible segments and collapse invisible\n\t\tfor (let i = 0; i <= segmentsToProcessCnt; i++) {\n\t\t\tif (segmentInd <= lastDisplayedSegmentInd) {\n\t\t\t\tlet segment = trendSegments[segmentInd];\n\t\t\t\tthis.setupSegmentVertices(i, segment.currentAnimationState);\n\t\t\t\tthis.segmentsIds[i] = segment.id;\n\t\t\t\tsegmentInd++;\n\t\t\t} else {\n\t\t\t\tthis.setupSegmentVertices(i);\n\t\t\t}\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\t}\n\n\n\t/**\n\t * setup gradient segment by segmentState\n\t * if segmentState is undefined, then collapse vertices to 0,0,0\n\t */\n\tprivate setupSegmentVertices(segmentInd: number, segmentState?: ITrendSegmentState) {\n\t\tlet gradientSegmentInd = segmentInd * 4;\n\t\tlet vertices = (this.gradient.geometry as PlaneGeometry).vertices;\n\t\tlet\ttopLeft = vertices[gradientSegmentInd];\n\t\tlet\tbottomLeft = vertices[gradientSegmentInd + 1];\n\t\tlet\tbottomRight = vertices[gradientSegmentInd + 2];\n\t\tlet\ttopRight = vertices[gradientSegmentInd + 3];\n\t\tlet screenHeightVal = Math.max(\n\t\t\tthis.chartState.pxToValueByYAxis(this.chartState.data.height),\n\t\t\tthis.chartState.screen.pxToValueByYAxis(this.chartState.data.height)\n\t\t);\n\n\t\tif (segmentState) {\n\t\t\tlet startX = this.toLocalX(segmentState.startXVal);\n\t\t\tlet startY = this.toLocalY(segmentState.startYVal);\n\t\t\tlet endX = this.toLocalX(segmentState.endXVal);\n\t\t\tlet endY = this.toLocalY(segmentState.endYVal);\n\t\t\ttopLeft.set(startX, startY, 0);\n\t\t\ttopRight.set(endX, endY, 0);\n\t\t\tbottomLeft.set(topLeft.x, topLeft.y - screenHeightVal, 0);\n\t\t\tbottomRight.set(topRight.x, topRight.y - screenHeightVal, 0);\n\t\t} else {\n\t\t\ttopLeft.set(0, 0, 0);\n\t\t\ttopRight.set(0, 0, 0);\n\t\t\tbottomLeft.set(0, 0, 0);\n\t\t\tbottomRight.set(0, 0, 0);\n\t\t}\n\n\t}\n\n\tprivate toLocalX(xVal: number): number {\n\t\treturn xVal - this.chartState.data.xAxis.range.zeroVal;\n\t}\n\n\n\tprivate toLocalY(yVal: number): number {\n\t\treturn yVal - this.chartState.data.yAxis.range.zeroVal;\n\t}\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsGradientWidget.ts\n **/","\nimport {ChartWidget} from \"../Widget\";\nimport Object3D = THREE.Object3D;\nimport {ChartState} from \"../State\";\nimport {ITrendOptions, ITrendData, Trend} from \"../Trend\";\nimport Vector2 = THREE.Vector2;\nimport Vector3 = THREE.Vector3;\nimport {TrendSegmentsManager} from \"../TrendSegmentsManager\";\nimport {IScreenTransformOptions} from \"../Screen\";\n\n\nexport interface ITrendWidgetClass<TrendWidgetType> {\n\tnew (chartState: ChartState, trendName: string): TrendWidgetType;\n\twidgetIsEnabled(trendOptions: ITrendOptions, chartState: ChartState): boolean;\n}\n\n/**\n * abstract manager class for all trends widgets\n */\nexport abstract class TrendsWidget<TrendWidgetType extends TrendWidget> extends ChartWidget {\n\tprotected abstract getTrendWidgetClass(): ITrendWidgetClass<TrendWidgetType>;\n\tprotected object3D: Object3D;\n\tprotected widgets: {[trendName: string]: TrendWidgetType} = {};\n\n\tonReadyHandler() {\n\t\tthis.object3D = new Object3D();\n\t\tthis.onTrendsChange();\n\t\tthis.bindEvents();\n\t}\n\n\tprotected bindEvents() {\n\t\tvar state = this.chartState;\n\t\tstate.onTrendsChange(() => this.onTrendsChange());\n\t\tstate.onTrendChange((trendName: string, changedOptions: ITrendOptions, newData: ITrendData) => {\n\t\t\tthis.onTrendChange(trendName, changedOptions, newData)\n\t\t});\n\t}\n\n\tprotected onTrendsChange() {\n\t\tvar trendsOptions = this.chartState.data.trends;\n\t\tvar TrendWidgetClass = this.getTrendWidgetClass();\n\t\tfor (let trendName in trendsOptions) {\n\t\t\tlet trendOptions = trendsOptions[trendName];\n\t\t\tlet widgetCanBeEnabled = TrendWidgetClass.widgetIsEnabled(trendOptions, this.chartState);\n\t\t\tif (widgetCanBeEnabled && !this.widgets[trendName]) {\n\t\t\t\tthis.createTrendWidget(trendName);\n\t\t\t} else if (!widgetCanBeEnabled && this.widgets[trendName]){\n\t\t\t\tthis.destroyTrendWidget(trendName);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onTrendChange(trendName: string, changedOptions: ITrendOptions, newData: ITrendData) {\n\t\tvar widget = this.widgets[trendName];\n\t\tif (!widget) return;\n\t\twidget.onTrendChange(changedOptions);\n\t\tif (newData) {\n\t\t\tvar data = this.chartState.getTrend(trendName).getData();\n\t\t\tvar isAppend = (!data.length || data[0].xVal < newData[0].xVal);\n\t\t\tisAppend ? widget.appendData(newData) : widget.prependData(newData);\n\t\t}\n\t}\n\n\tgetObject3D(): Object3D {\n\t\treturn this.object3D;\n\t}\n\n\tprivate createTrendWidget(trendName: string) {\n\t\tvar WidgetConstructor = this.getTrendWidgetClass();\n\t\tvar widget = new WidgetConstructor(this.chartState, trendName);\n\t\tthis.widgets[trendName] = widget;\n\t\tvar widgetObject = widget.getObject3D();\n\t\twidgetObject.name = trendName;\n\t\tthis.object3D.add(widget.getObject3D());\n\t}\n\n\tprivate destroyTrendWidget(trendName: string) {\n\t\tthis.widgets[trendName].onDestroy();\n\t\tdelete this.widgets[trendName];\n\t\tvar widgetObject = this.object3D.getObjectByName(trendName);\n\t\tthis.object3D.remove(widgetObject);\n\t}\n}\n\n/**\n * based class for all trends widgets\n */\nexport abstract class TrendWidget {\n\tprotected trend: Trend;\n\tprotected unbindList: Function[] = [];\n\n\tconstructor (protected chartState: ChartState, protected trendName: string) {\n\t\tthis.trend = chartState.trendsManager.getTrend(trendName);\n\t\tthis.chartState = chartState;\n\t\tthis.bindEvents();\n\t}\n\tabstract getObject3D(): Object3D;\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions, chartState: ChartState) {\n\t\treturn trendOptions.enabled;\n\t}\n\tappendData(newData: ITrendData) {};\n\tprependData(newData: ITrendData) {};\n\tonTrendChange(changedOptions?: ITrendOptions) {}\n\tonDestroy() {\n\t\tfor (let unsubscriber of this.unbindList) {\n\t\t\tunsubscriber();\n\t\t}\n\t}\n\tprotected onSegmentsAnimate(segments: TrendSegmentsManager) {\n\t}\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t}\n\tprotected onTransformationFrame(options: IScreenTransformOptions) {\n\t}\n\tprotected onZoom() {\n\t}\n\n\n\tprotected bindEvents() {\n\n\t\tthis.bindEvent(this.trend.segmentsManager.onAnimationFrame(\n\t\t\t(trendPoints: TrendSegmentsManager) => this.onSegmentsAnimate(trendPoints)\n\t\t));\n\n\t\tthis.bindEvent(this.chartState.screen.onTransformationFrame(\n\t\t\t(options) => this.onTransformationFrame(options)\n\t\t));\n\t\t\n\t\tthis.bindEvent(this.chartState.screen.onZoomFrame(\n\t\t\t(options) => this.onZoomFrame(options)\n\t\t));\n\n\t\tthis.bindEvent(this.chartState.onZoom(() => this.onZoom()));\n\t};\n\n\tprotected bindEvent(unbind: Function) {\n\t\tthis.unbindList.push(unbind);\n\t}\n\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsWidget.ts\n **/","export declare type TChartColor = string | number;\n\n\nexport class ChartColor {\n\n\t/**!\n\t * @preserve $.parseColor\n\t * Copyright 2011 THEtheChad Elliott\n\t * Released under the MIT and GPL licenses.\n\t */\n\t/**\n\t * Parse hex/rgb{a} color syntax.\n\t * @input string\n\t * @returns array [r,g,b{,o}]\n\t */\n\tstatic parseColor(color: string): number[] {\n\n\t\tvar cache: any\n\t\t\t, p = parseInt // Use p as a byte saving reference to parseInt\n\t\t\t, color = color.replace(/\\s\\s*/g, '') // Remove all spaces\n\t\t\t;//var\n\n\t\t// Checks for 6 digit hex and converts string to integer\n\t\tif (cache = /^#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16)];\n\n\t\t// Checks for 3 digit hex and converts string to integer\n\t\telse if (cache = /^#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color))\n\t\t\tcache = [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17];\n\n\n\t\t// Checks for 6 digit hex with alpha and converts string to integer\n\t\telse if (cache = /^rgba\\(#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2}),(([0-9]*[.])?[0-9]+)/.exec(color))\n\t\t\tcache = [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), +cache[4]];\n\n\t\t// Checks for rgba and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3], +cache[4]];\n\n\t\t// Checks for rgb and converts string to\n\t\t// integer/float using unary + operator to save bytes\n\t\telse if (cache = /^rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color))\n\t\t\tcache = [+cache[1], +cache[2], +cache[3]];\n\n\t\t// Otherwise throw an exception to make debugging easier\n\t\telse throw Error(color + ' is not supported by parseColor');\n\n\t\t// Performs RGBA conversion by default\n\t\tisNaN(cache[3]) && (cache[3] = 1);\n\t\treturn cache;\n\t\t// Adds or removes 4th value based on rgba support\n\t\t// Support is flipped twice to prevent erros if\n\t\t// it's not defined\n\t\t//return cache.slice(0,3 + !!$.support.rgba);\n\t}\n\n\tr: number;\n\tg: number;\n\tb: number;\n\ta: number;\n\tvalue: number;\n\thexStr: string;\n\trgbaStr: string;\n\n\tconstructor (color: TChartColor) {\n\t\tthis.set(color);\n\t}\n\n\tset(color: TChartColor) {\n\t\tif (typeof color == 'number') color = '#' + (color as number).toString(16);\n\t\tlet colorStr = color as string;\n\t\tlet rgba = ChartColor.parseColor(colorStr);\n\t\tthis.r = rgba[0];\n\t\tthis.g = rgba[1];\n\t\tthis.b = rgba[2];\n\t\tthis.a = rgba[3];\n\t\tthis.value = (rgba[0] << (8 * 2)) + (rgba[1] << 8) + rgba[2];\n\t\tthis.hexStr = '#' + this.value.toString(16);\n\t\tthis.rgbaStr = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Color.ts\n **/","import Geometry = THREE.Geometry;\nimport Mesh = THREE.Mesh;\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport Material = THREE.Material;\nimport Vector3 = THREE.Vector3;\nimport Line = THREE.Line;\nimport Object3D = THREE.Object3D;\nimport {ChartState} from \"../State\";\nimport Face3 = THREE.Face3;\nimport Texture = THREE.Texture;\nimport Vector2 = THREE.Vector2;\nimport {TrendsWidget, TrendWidget} from \"./TrendsWidget\";\nimport { TrendSegmentsManager, ITrendSegmentState } from \"../TrendSegmentsManager\";\nimport LineSegments = THREE.LineSegments;\nimport {IScreenTransformOptions} from \"../Screen\";\nimport { ITrendOptions, TREND_TYPE } from '../Trend';\nimport { Utils } from '../Utils';\n\n\n/**\n * widget for drawing trends lines\n */\nexport class TrendsLineWidget extends TrendsWidget<TrendLine> {\n\tstatic widgetName = \"TrendsLine\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendLine;\n\t}\n}\n\ninterface ILineSegment {\n\tind: number,\n\tsegmentId: number\n}\n\nexport class TrendLine extends TrendWidget {\n\tprivate material: LineBasicMaterial;\n\tprivate lineSegments: LineSegments;\n\tprivate vertices: Vector3[];\n\n\t// contains indexes of free segments\n\tprivate freeSegmentsInds: number[] = [];\n\n\t// contains segments to display\n\tprivate displayedSegments: {[segmentId: number]: ILineSegment} = {};\n\t\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.type == TREND_TYPE.LINE;\n\t}\n\t\n\tconstructor (chartState: ChartState, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tvar options = this.trend.getOptions();\n\t\tthis.material = new LineBasicMaterial( { color: options.lineColor, linewidth: options.lineWidth } );\n\t\tthis.initLine();\n\t}\n\n\tgetObject3D() {\n\t\treturn this.lineSegments;\n\t}\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.destroySegments();\n\t\t\tthis.setupSegments();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\tthis.setupSegments();\n\t\t}));\n\t}\n\t\n\tprivate initLine() {\n\t\tlet geometry = new Geometry();\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = this.chartState.data.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = this.chartState.data.yAxis.range;\n\t\tthis.lineSegments = new LineSegments(geometry, this.material);\n\t\tthis.lineSegments.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.lineSegments.frustumCulled = false;\n\t\tfor (let i = 0; i < this.chartState.data.maxVisibleSegments; i++) {\n\t\t\tgeometry.vertices.push(new  Vector3(), new Vector3());\n\t\t\tthis.freeSegmentsInds.push(i);\n\t\t}\n\t\tthis.vertices = geometry.vertices;\n\t\tthis.setupSegments();\n\t}\n\n\tprivate setupSegments() {\n\t\tlet geometry = this.lineSegments.geometry as Geometry;\n\n\t\tlet {firstDisplayedSegment, lastDisplayedSegment} = this.trend.segmentsManager;\n\n\t\tfor (let segmentId in this.displayedSegments) {\n\t\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\t\tlet segment = this.trend.segmentsManager.segments[lineSegment.segmentId];\n\t\t\tlet segmentIsNotDisplayed = (\n\t\t\t\tsegment.startXVal < firstDisplayedSegment.startXVal ||\n\t\t\t\tsegment.endXVal > lastDisplayedSegment.endXVal\n\t\t\t);\n\t\t\tif (segmentIsNotDisplayed) this.destroySegment(Number(segmentId));\n\t\t}\n\n\t\tlet segment = firstDisplayedSegment;\n\t\twhile (segment && segment.xVal <= lastDisplayedSegment.xVal) {\n\t\t\tthis.setupSegment(segment.id, segment.currentAnimationState);\n\t\t\tsegment = segment.getNext();\n\t\t}\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t}\n\n\tprivate setupSegment(segmentId: number, segmentState: ITrendSegmentState) {\n\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\tif (!lineSegment) {\n\t\t\tif (this.freeSegmentsInds.length == 0) Utils.error('Max allocated segments reached');\n\t\t\tlet ind = this.freeSegmentsInds.pop();\n\t\t\tlineSegment = this.displayedSegments[segmentId] = {segmentId, ind};\n\t\t}\n\t\tlet segmentInd = lineSegment.ind;\n\t\tlet lineStartVertex = this.vertices[segmentInd * 2];\n\t\tlet lineEndVertex = this.vertices[segmentInd * 2 + 1];\n\t\tlineStartVertex.set(this.toLocalX(segmentState.startXVal), this.toLocalY(segmentState.startYVal), 0);\n\t\tlineEndVertex.set(this.toLocalX(segmentState.endXVal), this.toLocalY(segmentState.endYVal), 0);\n\t}\n\n\tprivate destroySegments() {\n\t\tfor (let segmentId in this.displayedSegments) this.destroySegment(Number(segmentId));\n\t}\n\n\tprivate destroySegment(segmentId: number) {\n\t\tlet lineSegment = this.displayedSegments[segmentId];\n\t\tlet lineStartVertex = this.vertices[lineSegment.ind * 2];\n\t\tlet lineEndVertex = this.vertices[lineSegment.ind * 2 + 1];\n\t\tlineStartVertex.set(0, 0, 0);\n\t\tlineEndVertex.set(0, 0, 0);\n\t\tdelete this.displayedSegments[segmentId];\n\t\tthis.freeSegmentsInds.push(lineSegment.ind);\n\t}\n\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar currentScale = this.lineSegments.scale;\n\t\tlet state = this.chartState.data;\n\t\tlet scaleXFactor = state.xAxis.range.scaleFactor;\n\t\tlet scaleYFactor = state.yAxis.range.scaleFactor;\n\t\tif (options.zoomX) currentScale.setX(scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(scaleYFactor * options.zoomY);\n\t}\n\n\n\tprotected onSegmentsAnimate(trendSegments: TrendSegmentsManager) {\n\t\tvar geometry = this.lineSegments.geometry as Geometry;\n\t\tfor (let segmentId of trendSegments.animatedSegmentsIds) {\n\t\t\tif (!this.displayedSegments[segmentId]) continue;\n\t\t\tthis.setupSegment(segmentId, trendSegments.segmentsById[segmentId].currentAnimationState);\n\t\t}\n\t\tgeometry.verticesNeedUpdate = true;\n\t}\n\n\n\tprivate toLocalX(xVal: number): number {\n\t\treturn xVal - this.chartState.data.xAxis.range.zeroVal;\n\t}\n\n\tprivate toLocalY(yVal: number): number {\n\t\treturn yVal - this.chartState.data.yAxis.range.zeroVal;\n\t}\n\n\tprivate toLocalVec(vec: Vector3): Vector3 {\n\t\treturn new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsLineWidget.ts\n **/","\n\nimport { TrendsWidget, TrendWidget } from './TrendsWidget';\nimport { ChartState } from '../State';\nimport Object3D = THREE.Object3D;\nimport Geometry = THREE.Geometry;\nimport { IScreenTransformOptions } from '../Screen';\nimport { TrendSegmentsManager, ITrendSegmentState } from '../TrendSegmentsManager';\nimport Vector3 = THREE.Vector3;\nimport Mesh = THREE.Mesh;\nimport Line = THREE.Line;\nimport BoxGeometry = THREE.BoxGeometry;\nimport MeshBasicMaterial = THREE.MeshBasicMaterial;\nimport PlaneGeometry = THREE.PlaneGeometry;\nimport { TREND_TYPE, ITrendOptions } from '../Trend';\nimport LineBasicMaterial = THREE.LineBasicMaterial;\nimport remove = THREE.Cache.remove;\nimport { Utils } from '../Utils';\n\n\nconst RISE_COLOR = 0x2CAC40;\nconst FALL_COLOR = 0xEE5533;\nconst MARGIN_PERCENT = 0.3;\nconst MAX_CANDLES = 100;\n\n/**\n * widget for drawing trends candles\n */\nexport class TrendsCandlesWidget extends TrendsWidget<TrendCandlesWidget> {\n\tstatic widgetName = \"TrendsCandles\";\n\tprotected getTrendWidgetClass() {\n\t\treturn TrendCandlesWidget;\n\t}\n}\n\n\nexport class TrendCandlesWidget extends TrendWidget {\n\tprivate scaleXFactor: number;\n\tprivate scaleYFactor: number;\n\tprivate object3D: Object3D;\n\t\n\t// contains indexes of free candles\n\tprivate freeCandlesInds: number[] = [];\n\tprivate candlesPool: CandleWidget[] = [];\n\tprivate candles: {[segmentId: number]: CandleWidget} = {};\n\n\tstatic widgetIsEnabled(trendOptions: ITrendOptions) {\n\t\treturn trendOptions.enabled && trendOptions.type == TREND_TYPE.CANDLE;\n\t}\n\n\tconstructor (chartState: ChartState, trendName: string) {\n\t\tsuper(chartState, trendName);\n\t\tthis.initObject();\n\t}\n\n\n\tgetObject3D() {\n\t\treturn this.object3D;\n\t}\n\n\tprotected bindEvents() {\n\t\tsuper.bindEvents();\n\t\tthis.bindEvent(this.trend.segmentsManager.onRebuild(() => {\n\t\t\tthis.destroyCandles();\n\t\t\tthis.setupCandles();\n\t\t}));\n\t\tthis.bindEvent(this.trend.segmentsManager.onDisplayedRangeChanged(() => {\n\t\t\tthis.setupCandles();\n\t\t}));\n\t}\n\t\n\tprivate initObject() {\n\t\tlet stateData = this.chartState.data;\n\t\tlet {scaleFactor: scaleXFactor, zoom: zoomX} = stateData.xAxis.range;\n\t\tlet {scaleFactor: scaleYFactor, zoom: zoomY} = stateData.yAxis.range;\n\t\tthis.scaleXFactor = scaleXFactor;\n\t\tthis.scaleYFactor = scaleYFactor;\n\t\tthis.object3D = new Object3D();\n\t\tthis.object3D.scale.set(scaleXFactor * zoomX, scaleYFactor * zoomY, 1);\n\t\tthis.object3D.frustumCulled = false;\n\t\tfor (let i = 0; i < MAX_CANDLES; i++) this.freeCandlesInds.push(i);\n\t\tthis.setupCandles();\n\t}\n\n\tprivate setupCandles() {\n\n\t\t// remove invisible\n\t\tlet {firstDisplayedSegment, lastDisplayedSegment} = this.trend.segmentsManager;\n\n\t\tfor (let segmentId in this.candles) {\n\t\t\tlet segment = this.candles[segmentId].segment;\n\t\t\tlet segmentIsNotDisplayed = (\n\t\t\t\tsegment.startXVal < firstDisplayedSegment.startXVal ||\n\t\t\t\tsegment.endXVal > lastDisplayedSegment.endXVal\n\t\t\t);\n\t\t\tif (segmentIsNotDisplayed) this.destroyCandle(Number(segmentId));\n\t\t}\n\n\t\tlet segment = firstDisplayedSegment;\n\t\twhile (segment && segment.xVal <= lastDisplayedSegment.xVal) {\n\t\t\tthis.setupCandle(segment.id, segment.currentAnimationState);\n\t\t\tsegment = segment.getNext();\n\t\t}\n\t}\n\n\tprivate destroyCandles() {\n\t\tfor (let segmentId in this.candles) this.destroyCandle(Number(segmentId));\n\t}\n\n\tprivate destroyCandle(segmentId: number) {\n\t\tlet candle = this.candles[segmentId];\n\t\tthis.object3D.remove(candle.getObject3D());\n\t\tdelete this.candles[segmentId];\n\t}\n\n\tprotected onZoomFrame(options: IScreenTransformOptions) {\n\t\tvar currentScale = this.object3D.scale;\n\t\tif (options.zoomX) currentScale.setX(this.scaleXFactor * options.zoomX);\n\t\tif (options.zoomY) currentScale.setY(this.scaleYFactor * options.zoomY);\n\t}\n\n\tprotected onSegmentsAnimate(trendSegments: TrendSegmentsManager) {\n\t\tfor (let segmentId of trendSegments.animatedSegmentsIds) {\n\t\t\tif (!this.candles[segmentId]) continue;\n\t\t\tlet segmentState = trendSegments.segmentsById[segmentId].currentAnimationState;\n\t\t\tthis.setupCandle(segmentId, segmentState);\n\t\t}\n\t}\n\n\t/**\n\t * create or modify candle\n\t */\n\tprivate setupCandle(candleId: number, segmentState: ITrendSegmentState) {\n\t\tlet candleInd = candleId % MAX_CANDLES;\n\n\t\t// get candle from candlesPool to avoid creating new Objects by performance reasons\n\t\tlet candle = this.candlesPool[candleInd];\n\t\tif (!candle) {\n\t\t\tcandle = this.candlesPool[candleInd] = new CandleWidget();\n\t\t}\n\n\t\tif (!this.candles[candleId]) {\n\t\t\tthis.candles[candleId] = candle;\n\t\t\tthis.object3D.add(candle.getObject3D());\n\t\t}\n\t\tcandle.getObject3D().position.set(this.toLocalX(segmentState.xVal), this.toLocalY(segmentState.yVal), 0);\n\t\tcandle.setSegment(segmentState);\n\t}\n\n\ttoLocalX(xVal: number): number {\n\t\treturn xVal - this.chartState.data.xAxis.range.zeroVal;\n\t}\n\n\ttoLocalY(yVal: number): number {\n\t\treturn yVal - this.chartState.data.yAxis.range.zeroVal;\n\t}\n\n\ttoLocalVec(vec: Vector3): Vector3 {\n\t\treturn new Vector3(this.toLocalX(vec.x), this.toLocalY(vec.y), 0);\n\t}\n}\n\nclass CandleWidget {\n\tsegment: ITrendSegmentState;\n\tprivate rect: Mesh;\n\tprivate vLine: Line;\n\tprivate hLine: Line;\n\tconstructor () {\n\t\tthis.initObject();\n\t}\n\n\tgetObject3D(): Object3D {\n\t\treturn this.rect;\n\t}\n\n\tsetSegment(segment: ITrendSegmentState) {\n\t\tthis.segment = segment;\n\t\tlet color = segment.endYVal < segment.startYVal ? FALL_COLOR : RISE_COLOR;\n\n\t\t// update rect\n\t\tlet geometry = this.rect.geometry as PlaneGeometry;\n\t\tlet material = this.rect.material as MeshBasicMaterial;\n\t\tlet width = segment.endXVal - segment.startXVal;\n\t\twidth -= width * MARGIN_PERCENT;\n\t\tlet height = Math.max(segment.startYVal, segment.endYVal) - Math.min(segment.startYVal, segment.endYVal);\n\t\tlet [leftTop, rightTop, leftBottom, rightBottom] = geometry.vertices;\n\t\tleftTop.set(-width / 2, height / 2, 0);\n\t\trightTop.set(width / 2, height / 2, 0);\n\t\tleftBottom.set(-width / 2, -height / 2, 0);\n\t\trightBottom.set(width / 2, -height / 2, 0);\n\n\t\t// prevent to draw bars with height < 1px\n\t\tif (Utils.getDistance(leftTop.y, leftBottom.y) < 1) {\n\t\t\tleftBottom.setY(leftBottom.y + 1);\n\t\t\trightBottom.setY(rightBottom.y + 1);\n\t\t}\n\n\t\tmaterial.color.set(color);\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t// update lines\n\t\tlet vLineGeometry = this.vLine.geometry as Geometry;\n\t\tlet vLineMaterial = this.vLine.material as LineBasicMaterial;\n\t\tlet lineTop = segment.maxYVal - segment.yVal;\n\t\tlet lineBottom = segment.minYVal - segment.yVal;\n\t\tvLineGeometry.vertices[0].set(0, lineTop, 0);\n\t\tvLineGeometry.vertices[1].set(0, lineBottom, 0);\n\t\tvLineMaterial.color.set(color);\n\t\tvLineGeometry.verticesNeedUpdate = true;\n\n\t\tlet hLineGeometry = this.hLine.geometry as Geometry;\n\t\tlet hLineMaterial = this.hLine.material as LineBasicMaterial;\n\t\tlet lineLeft = (-width) / 2;\n\t\tlet lineRight = width / 2;\n\t\thLineGeometry.vertices[0].set(lineLeft, 0, 0);\n\t\thLineGeometry.vertices[1].set(lineRight, 0, 0);\n\t\thLineMaterial.color.set(color);\n\t\thLineGeometry.verticesNeedUpdate = true;\n\n\t}\n\n\tprivate initObject() {\n\t\tthis.rect = new Mesh(\n\t\t\tnew PlaneGeometry(1, 1),\n\t\t\tnew MeshBasicMaterial()\n\t\t);\n\t\tlet vLineGeometry = new Geometry();\n\t\tlet hLineGeometry = new Geometry();\n\t\tvLineGeometry.vertices.push(new Vector3(), new Vector3);\n\t\thLineGeometry.vertices.push(new Vector3(), new Vector3);\n\t\tthis.vLine = new Line(vLineGeometry, new LineBasicMaterial({linewidth: 1}));\n\t\tthis.hLine = new Line(hLineGeometry, new LineBasicMaterial({linewidth: 1}));\n\t\tthis.rect.add(this.vLine);\n\t\tthis.rect.add(this.hLine);\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/widgets/TrendsCandleWidget.ts\n **/"],"sourceRoot":""}